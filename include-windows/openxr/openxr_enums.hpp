// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************

/*
** Copyright (c) 2017-2023 The Khronos Group Inc.
** Copyright (c) 2019-2023 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_ENUMS_HPP_
#define OPENXR_ENUMS_HPP_
/**
 * @file
 * @brief C++ projections of OpenXR enum types.
 *
 * Does not include the flags (bitmasks).
 *
 * @see openxr_flags.hpp
 * @ingroup enums
 */

#include <openxr/openxr.h>

#if XR_CURRENT_API_VERSION > XR_MAKE_VERSION(1, 0, 32)
#ifndef XR_EXTENSION_PROTOTYPES
#define XR_EXTENSION_PROTOTYPES 1
#endif
#include <openxr/openxr_loader_negotiation.h>
#endif

#ifdef OPENXR_HPP_DOXYGEN
#include <openxr/openxr_platform.h>
#endif

#include <string>

// Fix name collisions from noisy includes
#ifdef Success
#undef Success
#endif
#ifdef None
#undef None
#endif

#if !defined(OPENXR_HPP_INLINE)
#if defined(__clang___)
#if __has_attribute(always_inline)
#define OPENXR_HPP_INLINE __attribute__((always_inline)) __inline__
#else
#define OPENXR_HPP_INLINE inline
#endif
#elif defined(__GNUC__)
#define OPENXR_HPP_INLINE __attribute__((always_inline)) __inline__
#elif defined(_MSC_VER)
#define OPENXR_HPP_INLINE inline
#else
#define OPENXR_HPP_INLINE inline
#endif
#endif  // !OPENXR_HPP_INLINE

#if !defined(OPENXR_HPP_CONSTEXPR)
#if defined(_MSC_VER) && (_MSC_VER <= 1800)
#define OPENXR_HPP_CONSTEXPR
#else
#define OPENXR_HPP_CONSTEXPR constexpr
#endif
#endif  // !OPENXR_HPP_CONSTEXPR

#if !defined(OPENXR_HPP_SWITCH_CONSTEXPR)
//! @todo set this to constexpr in c++14
#define OPENXR_HPP_SWITCH_CONSTEXPR
#endif  // !OPENXR_HPP_SWITCH_CONSTEXPR

#if !defined(OPENXR_HPP_NAMESPACE)
#define OPENXR_HPP_NAMESPACE xr
#endif  // !OPENXR_HPP_NAMESPACE
namespace OPENXR_HPP_NAMESPACE {
/*!
 * @defgroup enums Enumerations
 * @brief C++ enum classes corresponding to OpenXR C enumerations, plus associated utility
 * functions.
 * @ingroup wrappers
 *
 * All enumerations have three utility functions defined:
 *
 * - get() - returns the raw C enum value
 * - to_string_literal() - returns a const char* containing the C++ name
 * - to_string() - wraps to_string_literal(), returning a std::string
 *
 * They all should be accessible via argument-dependent lookup, meaning you should not need to
 * explicitly specify the namespace.
 * @{
 */

/*!
 * @brief Enum class for XrResult
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrResult>
 *
 * @see failed(), succeeded(), unqualifiedSuccess()
 * @xrentity{XrResult}
 */
enum class Result {

  Success = XR_SUCCESS,

  TimeoutExpired = XR_TIMEOUT_EXPIRED,

  SessionLossPending = XR_SESSION_LOSS_PENDING,

  EventUnavailable = XR_EVENT_UNAVAILABLE,

  SpaceBoundsUnavailable = XR_SPACE_BOUNDS_UNAVAILABLE,

  SessionNotFocused = XR_SESSION_NOT_FOCUSED,

  FrameDiscarded = XR_FRAME_DISCARDED,

  ErrorValidationFailure = XR_ERROR_VALIDATION_FAILURE,

  ErrorRuntimeFailure = XR_ERROR_RUNTIME_FAILURE,

  ErrorOutOfMemory = XR_ERROR_OUT_OF_MEMORY,

  ErrorAPIVersionUnsupported = XR_ERROR_API_VERSION_UNSUPPORTED,

  ErrorInitializationFailed = XR_ERROR_INITIALIZATION_FAILED,

  ErrorFunctionUnsupported = XR_ERROR_FUNCTION_UNSUPPORTED,

  ErrorFeatureUnsupported = XR_ERROR_FEATURE_UNSUPPORTED,

  ErrorExtensionNotPresent = XR_ERROR_EXTENSION_NOT_PRESENT,

  ErrorLimitReached = XR_ERROR_LIMIT_REACHED,

  ErrorSizeInsufficient = XR_ERROR_SIZE_INSUFFICIENT,

  ErrorHandleInvalid = XR_ERROR_HANDLE_INVALID,

  ErrorInstanceLost = XR_ERROR_INSTANCE_LOST,

  ErrorSessionRunning = XR_ERROR_SESSION_RUNNING,

  ErrorSessionNotRunning = XR_ERROR_SESSION_NOT_RUNNING,

  ErrorSessionLost = XR_ERROR_SESSION_LOST,

  ErrorSystemInvalid = XR_ERROR_SYSTEM_INVALID,

  ErrorPathInvalid = XR_ERROR_PATH_INVALID,

  ErrorPathCountExceeded = XR_ERROR_PATH_COUNT_EXCEEDED,

  ErrorPathFormatInvalid = XR_ERROR_PATH_FORMAT_INVALID,

  ErrorPathUnsupported = XR_ERROR_PATH_UNSUPPORTED,

  ErrorLayerInvalid = XR_ERROR_LAYER_INVALID,

  ErrorLayerLimitExceeded = XR_ERROR_LAYER_LIMIT_EXCEEDED,

  ErrorSwapchainRectInvalid = XR_ERROR_SWAPCHAIN_RECT_INVALID,

  ErrorSwapchainFormatUnsupported = XR_ERROR_SWAPCHAIN_FORMAT_UNSUPPORTED,

  ErrorActionTypeMismatch = XR_ERROR_ACTION_TYPE_MISMATCH,

  ErrorSessionNotReady = XR_ERROR_SESSION_NOT_READY,

  ErrorSessionNotStopping = XR_ERROR_SESSION_NOT_STOPPING,

  ErrorTimeInvalid = XR_ERROR_TIME_INVALID,

  ErrorReferenceSpaceUnsupported = XR_ERROR_REFERENCE_SPACE_UNSUPPORTED,

  ErrorFileAccessError = XR_ERROR_FILE_ACCESS_ERROR,

  ErrorFileContentsInvalid = XR_ERROR_FILE_CONTENTS_INVALID,

  ErrorFormFactorUnsupported = XR_ERROR_FORM_FACTOR_UNSUPPORTED,

  ErrorFormFactorUnavailable = XR_ERROR_FORM_FACTOR_UNAVAILABLE,

  ErrorAPILayerNotPresent = XR_ERROR_API_LAYER_NOT_PRESENT,

  ErrorCallOrderInvalid = XR_ERROR_CALL_ORDER_INVALID,

  ErrorGraphicsDeviceInvalid = XR_ERROR_GRAPHICS_DEVICE_INVALID,

  ErrorPoseInvalid = XR_ERROR_POSE_INVALID,

  ErrorIndexOutOfRange = XR_ERROR_INDEX_OUT_OF_RANGE,

  ErrorViewConfigurationTypeUnsupported = XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED,

  ErrorEnvironmentBlendModeUnsupported = XR_ERROR_ENVIRONMENT_BLEND_MODE_UNSUPPORTED,

  ErrorNameDuplicated = XR_ERROR_NAME_DUPLICATED,

  ErrorNameInvalid = XR_ERROR_NAME_INVALID,

  ErrorActionsetNotAttached = XR_ERROR_ACTIONSET_NOT_ATTACHED,

  ErrorActionsetsAlreadyAttached = XR_ERROR_ACTIONSETS_ALREADY_ATTACHED,

  ErrorLocalizedNameDuplicated = XR_ERROR_LOCALIZED_NAME_DUPLICATED,

  ErrorLocalizedNameInvalid = XR_ERROR_LOCALIZED_NAME_INVALID,

  ErrorGraphicsRequirementsCallMissing = XR_ERROR_GRAPHICS_REQUIREMENTS_CALL_MISSING,

  ErrorRuntimeUnavailable = XR_ERROR_RUNTIME_UNAVAILABLE,

  ErrorExtensionDependencyNotEnabled = XR_ERROR_EXTENSION_DEPENDENCY_NOT_ENABLED,

  ErrorPermissionInsufficient = XR_ERROR_PERMISSION_INSUFFICIENT,

#ifdef XR_KHR_android_thread_settings
  ErrorAndroidThreadSettingsIdInvalidKHR = XR_ERROR_ANDROID_THREAD_SETTINGS_ID_INVALID_KHR,
#endif  // XR_KHR_android_thread_settings
#ifdef XR_KHR_android_thread_settings
  ErrorAndroidThreadSettingsFailureKHR = XR_ERROR_ANDROID_THREAD_SETTINGS_FAILURE_KHR,
#endif  // XR_KHR_android_thread_settings
#ifdef XR_MSFT_spatial_anchor
  ErrorCreateSpatialAnchorFailedMSFT = XR_ERROR_CREATE_SPATIAL_ANCHOR_FAILED_MSFT,
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_secondary_view_configuration
  ErrorSecondaryViewConfigurationTypeNotEnabledMSFT =
      XR_ERROR_SECONDARY_VIEW_CONFIGURATION_TYPE_NOT_ENABLED_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_controller_model
  ErrorControllerModelKeyInvalidMSFT = XR_ERROR_CONTROLLER_MODEL_KEY_INVALID_MSFT,
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_composition_layer_reprojection
  ErrorReprojectionModeUnsupportedMSFT = XR_ERROR_REPROJECTION_MODE_UNSUPPORTED_MSFT,
#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_MSFT_scene_understanding
  ErrorComputeNewSceneNotCompletedMSFT = XR_ERROR_COMPUTE_NEW_SCENE_NOT_COMPLETED_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ErrorSceneComponentIdInvalidMSFT = XR_ERROR_SCENE_COMPONENT_ID_INVALID_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ErrorSceneComponentTypeMismatchMSFT = XR_ERROR_SCENE_COMPONENT_TYPE_MISMATCH_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ErrorSceneMeshBufferIdInvalidMSFT = XR_ERROR_SCENE_MESH_BUFFER_ID_INVALID_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ErrorSceneComputeFeatureIncompatibleMSFT = XR_ERROR_SCENE_COMPUTE_FEATURE_INCOMPATIBLE_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ErrorSceneComputeConsistencyMismatchMSFT = XR_ERROR_SCENE_COMPUTE_CONSISTENCY_MISMATCH_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_FB_display_refresh_rate
  ErrorDisplayRefreshRateUnsupportedFB = XR_ERROR_DISPLAY_REFRESH_RATE_UNSUPPORTED_FB,
#endif  // XR_FB_display_refresh_rate
#ifdef XR_FB_color_space
  ErrorColorSpaceUnsupportedFB = XR_ERROR_COLOR_SPACE_UNSUPPORTED_FB,
#endif  // XR_FB_color_space
#ifdef XR_FB_spatial_entity
  ErrorSpaceComponentNotSupportedFB = XR_ERROR_SPACE_COMPONENT_NOT_SUPPORTED_FB,
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
  ErrorSpaceComponentNotEnabledFB = XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB,
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
  ErrorSpaceComponentStatusPendingFB = XR_ERROR_SPACE_COMPONENT_STATUS_PENDING_FB,
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
  ErrorSpaceComponentStatusAlreadySetFB = XR_ERROR_SPACE_COMPONENT_STATUS_ALREADY_SET_FB,
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_passthrough
  ErrorUnexpectedStatePassthroughFB = XR_ERROR_UNEXPECTED_STATE_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  ErrorFeatureAlreadyCreatedPassthroughFB = XR_ERROR_FEATURE_ALREADY_CREATED_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  ErrorFeatureRequiredPassthroughFB = XR_ERROR_FEATURE_REQUIRED_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  ErrorNotPermittedPassthroughFB = XR_ERROR_NOT_PERMITTED_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  ErrorInsufficientResourcesPassthroughFB = XR_ERROR_INSUFFICIENT_RESOURCES_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  ErrorUnknownPassthroughFB = XR_ERROR_UNKNOWN_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_render_model
  ErrorRenderModelKeyInvalidFB = XR_ERROR_RENDER_MODEL_KEY_INVALID_FB,
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
  RenderModelUnavailableFB = XR_RENDER_MODEL_UNAVAILABLE_FB,
#endif  // XR_FB_render_model
#ifdef XR_VARJO_marker_tracking
  ErrorMarkerNotTrackedVARJO = XR_ERROR_MARKER_NOT_TRACKED_VARJO,
#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking
  ErrorMarkerIdInvalidVARJO = XR_ERROR_MARKER_ID_INVALID_VARJO,
#endif  // XR_VARJO_marker_tracking
#ifdef XR_ML_marker_understanding
  ErrorMarkerDetectorPermissionDeniedML = XR_ERROR_MARKER_DETECTOR_PERMISSION_DENIED_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
  ErrorMarkerDetectorLocateFailedML = XR_ERROR_MARKER_DETECTOR_LOCATE_FAILED_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
  ErrorMarkerDetectorInvalidDataQueryML = XR_ERROR_MARKER_DETECTOR_INVALID_DATA_QUERY_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
  ErrorMarkerDetectorInvalidCreateInfoML = XR_ERROR_MARKER_DETECTOR_INVALID_CREATE_INFO_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
  ErrorMarkerInvalidML = XR_ERROR_MARKER_INVALID_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_localization_map
  ErrorLocalizationMapIncompatibleML = XR_ERROR_LOCALIZATION_MAP_INCOMPATIBLE_ML,
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
  ErrorLocalizationMapUnavailableML = XR_ERROR_LOCALIZATION_MAP_UNAVAILABLE_ML,
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
  ErrorLocalizationMapFailML = XR_ERROR_LOCALIZATION_MAP_FAIL_ML,
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
  ErrorLocalizationMapImportExportPermissionDeniedML =
      XR_ERROR_LOCALIZATION_MAP_IMPORT_EXPORT_PERMISSION_DENIED_ML,
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
  ErrorLocalizationMapPermissionDeniedML = XR_ERROR_LOCALIZATION_MAP_PERMISSION_DENIED_ML,
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
  ErrorLocalizationMapAlreadyExistsML = XR_ERROR_LOCALIZATION_MAP_ALREADY_EXISTS_ML,
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
  ErrorLocalizationMapCannotExportCloudMapML = XR_ERROR_LOCALIZATION_MAP_CANNOT_EXPORT_CLOUD_MAP_ML,
#endif  // XR_ML_localization_map
#ifdef dsaXR_ML_spatial_anchors
  ErrorSpatialAnchorsPermissionDeniedML = XR_ERROR_SPATIAL_ANCHORS_PERMISSION_DENIED_ML,
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors
  ErrorSpatialAnchorsNotLocalizedML = XR_ERROR_SPATIAL_ANCHORS_NOT_LOCALIZED_ML,
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors
  ErrorSpatialAnchorsOutOfMapBoundsML = XR_ERROR_SPATIAL_ANCHORS_OUT_OF_MAP_BOUNDS_ML,
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors
  ErrorSpatialAnchorsSpaceNotLocatableML = XR_ERROR_SPATIAL_ANCHORS_SPACE_NOT_LOCATABLE_ML,
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors_storage
  ErrorSpatialAnchorsAnchorNotFoundML = XR_ERROR_SPATIAL_ANCHORS_ANCHOR_NOT_FOUND_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef XR_MSFT_spatial_anchor_persistence
  ErrorSpatialAnchorNameNotFoundMSFT = XR_ERROR_SPATIAL_ANCHOR_NAME_NOT_FOUND_MSFT,
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence
  ErrorSpatialAnchorNameInvalidMSFT = XR_ERROR_SPATIAL_ANCHOR_NAME_INVALID_MSFT,
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_scene_marker
  SceneMarkerDataNotStringMSFT = XR_SCENE_MARKER_DATA_NOT_STRING_MSFT,
#endif  // XR_MSFT_scene_marker
#ifdef XR_FB_spatial_entity_sharing
  ErrorSpaceMappingInsufficientFB = XR_ERROR_SPACE_MAPPING_INSUFFICIENT_FB,
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_spatial_entity_sharing
  ErrorSpaceLocalizationFailedFB = XR_ERROR_SPACE_LOCALIZATION_FAILED_FB,
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_spatial_entity_sharing
  ErrorSpaceNetworkTimeoutFB = XR_ERROR_SPACE_NETWORK_TIMEOUT_FB,
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_spatial_entity_sharing
  ErrorSpaceNetworkRequestFailedFB = XR_ERROR_SPACE_NETWORK_REQUEST_FAILED_FB,
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_spatial_entity_sharing
  ErrorSpaceCloudStorageDisabledFB = XR_ERROR_SPACE_CLOUD_STORAGE_DISABLED_FB,
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_META_passthrough_color_lut
  ErrorPassthroughColorLutBufferSizeMismatchMETA =
      XR_ERROR_PASSTHROUGH_COLOR_LUT_BUFFER_SIZE_MISMATCH_META,
#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_environment_depth
  EnvironmentDepthNotAvailableMETA = XR_ENVIRONMENT_DEPTH_NOT_AVAILABLE_META,
#endif  // XR_META_environment_depth
#ifdef XR_EXT_render_model
  ErrorRenderModelIdInvalidEXT = XR_ERROR_RENDER_MODEL_ID_INVALID_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  ErrorRenderModelAssetUnavailableEXT = XR_ERROR_RENDER_MODEL_ASSET_UNAVAILABLE_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  ErrorRenderModelGltfExtensionRequiredEXT = XR_ERROR_RENDER_MODEL_GLTF_EXTENSION_REQUIRED_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_interaction_render_model
  ErrorNotInteractionRenderModelEXT = XR_ERROR_NOT_INTERACTION_RENDER_MODEL_EXT,
#endif  // XR_EXT_interaction_render_model
#ifdef XR_QCOM_tracking_optimization_settings
  ErrorHintAlreadySetQCOM = XR_ERROR_HINT_ALREADY_SET_QCOM,
#endif  // XR_QCOM_tracking_optimization_settings
#ifdef XR_HTC_anchor
  ErrorNotAnAnchorHTC = XR_ERROR_NOT_AN_ANCHOR_HTC,
#endif  // XR_HTC_anchor
#ifdef XR_BD_spatial_sensing
  ErrorSpatialEntityIdInvalidBD = XR_ERROR_SPATIAL_ENTITY_ID_INVALID_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  ErrorSpatialSensingServiceUnavailableBD = XR_ERROR_SPATIAL_SENSING_SERVICE_UNAVAILABLE_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  ErrorAnchorNotSupportedForEntityBD = XR_ERROR_ANCHOR_NOT_SUPPORTED_FOR_ENTITY_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_anchor
  ErrorSpatialAnchorNotFoundBD = XR_ERROR_SPATIAL_ANCHOR_NOT_FOUND_BD,
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_anchor_sharing
  ErrorSpatialAnchorSharingNetworkTimeoutBD = XR_ERROR_SPATIAL_ANCHOR_SHARING_NETWORK_TIMEOUT_BD,
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_anchor_sharing
  ErrorSpatialAnchorSharingAuthenticationFailureBD =
      XR_ERROR_SPATIAL_ANCHOR_SHARING_AUTHENTICATION_FAILURE_BD,
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_anchor_sharing
  ErrorSpatialAnchorSharingNetworkFailureBD = XR_ERROR_SPATIAL_ANCHOR_SHARING_NETWORK_FAILURE_BD,
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_anchor_sharing
  ErrorSpatialAnchorSharingLocalizationFailBD =
      XR_ERROR_SPATIAL_ANCHOR_SHARING_LOCALIZATION_FAIL_BD,
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_anchor_sharing
  ErrorSpatialAnchorSharingMapInsufficientBD = XR_ERROR_SPATIAL_ANCHOR_SHARING_MAP_INSUFFICIENT_BD,
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_scene
  ErrorSceneCaptureFailureBD = XR_ERROR_SCENE_CAPTURE_FAILURE_BD,
#endif  // XR_BD_spatial_scene
#ifdef XR_EXT_plane_detection
  ErrorSpaceNotLocatableEXT = XR_ERROR_SPACE_NOT_LOCATABLE_EXT,
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
  ErrorPlaneDetectionPermissionDeniedEXT = XR_ERROR_PLANE_DETECTION_PERMISSION_DENIED_EXT,
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_future
  ErrorFuturePendingEXT = XR_ERROR_FUTURE_PENDING_EXT,
#endif  // XR_EXT_future
#ifdef XR_EXT_future
  ErrorFutureInvalidEXT = XR_ERROR_FUTURE_INVALID_EXT,
#endif  // XR_EXT_future
#ifdef XR_ML_system_notifications
  ErrorSystemNotificationPermissionDeniedML = XR_ERROR_SYSTEM_NOTIFICATION_PERMISSION_DENIED_ML,
#endif  // XR_ML_system_notifications
#ifdef XR_ML_system_notifications
  ErrorSystemNotificationIncompatibleSkuML = XR_ERROR_SYSTEM_NOTIFICATION_INCOMPATIBLE_SKU_ML,
#endif  // XR_ML_system_notifications
#ifdef dsaXR_ML_world_mesh_detection
  ErrorWorldMeshDetectorPermissionDeniedML = XR_ERROR_WORLD_MESH_DETECTOR_PERMISSION_DENIED_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
  ErrorWorldMeshDetectorSpaceNotLocatableML = XR_ERROR_WORLD_MESH_DETECTOR_SPACE_NOT_LOCATABLE_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef XR_ML_facial_expression
  ErrorFacialExpressionPermissionDeniedML = XR_ERROR_FACIAL_EXPRESSION_PERMISSION_DENIED_ML,
#endif  // XR_ML_facial_expression
#ifdef XR_META_colocation_discovery
  ErrorColocationDiscoveryNetworkFailedMETA = XR_ERROR_COLOCATION_DISCOVERY_NETWORK_FAILED_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  ErrorColocationDiscoveryNoDiscoveryMethodMETA =
      XR_ERROR_COLOCATION_DISCOVERY_NO_DISCOVERY_METHOD_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  ColocationDiscoveryAlreadyAdvertisingMETA = XR_COLOCATION_DISCOVERY_ALREADY_ADVERTISING_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  ColocationDiscoveryAlreadyDiscoveringMETA = XR_COLOCATION_DISCOVERY_ALREADY_DISCOVERING_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_spatial_entity_group_sharing
  ErrorSpaceGroupNotFoundMETA = XR_ERROR_SPACE_GROUP_NOT_FOUND_META,
#endif  // XR_META_spatial_entity_group_sharing
#ifdef XR_EXT_spatial_entity
  ErrorSpatialCapabilityUnsupportedEXT = XR_ERROR_SPATIAL_CAPABILITY_UNSUPPORTED_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  ErrorSpatialEntityIdInvalidEXT = XR_ERROR_SPATIAL_ENTITY_ID_INVALID_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  ErrorSpatialBufferIdInvalidEXT = XR_ERROR_SPATIAL_BUFFER_ID_INVALID_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  ErrorSpatialComponentUnsupportedForCapabilityEXT =
      XR_ERROR_SPATIAL_COMPONENT_UNSUPPORTED_FOR_CAPABILITY_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  ErrorSpatialCapabilityConfigurationInvalidEXT =
      XR_ERROR_SPATIAL_CAPABILITY_CONFIGURATION_INVALID_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  ErrorSpatialComponentNotEnabledEXT = XR_ERROR_SPATIAL_COMPONENT_NOT_ENABLED_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef dsaXR_EXT_spatial_persistence
  ErrorSpatialPersistenceScopeUnsupportedEXT = XR_ERROR_SPATIAL_PERSISTENCE_SCOPE_UNSUPPORTED_EXT,
#endif  // XR_EXT_spatial_persistence
#ifdef dsaXR_EXT_spatial_persistence_operations
  ErrorSpatialPersistenceScopeIncompatibleEXT = XR_ERROR_SPATIAL_PERSISTENCE_SCOPE_INCOMPATIBLE_EXT,
#endif  // XR_EXT_spatial_persistence_operations
};
static_assert(sizeof(Result) == sizeof(XrResult), "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrResult value from a Result.
 *
 * @found_by_adl
 * @see Result
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrResult get(Result const& v) {
  return static_cast<XrResult>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrResult address from a Result.
 *
 * @found_by_adl
 * @see Result
 */
OPENXR_HPP_INLINE XrResult* put(Result& v) { return reinterpret_cast<XrResult*>(&v); }

/*!
 * @brief Free function for retrieving the string name of a Result value as a const char *.
 *
 * @found_by_adl
 * @see Result
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(Result value) {
  switch (value) {
    case Result::Success:
      return "Success";

    case Result::TimeoutExpired:
      return "TimeoutExpired";

    case Result::SessionLossPending:
      return "SessionLossPending";

    case Result::EventUnavailable:
      return "EventUnavailable";

    case Result::SpaceBoundsUnavailable:
      return "SpaceBoundsUnavailable";

    case Result::SessionNotFocused:
      return "SessionNotFocused";

    case Result::FrameDiscarded:
      return "FrameDiscarded";

    case Result::ErrorValidationFailure:
      return "ErrorValidationFailure";

    case Result::ErrorRuntimeFailure:
      return "ErrorRuntimeFailure";

    case Result::ErrorOutOfMemory:
      return "ErrorOutOfMemory";

    case Result::ErrorAPIVersionUnsupported:
      return "ErrorAPIVersionUnsupported";

    case Result::ErrorInitializationFailed:
      return "ErrorInitializationFailed";

    case Result::ErrorFunctionUnsupported:
      return "ErrorFunctionUnsupported";

    case Result::ErrorFeatureUnsupported:
      return "ErrorFeatureUnsupported";

    case Result::ErrorExtensionNotPresent:
      return "ErrorExtensionNotPresent";

    case Result::ErrorLimitReached:
      return "ErrorLimitReached";

    case Result::ErrorSizeInsufficient:
      return "ErrorSizeInsufficient";

    case Result::ErrorHandleInvalid:
      return "ErrorHandleInvalid";

    case Result::ErrorInstanceLost:
      return "ErrorInstanceLost";

    case Result::ErrorSessionRunning:
      return "ErrorSessionRunning";

    case Result::ErrorSessionNotRunning:
      return "ErrorSessionNotRunning";

    case Result::ErrorSessionLost:
      return "ErrorSessionLost";

    case Result::ErrorSystemInvalid:
      return "ErrorSystemInvalid";

    case Result::ErrorPathInvalid:
      return "ErrorPathInvalid";

    case Result::ErrorPathCountExceeded:
      return "ErrorPathCountExceeded";

    case Result::ErrorPathFormatInvalid:
      return "ErrorPathFormatInvalid";

    case Result::ErrorPathUnsupported:
      return "ErrorPathUnsupported";

    case Result::ErrorLayerInvalid:
      return "ErrorLayerInvalid";

    case Result::ErrorLayerLimitExceeded:
      return "ErrorLayerLimitExceeded";

    case Result::ErrorSwapchainRectInvalid:
      return "ErrorSwapchainRectInvalid";

    case Result::ErrorSwapchainFormatUnsupported:
      return "ErrorSwapchainFormatUnsupported";

    case Result::ErrorActionTypeMismatch:
      return "ErrorActionTypeMismatch";

    case Result::ErrorSessionNotReady:
      return "ErrorSessionNotReady";

    case Result::ErrorSessionNotStopping:
      return "ErrorSessionNotStopping";

    case Result::ErrorTimeInvalid:
      return "ErrorTimeInvalid";

    case Result::ErrorReferenceSpaceUnsupported:
      return "ErrorReferenceSpaceUnsupported";

    case Result::ErrorFileAccessError:
      return "ErrorFileAccessError";

    case Result::ErrorFileContentsInvalid:
      return "ErrorFileContentsInvalid";

    case Result::ErrorFormFactorUnsupported:
      return "ErrorFormFactorUnsupported";

    case Result::ErrorFormFactorUnavailable:
      return "ErrorFormFactorUnavailable";

    case Result::ErrorAPILayerNotPresent:
      return "ErrorAPILayerNotPresent";

    case Result::ErrorCallOrderInvalid:
      return "ErrorCallOrderInvalid";

    case Result::ErrorGraphicsDeviceInvalid:
      return "ErrorGraphicsDeviceInvalid";

    case Result::ErrorPoseInvalid:
      return "ErrorPoseInvalid";

    case Result::ErrorIndexOutOfRange:
      return "ErrorIndexOutOfRange";

    case Result::ErrorViewConfigurationTypeUnsupported:
      return "ErrorViewConfigurationTypeUnsupported";

    case Result::ErrorEnvironmentBlendModeUnsupported:
      return "ErrorEnvironmentBlendModeUnsupported";

    case Result::ErrorNameDuplicated:
      return "ErrorNameDuplicated";

    case Result::ErrorNameInvalid:
      return "ErrorNameInvalid";

    case Result::ErrorActionsetNotAttached:
      return "ErrorActionsetNotAttached";

    case Result::ErrorActionsetsAlreadyAttached:
      return "ErrorActionsetsAlreadyAttached";

    case Result::ErrorLocalizedNameDuplicated:
      return "ErrorLocalizedNameDuplicated";

    case Result::ErrorLocalizedNameInvalid:
      return "ErrorLocalizedNameInvalid";

    case Result::ErrorGraphicsRequirementsCallMissing:
      return "ErrorGraphicsRequirementsCallMissing";

    case Result::ErrorRuntimeUnavailable:
      return "ErrorRuntimeUnavailable";

    case Result::ErrorExtensionDependencyNotEnabled:
      return "ErrorExtensionDependencyNotEnabled";

    case Result::ErrorPermissionInsufficient:
      return "ErrorPermissionInsufficient";

#ifdef XR_KHR_android_thread_settings
    case Result::ErrorAndroidThreadSettingsIdInvalidKHR:
      return "ErrorAndroidThreadSettingsIdInvalidKHR";
#endif  // XR_KHR_android_thread_settings
#ifdef XR_KHR_android_thread_settings
    case Result::ErrorAndroidThreadSettingsFailureKHR:
      return "ErrorAndroidThreadSettingsFailureKHR";
#endif  // XR_KHR_android_thread_settings
#ifdef XR_MSFT_spatial_anchor
    case Result::ErrorCreateSpatialAnchorFailedMSFT:
      return "ErrorCreateSpatialAnchorFailedMSFT";
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_secondary_view_configuration
    case Result::ErrorSecondaryViewConfigurationTypeNotEnabledMSFT:
      return "ErrorSecondaryViewConfigurationTypeNotEnabledMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_controller_model
    case Result::ErrorControllerModelKeyInvalidMSFT:
      return "ErrorControllerModelKeyInvalidMSFT";
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_composition_layer_reprojection
    case Result::ErrorReprojectionModeUnsupportedMSFT:
      return "ErrorReprojectionModeUnsupportedMSFT";
#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_MSFT_scene_understanding
    case Result::ErrorComputeNewSceneNotCompletedMSFT:
      return "ErrorComputeNewSceneNotCompletedMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case Result::ErrorSceneComponentIdInvalidMSFT:
      return "ErrorSceneComponentIdInvalidMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case Result::ErrorSceneComponentTypeMismatchMSFT:
      return "ErrorSceneComponentTypeMismatchMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case Result::ErrorSceneMeshBufferIdInvalidMSFT:
      return "ErrorSceneMeshBufferIdInvalidMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case Result::ErrorSceneComputeFeatureIncompatibleMSFT:
      return "ErrorSceneComputeFeatureIncompatibleMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case Result::ErrorSceneComputeConsistencyMismatchMSFT:
      return "ErrorSceneComputeConsistencyMismatchMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_FB_display_refresh_rate
    case Result::ErrorDisplayRefreshRateUnsupportedFB:
      return "ErrorDisplayRefreshRateUnsupportedFB";
#endif  // XR_FB_display_refresh_rate
#ifdef XR_FB_color_space
    case Result::ErrorColorSpaceUnsupportedFB:
      return "ErrorColorSpaceUnsupportedFB";
#endif  // XR_FB_color_space
#ifdef XR_FB_spatial_entity
    case Result::ErrorSpaceComponentNotSupportedFB:
      return "ErrorSpaceComponentNotSupportedFB";
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
    case Result::ErrorSpaceComponentNotEnabledFB:
      return "ErrorSpaceComponentNotEnabledFB";
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
    case Result::ErrorSpaceComponentStatusPendingFB:
      return "ErrorSpaceComponentStatusPendingFB";
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
    case Result::ErrorSpaceComponentStatusAlreadySetFB:
      return "ErrorSpaceComponentStatusAlreadySetFB";
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_passthrough
    case Result::ErrorUnexpectedStatePassthroughFB:
      return "ErrorUnexpectedStatePassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case Result::ErrorFeatureAlreadyCreatedPassthroughFB:
      return "ErrorFeatureAlreadyCreatedPassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case Result::ErrorFeatureRequiredPassthroughFB:
      return "ErrorFeatureRequiredPassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case Result::ErrorNotPermittedPassthroughFB:
      return "ErrorNotPermittedPassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case Result::ErrorInsufficientResourcesPassthroughFB:
      return "ErrorInsufficientResourcesPassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case Result::ErrorUnknownPassthroughFB:
      return "ErrorUnknownPassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_render_model
    case Result::ErrorRenderModelKeyInvalidFB:
      return "ErrorRenderModelKeyInvalidFB";
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
    case Result::RenderModelUnavailableFB:
      return "RenderModelUnavailableFB";
#endif  // XR_FB_render_model
#ifdef XR_VARJO_marker_tracking
    case Result::ErrorMarkerNotTrackedVARJO:
      return "ErrorMarkerNotTrackedVARJO";
#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking
    case Result::ErrorMarkerIdInvalidVARJO:
      return "ErrorMarkerIdInvalidVARJO";
#endif  // XR_VARJO_marker_tracking
#ifdef XR_ML_marker_understanding
    case Result::ErrorMarkerDetectorPermissionDeniedML:
      return "ErrorMarkerDetectorPermissionDeniedML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
    case Result::ErrorMarkerDetectorLocateFailedML:
      return "ErrorMarkerDetectorLocateFailedML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
    case Result::ErrorMarkerDetectorInvalidDataQueryML:
      return "ErrorMarkerDetectorInvalidDataQueryML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
    case Result::ErrorMarkerDetectorInvalidCreateInfoML:
      return "ErrorMarkerDetectorInvalidCreateInfoML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
    case Result::ErrorMarkerInvalidML:
      return "ErrorMarkerInvalidML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_localization_map
    case Result::ErrorLocalizationMapIncompatibleML:
      return "ErrorLocalizationMapIncompatibleML";
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
    case Result::ErrorLocalizationMapUnavailableML:
      return "ErrorLocalizationMapUnavailableML";
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
    case Result::ErrorLocalizationMapFailML:
      return "ErrorLocalizationMapFailML";
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
    case Result::ErrorLocalizationMapImportExportPermissionDeniedML:
      return "ErrorLocalizationMapImportExportPermissionDeniedML";
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
    case Result::ErrorLocalizationMapPermissionDeniedML:
      return "ErrorLocalizationMapPermissionDeniedML";
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
    case Result::ErrorLocalizationMapAlreadyExistsML:
      return "ErrorLocalizationMapAlreadyExistsML";
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
    case Result::ErrorLocalizationMapCannotExportCloudMapML:
      return "ErrorLocalizationMapCannotExportCloudMapML";
#endif  // XR_ML_localization_map
#ifdef dsaXR_ML_spatial_anchors
    case Result::ErrorSpatialAnchorsPermissionDeniedML:
      return "ErrorSpatialAnchorsPermissionDeniedML";
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors
    case Result::ErrorSpatialAnchorsNotLocalizedML:
      return "ErrorSpatialAnchorsNotLocalizedML";
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors
    case Result::ErrorSpatialAnchorsOutOfMapBoundsML:
      return "ErrorSpatialAnchorsOutOfMapBoundsML";
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors
    case Result::ErrorSpatialAnchorsSpaceNotLocatableML:
      return "ErrorSpatialAnchorsSpaceNotLocatableML";
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors_storage
    case Result::ErrorSpatialAnchorsAnchorNotFoundML:
      return "ErrorSpatialAnchorsAnchorNotFoundML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef XR_MSFT_spatial_anchor_persistence
    case Result::ErrorSpatialAnchorNameNotFoundMSFT:
      return "ErrorSpatialAnchorNameNotFoundMSFT";
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence
    case Result::ErrorSpatialAnchorNameInvalidMSFT:
      return "ErrorSpatialAnchorNameInvalidMSFT";
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_scene_marker
    case Result::SceneMarkerDataNotStringMSFT:
      return "SceneMarkerDataNotStringMSFT";
#endif  // XR_MSFT_scene_marker
#ifdef XR_FB_spatial_entity_sharing
    case Result::ErrorSpaceMappingInsufficientFB:
      return "ErrorSpaceMappingInsufficientFB";
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_spatial_entity_sharing
    case Result::ErrorSpaceLocalizationFailedFB:
      return "ErrorSpaceLocalizationFailedFB";
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_spatial_entity_sharing
    case Result::ErrorSpaceNetworkTimeoutFB:
      return "ErrorSpaceNetworkTimeoutFB";
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_spatial_entity_sharing
    case Result::ErrorSpaceNetworkRequestFailedFB:
      return "ErrorSpaceNetworkRequestFailedFB";
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_spatial_entity_sharing
    case Result::ErrorSpaceCloudStorageDisabledFB:
      return "ErrorSpaceCloudStorageDisabledFB";
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_META_passthrough_color_lut
    case Result::ErrorPassthroughColorLutBufferSizeMismatchMETA:
      return "ErrorPassthroughColorLutBufferSizeMismatchMETA";
#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_environment_depth
    case Result::EnvironmentDepthNotAvailableMETA:
      return "EnvironmentDepthNotAvailableMETA";
#endif  // XR_META_environment_depth
#ifdef XR_EXT_render_model
    case Result::ErrorRenderModelIdInvalidEXT:
      return "ErrorRenderModelIdInvalidEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case Result::ErrorRenderModelAssetUnavailableEXT:
      return "ErrorRenderModelAssetUnavailableEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case Result::ErrorRenderModelGltfExtensionRequiredEXT:
      return "ErrorRenderModelGltfExtensionRequiredEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_interaction_render_model
    case Result::ErrorNotInteractionRenderModelEXT:
      return "ErrorNotInteractionRenderModelEXT";
#endif  // XR_EXT_interaction_render_model
#ifdef XR_QCOM_tracking_optimization_settings
    case Result::ErrorHintAlreadySetQCOM:
      return "ErrorHintAlreadySetQCOM";
#endif  // XR_QCOM_tracking_optimization_settings
#ifdef XR_HTC_anchor
    case Result::ErrorNotAnAnchorHTC:
      return "ErrorNotAnAnchorHTC";
#endif  // XR_HTC_anchor
#ifdef XR_BD_spatial_sensing
    case Result::ErrorSpatialEntityIdInvalidBD:
      return "ErrorSpatialEntityIdInvalidBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case Result::ErrorSpatialSensingServiceUnavailableBD:
      return "ErrorSpatialSensingServiceUnavailableBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case Result::ErrorAnchorNotSupportedForEntityBD:
      return "ErrorAnchorNotSupportedForEntityBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_anchor
    case Result::ErrorSpatialAnchorNotFoundBD:
      return "ErrorSpatialAnchorNotFoundBD";
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_anchor_sharing
    case Result::ErrorSpatialAnchorSharingNetworkTimeoutBD:
      return "ErrorSpatialAnchorSharingNetworkTimeoutBD";
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_anchor_sharing
    case Result::ErrorSpatialAnchorSharingAuthenticationFailureBD:
      return "ErrorSpatialAnchorSharingAuthenticationFailureBD";
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_anchor_sharing
    case Result::ErrorSpatialAnchorSharingNetworkFailureBD:
      return "ErrorSpatialAnchorSharingNetworkFailureBD";
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_anchor_sharing
    case Result::ErrorSpatialAnchorSharingLocalizationFailBD:
      return "ErrorSpatialAnchorSharingLocalizationFailBD";
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_anchor_sharing
    case Result::ErrorSpatialAnchorSharingMapInsufficientBD:
      return "ErrorSpatialAnchorSharingMapInsufficientBD";
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_scene
    case Result::ErrorSceneCaptureFailureBD:
      return "ErrorSceneCaptureFailureBD";
#endif  // XR_BD_spatial_scene
#ifdef XR_EXT_plane_detection
    case Result::ErrorSpaceNotLocatableEXT:
      return "ErrorSpaceNotLocatableEXT";
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
    case Result::ErrorPlaneDetectionPermissionDeniedEXT:
      return "ErrorPlaneDetectionPermissionDeniedEXT";
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_future
    case Result::ErrorFuturePendingEXT:
      return "ErrorFuturePendingEXT";
#endif  // XR_EXT_future
#ifdef XR_EXT_future
    case Result::ErrorFutureInvalidEXT:
      return "ErrorFutureInvalidEXT";
#endif  // XR_EXT_future
#ifdef XR_ML_system_notifications
    case Result::ErrorSystemNotificationPermissionDeniedML:
      return "ErrorSystemNotificationPermissionDeniedML";
#endif  // XR_ML_system_notifications
#ifdef XR_ML_system_notifications
    case Result::ErrorSystemNotificationIncompatibleSkuML:
      return "ErrorSystemNotificationIncompatibleSkuML";
#endif  // XR_ML_system_notifications
#ifdef dsaXR_ML_world_mesh_detection
    case Result::ErrorWorldMeshDetectorPermissionDeniedML:
      return "ErrorWorldMeshDetectorPermissionDeniedML";
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
    case Result::ErrorWorldMeshDetectorSpaceNotLocatableML:
      return "ErrorWorldMeshDetectorSpaceNotLocatableML";
#endif  // XR_ML_world_mesh_detection
#ifdef XR_ML_facial_expression
    case Result::ErrorFacialExpressionPermissionDeniedML:
      return "ErrorFacialExpressionPermissionDeniedML";
#endif  // XR_ML_facial_expression
#ifdef XR_META_colocation_discovery
    case Result::ErrorColocationDiscoveryNetworkFailedMETA:
      return "ErrorColocationDiscoveryNetworkFailedMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case Result::ErrorColocationDiscoveryNoDiscoveryMethodMETA:
      return "ErrorColocationDiscoveryNoDiscoveryMethodMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case Result::ColocationDiscoveryAlreadyAdvertisingMETA:
      return "ColocationDiscoveryAlreadyAdvertisingMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case Result::ColocationDiscoveryAlreadyDiscoveringMETA:
      return "ColocationDiscoveryAlreadyDiscoveringMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_spatial_entity_group_sharing
    case Result::ErrorSpaceGroupNotFoundMETA:
      return "ErrorSpaceGroupNotFoundMETA";
#endif  // XR_META_spatial_entity_group_sharing
#ifdef XR_EXT_spatial_entity
    case Result::ErrorSpatialCapabilityUnsupportedEXT:
      return "ErrorSpatialCapabilityUnsupportedEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case Result::ErrorSpatialEntityIdInvalidEXT:
      return "ErrorSpatialEntityIdInvalidEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case Result::ErrorSpatialBufferIdInvalidEXT:
      return "ErrorSpatialBufferIdInvalidEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case Result::ErrorSpatialComponentUnsupportedForCapabilityEXT:
      return "ErrorSpatialComponentUnsupportedForCapabilityEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case Result::ErrorSpatialCapabilityConfigurationInvalidEXT:
      return "ErrorSpatialCapabilityConfigurationInvalidEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case Result::ErrorSpatialComponentNotEnabledEXT:
      return "ErrorSpatialComponentNotEnabledEXT";
#endif  // XR_EXT_spatial_entity
#ifdef dsaXR_EXT_spatial_persistence
    case Result::ErrorSpatialPersistenceScopeUnsupportedEXT:
      return "ErrorSpatialPersistenceScopeUnsupportedEXT";
#endif  // XR_EXT_spatial_persistence
#ifdef dsaXR_EXT_spatial_persistence_operations
    case Result::ErrorSpatialPersistenceScopeIncompatibleEXT:
      return "ErrorSpatialPersistenceScopeIncompatibleEXT";
#endif  // XR_EXT_spatial_persistence_operations
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a Result value as a std::string.
 *
 * @found_by_adl
 * @see Result
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(Result value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @defgroup result_helpers Result helper free functions
 * @brief C++ projections of the XrResult-checking function-style macros as constexpr functions.
 * @ingroup enums
 * @{
 */
/*!
 * @brief Return true if the Result is negative, indicating a failure.
 * Equivalent of XR_FAILED().
 * @found_by_adl
 * @see Result
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XR_FAILED>
 * @xrentity{XR_FAILED}
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool failed(Result v) { return static_cast<int>(v) < 0; }

/*!
 * @brief Return true if the result is non-negative, indicating a success or non-error result.
 * Equivalent of XR_SUCCEEDED().
 * @found_by_adl
 * @see Result
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XR_SUCCEEDED>
 * @xrentity{XR_SUCCEEDED}
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool succeeded(Result v) { return static_cast<int>(v) >= 0; }

/*!
 * @brief Return true if the result is exactly equal to Result::Success.
 * Equivalent of XR_UNQUALIFIED_SUCCESS().
 * @found_by_adl
 * @see Result
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XR_UNQUALIFIED_SUCCESS>
 * @xrentity{XR_UNQUALIFIED_SUCCESS}
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool unqualifiedSuccess(Result v) {
  return v == Result::Success;
}
//! @}

/*!
 * @brief `<` comparison between Result and integer, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Result lhs, int rhs) {
  return get(lhs) < rhs;
}

/*!
 * @brief `<` comparison between integer and Result, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(int lhs, Result rhs) {
  return lhs < get(rhs);
}

/*!
 * @brief `>` comparison between Result and integer, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Result lhs, int rhs) {
  return get(lhs) > rhs;
}

/*!
 * @brief `>` comparison between integer and Result, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(int lhs, Result rhs) {
  return lhs > get(rhs);
}

/*!
 * @brief `<=` comparison between Result and integer, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Result lhs, int rhs) {
  return get(lhs) <= rhs;
}

/*!
 * @brief `<=` comparison between integer and Result, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(int lhs, Result rhs) {
  return lhs <= get(rhs);
}

/*!
 * @brief `>=` comparison between Result and integer, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Result lhs, int rhs) {
  return get(lhs) >= rhs;
}

/*!
 * @brief `>=` comparison between integer and Result, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(int lhs, Result rhs) {
  return lhs >= get(rhs);
}

/*!
 * @brief `==` comparison between Result and integer, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Result lhs, int rhs) {
  return get(lhs) == rhs;
}

/*!
 * @brief `==` comparison between integer and Result, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(int lhs, Result rhs) {
  return lhs == get(rhs);
}

/*!
 * @brief `!=` comparison between Result and integer, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Result lhs, int rhs) {
  return get(lhs) != rhs;
}

/*!
 * @brief `!=` comparison between integer and Result, for compatibility with the XR_ function-type
 * macros and XrResult.
 * @see Result
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(int lhs, Result rhs) {
  return lhs != get(rhs);
}

/*!
 * @brief Enum class for XrStructureType
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrStructureType>
 *
 * @xrentity{XrStructureType}
 */
enum class StructureType {

  Unknown = XR_TYPE_UNKNOWN,

  APILayerProperties = XR_TYPE_API_LAYER_PROPERTIES,

  ExtensionProperties = XR_TYPE_EXTENSION_PROPERTIES,

  InstanceCreateInfo = XR_TYPE_INSTANCE_CREATE_INFO,

  SystemGetInfo = XR_TYPE_SYSTEM_GET_INFO,

  SystemProperties = XR_TYPE_SYSTEM_PROPERTIES,

  ViewLocateInfo = XR_TYPE_VIEW_LOCATE_INFO,

  View = XR_TYPE_VIEW,

  SessionCreateInfo = XR_TYPE_SESSION_CREATE_INFO,

  SwapchainCreateInfo = XR_TYPE_SWAPCHAIN_CREATE_INFO,

  SessionBeginInfo = XR_TYPE_SESSION_BEGIN_INFO,

  ViewState = XR_TYPE_VIEW_STATE,

  FrameEndInfo = XR_TYPE_FRAME_END_INFO,

  HapticVibration = XR_TYPE_HAPTIC_VIBRATION,

  EventDataBuffer = XR_TYPE_EVENT_DATA_BUFFER,

  EventDataInstanceLossPending = XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING,

  EventDataSessionStateChanged = XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED,

  ActionStateBoolean = XR_TYPE_ACTION_STATE_BOOLEAN,

  ActionStateFloat = XR_TYPE_ACTION_STATE_FLOAT,

  ActionStateVector2F = XR_TYPE_ACTION_STATE_VECTOR2F,

  ActionStatePose = XR_TYPE_ACTION_STATE_POSE,

  ActionSetCreateInfo = XR_TYPE_ACTION_SET_CREATE_INFO,

  ActionCreateInfo = XR_TYPE_ACTION_CREATE_INFO,

  InstanceProperties = XR_TYPE_INSTANCE_PROPERTIES,

  FrameWaitInfo = XR_TYPE_FRAME_WAIT_INFO,

  CompositionLayerProjection = XR_TYPE_COMPOSITION_LAYER_PROJECTION,

  CompositionLayerQuad = XR_TYPE_COMPOSITION_LAYER_QUAD,

  ReferenceSpaceCreateInfo = XR_TYPE_REFERENCE_SPACE_CREATE_INFO,

  ActionSpaceCreateInfo = XR_TYPE_ACTION_SPACE_CREATE_INFO,

  EventDataReferenceSpaceChangePending = XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING,

  ViewConfigurationView = XR_TYPE_VIEW_CONFIGURATION_VIEW,

  SpaceLocation = XR_TYPE_SPACE_LOCATION,

  SpaceVelocity = XR_TYPE_SPACE_VELOCITY,

  FrameState = XR_TYPE_FRAME_STATE,

  ViewConfigurationProperties = XR_TYPE_VIEW_CONFIGURATION_PROPERTIES,

  FrameBeginInfo = XR_TYPE_FRAME_BEGIN_INFO,

  CompositionLayerProjectionView = XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW,

  EventDataEventsLost = XR_TYPE_EVENT_DATA_EVENTS_LOST,

  InteractionProfileSuggestedBinding = XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING,

  EventDataInteractionProfileChanged = XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED,

  InteractionProfileState = XR_TYPE_INTERACTION_PROFILE_STATE,

  SwapchainImageAcquireInfo = XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO,

  SwapchainImageWaitInfo = XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO,

  SwapchainImageReleaseInfo = XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO,

  ActionStateGetInfo = XR_TYPE_ACTION_STATE_GET_INFO,

  HapticActionInfo = XR_TYPE_HAPTIC_ACTION_INFO,

  SessionActionSetsAttachInfo = XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO,

  ActionsSyncInfo = XR_TYPE_ACTIONS_SYNC_INFO,

  BoundSourcesForActionEnumerateInfo = XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO,

  InputSourceLocalizedNameGetInfo = XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO,

  SpacesLocateInfo = XR_TYPE_SPACES_LOCATE_INFO,

  SpaceLocations = XR_TYPE_SPACE_LOCATIONS,

  SpaceVelocities = XR_TYPE_SPACE_VELOCITIES,

#ifdef XR_KHR_composition_layer_cube
  CompositionLayerCubeKHR = XR_TYPE_COMPOSITION_LAYER_CUBE_KHR,
#endif  // XR_KHR_composition_layer_cube
#ifdef XR_KHR_android_create_instance
  InstanceCreateInfoAndroidKHR = XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR,
#endif  // XR_KHR_android_create_instance
#ifdef XR_KHR_composition_layer_depth
  CompositionLayerDepthInfoKHR = XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR,
#endif  // XR_KHR_composition_layer_depth
#ifdef XR_KHR_vulkan_swapchain_format_list
  VulkanSwapchainFormatListCreateInfoKHR = XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR,
#endif  // XR_KHR_vulkan_swapchain_format_list
#ifdef XR_EXT_performance_settings
  EventDataPerfSettingsEXT = XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT,
#endif  // XR_EXT_performance_settings
#ifdef XR_KHR_composition_layer_cylinder
  CompositionLayerCylinderKHR = XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR,
#endif  // XR_KHR_composition_layer_cylinder
#ifdef XR_KHR_composition_layer_equirect
  CompositionLayerEquirectKHR = XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR,
#endif  // XR_KHR_composition_layer_equirect
#ifdef XR_EXT_debug_utils
  DebugUtilsObjectNameInfoEXT = XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils
  DebugUtilsMessengerCallbackDataEXT = XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils
  DebugUtilsMessengerCreateInfoEXT = XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils
  DebugUtilsLabelEXT = XR_TYPE_DEBUG_UTILS_LABEL_EXT,
#endif  // XR_EXT_debug_utils
#ifdef XR_KHR_opengl_enable
  GraphicsBindingOpenGLWin32KHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR,
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
  GraphicsBindingOpenGLXlibKHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR,
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
  GraphicsBindingOpenGLXcbKHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR,
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
  GraphicsBindingOpenGLWaylandKHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR,
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
  SwapchainImageOpenGLKHR = XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR,
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
  GraphicsRequirementsOpenGLKHR = XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR,
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_es_enable
  GraphicsBindingOpenGLESAndroidKHR = XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR,
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_opengl_es_enable
  SwapchainImageOpenGLESKHR = XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR,
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_opengl_es_enable
  GraphicsRequirementsOpenGLESKHR = XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR,
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_vulkan_enable
  GraphicsBindingVulkanKHR = XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR,
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
  SwapchainImageVulkanKHR = XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR,
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
  GraphicsRequirementsVulkanKHR = XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR,
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_D3D11_enable
  GraphicsBindingD3D11KHR = XR_TYPE_GRAPHICS_BINDING_D3D11_KHR,
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D11_enable
  SwapchainImageD3D11KHR = XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR,
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D11_enable
  GraphicsRequirementsD3D11KHR = XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR,
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D12_enable
  GraphicsBindingD3D12KHR = XR_TYPE_GRAPHICS_BINDING_D3D12_KHR,
#endif  // XR_KHR_D3D12_enable
#ifdef XR_KHR_D3D12_enable
  SwapchainImageD3D12KHR = XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR,
#endif  // XR_KHR_D3D12_enable
#ifdef XR_KHR_D3D12_enable
  GraphicsRequirementsD3D12KHR = XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR,
#endif  // XR_KHR_D3D12_enable
#ifdef XR_KHR_metal_enable
  GraphicsBindingMetalKHR = XR_TYPE_GRAPHICS_BINDING_METAL_KHR,
#endif  // XR_KHR_metal_enable
#ifdef XR_KHR_metal_enable
  SwapchainImageMetalKHR = XR_TYPE_SWAPCHAIN_IMAGE_METAL_KHR,
#endif  // XR_KHR_metal_enable
#ifdef XR_KHR_metal_enable
  GraphicsRequirementsMetalKHR = XR_TYPE_GRAPHICS_REQUIREMENTS_METAL_KHR,
#endif  // XR_KHR_metal_enable
#ifdef XR_EXT_eye_gaze_interaction
  SystemEyeGazeInteractionPropertiesEXT = XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT,
#endif  // XR_EXT_eye_gaze_interaction
#ifdef XR_EXT_eye_gaze_interaction
  EyeGazeSampleTimeEXT = XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT,
#endif  // XR_EXT_eye_gaze_interaction
#ifdef XR_KHR_visibility_mask
  VisibilityMaskKHR = XR_TYPE_VISIBILITY_MASK_KHR,
#endif  // XR_KHR_visibility_mask
#ifdef XR_KHR_visibility_mask
  EventDataVisibilityMaskChangedKHR = XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR,
#endif  // XR_KHR_visibility_mask
#ifdef XR_EXTX_overlay
  SessionCreateInfoOverlayEXTX = XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX,
#endif  // XR_EXTX_overlay
#ifdef XR_EXTX_overlay
  EventDataMainSessionVisibilityChangedEXTX =
      XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX,
#endif  // XR_EXTX_overlay
#ifdef XR_KHR_composition_layer_color_scale_bias
  CompositionLayerColorScaleBiasKHR = XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR,
#endif  // XR_KHR_composition_layer_color_scale_bias
#ifdef XR_MSFT_spatial_anchor
  SpatialAnchorCreateInfoMSFT = XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT,
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_spatial_anchor
  SpatialAnchorSpaceCreateInfoMSFT = XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT,
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_FB_composition_layer_image_layout
  CompositionLayerImageLayoutFB = XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB,
#endif  // XR_FB_composition_layer_image_layout
#ifdef XR_FB_composition_layer_alpha_blend
  CompositionLayerAlphaBlendFB = XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB,
#endif  // XR_FB_composition_layer_alpha_blend
#ifdef XR_EXT_view_configuration_depth_range
  ViewConfigurationDepthRangeEXT = XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT,
#endif  // XR_EXT_view_configuration_depth_range
#ifdef XR_MNDX_egl_enable
  GraphicsBindingEGLMNDX = XR_TYPE_GRAPHICS_BINDING_EGL_MNDX,
#endif  // XR_MNDX_egl_enable
#ifdef XR_MSFT_spatial_graph_bridge
  SpatialGraphNodeSpaceCreateInfoMSFT = XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT,
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_MSFT_spatial_graph_bridge
  SpatialGraphStaticNodeBindingCreateInfoMSFT =
      XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT,
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_MSFT_spatial_graph_bridge
  SpatialGraphNodeBindingPropertiesGetInfoMSFT =
      XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT,
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_MSFT_spatial_graph_bridge
  SpatialGraphNodeBindingPropertiesMSFT = XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT,
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_EXT_hand_tracking
  SystemHandTrackingPropertiesEXT = XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT,
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
  HandTrackerCreateInfoEXT = XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT,
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
  HandJointsLocateInfoEXT = XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT,
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
  HandJointLocationsEXT = XR_TYPE_HAND_JOINT_LOCATIONS_EXT,
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
  HandJointVelocitiesEXT = XR_TYPE_HAND_JOINT_VELOCITIES_EXT,
#endif  // XR_EXT_hand_tracking
#ifdef XR_MSFT_hand_tracking_mesh
  SystemHandTrackingMeshPropertiesMSFT = XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT,
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
  HandMeshSpaceCreateInfoMSFT = XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT,
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
  HandMeshUpdateInfoMSFT = XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT,
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
  HandMeshMSFT = XR_TYPE_HAND_MESH_MSFT,
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
  HandPoseTypeInfoMSFT = XR_TYPE_HAND_POSE_TYPE_INFO_MSFT,
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_secondary_view_configuration
  SecondaryViewConfigurationSessionBeginInfoMSFT =
      XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
  SecondaryViewConfigurationStateMSFT = XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
  SecondaryViewConfigurationFrameStateMSFT = XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
  SecondaryViewConfigurationFrameEndInfoMSFT =
      XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
  SecondaryViewConfigurationLayerInfoMSFT = XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
  SecondaryViewConfigurationSwapchainCreateInfoMSFT =
      XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT,
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_controller_model
  ControllerModelKeyStateMSFT = XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT,
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
  ControllerModelNodePropertiesMSFT = XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT,
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
  ControllerModelPropertiesMSFT = XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT,
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
  ControllerModelNodeStateMSFT = XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT,
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
  ControllerModelStateMSFT = XR_TYPE_CONTROLLER_MODEL_STATE_MSFT,
#endif  // XR_MSFT_controller_model
#ifdef XR_EPIC_view_configuration_fov
  ViewConfigurationViewFovEPIC = XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC,
#endif  // XR_EPIC_view_configuration_fov
#ifdef XR_MSFT_holographic_window_attachment
  HolographicWindowAttachmentMSFT = XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT,
#endif  // XR_MSFT_holographic_window_attachment
#ifdef XR_MSFT_composition_layer_reprojection
  CompositionLayerReprojectionInfoMSFT = XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT,
#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_MSFT_composition_layer_reprojection
  CompositionLayerReprojectionPlaneOverrideMSFT =
      XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT,
#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_FB_android_surface_swapchain_create
  AndroidSurfaceSwapchainCreateInfoFB = XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB,
#endif  // XR_FB_android_surface_swapchain_create
#ifdef XR_FB_composition_layer_secure_content
  CompositionLayerSecureContentFB = XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB,
#endif  // XR_FB_composition_layer_secure_content
#ifdef XR_FB_body_tracking
  BodyTrackerCreateInfoFB = XR_TYPE_BODY_TRACKER_CREATE_INFO_FB,
#endif  // XR_FB_body_tracking
#ifdef XR_FB_body_tracking
  BodyJointsLocateInfoFB = XR_TYPE_BODY_JOINTS_LOCATE_INFO_FB,
#endif  // XR_FB_body_tracking
#ifdef XR_FB_body_tracking
  SystemBodyTrackingPropertiesFB = XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_FB,
#endif  // XR_FB_body_tracking
#ifdef XR_FB_body_tracking
  BodyJointLocationsFB = XR_TYPE_BODY_JOINT_LOCATIONS_FB,
#endif  // XR_FB_body_tracking
#ifdef XR_FB_body_tracking
  BodySkeletonFB = XR_TYPE_BODY_SKELETON_FB,
#endif  // XR_FB_body_tracking
#ifdef XR_EXT_dpad_binding
  InteractionProfileDpadBindingEXT = XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT,
#endif  // XR_EXT_dpad_binding
#ifdef XR_VALVE_analog_threshold
  InteractionProfileAnalogThresholdVALVE = XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE,
#endif  // XR_VALVE_analog_threshold
#ifdef XR_EXT_hand_joints_motion_range
  HandJointsMotionRangeInfoEXT = XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT,
#endif  // XR_EXT_hand_joints_motion_range
#ifdef XR_KHR_loader_init_android
  LoaderInitInfoAndroidKHR = XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR,
#endif  // XR_KHR_loader_init_android
#ifdef XR_KHR_vulkan_enable2
  VulkanInstanceCreateInfoKHR = XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR,
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
  VulkanDeviceCreateInfoKHR = XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR,
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
  VulkanGraphicsDeviceGetInfoKHR = XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR,
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
  GraphicsBindingVulkan2KHR = XR_TYPE_GRAPHICS_BINDING_VULKAN2_KHR,
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
  SwapchainImageVulkan2KHR = XR_TYPE_SWAPCHAIN_IMAGE_VULKAN2_KHR,
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
  GraphicsRequirementsVulkan2KHR = XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN2_KHR,
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_composition_layer_equirect2
  CompositionLayerEquirect2KHR = XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR,
#endif  // XR_KHR_composition_layer_equirect2
#ifdef XR_MSFT_scene_understanding
  SceneObserverCreateInfoMSFT = XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneCreateInfoMSFT = XR_TYPE_SCENE_CREATE_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  NewSceneComputeInfoMSFT = XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  VisualMeshComputeLodInfoMSFT = XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneComponentsMSFT = XR_TYPE_SCENE_COMPONENTS_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneComponentsGetInfoMSFT = XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneComponentLocationsMSFT = XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneComponentsLocateInfoMSFT = XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneObjectsMSFT = XR_TYPE_SCENE_OBJECTS_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneComponentParentFilterInfoMSFT = XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneObjectTypesFilterInfoMSFT = XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ScenePlanesMSFT = XR_TYPE_SCENE_PLANES_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  ScenePlaneAlignmentFilterInfoMSFT = XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMeshesMSFT = XR_TYPE_SCENE_MESHES_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMeshBuffersGetInfoMSFT = XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMeshBuffersMSFT = XR_TYPE_SCENE_MESH_BUFFERS_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMeshVertexBufferMSFT = XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMeshIndicesUint32MSFT = XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMeshIndicesUint16MSFT = XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding_serialization
  SerializedSceneFragmentDataGetInfoMSFT = XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_MSFT_scene_understanding_serialization
  SceneDeserializeInfoMSFT = XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT,
#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_FB_display_refresh_rate
  EventDataDisplayRefreshRateChangedFB = XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB,
#endif  // XR_FB_display_refresh_rate
#ifdef XR_HTCX_vive_tracker_interaction
  ViveTrackerPathsHTCX = XR_TYPE_VIVE_TRACKER_PATHS_HTCX,
#endif  // XR_HTCX_vive_tracker_interaction
#ifdef XR_HTCX_vive_tracker_interaction
  EventDataViveTrackerConnectedHTCX = XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX,
#endif  // XR_HTCX_vive_tracker_interaction
#ifdef XR_HTC_facial_tracking
  SystemFacialTrackingPropertiesHTC = XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC,
#endif  // XR_HTC_facial_tracking
#ifdef XR_HTC_facial_tracking
  FacialTrackerCreateInfoHTC = XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC,
#endif  // XR_HTC_facial_tracking
#ifdef XR_HTC_facial_tracking
  FacialExpressionsHTC = XR_TYPE_FACIAL_EXPRESSIONS_HTC,
#endif  // XR_HTC_facial_tracking
#ifdef XR_FB_color_space
  SystemColorSpacePropertiesFB = XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB,
#endif  // XR_FB_color_space
#ifdef XR_FB_hand_tracking_mesh
  HandTrackingMeshFB = XR_TYPE_HAND_TRACKING_MESH_FB,
#endif  // XR_FB_hand_tracking_mesh
#ifdef XR_FB_hand_tracking_mesh
  HandTrackingScaleFB = XR_TYPE_HAND_TRACKING_SCALE_FB,
#endif  // XR_FB_hand_tracking_mesh
#ifdef XR_FB_hand_tracking_aim
  HandTrackingAimStateFB = XR_TYPE_HAND_TRACKING_AIM_STATE_FB,
#endif  // XR_FB_hand_tracking_aim
#ifdef XR_FB_hand_tracking_capsules
  HandTrackingCapsulesStateFB = XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB,
#endif  // XR_FB_hand_tracking_capsules
#ifdef XR_FB_spatial_entity
  SystemSpatialEntityPropertiesFB = XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB,
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
  SpatialAnchorCreateInfoFB = XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB,
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
  SpaceComponentStatusSetInfoFB = XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB,
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
  SpaceComponentStatusFB = XR_TYPE_SPACE_COMPONENT_STATUS_FB,
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
  EventDataSpatialAnchorCreateCompleteFB = XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB,
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
  EventDataSpaceSetStatusCompleteFB = XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB,
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_foveation
  FoveationProfileCreateInfoFB = XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB,
#endif  // XR_FB_foveation
#ifdef XR_FB_foveation
  SwapchainCreateInfoFoveationFB = XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB,
#endif  // XR_FB_foveation
#ifdef XR_FB_foveation
  SwapchainStateFoveationFB = XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB,
#endif  // XR_FB_foveation
#ifdef XR_FB_foveation_configuration
  FoveationLevelProfileCreateInfoFB = XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB,
#endif  // XR_FB_foveation_configuration
#ifdef XR_FB_keyboard_tracking
  KeyboardSpaceCreateInfoFB = XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB,
#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_keyboard_tracking
  KeyboardTrackingQueryFB = XR_TYPE_KEYBOARD_TRACKING_QUERY_FB,
#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_keyboard_tracking
  SystemKeyboardTrackingPropertiesFB = XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB,
#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_triangle_mesh
  TriangleMeshCreateInfoFB = XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB,
#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_passthrough
  SystemPassthroughPropertiesFB = XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughCreateInfoFB = XR_TYPE_PASSTHROUGH_CREATE_INFO_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughLayerCreateInfoFB = XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  CompositionLayerPassthroughFB = XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  GeometryInstanceCreateInfoFB = XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  GeometryInstanceTransformFB = XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  SystemPassthroughProperties2FB = XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughStyleFB = XR_TYPE_PASSTHROUGH_STYLE_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughColorMapMonoToRgbaFB = XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughColorMapMonoToMonoFB = XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughBrightnessContrastSaturationFB = XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  EventDataPassthroughStateChangedFB = XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_render_model
  RenderModelPathInfoFB = XR_TYPE_RENDER_MODEL_PATH_INFO_FB,
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
  RenderModelPropertiesFB = XR_TYPE_RENDER_MODEL_PROPERTIES_FB,
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
  RenderModelBufferFB = XR_TYPE_RENDER_MODEL_BUFFER_FB,
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
  RenderModelLoadInfoFB = XR_TYPE_RENDER_MODEL_LOAD_INFO_FB,
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
  SystemRenderModelPropertiesFB = XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB,
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
  RenderModelCapabilitiesRequestFB = XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB,
#endif  // XR_FB_render_model
#ifdef XR_KHR_binding_modification
  BindingModificationsKHR = XR_TYPE_BINDING_MODIFICATIONS_KHR,
#endif  // XR_KHR_binding_modification
#ifdef XR_VARJO_foveated_rendering
  ViewLocateFoveatedRenderingVARJO = XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO,
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_VARJO_foveated_rendering
  FoveatedViewConfigurationViewVARJO = XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO,
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_VARJO_foveated_rendering
  SystemFoveatedRenderingPropertiesVARJO = XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO,
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_VARJO_composition_layer_depth_test
  CompositionLayerDepthTestVARJO = XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO,
#endif  // XR_VARJO_composition_layer_depth_test
#ifdef XR_VARJO_marker_tracking
  SystemMarkerTrackingPropertiesVARJO = XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO,
#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking
  EventDataMarkerTrackingUpdateVARJO = XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO,
#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking
  MarkerSpaceCreateInfoVARJO = XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO,
#endif  // XR_VARJO_marker_tracking
#ifdef XR_ML_frame_end_info
  FrameEndInfoML = XR_TYPE_FRAME_END_INFO_ML,
#endif  // XR_ML_frame_end_info
#ifdef XR_ML_global_dimmer
  GlobalDimmerFrameEndInfoML = XR_TYPE_GLOBAL_DIMMER_FRAME_END_INFO_ML,
#endif  // XR_ML_global_dimmer
#ifdef XR_ML_compat
  CoordinateSpaceCreateInfoML = XR_TYPE_COORDINATE_SPACE_CREATE_INFO_ML,
#endif  // XR_ML_compat
#ifdef XR_ML_marker_understanding
  SystemMarkerUnderstandingPropertiesML = XR_TYPE_SYSTEM_MARKER_UNDERSTANDING_PROPERTIES_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
  MarkerDetectorCreateInfoML = XR_TYPE_MARKER_DETECTOR_CREATE_INFO_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
  MarkerDetectorArucoInfoML = XR_TYPE_MARKER_DETECTOR_ARUCO_INFO_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
  MarkerDetectorSizeInfoML = XR_TYPE_MARKER_DETECTOR_SIZE_INFO_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
  MarkerDetectorAprilTagInfoML = XR_TYPE_MARKER_DETECTOR_APRIL_TAG_INFO_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
  MarkerDetectorCustomProfileInfoML = XR_TYPE_MARKER_DETECTOR_CUSTOM_PROFILE_INFO_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
  MarkerDetectorSnapshotInfoML = XR_TYPE_MARKER_DETECTOR_SNAPSHOT_INFO_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
  MarkerDetectorStateML = XR_TYPE_MARKER_DETECTOR_STATE_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
  MarkerSpaceCreateInfoML = XR_TYPE_MARKER_SPACE_CREATE_INFO_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_localization_map
  LocalizationMapML = XR_TYPE_LOCALIZATION_MAP_ML,
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
  EventDataLocalizationChangedML = XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML,
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
  MapLocalizationRequestInfoML = XR_TYPE_MAP_LOCALIZATION_REQUEST_INFO_ML,
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
  LocalizationMapImportInfoML = XR_TYPE_LOCALIZATION_MAP_IMPORT_INFO_ML,
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
  LocalizationEnableEventsInfoML = XR_TYPE_LOCALIZATION_ENABLE_EVENTS_INFO_ML,
#endif  // XR_ML_localization_map
#ifdef dsaXR_ML_spatial_anchors
  SpatialAnchorsCreateInfoFromPoseML = XR_TYPE_SPATIAL_ANCHORS_CREATE_INFO_FROM_POSE_ML,
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors
  CreateSpatialAnchorsCompletionML = XR_TYPE_CREATE_SPATIAL_ANCHORS_COMPLETION_ML,
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors
  SpatialAnchorStateML = XR_TYPE_SPATIAL_ANCHOR_STATE_ML,
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsCreateStorageInfoML = XR_TYPE_SPATIAL_ANCHORS_CREATE_STORAGE_INFO_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsQueryInfoRadiusML = XR_TYPE_SPATIAL_ANCHORS_QUERY_INFO_RADIUS_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsQueryCompletionML = XR_TYPE_SPATIAL_ANCHORS_QUERY_COMPLETION_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsCreateInfoFromUuidsML = XR_TYPE_SPATIAL_ANCHORS_CREATE_INFO_FROM_UUIDS_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsPublishInfoML = XR_TYPE_SPATIAL_ANCHORS_PUBLISH_INFO_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsPublishCompletionML = XR_TYPE_SPATIAL_ANCHORS_PUBLISH_COMPLETION_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsDeleteInfoML = XR_TYPE_SPATIAL_ANCHORS_DELETE_INFO_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsDeleteCompletionML = XR_TYPE_SPATIAL_ANCHORS_DELETE_COMPLETION_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsUpdateExpirationInfoML = XR_TYPE_SPATIAL_ANCHORS_UPDATE_EXPIRATION_INFO_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsUpdateExpirationCompletionML =
      XR_TYPE_SPATIAL_ANCHORS_UPDATE_EXPIRATION_COMPLETION_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsPublishCompletionDetailsML = XR_TYPE_SPATIAL_ANCHORS_PUBLISH_COMPLETION_DETAILS_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsDeleteCompletionDetailsML = XR_TYPE_SPATIAL_ANCHORS_DELETE_COMPLETION_DETAILS_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsUpdateExpirationCompletionDetailsML =
      XR_TYPE_SPATIAL_ANCHORS_UPDATE_EXPIRATION_COMPLETION_DETAILS_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef XR_ML_user_calibration
  EventDataHeadsetFitChangedML = XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML,
#endif  // XR_ML_user_calibration
#ifdef XR_ML_user_calibration
  EventDataEyeCalibrationChangedML = XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML,
#endif  // XR_ML_user_calibration
#ifdef XR_ML_user_calibration
  UserCalibrationEnableEventsInfoML = XR_TYPE_USER_CALIBRATION_ENABLE_EVENTS_INFO_ML,
#endif  // XR_ML_user_calibration
#ifdef XR_MSFT_spatial_anchor_persistence
  SpatialAnchorPersistenceInfoMSFT = XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT,
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT =
      XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT,
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_scene_marker
  SceneMarkersMSFT = XR_TYPE_SCENE_MARKERS_MSFT,
#endif  // XR_MSFT_scene_marker
#ifdef XR_MSFT_scene_marker
  SceneMarkerTypeFilterMSFT = XR_TYPE_SCENE_MARKER_TYPE_FILTER_MSFT,
#endif  // XR_MSFT_scene_marker
#ifdef XR_MSFT_scene_marker
  SceneMarkerQrCodesMSFT = XR_TYPE_SCENE_MARKER_QR_CODES_MSFT,
#endif  // XR_MSFT_scene_marker
#ifdef XR_FB_spatial_entity_query
  SpaceQueryInfoFB = XR_TYPE_SPACE_QUERY_INFO_FB,
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query
  SpaceQueryResultsFB = XR_TYPE_SPACE_QUERY_RESULTS_FB,
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query
  SpaceStorageLocationFilterInfoFB = XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB,
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query
  SpaceUuidFilterInfoFB = XR_TYPE_SPACE_UUID_FILTER_INFO_FB,
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query
  SpaceComponentFilterInfoFB = XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB,
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query
  EventDataSpaceQueryResultsAvailableFB = XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB,
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query
  EventDataSpaceQueryCompleteFB = XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB,
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_storage
  SpaceSaveInfoFB = XR_TYPE_SPACE_SAVE_INFO_FB,
#endif  // XR_FB_spatial_entity_storage
#ifdef XR_FB_spatial_entity_storage
  SpaceEraseInfoFB = XR_TYPE_SPACE_ERASE_INFO_FB,
#endif  // XR_FB_spatial_entity_storage
#ifdef XR_FB_spatial_entity_storage
  EventDataSpaceSaveCompleteFB = XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB,
#endif  // XR_FB_spatial_entity_storage
#ifdef XR_FB_spatial_entity_storage
  EventDataSpaceEraseCompleteFB = XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB,
#endif  // XR_FB_spatial_entity_storage
#ifdef XR_FB_foveation_vulkan
  SwapchainImageFoveationVulkanFB = XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB,
#endif  // XR_FB_foveation_vulkan
#ifdef XR_FB_swapchain_update_state_android_surface
  SwapchainStateAndroidSurfaceDimensionsFB = XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB,
#endif  // XR_FB_swapchain_update_state_android_surface
#ifdef XR_FB_swapchain_update_state_opengl_es
  SwapchainStateSamplerOpenGLESFB = XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB,
#endif  // XR_FB_swapchain_update_state_opengl_es
#ifdef XR_FB_swapchain_update_state_vulkan
  SwapchainStateSamplerVulkanFB = XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB,
#endif  // XR_FB_swapchain_update_state_vulkan
#ifdef XR_FB_spatial_entity_sharing
  SpaceShareInfoFB = XR_TYPE_SPACE_SHARE_INFO_FB,
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_spatial_entity_sharing
  EventDataSpaceShareCompleteFB = XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB,
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_space_warp
  CompositionLayerSpaceWarpInfoFB = XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB,
#endif  // XR_FB_space_warp
#ifdef XR_FB_space_warp
  SystemSpaceWarpPropertiesFB = XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB,
#endif  // XR_FB_space_warp
#ifdef XR_FB_haptic_amplitude_envelope
  HapticAmplitudeEnvelopeVibrationFB = XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB,
#endif  // XR_FB_haptic_amplitude_envelope
#ifdef XR_FB_scene
  SemanticLabelsFB = XR_TYPE_SEMANTIC_LABELS_FB,
#endif  // XR_FB_scene
#ifdef XR_FB_scene
  RoomLayoutFB = XR_TYPE_ROOM_LAYOUT_FB,
#endif  // XR_FB_scene
#ifdef XR_FB_scene
  Boundary2DFB = XR_TYPE_BOUNDARY_2D_FB,
#endif  // XR_FB_scene
#ifdef XR_FB_scene
  SemanticLabelsSupportInfoFB = XR_TYPE_SEMANTIC_LABELS_SUPPORT_INFO_FB,
#endif  // XR_FB_scene
#ifdef XR_ALMALENCE_digital_lens_control
  DigitalLensControlALMALENCE = XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE,
#endif  // XR_ALMALENCE_digital_lens_control
#ifdef XR_FB_scene_capture
  EventDataSceneCaptureCompleteFB = XR_TYPE_EVENT_DATA_SCENE_CAPTURE_COMPLETE_FB,
#endif  // XR_FB_scene_capture
#ifdef XR_FB_scene_capture
  SceneCaptureRequestInfoFB = XR_TYPE_SCENE_CAPTURE_REQUEST_INFO_FB,
#endif  // XR_FB_scene_capture
#ifdef XR_FB_spatial_entity_container
  SpaceContainerFB = XR_TYPE_SPACE_CONTAINER_FB,
#endif  // XR_FB_spatial_entity_container
#ifdef XR_META_foveation_eye_tracked
  FoveationEyeTrackedProfileCreateInfoMETA = XR_TYPE_FOVEATION_EYE_TRACKED_PROFILE_CREATE_INFO_META,
#endif  // XR_META_foveation_eye_tracked
#ifdef XR_META_foveation_eye_tracked
  FoveationEyeTrackedStateMETA = XR_TYPE_FOVEATION_EYE_TRACKED_STATE_META,
#endif  // XR_META_foveation_eye_tracked
#ifdef XR_META_foveation_eye_tracked
  SystemFoveationEyeTrackedPropertiesMETA = XR_TYPE_SYSTEM_FOVEATION_EYE_TRACKED_PROPERTIES_META,
#endif  // XR_META_foveation_eye_tracked
#ifdef XR_FB_face_tracking
  SystemFaceTrackingPropertiesFB = XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES_FB,
#endif  // XR_FB_face_tracking
#ifdef XR_FB_face_tracking
  FaceTrackerCreateInfoFB = XR_TYPE_FACE_TRACKER_CREATE_INFO_FB,
#endif  // XR_FB_face_tracking
#ifdef XR_FB_face_tracking
  FaceExpressionInfoFB = XR_TYPE_FACE_EXPRESSION_INFO_FB,
#endif  // XR_FB_face_tracking
#ifdef XR_FB_face_tracking
  FaceExpressionWeightsFB = XR_TYPE_FACE_EXPRESSION_WEIGHTS_FB,
#endif  // XR_FB_face_tracking
#ifdef XR_FB_eye_tracking_social
  EyeTrackerCreateInfoFB = XR_TYPE_EYE_TRACKER_CREATE_INFO_FB,
#endif  // XR_FB_eye_tracking_social
#ifdef XR_FB_eye_tracking_social
  EyeGazesInfoFB = XR_TYPE_EYE_GAZES_INFO_FB,
#endif  // XR_FB_eye_tracking_social
#ifdef XR_FB_eye_tracking_social
  EyeGazesFB = XR_TYPE_EYE_GAZES_FB,
#endif  // XR_FB_eye_tracking_social
#ifdef XR_FB_eye_tracking_social
  SystemEyeTrackingPropertiesFB = XR_TYPE_SYSTEM_EYE_TRACKING_PROPERTIES_FB,
#endif  // XR_FB_eye_tracking_social
#ifdef XR_FB_passthrough_keyboard_hands
  PassthroughKeyboardHandsIntensityFB = XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB,
#endif  // XR_FB_passthrough_keyboard_hands
#ifdef XR_FB_composition_layer_settings
  CompositionLayerSettingsFB = XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB,
#endif  // XR_FB_composition_layer_settings
#ifdef XR_FB_haptic_pcm
  HapticPcmVibrationFB = XR_TYPE_HAPTIC_PCM_VIBRATION_FB,
#endif  // XR_FB_haptic_pcm
#ifdef XR_FB_haptic_pcm
  DevicePcmSampleRateStateFB = XR_TYPE_DEVICE_PCM_SAMPLE_RATE_STATE_FB,
#endif  // XR_FB_haptic_pcm
#ifdef XR_FB_haptic_pcm
  DevicePcmSampleRateGetInfoFB = XR_TYPE_DEVICE_PCM_SAMPLE_RATE_GET_INFO_FB,
#endif  // XR_FB_haptic_pcm
#ifdef XR_EXT_frame_synthesis
  FrameSynthesisInfoEXT = XR_TYPE_FRAME_SYNTHESIS_INFO_EXT,
#endif  // XR_EXT_frame_synthesis
#ifdef XR_EXT_frame_synthesis
  FrameSynthesisConfigViewEXT = XR_TYPE_FRAME_SYNTHESIS_CONFIG_VIEW_EXT,
#endif  // XR_EXT_frame_synthesis
#ifdef XR_FB_composition_layer_depth_test
  CompositionLayerDepthTestFB = XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_FB,
#endif  // XR_FB_composition_layer_depth_test
#ifdef XR_META_local_dimming
  LocalDimmingFrameEndInfoMETA = XR_TYPE_LOCAL_DIMMING_FRAME_END_INFO_META,
#endif  // XR_META_local_dimming
#ifdef XR_META_passthrough_preferences
  PassthroughPreferencesMETA = XR_TYPE_PASSTHROUGH_PREFERENCES_META,
#endif  // XR_META_passthrough_preferences
#ifdef XR_META_virtual_keyboard
  SystemVirtualKeyboardPropertiesMETA = XR_TYPE_SYSTEM_VIRTUAL_KEYBOARD_PROPERTIES_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  VirtualKeyboardCreateInfoMETA = XR_TYPE_VIRTUAL_KEYBOARD_CREATE_INFO_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  VirtualKeyboardSpaceCreateInfoMETA = XR_TYPE_VIRTUAL_KEYBOARD_SPACE_CREATE_INFO_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  VirtualKeyboardLocationInfoMETA = XR_TYPE_VIRTUAL_KEYBOARD_LOCATION_INFO_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  VirtualKeyboardModelVisibilitySetInfoMETA =
      XR_TYPE_VIRTUAL_KEYBOARD_MODEL_VISIBILITY_SET_INFO_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  VirtualKeyboardAnimationStateMETA = XR_TYPE_VIRTUAL_KEYBOARD_ANIMATION_STATE_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  VirtualKeyboardModelAnimationStatesMETA = XR_TYPE_VIRTUAL_KEYBOARD_MODEL_ANIMATION_STATES_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  VirtualKeyboardTextureDataMETA = XR_TYPE_VIRTUAL_KEYBOARD_TEXTURE_DATA_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  VirtualKeyboardInputInfoMETA = XR_TYPE_VIRTUAL_KEYBOARD_INPUT_INFO_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  VirtualKeyboardTextContextChangeInfoMETA = XR_TYPE_VIRTUAL_KEYBOARD_TEXT_CONTEXT_CHANGE_INFO_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  EventDataVirtualKeyboardCommitTextMETA = XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_COMMIT_TEXT_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  EventDataVirtualKeyboardBackspaceMETA = XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_BACKSPACE_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  EventDataVirtualKeyboardEnterMETA = XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_ENTER_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  EventDataVirtualKeyboardShownMETA = XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_SHOWN_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
  EventDataVirtualKeyboardHiddenMETA = XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_HIDDEN_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_OCULUS_external_camera
  ExternalCameraOCULUS = XR_TYPE_EXTERNAL_CAMERA_OCULUS,
#endif  // XR_OCULUS_external_camera
#ifdef XR_META_vulkan_swapchain_create_info
  VulkanSwapchainCreateInfoMETA = XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META,
#endif  // XR_META_vulkan_swapchain_create_info
#ifdef XR_META_performance_metrics
  PerformanceMetricsStateMETA = XR_TYPE_PERFORMANCE_METRICS_STATE_META,
#endif  // XR_META_performance_metrics
#ifdef XR_META_performance_metrics
  PerformanceMetricsCounterMETA = XR_TYPE_PERFORMANCE_METRICS_COUNTER_META,
#endif  // XR_META_performance_metrics
#ifdef XR_FB_spatial_entity_storage_batch
  SpaceListSaveInfoFB = XR_TYPE_SPACE_LIST_SAVE_INFO_FB,
#endif  // XR_FB_spatial_entity_storage_batch
#ifdef XR_FB_spatial_entity_storage_batch
  EventDataSpaceListSaveCompleteFB = XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB,
#endif  // XR_FB_spatial_entity_storage_batch
#ifdef XR_FB_spatial_entity_user
  SpaceUserCreateInfoFB = XR_TYPE_SPACE_USER_CREATE_INFO_FB,
#endif  // XR_FB_spatial_entity_user
#ifdef XR_META_headset_id
  SystemHeadsetIdPropertiesMETA = XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META,
#endif  // XR_META_headset_id
#ifdef XR_META_recommended_layer_resolution
  RecommendedLayerResolutionMETA = XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_META,
#endif  // XR_META_recommended_layer_resolution
#ifdef XR_META_recommended_layer_resolution
  RecommendedLayerResolutionGetInfoMETA = XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_GET_INFO_META,
#endif  // XR_META_recommended_layer_resolution
#ifdef XR_META_passthrough_color_lut
  SystemPassthroughColorLutPropertiesMETA = XR_TYPE_SYSTEM_PASSTHROUGH_COLOR_LUT_PROPERTIES_META,
#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_passthrough_color_lut
  PassthroughColorLutCreateInfoMETA = XR_TYPE_PASSTHROUGH_COLOR_LUT_CREATE_INFO_META,
#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_passthrough_color_lut
  PassthroughColorLutUpdateInfoMETA = XR_TYPE_PASSTHROUGH_COLOR_LUT_UPDATE_INFO_META,
#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_passthrough_color_lut
  PassthroughColorMapLutMETA = XR_TYPE_PASSTHROUGH_COLOR_MAP_LUT_META,
#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_passthrough_color_lut
  PassthroughColorMapInterpolatedLutMETA = XR_TYPE_PASSTHROUGH_COLOR_MAP_INTERPOLATED_LUT_META,
#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_spatial_entity_mesh
  SpaceTriangleMeshGetInfoMETA = XR_TYPE_SPACE_TRIANGLE_MESH_GET_INFO_META,
#endif  // XR_META_spatial_entity_mesh
#ifdef XR_META_spatial_entity_mesh
  SpaceTriangleMeshMETA = XR_TYPE_SPACE_TRIANGLE_MESH_META,
#endif  // XR_META_spatial_entity_mesh
#ifdef XR_META_body_tracking_full_body
  SystemPropertiesBodyTrackingFullBodyMETA = XR_TYPE_SYSTEM_PROPERTIES_BODY_TRACKING_FULL_BODY_META,
#endif  // XR_META_body_tracking_full_body
#ifdef XR_META_passthrough_layer_resumed_event
  EventDataPassthroughLayerResumedMETA = XR_TYPE_EVENT_DATA_PASSTHROUGH_LAYER_RESUMED_META,
#endif  // XR_META_passthrough_layer_resumed_event
#ifdef XR_FB_face_tracking2
  SystemFaceTrackingProperties2FB = XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES2_FB,
#endif  // XR_FB_face_tracking2
#ifdef XR_FB_face_tracking2
  FaceTrackerCreateInfo2FB = XR_TYPE_FACE_TRACKER_CREATE_INFO2_FB,
#endif  // XR_FB_face_tracking2
#ifdef XR_FB_face_tracking2
  FaceExpressionInfo2FB = XR_TYPE_FACE_EXPRESSION_INFO2_FB,
#endif  // XR_FB_face_tracking2
#ifdef XR_FB_face_tracking2
  FaceExpressionWeights2FB = XR_TYPE_FACE_EXPRESSION_WEIGHTS2_FB,
#endif  // XR_FB_face_tracking2
#ifdef XR_META_spatial_entity_sharing
  SystemSpatialEntitySharingPropertiesMETA = XR_TYPE_SYSTEM_SPATIAL_ENTITY_SHARING_PROPERTIES_META,
#endif  // XR_META_spatial_entity_sharing
#ifdef XR_META_spatial_entity_sharing
  ShareSpacesInfoMETA = XR_TYPE_SHARE_SPACES_INFO_META,
#endif  // XR_META_spatial_entity_sharing
#ifdef XR_META_spatial_entity_sharing
  EventDataShareSpacesCompleteMETA = XR_TYPE_EVENT_DATA_SHARE_SPACES_COMPLETE_META,
#endif  // XR_META_spatial_entity_sharing
#ifdef XR_META_environment_depth
  EnvironmentDepthProviderCreateInfoMETA = XR_TYPE_ENVIRONMENT_DEPTH_PROVIDER_CREATE_INFO_META,
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
  EnvironmentDepthSwapchainCreateInfoMETA = XR_TYPE_ENVIRONMENT_DEPTH_SWAPCHAIN_CREATE_INFO_META,
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
  EnvironmentDepthSwapchainStateMETA = XR_TYPE_ENVIRONMENT_DEPTH_SWAPCHAIN_STATE_META,
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
  EnvironmentDepthImageAcquireInfoMETA = XR_TYPE_ENVIRONMENT_DEPTH_IMAGE_ACQUIRE_INFO_META,
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
  EnvironmentDepthImageViewMETA = XR_TYPE_ENVIRONMENT_DEPTH_IMAGE_VIEW_META,
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
  EnvironmentDepthImageMETA = XR_TYPE_ENVIRONMENT_DEPTH_IMAGE_META,
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
  EnvironmentDepthHandRemovalSetInfoMETA = XR_TYPE_ENVIRONMENT_DEPTH_HAND_REMOVAL_SET_INFO_META,
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
  SystemEnvironmentDepthPropertiesMETA = XR_TYPE_SYSTEM_ENVIRONMENT_DEPTH_PROPERTIES_META,
#endif  // XR_META_environment_depth
#ifdef XR_EXT_render_model
  RenderModelCreateInfoEXT = XR_TYPE_RENDER_MODEL_CREATE_INFO_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  RenderModelPropertiesGetInfoEXT = XR_TYPE_RENDER_MODEL_PROPERTIES_GET_INFO_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  RenderModelPropertiesEXT = XR_TYPE_RENDER_MODEL_PROPERTIES_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  RenderModelSpaceCreateInfoEXT = XR_TYPE_RENDER_MODEL_SPACE_CREATE_INFO_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  RenderModelStateGetInfoEXT = XR_TYPE_RENDER_MODEL_STATE_GET_INFO_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  RenderModelStateEXT = XR_TYPE_RENDER_MODEL_STATE_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  RenderModelAssetCreateInfoEXT = XR_TYPE_RENDER_MODEL_ASSET_CREATE_INFO_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  RenderModelAssetDataGetInfoEXT = XR_TYPE_RENDER_MODEL_ASSET_DATA_GET_INFO_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  RenderModelAssetDataEXT = XR_TYPE_RENDER_MODEL_ASSET_DATA_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  RenderModelAssetPropertiesGetInfoEXT = XR_TYPE_RENDER_MODEL_ASSET_PROPERTIES_GET_INFO_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  RenderModelAssetPropertiesEXT = XR_TYPE_RENDER_MODEL_ASSET_PROPERTIES_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_interaction_render_model
  InteractionRenderModelIdsEnumerateInfoEXT =
      XR_TYPE_INTERACTION_RENDER_MODEL_IDS_ENUMERATE_INFO_EXT,
#endif  // XR_EXT_interaction_render_model
#ifdef XR_EXT_interaction_render_model
  InteractionRenderModelSubactionPathInfoEXT =
      XR_TYPE_INTERACTION_RENDER_MODEL_SUBACTION_PATH_INFO_EXT,
#endif  // XR_EXT_interaction_render_model
#ifdef XR_EXT_interaction_render_model
  EventDataInteractionRenderModelsChangedEXT =
      XR_TYPE_EVENT_DATA_INTERACTION_RENDER_MODELS_CHANGED_EXT,
#endif  // XR_EXT_interaction_render_model
#ifdef XR_EXT_interaction_render_model
  InteractionRenderModelTopLevelUserPathGetInfoEXT =
      XR_TYPE_INTERACTION_RENDER_MODEL_TOP_LEVEL_USER_PATH_GET_INFO_EXT,
#endif  // XR_EXT_interaction_render_model
#ifdef XR_HTC_passthrough
  PassthroughCreateInfoHTC = XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC,
#endif  // XR_HTC_passthrough
#ifdef XR_HTC_passthrough
  PassthroughColorHTC = XR_TYPE_PASSTHROUGH_COLOR_HTC,
#endif  // XR_HTC_passthrough
#ifdef XR_HTC_passthrough
  PassthroughMeshTransformInfoHTC = XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC,
#endif  // XR_HTC_passthrough
#ifdef XR_HTC_passthrough
  CompositionLayerPassthroughHTC = XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC,
#endif  // XR_HTC_passthrough
#ifdef XR_HTC_foveation
  FoveationApplyInfoHTC = XR_TYPE_FOVEATION_APPLY_INFO_HTC,
#endif  // XR_HTC_foveation
#ifdef XR_HTC_foveation
  FoveationDynamicModeInfoHTC = XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC,
#endif  // XR_HTC_foveation
#ifdef XR_HTC_foveation
  FoveationCustomModeInfoHTC = XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC,
#endif  // XR_HTC_foveation
#ifdef XR_HTC_anchor
  SystemAnchorPropertiesHTC = XR_TYPE_SYSTEM_ANCHOR_PROPERTIES_HTC,
#endif  // XR_HTC_anchor
#ifdef XR_HTC_anchor
  SpatialAnchorCreateInfoHTC = XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_HTC,
#endif  // XR_HTC_anchor
#ifdef XR_HTC_body_tracking
  SystemBodyTrackingPropertiesHTC = XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_HTC,
#endif  // XR_HTC_body_tracking
#ifdef XR_HTC_body_tracking
  BodyTrackerCreateInfoHTC = XR_TYPE_BODY_TRACKER_CREATE_INFO_HTC,
#endif  // XR_HTC_body_tracking
#ifdef XR_HTC_body_tracking
  BodyJointsLocateInfoHTC = XR_TYPE_BODY_JOINTS_LOCATE_INFO_HTC,
#endif  // XR_HTC_body_tracking
#ifdef XR_HTC_body_tracking
  BodyJointLocationsHTC = XR_TYPE_BODY_JOINT_LOCATIONS_HTC,
#endif  // XR_HTC_body_tracking
#ifdef XR_HTC_body_tracking
  BodySkeletonHTC = XR_TYPE_BODY_SKELETON_HTC,
#endif  // XR_HTC_body_tracking
#ifdef XR_EXT_active_action_set_priority
  ActiveActionSetPrioritiesEXT = XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT,
#endif  // XR_EXT_active_action_set_priority
#ifdef XR_MNDX_force_feedback_curl
  SystemForceFeedbackCurlPropertiesMNDX = XR_TYPE_SYSTEM_FORCE_FEEDBACK_CURL_PROPERTIES_MNDX,
#endif  // XR_MNDX_force_feedback_curl
#ifdef XR_MNDX_force_feedback_curl
  ForceFeedbackCurlApplyLocationsMNDX = XR_TYPE_FORCE_FEEDBACK_CURL_APPLY_LOCATIONS_MNDX,
#endif  // XR_MNDX_force_feedback_curl
#ifdef XR_BD_body_tracking
  BodyTrackerCreateInfoBD = XR_TYPE_BODY_TRACKER_CREATE_INFO_BD,
#endif  // XR_BD_body_tracking
#ifdef XR_BD_body_tracking
  BodyJointsLocateInfoBD = XR_TYPE_BODY_JOINTS_LOCATE_INFO_BD,
#endif  // XR_BD_body_tracking
#ifdef XR_BD_body_tracking
  BodyJointLocationsBD = XR_TYPE_BODY_JOINT_LOCATIONS_BD,
#endif  // XR_BD_body_tracking
#ifdef XR_BD_body_tracking
  SystemBodyTrackingPropertiesBD = XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_BD,
#endif  // XR_BD_body_tracking
#ifdef XR_BD_spatial_sensing
  SystemSpatialSensingPropertiesBD = XR_TYPE_SYSTEM_SPATIAL_SENSING_PROPERTIES_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SpatialEntityComponentGetInfoBD = XR_TYPE_SPATIAL_ENTITY_COMPONENT_GET_INFO_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SpatialEntityLocationGetInfoBD = XR_TYPE_SPATIAL_ENTITY_LOCATION_GET_INFO_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SpatialEntityComponentDataLocationBD = XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_LOCATION_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SpatialEntityComponentDataSemanticBD = XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_SEMANTIC_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SpatialEntityComponentDataBoundingBox2DBD =
      XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_BOUNDING_BOX_2D_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SpatialEntityComponentDataPolygonBD = XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_POLYGON_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SpatialEntityComponentDataBoundingBox3DBD =
      XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_BOUNDING_BOX_3D_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SpatialEntityComponentDataTriangleMeshBD = XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_TRIANGLE_MESH_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SenseDataProviderCreateInfoBD = XR_TYPE_SENSE_DATA_PROVIDER_CREATE_INFO_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SenseDataProviderStartInfoBD = XR_TYPE_SENSE_DATA_PROVIDER_START_INFO_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  EventDataSenseDataProviderStateChangedBD =
      XR_TYPE_EVENT_DATA_SENSE_DATA_PROVIDER_STATE_CHANGED_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  EventDataSenseDataUpdatedBD = XR_TYPE_EVENT_DATA_SENSE_DATA_UPDATED_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SenseDataQueryInfoBD = XR_TYPE_SENSE_DATA_QUERY_INFO_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SenseDataQueryCompletionBD = XR_TYPE_SENSE_DATA_QUERY_COMPLETION_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SenseDataFilterUuidBD = XR_TYPE_SENSE_DATA_FILTER_UUID_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SenseDataFilterSemanticBD = XR_TYPE_SENSE_DATA_FILTER_SEMANTIC_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  QueriedSenseDataGetInfoBD = XR_TYPE_QUERIED_SENSE_DATA_GET_INFO_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  QueriedSenseDataBD = XR_TYPE_QUERIED_SENSE_DATA_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SpatialEntityStateBD = XR_TYPE_SPATIAL_ENTITY_STATE_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SpatialEntityAnchorCreateInfoBD = XR_TYPE_SPATIAL_ENTITY_ANCHOR_CREATE_INFO_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  AnchorSpaceCreateInfoBD = XR_TYPE_ANCHOR_SPACE_CREATE_INFO_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_anchor
  SystemSpatialAnchorPropertiesBD = XR_TYPE_SYSTEM_SPATIAL_ANCHOR_PROPERTIES_BD,
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_anchor
  SpatialAnchorCreateInfoBD = XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_BD,
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_anchor
  SpatialAnchorCreateCompletionBD = XR_TYPE_SPATIAL_ANCHOR_CREATE_COMPLETION_BD,
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_anchor
  SpatialAnchorPersistInfoBD = XR_TYPE_SPATIAL_ANCHOR_PERSIST_INFO_BD,
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_anchor
  SpatialAnchorUnpersistInfoBD = XR_TYPE_SPATIAL_ANCHOR_UNPERSIST_INFO_BD,
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_anchor_sharing
  SystemSpatialAnchorSharingPropertiesBD = XR_TYPE_SYSTEM_SPATIAL_ANCHOR_SHARING_PROPERTIES_BD,
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_anchor_sharing
  SpatialAnchorShareInfoBD = XR_TYPE_SPATIAL_ANCHOR_SHARE_INFO_BD,
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_anchor_sharing
  SharedSpatialAnchorDownloadInfoBD = XR_TYPE_SHARED_SPATIAL_ANCHOR_DOWNLOAD_INFO_BD,
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_scene
  SystemSpatialScenePropertiesBD = XR_TYPE_SYSTEM_SPATIAL_SCENE_PROPERTIES_BD,
#endif  // XR_BD_spatial_scene
#ifdef XR_BD_spatial_scene
  SceneCaptureInfoBD = XR_TYPE_SCENE_CAPTURE_INFO_BD,
#endif  // XR_BD_spatial_scene
#ifdef XR_BD_spatial_mesh
  SystemSpatialMeshPropertiesBD = XR_TYPE_SYSTEM_SPATIAL_MESH_PROPERTIES_BD,
#endif  // XR_BD_spatial_mesh
#ifdef XR_BD_spatial_mesh
  SenseDataProviderCreateInfoSpatialMeshBD =
      XR_TYPE_SENSE_DATA_PROVIDER_CREATE_INFO_SPATIAL_MESH_BD,
#endif  // XR_BD_spatial_mesh
#ifdef XR_BD_future_progress
  FuturePollResultProgressBD = XR_TYPE_FUTURE_POLL_RESULT_PROGRESS_BD,
#endif  // XR_BD_future_progress
#ifdef XR_BD_spatial_plane
  SystemSpatialPlanePropertiesBD = XR_TYPE_SYSTEM_SPATIAL_PLANE_PROPERTIES_BD,
#endif  // XR_BD_spatial_plane
#ifdef XR_BD_spatial_plane
  SpatialEntityComponentDataPlaneOrientationBD =
      XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_PLANE_ORIENTATION_BD,
#endif  // XR_BD_spatial_plane
#ifdef XR_BD_spatial_plane
  SenseDataFilterPlaneOrientationBD = XR_TYPE_SENSE_DATA_FILTER_PLANE_ORIENTATION_BD,
#endif  // XR_BD_spatial_plane
#ifdef XR_EXT_hand_tracking_data_source
  HandTrackingDataSourceInfoEXT = XR_TYPE_HAND_TRACKING_DATA_SOURCE_INFO_EXT,
#endif  // XR_EXT_hand_tracking_data_source
#ifdef XR_EXT_hand_tracking_data_source
  HandTrackingDataSourceStateEXT = XR_TYPE_HAND_TRACKING_DATA_SOURCE_STATE_EXT,
#endif  // XR_EXT_hand_tracking_data_source
#ifdef XR_EXT_plane_detection
  PlaneDetectorCreateInfoEXT = XR_TYPE_PLANE_DETECTOR_CREATE_INFO_EXT,
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
  PlaneDetectorBeginInfoEXT = XR_TYPE_PLANE_DETECTOR_BEGIN_INFO_EXT,
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
  PlaneDetectorGetInfoEXT = XR_TYPE_PLANE_DETECTOR_GET_INFO_EXT,
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
  PlaneDetectorLocationsEXT = XR_TYPE_PLANE_DETECTOR_LOCATIONS_EXT,
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
  PlaneDetectorLocationEXT = XR_TYPE_PLANE_DETECTOR_LOCATION_EXT,
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
  PlaneDetectorPolygonBufferEXT = XR_TYPE_PLANE_DETECTOR_POLYGON_BUFFER_EXT,
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
  SystemPlaneDetectionPropertiesEXT = XR_TYPE_SYSTEM_PLANE_DETECTION_PROPERTIES_EXT,
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_future
  FutureCancelInfoEXT = XR_TYPE_FUTURE_CANCEL_INFO_EXT,
#endif  // XR_EXT_future
#ifdef XR_EXT_future
  FuturePollInfoEXT = XR_TYPE_FUTURE_POLL_INFO_EXT,
#endif  // XR_EXT_future
#ifdef XR_EXT_future
  FutureCompletionEXT = XR_TYPE_FUTURE_COMPLETION_EXT,
#endif  // XR_EXT_future
#ifdef XR_EXT_future
  FuturePollResultEXT = XR_TYPE_FUTURE_POLL_RESULT_EXT,
#endif  // XR_EXT_future
#ifdef XR_EXT_user_presence
  EventDataUserPresenceChangedEXT = XR_TYPE_EVENT_DATA_USER_PRESENCE_CHANGED_EXT,
#endif  // XR_EXT_user_presence
#ifdef XR_EXT_user_presence
  SystemUserPresencePropertiesEXT = XR_TYPE_SYSTEM_USER_PRESENCE_PROPERTIES_EXT,
#endif  // XR_EXT_user_presence
#ifdef XR_KHR_locate_spaces
  SpacesLocateInfoKHR = XR_TYPE_SPACES_LOCATE_INFO_KHR,
#endif  // XR_KHR_locate_spaces
#ifdef XR_KHR_locate_spaces
  SpaceLocationsKHR = XR_TYPE_SPACE_LOCATIONS_KHR,
#endif  // XR_KHR_locate_spaces
#ifdef XR_KHR_locate_spaces
  SpaceVelocitiesKHR = XR_TYPE_SPACE_VELOCITIES_KHR,
#endif  // XR_KHR_locate_spaces
#ifdef XR_ML_system_notifications
  SystemNotificationsSetInfoML = XR_TYPE_SYSTEM_NOTIFICATIONS_SET_INFO_ML,
#endif  // XR_ML_system_notifications
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshDetectorCreateInfoML = XR_TYPE_WORLD_MESH_DETECTOR_CREATE_INFO_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshStateRequestInfoML = XR_TYPE_WORLD_MESH_STATE_REQUEST_INFO_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshBlockStateML = XR_TYPE_WORLD_MESH_BLOCK_STATE_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshStateRequestCompletionML = XR_TYPE_WORLD_MESH_STATE_REQUEST_COMPLETION_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshBufferRecommendedSizeInfoML = XR_TYPE_WORLD_MESH_BUFFER_RECOMMENDED_SIZE_INFO_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshBufferSizeML = XR_TYPE_WORLD_MESH_BUFFER_SIZE_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshBufferML = XR_TYPE_WORLD_MESH_BUFFER_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshBlockRequestML = XR_TYPE_WORLD_MESH_BLOCK_REQUEST_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshGetInfoML = XR_TYPE_WORLD_MESH_GET_INFO_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshBlockML = XR_TYPE_WORLD_MESH_BLOCK_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshRequestCompletionML = XR_TYPE_WORLD_MESH_REQUEST_COMPLETION_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshRequestCompletionInfoML = XR_TYPE_WORLD_MESH_REQUEST_COMPLETION_INFO_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef XR_ML_facial_expression
  SystemFacialExpressionPropertiesML = XR_TYPE_SYSTEM_FACIAL_EXPRESSION_PROPERTIES_ML,
#endif  // XR_ML_facial_expression
#ifdef XR_ML_facial_expression
  FacialExpressionClientCreateInfoML = XR_TYPE_FACIAL_EXPRESSION_CLIENT_CREATE_INFO_ML,
#endif  // XR_ML_facial_expression
#ifdef XR_ML_facial_expression
  FacialExpressionBlendShapeGetInfoML = XR_TYPE_FACIAL_EXPRESSION_BLEND_SHAPE_GET_INFO_ML,
#endif  // XR_ML_facial_expression
#ifdef XR_ML_facial_expression
  FacialExpressionBlendShapePropertiesML = XR_TYPE_FACIAL_EXPRESSION_BLEND_SHAPE_PROPERTIES_ML,
#endif  // XR_ML_facial_expression
#ifdef XR_META_simultaneous_hands_and_controllers
  SystemSimultaneousHandsAndControllersPropertiesMETA =
      XR_TYPE_SYSTEM_SIMULTANEOUS_HANDS_AND_CONTROLLERS_PROPERTIES_META,
#endif  // XR_META_simultaneous_hands_and_controllers
#ifdef XR_META_simultaneous_hands_and_controllers
  SimultaneousHandsAndControllersTrackingResumeInfoMETA =
      XR_TYPE_SIMULTANEOUS_HANDS_AND_CONTROLLERS_TRACKING_RESUME_INFO_META,
#endif  // XR_META_simultaneous_hands_and_controllers
#ifdef XR_META_simultaneous_hands_and_controllers
  SimultaneousHandsAndControllersTrackingPauseInfoMETA =
      XR_TYPE_SIMULTANEOUS_HANDS_AND_CONTROLLERS_TRACKING_PAUSE_INFO_META,
#endif  // XR_META_simultaneous_hands_and_controllers
#ifdef XR_META_colocation_discovery
  ColocationDiscoveryStartInfoMETA = XR_TYPE_COLOCATION_DISCOVERY_START_INFO_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  ColocationDiscoveryStopInfoMETA = XR_TYPE_COLOCATION_DISCOVERY_STOP_INFO_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  ColocationAdvertisementStartInfoMETA = XR_TYPE_COLOCATION_ADVERTISEMENT_START_INFO_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  ColocationAdvertisementStopInfoMETA = XR_TYPE_COLOCATION_ADVERTISEMENT_STOP_INFO_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  EventDataStartColocationAdvertisementCompleteMETA =
      XR_TYPE_EVENT_DATA_START_COLOCATION_ADVERTISEMENT_COMPLETE_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  EventDataStopColocationAdvertisementCompleteMETA =
      XR_TYPE_EVENT_DATA_STOP_COLOCATION_ADVERTISEMENT_COMPLETE_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  EventDataColocationAdvertisementCompleteMETA =
      XR_TYPE_EVENT_DATA_COLOCATION_ADVERTISEMENT_COMPLETE_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  EventDataStartColocationDiscoveryCompleteMETA =
      XR_TYPE_EVENT_DATA_START_COLOCATION_DISCOVERY_COMPLETE_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  EventDataColocationDiscoveryResultMETA = XR_TYPE_EVENT_DATA_COLOCATION_DISCOVERY_RESULT_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  EventDataColocationDiscoveryCompleteMETA = XR_TYPE_EVENT_DATA_COLOCATION_DISCOVERY_COMPLETE_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  EventDataStopColocationDiscoveryCompleteMETA =
      XR_TYPE_EVENT_DATA_STOP_COLOCATION_DISCOVERY_COMPLETE_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
  SystemColocationDiscoveryPropertiesMETA = XR_TYPE_SYSTEM_COLOCATION_DISCOVERY_PROPERTIES_META,
#endif  // XR_META_colocation_discovery
#ifdef XR_META_spatial_entity_group_sharing
  ShareSpacesRecipientGroupsMETA = XR_TYPE_SHARE_SPACES_RECIPIENT_GROUPS_META,
#endif  // XR_META_spatial_entity_group_sharing
#ifdef XR_META_spatial_entity_group_sharing
  SpaceGroupUuidFilterInfoMETA = XR_TYPE_SPACE_GROUP_UUID_FILTER_INFO_META,
#endif  // XR_META_spatial_entity_group_sharing
#ifdef XR_META_spatial_entity_group_sharing
  SystemSpatialEntityGroupSharingPropertiesMETA =
      XR_TYPE_SYSTEM_SPATIAL_ENTITY_GROUP_SHARING_PROPERTIES_META,
#endif  // XR_META_spatial_entity_group_sharing
#ifdef XR_EXT_spatial_entity
  SpatialCapabilityComponentTypesEXT = XR_TYPE_SPATIAL_CAPABILITY_COMPONENT_TYPES_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialContextCreateInfoEXT = XR_TYPE_SPATIAL_CONTEXT_CREATE_INFO_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  CreateSpatialContextCompletionEXT = XR_TYPE_CREATE_SPATIAL_CONTEXT_COMPLETION_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialDiscoverySnapshotCreateInfoEXT = XR_TYPE_SPATIAL_DISCOVERY_SNAPSHOT_CREATE_INFO_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  CreateSpatialDiscoverySnapshotCompletionInfoEXT =
      XR_TYPE_CREATE_SPATIAL_DISCOVERY_SNAPSHOT_COMPLETION_INFO_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  CreateSpatialDiscoverySnapshotCompletionEXT =
      XR_TYPE_CREATE_SPATIAL_DISCOVERY_SNAPSHOT_COMPLETION_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialComponentDataQueryConditionEXT = XR_TYPE_SPATIAL_COMPONENT_DATA_QUERY_CONDITION_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialComponentDataQueryResultEXT = XR_TYPE_SPATIAL_COMPONENT_DATA_QUERY_RESULT_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialBufferGetInfoEXT = XR_TYPE_SPATIAL_BUFFER_GET_INFO_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialComponentBounded2DListEXT = XR_TYPE_SPATIAL_COMPONENT_BOUNDED_2D_LIST_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialComponentBounded3DListEXT = XR_TYPE_SPATIAL_COMPONENT_BOUNDED_3D_LIST_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialComponentParentListEXT = XR_TYPE_SPATIAL_COMPONENT_PARENT_LIST_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialComponentMesh3DListEXT = XR_TYPE_SPATIAL_COMPONENT_MESH_3D_LIST_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialEntityFromIdCreateInfoEXT = XR_TYPE_SPATIAL_ENTITY_FROM_ID_CREATE_INFO_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialUpdateSnapshotCreateInfoEXT = XR_TYPE_SPATIAL_UPDATE_SNAPSHOT_CREATE_INFO_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  EventDataSpatialDiscoveryRecommendedEXT = XR_TYPE_EVENT_DATA_SPATIAL_DISCOVERY_RECOMMENDED_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialFilterTrackingStateEXT = XR_TYPE_SPATIAL_FILTER_TRACKING_STATE_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_plane_tracking
  SpatialCapabilityConfigurationPlaneTrackingEXT =
      XR_TYPE_SPATIAL_CAPABILITY_CONFIGURATION_PLANE_TRACKING_EXT,
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
  SpatialComponentPlaneAlignmentListEXT = XR_TYPE_SPATIAL_COMPONENT_PLANE_ALIGNMENT_LIST_EXT,
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
  SpatialComponentMesh2DListEXT = XR_TYPE_SPATIAL_COMPONENT_MESH_2D_LIST_EXT,
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
  SpatialComponentPolygon2DListEXT = XR_TYPE_SPATIAL_COMPONENT_POLYGON_2D_LIST_EXT,
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
  SpatialComponentPlaneSemanticLabelListEXT =
      XR_TYPE_SPATIAL_COMPONENT_PLANE_SEMANTIC_LABEL_LIST_EXT,
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_marker_tracking
  SpatialCapabilityConfigurationQrCodeEXT = XR_TYPE_SPATIAL_CAPABILITY_CONFIGURATION_QR_CODE_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
  SpatialCapabilityConfigurationMicroQrCodeEXT =
      XR_TYPE_SPATIAL_CAPABILITY_CONFIGURATION_MICRO_QR_CODE_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
  SpatialCapabilityConfigurationArucoMarkerEXT =
      XR_TYPE_SPATIAL_CAPABILITY_CONFIGURATION_ARUCO_MARKER_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
  SpatialCapabilityConfigurationAprilTagEXT =
      XR_TYPE_SPATIAL_CAPABILITY_CONFIGURATION_APRIL_TAG_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
  SpatialMarkerSizeEXT = XR_TYPE_SPATIAL_MARKER_SIZE_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
  SpatialMarkerStaticOptimizationEXT = XR_TYPE_SPATIAL_MARKER_STATIC_OPTIMIZATION_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
  SpatialComponentMarkerListEXT = XR_TYPE_SPATIAL_COMPONENT_MARKER_LIST_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_anchor
  SpatialCapabilityConfigurationAnchorEXT = XR_TYPE_SPATIAL_CAPABILITY_CONFIGURATION_ANCHOR_EXT,
#endif  // XR_EXT_spatial_anchor
#ifdef XR_EXT_spatial_anchor
  SpatialComponentAnchorListEXT = XR_TYPE_SPATIAL_COMPONENT_ANCHOR_LIST_EXT,
#endif  // XR_EXT_spatial_anchor
#ifdef XR_EXT_spatial_anchor
  SpatialAnchorCreateInfoEXT = XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_EXT,
#endif  // XR_EXT_spatial_anchor
#ifdef dsaXR_EXT_spatial_persistence
  SpatialPersistenceContextCreateInfoEXT = XR_TYPE_SPATIAL_PERSISTENCE_CONTEXT_CREATE_INFO_EXT,
#endif  // XR_EXT_spatial_persistence
#ifdef dsaXR_EXT_spatial_persistence
  CreateSpatialPersistenceContextCompletionEXT =
      XR_TYPE_CREATE_SPATIAL_PERSISTENCE_CONTEXT_COMPLETION_EXT,
#endif  // XR_EXT_spatial_persistence
#ifdef dsaXR_EXT_spatial_persistence
  SpatialContextPersistenceConfigEXT = XR_TYPE_SPATIAL_CONTEXT_PERSISTENCE_CONFIG_EXT,
#endif  // XR_EXT_spatial_persistence
#ifdef dsaXR_EXT_spatial_persistence
  SpatialDiscoveryPersistenceUuidFilterEXT = XR_TYPE_SPATIAL_DISCOVERY_PERSISTENCE_UUID_FILTER_EXT,
#endif  // XR_EXT_spatial_persistence
#ifdef dsaXR_EXT_spatial_persistence
  SpatialComponentPersistenceListEXT = XR_TYPE_SPATIAL_COMPONENT_PERSISTENCE_LIST_EXT,
#endif  // XR_EXT_spatial_persistence
#ifdef dsaXR_EXT_spatial_persistence_operations
  SpatialEntityPersistInfoEXT = XR_TYPE_SPATIAL_ENTITY_PERSIST_INFO_EXT,
#endif  // XR_EXT_spatial_persistence_operations
#ifdef dsaXR_EXT_spatial_persistence_operations
  PersistSpatialEntityCompletionEXT = XR_TYPE_PERSIST_SPATIAL_ENTITY_COMPLETION_EXT,
#endif  // XR_EXT_spatial_persistence_operations
#ifdef dsaXR_EXT_spatial_persistence_operations
  SpatialEntityUnpersistInfoEXT = XR_TYPE_SPATIAL_ENTITY_UNPERSIST_INFO_EXT,
#endif  // XR_EXT_spatial_persistence_operations
#ifdef dsaXR_EXT_spatial_persistence_operations
  UnpersistSpatialEntityCompletionEXT = XR_TYPE_UNPERSIST_SPATIAL_ENTITY_COMPLETION_EXT,
#endif  // XR_EXT_spatial_persistence_operations
};
static_assert(sizeof(StructureType) == sizeof(XrStructureType),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrStructureType value from a StructureType.
 *
 * @found_by_adl
 * @see StructureType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrStructureType get(StructureType const& v) {
  return static_cast<XrStructureType>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrStructureType address from a StructureType.
 *
 * @found_by_adl
 * @see StructureType
 */
OPENXR_HPP_INLINE XrStructureType* put(StructureType& v) {
  return reinterpret_cast<XrStructureType*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a StructureType value as a const char *.
 *
 * @found_by_adl
 * @see StructureType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(StructureType value) {
  switch (value) {
    case StructureType::Unknown:
      return "Unknown";

    case StructureType::APILayerProperties:
      return "APILayerProperties";

    case StructureType::ExtensionProperties:
      return "ExtensionProperties";

    case StructureType::InstanceCreateInfo:
      return "InstanceCreateInfo";

    case StructureType::SystemGetInfo:
      return "SystemGetInfo";

    case StructureType::SystemProperties:
      return "SystemProperties";

    case StructureType::ViewLocateInfo:
      return "ViewLocateInfo";

    case StructureType::View:
      return "View";

    case StructureType::SessionCreateInfo:
      return "SessionCreateInfo";

    case StructureType::SwapchainCreateInfo:
      return "SwapchainCreateInfo";

    case StructureType::SessionBeginInfo:
      return "SessionBeginInfo";

    case StructureType::ViewState:
      return "ViewState";

    case StructureType::FrameEndInfo:
      return "FrameEndInfo";

    case StructureType::HapticVibration:
      return "HapticVibration";

    case StructureType::EventDataBuffer:
      return "EventDataBuffer";

    case StructureType::EventDataInstanceLossPending:
      return "EventDataInstanceLossPending";

    case StructureType::EventDataSessionStateChanged:
      return "EventDataSessionStateChanged";

    case StructureType::ActionStateBoolean:
      return "ActionStateBoolean";

    case StructureType::ActionStateFloat:
      return "ActionStateFloat";

    case StructureType::ActionStateVector2F:
      return "ActionStateVector2F";

    case StructureType::ActionStatePose:
      return "ActionStatePose";

    case StructureType::ActionSetCreateInfo:
      return "ActionSetCreateInfo";

    case StructureType::ActionCreateInfo:
      return "ActionCreateInfo";

    case StructureType::InstanceProperties:
      return "InstanceProperties";

    case StructureType::FrameWaitInfo:
      return "FrameWaitInfo";

    case StructureType::CompositionLayerProjection:
      return "CompositionLayerProjection";

    case StructureType::CompositionLayerQuad:
      return "CompositionLayerQuad";

    case StructureType::ReferenceSpaceCreateInfo:
      return "ReferenceSpaceCreateInfo";

    case StructureType::ActionSpaceCreateInfo:
      return "ActionSpaceCreateInfo";

    case StructureType::EventDataReferenceSpaceChangePending:
      return "EventDataReferenceSpaceChangePending";

    case StructureType::ViewConfigurationView:
      return "ViewConfigurationView";

    case StructureType::SpaceLocation:
      return "SpaceLocation";

    case StructureType::SpaceVelocity:
      return "SpaceVelocity";

    case StructureType::FrameState:
      return "FrameState";

    case StructureType::ViewConfigurationProperties:
      return "ViewConfigurationProperties";

    case StructureType::FrameBeginInfo:
      return "FrameBeginInfo";

    case StructureType::CompositionLayerProjectionView:
      return "CompositionLayerProjectionView";

    case StructureType::EventDataEventsLost:
      return "EventDataEventsLost";

    case StructureType::InteractionProfileSuggestedBinding:
      return "InteractionProfileSuggestedBinding";

    case StructureType::EventDataInteractionProfileChanged:
      return "EventDataInteractionProfileChanged";

    case StructureType::InteractionProfileState:
      return "InteractionProfileState";

    case StructureType::SwapchainImageAcquireInfo:
      return "SwapchainImageAcquireInfo";

    case StructureType::SwapchainImageWaitInfo:
      return "SwapchainImageWaitInfo";

    case StructureType::SwapchainImageReleaseInfo:
      return "SwapchainImageReleaseInfo";

    case StructureType::ActionStateGetInfo:
      return "ActionStateGetInfo";

    case StructureType::HapticActionInfo:
      return "HapticActionInfo";

    case StructureType::SessionActionSetsAttachInfo:
      return "SessionActionSetsAttachInfo";

    case StructureType::ActionsSyncInfo:
      return "ActionsSyncInfo";

    case StructureType::BoundSourcesForActionEnumerateInfo:
      return "BoundSourcesForActionEnumerateInfo";

    case StructureType::InputSourceLocalizedNameGetInfo:
      return "InputSourceLocalizedNameGetInfo";

    case StructureType::SpacesLocateInfo:
      return "SpacesLocateInfo";

    case StructureType::SpaceLocations:
      return "SpaceLocations";

    case StructureType::SpaceVelocities:
      return "SpaceVelocities";

#ifdef XR_KHR_composition_layer_cube
    case StructureType::CompositionLayerCubeKHR:
      return "CompositionLayerCubeKHR";
#endif  // XR_KHR_composition_layer_cube
#ifdef XR_KHR_android_create_instance
    case StructureType::InstanceCreateInfoAndroidKHR:
      return "InstanceCreateInfoAndroidKHR";
#endif  // XR_KHR_android_create_instance
#ifdef XR_KHR_composition_layer_depth
    case StructureType::CompositionLayerDepthInfoKHR:
      return "CompositionLayerDepthInfoKHR";
#endif  // XR_KHR_composition_layer_depth
#ifdef XR_KHR_vulkan_swapchain_format_list
    case StructureType::VulkanSwapchainFormatListCreateInfoKHR:
      return "VulkanSwapchainFormatListCreateInfoKHR";
#endif  // XR_KHR_vulkan_swapchain_format_list
#ifdef XR_EXT_performance_settings
    case StructureType::EventDataPerfSettingsEXT:
      return "EventDataPerfSettingsEXT";
#endif  // XR_EXT_performance_settings
#ifdef XR_KHR_composition_layer_cylinder
    case StructureType::CompositionLayerCylinderKHR:
      return "CompositionLayerCylinderKHR";
#endif  // XR_KHR_composition_layer_cylinder
#ifdef XR_KHR_composition_layer_equirect
    case StructureType::CompositionLayerEquirectKHR:
      return "CompositionLayerEquirectKHR";
#endif  // XR_KHR_composition_layer_equirect
#ifdef XR_EXT_debug_utils
    case StructureType::DebugUtilsObjectNameInfoEXT:
      return "DebugUtilsObjectNameInfoEXT";
#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils
    case StructureType::DebugUtilsMessengerCallbackDataEXT:
      return "DebugUtilsMessengerCallbackDataEXT";
#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils
    case StructureType::DebugUtilsMessengerCreateInfoEXT:
      return "DebugUtilsMessengerCreateInfoEXT";
#endif  // XR_EXT_debug_utils
#ifdef XR_EXT_debug_utils
    case StructureType::DebugUtilsLabelEXT:
      return "DebugUtilsLabelEXT";
#endif  // XR_EXT_debug_utils
#ifdef XR_KHR_opengl_enable
    case StructureType::GraphicsBindingOpenGLWin32KHR:
      return "GraphicsBindingOpenGLWin32KHR";
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
    case StructureType::GraphicsBindingOpenGLXlibKHR:
      return "GraphicsBindingOpenGLXlibKHR";
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
    case StructureType::GraphicsBindingOpenGLXcbKHR:
      return "GraphicsBindingOpenGLXcbKHR";
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
    case StructureType::GraphicsBindingOpenGLWaylandKHR:
      return "GraphicsBindingOpenGLWaylandKHR";
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
    case StructureType::SwapchainImageOpenGLKHR:
      return "SwapchainImageOpenGLKHR";
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_enable
    case StructureType::GraphicsRequirementsOpenGLKHR:
      return "GraphicsRequirementsOpenGLKHR";
#endif  // XR_KHR_opengl_enable
#ifdef XR_KHR_opengl_es_enable
    case StructureType::GraphicsBindingOpenGLESAndroidKHR:
      return "GraphicsBindingOpenGLESAndroidKHR";
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_opengl_es_enable
    case StructureType::SwapchainImageOpenGLESKHR:
      return "SwapchainImageOpenGLESKHR";
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_opengl_es_enable
    case StructureType::GraphicsRequirementsOpenGLESKHR:
      return "GraphicsRequirementsOpenGLESKHR";
#endif  // XR_KHR_opengl_es_enable
#ifdef XR_KHR_vulkan_enable
    case StructureType::GraphicsBindingVulkanKHR:
      return "GraphicsBindingVulkanKHR";
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
    case StructureType::SwapchainImageVulkanKHR:
      return "SwapchainImageVulkanKHR";
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_vulkan_enable
    case StructureType::GraphicsRequirementsVulkanKHR:
      return "GraphicsRequirementsVulkanKHR";
#endif  // XR_KHR_vulkan_enable
#ifdef XR_KHR_D3D11_enable
    case StructureType::GraphicsBindingD3D11KHR:
      return "GraphicsBindingD3D11KHR";
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D11_enable
    case StructureType::SwapchainImageD3D11KHR:
      return "SwapchainImageD3D11KHR";
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D11_enable
    case StructureType::GraphicsRequirementsD3D11KHR:
      return "GraphicsRequirementsD3D11KHR";
#endif  // XR_KHR_D3D11_enable
#ifdef XR_KHR_D3D12_enable
    case StructureType::GraphicsBindingD3D12KHR:
      return "GraphicsBindingD3D12KHR";
#endif  // XR_KHR_D3D12_enable
#ifdef XR_KHR_D3D12_enable
    case StructureType::SwapchainImageD3D12KHR:
      return "SwapchainImageD3D12KHR";
#endif  // XR_KHR_D3D12_enable
#ifdef XR_KHR_D3D12_enable
    case StructureType::GraphicsRequirementsD3D12KHR:
      return "GraphicsRequirementsD3D12KHR";
#endif  // XR_KHR_D3D12_enable
#ifdef XR_KHR_metal_enable
    case StructureType::GraphicsBindingMetalKHR:
      return "GraphicsBindingMetalKHR";
#endif  // XR_KHR_metal_enable
#ifdef XR_KHR_metal_enable
    case StructureType::SwapchainImageMetalKHR:
      return "SwapchainImageMetalKHR";
#endif  // XR_KHR_metal_enable
#ifdef XR_KHR_metal_enable
    case StructureType::GraphicsRequirementsMetalKHR:
      return "GraphicsRequirementsMetalKHR";
#endif  // XR_KHR_metal_enable
#ifdef XR_EXT_eye_gaze_interaction
    case StructureType::SystemEyeGazeInteractionPropertiesEXT:
      return "SystemEyeGazeInteractionPropertiesEXT";
#endif  // XR_EXT_eye_gaze_interaction
#ifdef XR_EXT_eye_gaze_interaction
    case StructureType::EyeGazeSampleTimeEXT:
      return "EyeGazeSampleTimeEXT";
#endif  // XR_EXT_eye_gaze_interaction
#ifdef XR_KHR_visibility_mask
    case StructureType::VisibilityMaskKHR:
      return "VisibilityMaskKHR";
#endif  // XR_KHR_visibility_mask
#ifdef XR_KHR_visibility_mask
    case StructureType::EventDataVisibilityMaskChangedKHR:
      return "EventDataVisibilityMaskChangedKHR";
#endif  // XR_KHR_visibility_mask
#ifdef XR_EXTX_overlay
    case StructureType::SessionCreateInfoOverlayEXTX:
      return "SessionCreateInfoOverlayEXTX";
#endif  // XR_EXTX_overlay
#ifdef XR_EXTX_overlay
    case StructureType::EventDataMainSessionVisibilityChangedEXTX:
      return "EventDataMainSessionVisibilityChangedEXTX";
#endif  // XR_EXTX_overlay
#ifdef XR_KHR_composition_layer_color_scale_bias
    case StructureType::CompositionLayerColorScaleBiasKHR:
      return "CompositionLayerColorScaleBiasKHR";
#endif  // XR_KHR_composition_layer_color_scale_bias
#ifdef XR_MSFT_spatial_anchor
    case StructureType::SpatialAnchorCreateInfoMSFT:
      return "SpatialAnchorCreateInfoMSFT";
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_spatial_anchor
    case StructureType::SpatialAnchorSpaceCreateInfoMSFT:
      return "SpatialAnchorSpaceCreateInfoMSFT";
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_FB_composition_layer_image_layout
    case StructureType::CompositionLayerImageLayoutFB:
      return "CompositionLayerImageLayoutFB";
#endif  // XR_FB_composition_layer_image_layout
#ifdef XR_FB_composition_layer_alpha_blend
    case StructureType::CompositionLayerAlphaBlendFB:
      return "CompositionLayerAlphaBlendFB";
#endif  // XR_FB_composition_layer_alpha_blend
#ifdef XR_EXT_view_configuration_depth_range
    case StructureType::ViewConfigurationDepthRangeEXT:
      return "ViewConfigurationDepthRangeEXT";
#endif  // XR_EXT_view_configuration_depth_range
#ifdef XR_MNDX_egl_enable
    case StructureType::GraphicsBindingEGLMNDX:
      return "GraphicsBindingEGLMNDX";
#endif  // XR_MNDX_egl_enable
#ifdef XR_MSFT_spatial_graph_bridge
    case StructureType::SpatialGraphNodeSpaceCreateInfoMSFT:
      return "SpatialGraphNodeSpaceCreateInfoMSFT";
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_MSFT_spatial_graph_bridge
    case StructureType::SpatialGraphStaticNodeBindingCreateInfoMSFT:
      return "SpatialGraphStaticNodeBindingCreateInfoMSFT";
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_MSFT_spatial_graph_bridge
    case StructureType::SpatialGraphNodeBindingPropertiesGetInfoMSFT:
      return "SpatialGraphNodeBindingPropertiesGetInfoMSFT";
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_MSFT_spatial_graph_bridge
    case StructureType::SpatialGraphNodeBindingPropertiesMSFT:
      return "SpatialGraphNodeBindingPropertiesMSFT";
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_EXT_hand_tracking
    case StructureType::SystemHandTrackingPropertiesEXT:
      return "SystemHandTrackingPropertiesEXT";
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
    case StructureType::HandTrackerCreateInfoEXT:
      return "HandTrackerCreateInfoEXT";
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
    case StructureType::HandJointsLocateInfoEXT:
      return "HandJointsLocateInfoEXT";
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
    case StructureType::HandJointLocationsEXT:
      return "HandJointLocationsEXT";
#endif  // XR_EXT_hand_tracking
#ifdef XR_EXT_hand_tracking
    case StructureType::HandJointVelocitiesEXT:
      return "HandJointVelocitiesEXT";
#endif  // XR_EXT_hand_tracking
#ifdef XR_MSFT_hand_tracking_mesh
    case StructureType::SystemHandTrackingMeshPropertiesMSFT:
      return "SystemHandTrackingMeshPropertiesMSFT";
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
    case StructureType::HandMeshSpaceCreateInfoMSFT:
      return "HandMeshSpaceCreateInfoMSFT";
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
    case StructureType::HandMeshUpdateInfoMSFT:
      return "HandMeshUpdateInfoMSFT";
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
    case StructureType::HandMeshMSFT:
      return "HandMeshMSFT";
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_hand_tracking_mesh
    case StructureType::HandPoseTypeInfoMSFT:
      return "HandPoseTypeInfoMSFT";
#endif  // XR_MSFT_hand_tracking_mesh
#ifdef XR_MSFT_secondary_view_configuration
    case StructureType::SecondaryViewConfigurationSessionBeginInfoMSFT:
      return "SecondaryViewConfigurationSessionBeginInfoMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
    case StructureType::SecondaryViewConfigurationStateMSFT:
      return "SecondaryViewConfigurationStateMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
    case StructureType::SecondaryViewConfigurationFrameStateMSFT:
      return "SecondaryViewConfigurationFrameStateMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
    case StructureType::SecondaryViewConfigurationFrameEndInfoMSFT:
      return "SecondaryViewConfigurationFrameEndInfoMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
    case StructureType::SecondaryViewConfigurationLayerInfoMSFT:
      return "SecondaryViewConfigurationLayerInfoMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_secondary_view_configuration
    case StructureType::SecondaryViewConfigurationSwapchainCreateInfoMSFT:
      return "SecondaryViewConfigurationSwapchainCreateInfoMSFT";
#endif  // XR_MSFT_secondary_view_configuration
#ifdef XR_MSFT_controller_model
    case StructureType::ControllerModelKeyStateMSFT:
      return "ControllerModelKeyStateMSFT";
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
    case StructureType::ControllerModelNodePropertiesMSFT:
      return "ControllerModelNodePropertiesMSFT";
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
    case StructureType::ControllerModelPropertiesMSFT:
      return "ControllerModelPropertiesMSFT";
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
    case StructureType::ControllerModelNodeStateMSFT:
      return "ControllerModelNodeStateMSFT";
#endif  // XR_MSFT_controller_model
#ifdef XR_MSFT_controller_model
    case StructureType::ControllerModelStateMSFT:
      return "ControllerModelStateMSFT";
#endif  // XR_MSFT_controller_model
#ifdef XR_EPIC_view_configuration_fov
    case StructureType::ViewConfigurationViewFovEPIC:
      return "ViewConfigurationViewFovEPIC";
#endif  // XR_EPIC_view_configuration_fov
#ifdef XR_MSFT_holographic_window_attachment
    case StructureType::HolographicWindowAttachmentMSFT:
      return "HolographicWindowAttachmentMSFT";
#endif  // XR_MSFT_holographic_window_attachment
#ifdef XR_MSFT_composition_layer_reprojection
    case StructureType::CompositionLayerReprojectionInfoMSFT:
      return "CompositionLayerReprojectionInfoMSFT";
#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_MSFT_composition_layer_reprojection
    case StructureType::CompositionLayerReprojectionPlaneOverrideMSFT:
      return "CompositionLayerReprojectionPlaneOverrideMSFT";
#endif  // XR_MSFT_composition_layer_reprojection
#ifdef XR_FB_android_surface_swapchain_create
    case StructureType::AndroidSurfaceSwapchainCreateInfoFB:
      return "AndroidSurfaceSwapchainCreateInfoFB";
#endif  // XR_FB_android_surface_swapchain_create
#ifdef XR_FB_composition_layer_secure_content
    case StructureType::CompositionLayerSecureContentFB:
      return "CompositionLayerSecureContentFB";
#endif  // XR_FB_composition_layer_secure_content
#ifdef XR_FB_body_tracking
    case StructureType::BodyTrackerCreateInfoFB:
      return "BodyTrackerCreateInfoFB";
#endif  // XR_FB_body_tracking
#ifdef XR_FB_body_tracking
    case StructureType::BodyJointsLocateInfoFB:
      return "BodyJointsLocateInfoFB";
#endif  // XR_FB_body_tracking
#ifdef XR_FB_body_tracking
    case StructureType::SystemBodyTrackingPropertiesFB:
      return "SystemBodyTrackingPropertiesFB";
#endif  // XR_FB_body_tracking
#ifdef XR_FB_body_tracking
    case StructureType::BodyJointLocationsFB:
      return "BodyJointLocationsFB";
#endif  // XR_FB_body_tracking
#ifdef XR_FB_body_tracking
    case StructureType::BodySkeletonFB:
      return "BodySkeletonFB";
#endif  // XR_FB_body_tracking
#ifdef XR_EXT_dpad_binding
    case StructureType::InteractionProfileDpadBindingEXT:
      return "InteractionProfileDpadBindingEXT";
#endif  // XR_EXT_dpad_binding
#ifdef XR_VALVE_analog_threshold
    case StructureType::InteractionProfileAnalogThresholdVALVE:
      return "InteractionProfileAnalogThresholdVALVE";
#endif  // XR_VALVE_analog_threshold
#ifdef XR_EXT_hand_joints_motion_range
    case StructureType::HandJointsMotionRangeInfoEXT:
      return "HandJointsMotionRangeInfoEXT";
#endif  // XR_EXT_hand_joints_motion_range
#ifdef XR_KHR_loader_init_android
    case StructureType::LoaderInitInfoAndroidKHR:
      return "LoaderInitInfoAndroidKHR";
#endif  // XR_KHR_loader_init_android
#ifdef XR_KHR_vulkan_enable2
    case StructureType::VulkanInstanceCreateInfoKHR:
      return "VulkanInstanceCreateInfoKHR";
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
    case StructureType::VulkanDeviceCreateInfoKHR:
      return "VulkanDeviceCreateInfoKHR";
#endif  // XR_KHR_vulkan_enable2
#ifdef XR_KHR_vulkan_enable2
    case StructureType::VulkanGraphicsDeviceGetInfoKHR:
      return "VulkanGraphicsDeviceGetInfoKHR";
#endif  // XR_KHR_vulkan_enable2
        // GraphicsBindingVulkan2KHR is an alias for GraphicsBindingVulkanKHR
        // SwapchainImageVulkan2KHR is an alias for SwapchainImageVulkanKHR
        // GraphicsRequirementsVulkan2KHR is an alias for GraphicsRequirementsVulkanKHR
#ifdef XR_KHR_composition_layer_equirect2
    case StructureType::CompositionLayerEquirect2KHR:
      return "CompositionLayerEquirect2KHR";
#endif  // XR_KHR_composition_layer_equirect2
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneObserverCreateInfoMSFT:
      return "SceneObserverCreateInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneCreateInfoMSFT:
      return "SceneCreateInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::NewSceneComputeInfoMSFT:
      return "NewSceneComputeInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::VisualMeshComputeLodInfoMSFT:
      return "VisualMeshComputeLodInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneComponentsMSFT:
      return "SceneComponentsMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneComponentsGetInfoMSFT:
      return "SceneComponentsGetInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneComponentLocationsMSFT:
      return "SceneComponentLocationsMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneComponentsLocateInfoMSFT:
      return "SceneComponentsLocateInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneObjectsMSFT:
      return "SceneObjectsMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneComponentParentFilterInfoMSFT:
      return "SceneComponentParentFilterInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneObjectTypesFilterInfoMSFT:
      return "SceneObjectTypesFilterInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::ScenePlanesMSFT:
      return "ScenePlanesMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::ScenePlaneAlignmentFilterInfoMSFT:
      return "ScenePlaneAlignmentFilterInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneMeshesMSFT:
      return "SceneMeshesMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneMeshBuffersGetInfoMSFT:
      return "SceneMeshBuffersGetInfoMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneMeshBuffersMSFT:
      return "SceneMeshBuffersMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneMeshVertexBufferMSFT:
      return "SceneMeshVertexBufferMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneMeshIndicesUint32MSFT:
      return "SceneMeshIndicesUint32MSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case StructureType::SceneMeshIndicesUint16MSFT:
      return "SceneMeshIndicesUint16MSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding_serialization
    case StructureType::SerializedSceneFragmentDataGetInfoMSFT:
      return "SerializedSceneFragmentDataGetInfoMSFT";
#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_MSFT_scene_understanding_serialization
    case StructureType::SceneDeserializeInfoMSFT:
      return "SceneDeserializeInfoMSFT";
#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_FB_display_refresh_rate
    case StructureType::EventDataDisplayRefreshRateChangedFB:
      return "EventDataDisplayRefreshRateChangedFB";
#endif  // XR_FB_display_refresh_rate
#ifdef XR_HTCX_vive_tracker_interaction
    case StructureType::ViveTrackerPathsHTCX:
      return "ViveTrackerPathsHTCX";
#endif  // XR_HTCX_vive_tracker_interaction
#ifdef XR_HTCX_vive_tracker_interaction
    case StructureType::EventDataViveTrackerConnectedHTCX:
      return "EventDataViveTrackerConnectedHTCX";
#endif  // XR_HTCX_vive_tracker_interaction
#ifdef XR_HTC_facial_tracking
    case StructureType::SystemFacialTrackingPropertiesHTC:
      return "SystemFacialTrackingPropertiesHTC";
#endif  // XR_HTC_facial_tracking
#ifdef XR_HTC_facial_tracking
    case StructureType::FacialTrackerCreateInfoHTC:
      return "FacialTrackerCreateInfoHTC";
#endif  // XR_HTC_facial_tracking
#ifdef XR_HTC_facial_tracking
    case StructureType::FacialExpressionsHTC:
      return "FacialExpressionsHTC";
#endif  // XR_HTC_facial_tracking
#ifdef XR_FB_color_space
    case StructureType::SystemColorSpacePropertiesFB:
      return "SystemColorSpacePropertiesFB";
#endif  // XR_FB_color_space
#ifdef XR_FB_hand_tracking_mesh
    case StructureType::HandTrackingMeshFB:
      return "HandTrackingMeshFB";
#endif  // XR_FB_hand_tracking_mesh
#ifdef XR_FB_hand_tracking_mesh
    case StructureType::HandTrackingScaleFB:
      return "HandTrackingScaleFB";
#endif  // XR_FB_hand_tracking_mesh
#ifdef XR_FB_hand_tracking_aim
    case StructureType::HandTrackingAimStateFB:
      return "HandTrackingAimStateFB";
#endif  // XR_FB_hand_tracking_aim
#ifdef XR_FB_hand_tracking_capsules
    case StructureType::HandTrackingCapsulesStateFB:
      return "HandTrackingCapsulesStateFB";
#endif  // XR_FB_hand_tracking_capsules
#ifdef XR_FB_spatial_entity
    case StructureType::SystemSpatialEntityPropertiesFB:
      return "SystemSpatialEntityPropertiesFB";
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
    case StructureType::SpatialAnchorCreateInfoFB:
      return "SpatialAnchorCreateInfoFB";
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
    case StructureType::SpaceComponentStatusSetInfoFB:
      return "SpaceComponentStatusSetInfoFB";
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
    case StructureType::SpaceComponentStatusFB:
      return "SpaceComponentStatusFB";
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
    case StructureType::EventDataSpatialAnchorCreateCompleteFB:
      return "EventDataSpatialAnchorCreateCompleteFB";
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_spatial_entity
    case StructureType::EventDataSpaceSetStatusCompleteFB:
      return "EventDataSpaceSetStatusCompleteFB";
#endif  // XR_FB_spatial_entity
#ifdef XR_FB_foveation
    case StructureType::FoveationProfileCreateInfoFB:
      return "FoveationProfileCreateInfoFB";
#endif  // XR_FB_foveation
#ifdef XR_FB_foveation
    case StructureType::SwapchainCreateInfoFoveationFB:
      return "SwapchainCreateInfoFoveationFB";
#endif  // XR_FB_foveation
#ifdef XR_FB_foveation
    case StructureType::SwapchainStateFoveationFB:
      return "SwapchainStateFoveationFB";
#endif  // XR_FB_foveation
#ifdef XR_FB_foveation_configuration
    case StructureType::FoveationLevelProfileCreateInfoFB:
      return "FoveationLevelProfileCreateInfoFB";
#endif  // XR_FB_foveation_configuration
#ifdef XR_FB_keyboard_tracking
    case StructureType::KeyboardSpaceCreateInfoFB:
      return "KeyboardSpaceCreateInfoFB";
#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_keyboard_tracking
    case StructureType::KeyboardTrackingQueryFB:
      return "KeyboardTrackingQueryFB";
#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_keyboard_tracking
    case StructureType::SystemKeyboardTrackingPropertiesFB:
      return "SystemKeyboardTrackingPropertiesFB";
#endif  // XR_FB_keyboard_tracking
#ifdef XR_FB_triangle_mesh
    case StructureType::TriangleMeshCreateInfoFB:
      return "TriangleMeshCreateInfoFB";
#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_passthrough
    case StructureType::SystemPassthroughPropertiesFB:
      return "SystemPassthroughPropertiesFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::PassthroughCreateInfoFB:
      return "PassthroughCreateInfoFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::PassthroughLayerCreateInfoFB:
      return "PassthroughLayerCreateInfoFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::CompositionLayerPassthroughFB:
      return "CompositionLayerPassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::GeometryInstanceCreateInfoFB:
      return "GeometryInstanceCreateInfoFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::GeometryInstanceTransformFB:
      return "GeometryInstanceTransformFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::SystemPassthroughProperties2FB:
      return "SystemPassthroughProperties2FB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::PassthroughStyleFB:
      return "PassthroughStyleFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::PassthroughColorMapMonoToRgbaFB:
      return "PassthroughColorMapMonoToRgbaFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::PassthroughColorMapMonoToMonoFB:
      return "PassthroughColorMapMonoToMonoFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::PassthroughBrightnessContrastSaturationFB:
      return "PassthroughBrightnessContrastSaturationFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case StructureType::EventDataPassthroughStateChangedFB:
      return "EventDataPassthroughStateChangedFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_render_model
    case StructureType::RenderModelPathInfoFB:
      return "RenderModelPathInfoFB";
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
    case StructureType::RenderModelPropertiesFB:
      return "RenderModelPropertiesFB";
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
    case StructureType::RenderModelBufferFB:
      return "RenderModelBufferFB";
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
    case StructureType::RenderModelLoadInfoFB:
      return "RenderModelLoadInfoFB";
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
    case StructureType::SystemRenderModelPropertiesFB:
      return "SystemRenderModelPropertiesFB";
#endif  // XR_FB_render_model
#ifdef XR_FB_render_model
    case StructureType::RenderModelCapabilitiesRequestFB:
      return "RenderModelCapabilitiesRequestFB";
#endif  // XR_FB_render_model
#ifdef XR_KHR_binding_modification
    case StructureType::BindingModificationsKHR:
      return "BindingModificationsKHR";
#endif  // XR_KHR_binding_modification
#ifdef XR_VARJO_foveated_rendering
    case StructureType::ViewLocateFoveatedRenderingVARJO:
      return "ViewLocateFoveatedRenderingVARJO";
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_VARJO_foveated_rendering
    case StructureType::FoveatedViewConfigurationViewVARJO:
      return "FoveatedViewConfigurationViewVARJO";
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_VARJO_foveated_rendering
    case StructureType::SystemFoveatedRenderingPropertiesVARJO:
      return "SystemFoveatedRenderingPropertiesVARJO";
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_VARJO_composition_layer_depth_test
    case StructureType::CompositionLayerDepthTestVARJO:
      return "CompositionLayerDepthTestVARJO";
#endif  // XR_VARJO_composition_layer_depth_test
#ifdef XR_VARJO_marker_tracking
    case StructureType::SystemMarkerTrackingPropertiesVARJO:
      return "SystemMarkerTrackingPropertiesVARJO";
#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking
    case StructureType::EventDataMarkerTrackingUpdateVARJO:
      return "EventDataMarkerTrackingUpdateVARJO";
#endif  // XR_VARJO_marker_tracking
#ifdef XR_VARJO_marker_tracking
    case StructureType::MarkerSpaceCreateInfoVARJO:
      return "MarkerSpaceCreateInfoVARJO";
#endif  // XR_VARJO_marker_tracking
#ifdef XR_ML_frame_end_info
    case StructureType::FrameEndInfoML:
      return "FrameEndInfoML";
#endif  // XR_ML_frame_end_info
#ifdef XR_ML_global_dimmer
    case StructureType::GlobalDimmerFrameEndInfoML:
      return "GlobalDimmerFrameEndInfoML";
#endif  // XR_ML_global_dimmer
#ifdef XR_ML_compat
    case StructureType::CoordinateSpaceCreateInfoML:
      return "CoordinateSpaceCreateInfoML";
#endif  // XR_ML_compat
#ifdef XR_ML_marker_understanding
    case StructureType::SystemMarkerUnderstandingPropertiesML:
      return "SystemMarkerUnderstandingPropertiesML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
    case StructureType::MarkerDetectorCreateInfoML:
      return "MarkerDetectorCreateInfoML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
    case StructureType::MarkerDetectorArucoInfoML:
      return "MarkerDetectorArucoInfoML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
    case StructureType::MarkerDetectorSizeInfoML:
      return "MarkerDetectorSizeInfoML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
    case StructureType::MarkerDetectorAprilTagInfoML:
      return "MarkerDetectorAprilTagInfoML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
    case StructureType::MarkerDetectorCustomProfileInfoML:
      return "MarkerDetectorCustomProfileInfoML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
    case StructureType::MarkerDetectorSnapshotInfoML:
      return "MarkerDetectorSnapshotInfoML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
    case StructureType::MarkerDetectorStateML:
      return "MarkerDetectorStateML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_marker_understanding
    case StructureType::MarkerSpaceCreateInfoML:
      return "MarkerSpaceCreateInfoML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_localization_map
    case StructureType::LocalizationMapML:
      return "LocalizationMapML";
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
    case StructureType::EventDataLocalizationChangedML:
      return "EventDataLocalizationChangedML";
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
    case StructureType::MapLocalizationRequestInfoML:
      return "MapLocalizationRequestInfoML";
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
    case StructureType::LocalizationMapImportInfoML:
      return "LocalizationMapImportInfoML";
#endif  // XR_ML_localization_map
#ifdef XR_ML_localization_map
    case StructureType::LocalizationEnableEventsInfoML:
      return "LocalizationEnableEventsInfoML";
#endif  // XR_ML_localization_map
#ifdef dsaXR_ML_spatial_anchors
    case StructureType::SpatialAnchorsCreateInfoFromPoseML:
      return "SpatialAnchorsCreateInfoFromPoseML";
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors
    case StructureType::CreateSpatialAnchorsCompletionML:
      return "CreateSpatialAnchorsCompletionML";
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors
    case StructureType::SpatialAnchorStateML:
      return "SpatialAnchorStateML";
#endif  // XR_ML_spatial_anchors
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsCreateStorageInfoML:
      return "SpatialAnchorsCreateStorageInfoML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsQueryInfoRadiusML:
      return "SpatialAnchorsQueryInfoRadiusML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsQueryCompletionML:
      return "SpatialAnchorsQueryCompletionML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsCreateInfoFromUuidsML:
      return "SpatialAnchorsCreateInfoFromUuidsML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsPublishInfoML:
      return "SpatialAnchorsPublishInfoML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsPublishCompletionML:
      return "SpatialAnchorsPublishCompletionML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsDeleteInfoML:
      return "SpatialAnchorsDeleteInfoML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsDeleteCompletionML:
      return "SpatialAnchorsDeleteCompletionML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsUpdateExpirationInfoML:
      return "SpatialAnchorsUpdateExpirationInfoML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsUpdateExpirationCompletionML:
      return "SpatialAnchorsUpdateExpirationCompletionML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsPublishCompletionDetailsML:
      return "SpatialAnchorsPublishCompletionDetailsML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsDeleteCompletionDetailsML:
      return "SpatialAnchorsDeleteCompletionDetailsML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef dsaXR_ML_spatial_anchors_storage
    case StructureType::SpatialAnchorsUpdateExpirationCompletionDetailsML:
      return "SpatialAnchorsUpdateExpirationCompletionDetailsML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef XR_ML_user_calibration
    case StructureType::EventDataHeadsetFitChangedML:
      return "EventDataHeadsetFitChangedML";
#endif  // XR_ML_user_calibration
#ifdef XR_ML_user_calibration
    case StructureType::EventDataEyeCalibrationChangedML:
      return "EventDataEyeCalibrationChangedML";
#endif  // XR_ML_user_calibration
#ifdef XR_ML_user_calibration
    case StructureType::UserCalibrationEnableEventsInfoML:
      return "UserCalibrationEnableEventsInfoML";
#endif  // XR_ML_user_calibration
#ifdef XR_MSFT_spatial_anchor_persistence
    case StructureType::SpatialAnchorPersistenceInfoMSFT:
      return "SpatialAnchorPersistenceInfoMSFT";
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_spatial_anchor_persistence
    case StructureType::SpatialAnchorFromPersistedAnchorCreateInfoMSFT:
      return "SpatialAnchorFromPersistedAnchorCreateInfoMSFT";
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_MSFT_scene_marker
    case StructureType::SceneMarkersMSFT:
      return "SceneMarkersMSFT";
#endif  // XR_MSFT_scene_marker
#ifdef XR_MSFT_scene_marker
    case StructureType::SceneMarkerTypeFilterMSFT:
      return "SceneMarkerTypeFilterMSFT";
#endif  // XR_MSFT_scene_marker
#ifdef XR_MSFT_scene_marker
    case StructureType::SceneMarkerQrCodesMSFT:
      return "SceneMarkerQrCodesMSFT";
#endif  // XR_MSFT_scene_marker
#ifdef XR_FB_spatial_entity_query
    case StructureType::SpaceQueryInfoFB:
      return "SpaceQueryInfoFB";
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query
    case StructureType::SpaceQueryResultsFB:
      return "SpaceQueryResultsFB";
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query
    case StructureType::SpaceStorageLocationFilterInfoFB:
      return "SpaceStorageLocationFilterInfoFB";
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query
    case StructureType::SpaceUuidFilterInfoFB:
      return "SpaceUuidFilterInfoFB";
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query
    case StructureType::SpaceComponentFilterInfoFB:
      return "SpaceComponentFilterInfoFB";
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query
    case StructureType::EventDataSpaceQueryResultsAvailableFB:
      return "EventDataSpaceQueryResultsAvailableFB";
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_query
    case StructureType::EventDataSpaceQueryCompleteFB:
      return "EventDataSpaceQueryCompleteFB";
#endif  // XR_FB_spatial_entity_query
#ifdef XR_FB_spatial_entity_storage
    case StructureType::SpaceSaveInfoFB:
      return "SpaceSaveInfoFB";
#endif  // XR_FB_spatial_entity_storage
#ifdef XR_FB_spatial_entity_storage
    case StructureType::SpaceEraseInfoFB:
      return "SpaceEraseInfoFB";
#endif  // XR_FB_spatial_entity_storage
#ifdef XR_FB_spatial_entity_storage
    case StructureType::EventDataSpaceSaveCompleteFB:
      return "EventDataSpaceSaveCompleteFB";
#endif  // XR_FB_spatial_entity_storage
#ifdef XR_FB_spatial_entity_storage
    case StructureType::EventDataSpaceEraseCompleteFB:
      return "EventDataSpaceEraseCompleteFB";
#endif  // XR_FB_spatial_entity_storage
#ifdef XR_FB_foveation_vulkan
    case StructureType::SwapchainImageFoveationVulkanFB:
      return "SwapchainImageFoveationVulkanFB";
#endif  // XR_FB_foveation_vulkan
#ifdef XR_FB_swapchain_update_state_android_surface
    case StructureType::SwapchainStateAndroidSurfaceDimensionsFB:
      return "SwapchainStateAndroidSurfaceDimensionsFB";
#endif  // XR_FB_swapchain_update_state_android_surface
#ifdef XR_FB_swapchain_update_state_opengl_es
    case StructureType::SwapchainStateSamplerOpenGLESFB:
      return "SwapchainStateSamplerOpenGLESFB";
#endif  // XR_FB_swapchain_update_state_opengl_es
#ifdef XR_FB_swapchain_update_state_vulkan
    case StructureType::SwapchainStateSamplerVulkanFB:
      return "SwapchainStateSamplerVulkanFB";
#endif  // XR_FB_swapchain_update_state_vulkan
#ifdef XR_FB_spatial_entity_sharing
    case StructureType::SpaceShareInfoFB:
      return "SpaceShareInfoFB";
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_spatial_entity_sharing
    case StructureType::EventDataSpaceShareCompleteFB:
      return "EventDataSpaceShareCompleteFB";
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_space_warp
    case StructureType::CompositionLayerSpaceWarpInfoFB:
      return "CompositionLayerSpaceWarpInfoFB";
#endif  // XR_FB_space_warp
#ifdef XR_FB_space_warp
    case StructureType::SystemSpaceWarpPropertiesFB:
      return "SystemSpaceWarpPropertiesFB";
#endif  // XR_FB_space_warp
#ifdef XR_FB_haptic_amplitude_envelope
    case StructureType::HapticAmplitudeEnvelopeVibrationFB:
      return "HapticAmplitudeEnvelopeVibrationFB";
#endif  // XR_FB_haptic_amplitude_envelope
#ifdef XR_FB_scene
    case StructureType::SemanticLabelsFB:
      return "SemanticLabelsFB";
#endif  // XR_FB_scene
#ifdef XR_FB_scene
    case StructureType::RoomLayoutFB:
      return "RoomLayoutFB";
#endif  // XR_FB_scene
#ifdef XR_FB_scene
    case StructureType::Boundary2DFB:
      return "Boundary2DFB";
#endif  // XR_FB_scene
#ifdef XR_FB_scene
    case StructureType::SemanticLabelsSupportInfoFB:
      return "SemanticLabelsSupportInfoFB";
#endif  // XR_FB_scene
#ifdef XR_ALMALENCE_digital_lens_control
    case StructureType::DigitalLensControlALMALENCE:
      return "DigitalLensControlALMALENCE";
#endif  // XR_ALMALENCE_digital_lens_control
#ifdef XR_FB_scene_capture
    case StructureType::EventDataSceneCaptureCompleteFB:
      return "EventDataSceneCaptureCompleteFB";
#endif  // XR_FB_scene_capture
#ifdef XR_FB_scene_capture
    case StructureType::SceneCaptureRequestInfoFB:
      return "SceneCaptureRequestInfoFB";
#endif  // XR_FB_scene_capture
#ifdef XR_FB_spatial_entity_container
    case StructureType::SpaceContainerFB:
      return "SpaceContainerFB";
#endif  // XR_FB_spatial_entity_container
#ifdef XR_META_foveation_eye_tracked
    case StructureType::FoveationEyeTrackedProfileCreateInfoMETA:
      return "FoveationEyeTrackedProfileCreateInfoMETA";
#endif  // XR_META_foveation_eye_tracked
#ifdef XR_META_foveation_eye_tracked
    case StructureType::FoveationEyeTrackedStateMETA:
      return "FoveationEyeTrackedStateMETA";
#endif  // XR_META_foveation_eye_tracked
#ifdef XR_META_foveation_eye_tracked
    case StructureType::SystemFoveationEyeTrackedPropertiesMETA:
      return "SystemFoveationEyeTrackedPropertiesMETA";
#endif  // XR_META_foveation_eye_tracked
#ifdef XR_FB_face_tracking
    case StructureType::SystemFaceTrackingPropertiesFB:
      return "SystemFaceTrackingPropertiesFB";
#endif  // XR_FB_face_tracking
#ifdef XR_FB_face_tracking
    case StructureType::FaceTrackerCreateInfoFB:
      return "FaceTrackerCreateInfoFB";
#endif  // XR_FB_face_tracking
#ifdef XR_FB_face_tracking
    case StructureType::FaceExpressionInfoFB:
      return "FaceExpressionInfoFB";
#endif  // XR_FB_face_tracking
#ifdef XR_FB_face_tracking
    case StructureType::FaceExpressionWeightsFB:
      return "FaceExpressionWeightsFB";
#endif  // XR_FB_face_tracking
#ifdef XR_FB_eye_tracking_social
    case StructureType::EyeTrackerCreateInfoFB:
      return "EyeTrackerCreateInfoFB";
#endif  // XR_FB_eye_tracking_social
#ifdef XR_FB_eye_tracking_social
    case StructureType::EyeGazesInfoFB:
      return "EyeGazesInfoFB";
#endif  // XR_FB_eye_tracking_social
#ifdef XR_FB_eye_tracking_social
    case StructureType::EyeGazesFB:
      return "EyeGazesFB";
#endif  // XR_FB_eye_tracking_social
#ifdef XR_FB_eye_tracking_social
    case StructureType::SystemEyeTrackingPropertiesFB:
      return "SystemEyeTrackingPropertiesFB";
#endif  // XR_FB_eye_tracking_social
#ifdef XR_FB_passthrough_keyboard_hands
    case StructureType::PassthroughKeyboardHandsIntensityFB:
      return "PassthroughKeyboardHandsIntensityFB";
#endif  // XR_FB_passthrough_keyboard_hands
#ifdef XR_FB_composition_layer_settings
    case StructureType::CompositionLayerSettingsFB:
      return "CompositionLayerSettingsFB";
#endif  // XR_FB_composition_layer_settings
#ifdef XR_FB_haptic_pcm
    case StructureType::HapticPcmVibrationFB:
      return "HapticPcmVibrationFB";
#endif  // XR_FB_haptic_pcm
#ifdef XR_FB_haptic_pcm
    case StructureType::DevicePcmSampleRateStateFB:
      return "DevicePcmSampleRateStateFB";
#endif  // XR_FB_haptic_pcm
        // DevicePcmSampleRateGetInfoFB is an alias for DevicePcmSampleRateStateFB
#ifdef XR_EXT_frame_synthesis
    case StructureType::FrameSynthesisInfoEXT:
      return "FrameSynthesisInfoEXT";
#endif  // XR_EXT_frame_synthesis
#ifdef XR_EXT_frame_synthesis
    case StructureType::FrameSynthesisConfigViewEXT:
      return "FrameSynthesisConfigViewEXT";
#endif  // XR_EXT_frame_synthesis
#ifdef XR_FB_composition_layer_depth_test
    case StructureType::CompositionLayerDepthTestFB:
      return "CompositionLayerDepthTestFB";
#endif  // XR_FB_composition_layer_depth_test
#ifdef XR_META_local_dimming
    case StructureType::LocalDimmingFrameEndInfoMETA:
      return "LocalDimmingFrameEndInfoMETA";
#endif  // XR_META_local_dimming
#ifdef XR_META_passthrough_preferences
    case StructureType::PassthroughPreferencesMETA:
      return "PassthroughPreferencesMETA";
#endif  // XR_META_passthrough_preferences
#ifdef XR_META_virtual_keyboard
    case StructureType::SystemVirtualKeyboardPropertiesMETA:
      return "SystemVirtualKeyboardPropertiesMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::VirtualKeyboardCreateInfoMETA:
      return "VirtualKeyboardCreateInfoMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::VirtualKeyboardSpaceCreateInfoMETA:
      return "VirtualKeyboardSpaceCreateInfoMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::VirtualKeyboardLocationInfoMETA:
      return "VirtualKeyboardLocationInfoMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::VirtualKeyboardModelVisibilitySetInfoMETA:
      return "VirtualKeyboardModelVisibilitySetInfoMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::VirtualKeyboardAnimationStateMETA:
      return "VirtualKeyboardAnimationStateMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::VirtualKeyboardModelAnimationStatesMETA:
      return "VirtualKeyboardModelAnimationStatesMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::VirtualKeyboardTextureDataMETA:
      return "VirtualKeyboardTextureDataMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::VirtualKeyboardInputInfoMETA:
      return "VirtualKeyboardInputInfoMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::VirtualKeyboardTextContextChangeInfoMETA:
      return "VirtualKeyboardTextContextChangeInfoMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::EventDataVirtualKeyboardCommitTextMETA:
      return "EventDataVirtualKeyboardCommitTextMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::EventDataVirtualKeyboardBackspaceMETA:
      return "EventDataVirtualKeyboardBackspaceMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::EventDataVirtualKeyboardEnterMETA:
      return "EventDataVirtualKeyboardEnterMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::EventDataVirtualKeyboardShownMETA:
      return "EventDataVirtualKeyboardShownMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_virtual_keyboard
    case StructureType::EventDataVirtualKeyboardHiddenMETA:
      return "EventDataVirtualKeyboardHiddenMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_OCULUS_external_camera
    case StructureType::ExternalCameraOCULUS:
      return "ExternalCameraOCULUS";
#endif  // XR_OCULUS_external_camera
#ifdef XR_META_vulkan_swapchain_create_info
    case StructureType::VulkanSwapchainCreateInfoMETA:
      return "VulkanSwapchainCreateInfoMETA";
#endif  // XR_META_vulkan_swapchain_create_info
#ifdef XR_META_performance_metrics
    case StructureType::PerformanceMetricsStateMETA:
      return "PerformanceMetricsStateMETA";
#endif  // XR_META_performance_metrics
#ifdef XR_META_performance_metrics
    case StructureType::PerformanceMetricsCounterMETA:
      return "PerformanceMetricsCounterMETA";
#endif  // XR_META_performance_metrics
#ifdef XR_FB_spatial_entity_storage_batch
    case StructureType::SpaceListSaveInfoFB:
      return "SpaceListSaveInfoFB";
#endif  // XR_FB_spatial_entity_storage_batch
#ifdef XR_FB_spatial_entity_storage_batch
    case StructureType::EventDataSpaceListSaveCompleteFB:
      return "EventDataSpaceListSaveCompleteFB";
#endif  // XR_FB_spatial_entity_storage_batch
#ifdef XR_FB_spatial_entity_user
    case StructureType::SpaceUserCreateInfoFB:
      return "SpaceUserCreateInfoFB";
#endif  // XR_FB_spatial_entity_user
#ifdef XR_META_headset_id
    case StructureType::SystemHeadsetIdPropertiesMETA:
      return "SystemHeadsetIdPropertiesMETA";
#endif  // XR_META_headset_id
#ifdef XR_META_recommended_layer_resolution
    case StructureType::RecommendedLayerResolutionMETA:
      return "RecommendedLayerResolutionMETA";
#endif  // XR_META_recommended_layer_resolution
#ifdef XR_META_recommended_layer_resolution
    case StructureType::RecommendedLayerResolutionGetInfoMETA:
      return "RecommendedLayerResolutionGetInfoMETA";
#endif  // XR_META_recommended_layer_resolution
#ifdef XR_META_passthrough_color_lut
    case StructureType::SystemPassthroughColorLutPropertiesMETA:
      return "SystemPassthroughColorLutPropertiesMETA";
#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_passthrough_color_lut
    case StructureType::PassthroughColorLutCreateInfoMETA:
      return "PassthroughColorLutCreateInfoMETA";
#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_passthrough_color_lut
    case StructureType::PassthroughColorLutUpdateInfoMETA:
      return "PassthroughColorLutUpdateInfoMETA";
#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_passthrough_color_lut
    case StructureType::PassthroughColorMapLutMETA:
      return "PassthroughColorMapLutMETA";
#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_passthrough_color_lut
    case StructureType::PassthroughColorMapInterpolatedLutMETA:
      return "PassthroughColorMapInterpolatedLutMETA";
#endif  // XR_META_passthrough_color_lut
#ifdef XR_META_spatial_entity_mesh
    case StructureType::SpaceTriangleMeshGetInfoMETA:
      return "SpaceTriangleMeshGetInfoMETA";
#endif  // XR_META_spatial_entity_mesh
#ifdef XR_META_spatial_entity_mesh
    case StructureType::SpaceTriangleMeshMETA:
      return "SpaceTriangleMeshMETA";
#endif  // XR_META_spatial_entity_mesh
#ifdef XR_META_body_tracking_full_body
    case StructureType::SystemPropertiesBodyTrackingFullBodyMETA:
      return "SystemPropertiesBodyTrackingFullBodyMETA";
#endif  // XR_META_body_tracking_full_body
#ifdef XR_META_passthrough_layer_resumed_event
    case StructureType::EventDataPassthroughLayerResumedMETA:
      return "EventDataPassthroughLayerResumedMETA";
#endif  // XR_META_passthrough_layer_resumed_event
#ifdef XR_FB_face_tracking2
    case StructureType::SystemFaceTrackingProperties2FB:
      return "SystemFaceTrackingProperties2FB";
#endif  // XR_FB_face_tracking2
#ifdef XR_FB_face_tracking2
    case StructureType::FaceTrackerCreateInfo2FB:
      return "FaceTrackerCreateInfo2FB";
#endif  // XR_FB_face_tracking2
#ifdef XR_FB_face_tracking2
    case StructureType::FaceExpressionInfo2FB:
      return "FaceExpressionInfo2FB";
#endif  // XR_FB_face_tracking2
#ifdef XR_FB_face_tracking2
    case StructureType::FaceExpressionWeights2FB:
      return "FaceExpressionWeights2FB";
#endif  // XR_FB_face_tracking2
#ifdef XR_META_spatial_entity_sharing
    case StructureType::SystemSpatialEntitySharingPropertiesMETA:
      return "SystemSpatialEntitySharingPropertiesMETA";
#endif  // XR_META_spatial_entity_sharing
#ifdef XR_META_spatial_entity_sharing
    case StructureType::ShareSpacesInfoMETA:
      return "ShareSpacesInfoMETA";
#endif  // XR_META_spatial_entity_sharing
#ifdef XR_META_spatial_entity_sharing
    case StructureType::EventDataShareSpacesCompleteMETA:
      return "EventDataShareSpacesCompleteMETA";
#endif  // XR_META_spatial_entity_sharing
#ifdef XR_META_environment_depth
    case StructureType::EnvironmentDepthProviderCreateInfoMETA:
      return "EnvironmentDepthProviderCreateInfoMETA";
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
    case StructureType::EnvironmentDepthSwapchainCreateInfoMETA:
      return "EnvironmentDepthSwapchainCreateInfoMETA";
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
    case StructureType::EnvironmentDepthSwapchainStateMETA:
      return "EnvironmentDepthSwapchainStateMETA";
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
    case StructureType::EnvironmentDepthImageAcquireInfoMETA:
      return "EnvironmentDepthImageAcquireInfoMETA";
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
    case StructureType::EnvironmentDepthImageViewMETA:
      return "EnvironmentDepthImageViewMETA";
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
    case StructureType::EnvironmentDepthImageMETA:
      return "EnvironmentDepthImageMETA";
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
    case StructureType::EnvironmentDepthHandRemovalSetInfoMETA:
      return "EnvironmentDepthHandRemovalSetInfoMETA";
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
    case StructureType::SystemEnvironmentDepthPropertiesMETA:
      return "SystemEnvironmentDepthPropertiesMETA";
#endif  // XR_META_environment_depth
#ifdef XR_EXT_render_model
    case StructureType::RenderModelCreateInfoEXT:
      return "RenderModelCreateInfoEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case StructureType::RenderModelPropertiesGetInfoEXT:
      return "RenderModelPropertiesGetInfoEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case StructureType::RenderModelPropertiesEXT:
      return "RenderModelPropertiesEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case StructureType::RenderModelSpaceCreateInfoEXT:
      return "RenderModelSpaceCreateInfoEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case StructureType::RenderModelStateGetInfoEXT:
      return "RenderModelStateGetInfoEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case StructureType::RenderModelStateEXT:
      return "RenderModelStateEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case StructureType::RenderModelAssetCreateInfoEXT:
      return "RenderModelAssetCreateInfoEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case StructureType::RenderModelAssetDataGetInfoEXT:
      return "RenderModelAssetDataGetInfoEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case StructureType::RenderModelAssetDataEXT:
      return "RenderModelAssetDataEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case StructureType::RenderModelAssetPropertiesGetInfoEXT:
      return "RenderModelAssetPropertiesGetInfoEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case StructureType::RenderModelAssetPropertiesEXT:
      return "RenderModelAssetPropertiesEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_interaction_render_model
    case StructureType::InteractionRenderModelIdsEnumerateInfoEXT:
      return "InteractionRenderModelIdsEnumerateInfoEXT";
#endif  // XR_EXT_interaction_render_model
#ifdef XR_EXT_interaction_render_model
    case StructureType::InteractionRenderModelSubactionPathInfoEXT:
      return "InteractionRenderModelSubactionPathInfoEXT";
#endif  // XR_EXT_interaction_render_model
#ifdef XR_EXT_interaction_render_model
    case StructureType::EventDataInteractionRenderModelsChangedEXT:
      return "EventDataInteractionRenderModelsChangedEXT";
#endif  // XR_EXT_interaction_render_model
#ifdef XR_EXT_interaction_render_model
    case StructureType::InteractionRenderModelTopLevelUserPathGetInfoEXT:
      return "InteractionRenderModelTopLevelUserPathGetInfoEXT";
#endif  // XR_EXT_interaction_render_model
#ifdef XR_HTC_passthrough
    case StructureType::PassthroughCreateInfoHTC:
      return "PassthroughCreateInfoHTC";
#endif  // XR_HTC_passthrough
#ifdef XR_HTC_passthrough
    case StructureType::PassthroughColorHTC:
      return "PassthroughColorHTC";
#endif  // XR_HTC_passthrough
#ifdef XR_HTC_passthrough
    case StructureType::PassthroughMeshTransformInfoHTC:
      return "PassthroughMeshTransformInfoHTC";
#endif  // XR_HTC_passthrough
#ifdef XR_HTC_passthrough
    case StructureType::CompositionLayerPassthroughHTC:
      return "CompositionLayerPassthroughHTC";
#endif  // XR_HTC_passthrough
#ifdef XR_HTC_foveation
    case StructureType::FoveationApplyInfoHTC:
      return "FoveationApplyInfoHTC";
#endif  // XR_HTC_foveation
#ifdef XR_HTC_foveation
    case StructureType::FoveationDynamicModeInfoHTC:
      return "FoveationDynamicModeInfoHTC";
#endif  // XR_HTC_foveation
#ifdef XR_HTC_foveation
    case StructureType::FoveationCustomModeInfoHTC:
      return "FoveationCustomModeInfoHTC";
#endif  // XR_HTC_foveation
#ifdef XR_HTC_anchor
    case StructureType::SystemAnchorPropertiesHTC:
      return "SystemAnchorPropertiesHTC";
#endif  // XR_HTC_anchor
#ifdef XR_HTC_anchor
    case StructureType::SpatialAnchorCreateInfoHTC:
      return "SpatialAnchorCreateInfoHTC";
#endif  // XR_HTC_anchor
#ifdef XR_HTC_body_tracking
    case StructureType::SystemBodyTrackingPropertiesHTC:
      return "SystemBodyTrackingPropertiesHTC";
#endif  // XR_HTC_body_tracking
#ifdef XR_HTC_body_tracking
    case StructureType::BodyTrackerCreateInfoHTC:
      return "BodyTrackerCreateInfoHTC";
#endif  // XR_HTC_body_tracking
#ifdef XR_HTC_body_tracking
    case StructureType::BodyJointsLocateInfoHTC:
      return "BodyJointsLocateInfoHTC";
#endif  // XR_HTC_body_tracking
#ifdef XR_HTC_body_tracking
    case StructureType::BodyJointLocationsHTC:
      return "BodyJointLocationsHTC";
#endif  // XR_HTC_body_tracking
#ifdef XR_HTC_body_tracking
    case StructureType::BodySkeletonHTC:
      return "BodySkeletonHTC";
#endif  // XR_HTC_body_tracking
#ifdef XR_EXT_active_action_set_priority
    case StructureType::ActiveActionSetPrioritiesEXT:
      return "ActiveActionSetPrioritiesEXT";
#endif  // XR_EXT_active_action_set_priority
#ifdef XR_MNDX_force_feedback_curl
    case StructureType::SystemForceFeedbackCurlPropertiesMNDX:
      return "SystemForceFeedbackCurlPropertiesMNDX";
#endif  // XR_MNDX_force_feedback_curl
#ifdef XR_MNDX_force_feedback_curl
    case StructureType::ForceFeedbackCurlApplyLocationsMNDX:
      return "ForceFeedbackCurlApplyLocationsMNDX";
#endif  // XR_MNDX_force_feedback_curl
#ifdef XR_BD_body_tracking
    case StructureType::BodyTrackerCreateInfoBD:
      return "BodyTrackerCreateInfoBD";
#endif  // XR_BD_body_tracking
#ifdef XR_BD_body_tracking
    case StructureType::BodyJointsLocateInfoBD:
      return "BodyJointsLocateInfoBD";
#endif  // XR_BD_body_tracking
#ifdef XR_BD_body_tracking
    case StructureType::BodyJointLocationsBD:
      return "BodyJointLocationsBD";
#endif  // XR_BD_body_tracking
#ifdef XR_BD_body_tracking
    case StructureType::SystemBodyTrackingPropertiesBD:
      return "SystemBodyTrackingPropertiesBD";
#endif  // XR_BD_body_tracking
#ifdef XR_BD_spatial_sensing
    case StructureType::SystemSpatialSensingPropertiesBD:
      return "SystemSpatialSensingPropertiesBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SpatialEntityComponentGetInfoBD:
      return "SpatialEntityComponentGetInfoBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SpatialEntityLocationGetInfoBD:
      return "SpatialEntityLocationGetInfoBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SpatialEntityComponentDataLocationBD:
      return "SpatialEntityComponentDataLocationBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SpatialEntityComponentDataSemanticBD:
      return "SpatialEntityComponentDataSemanticBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SpatialEntityComponentDataBoundingBox2DBD:
      return "SpatialEntityComponentDataBoundingBox2DBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SpatialEntityComponentDataPolygonBD:
      return "SpatialEntityComponentDataPolygonBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SpatialEntityComponentDataBoundingBox3DBD:
      return "SpatialEntityComponentDataBoundingBox3DBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SpatialEntityComponentDataTriangleMeshBD:
      return "SpatialEntityComponentDataTriangleMeshBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SenseDataProviderCreateInfoBD:
      return "SenseDataProviderCreateInfoBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SenseDataProviderStartInfoBD:
      return "SenseDataProviderStartInfoBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::EventDataSenseDataProviderStateChangedBD:
      return "EventDataSenseDataProviderStateChangedBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::EventDataSenseDataUpdatedBD:
      return "EventDataSenseDataUpdatedBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SenseDataQueryInfoBD:
      return "SenseDataQueryInfoBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SenseDataQueryCompletionBD:
      return "SenseDataQueryCompletionBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SenseDataFilterUuidBD:
      return "SenseDataFilterUuidBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SenseDataFilterSemanticBD:
      return "SenseDataFilterSemanticBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::QueriedSenseDataGetInfoBD:
      return "QueriedSenseDataGetInfoBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::QueriedSenseDataBD:
      return "QueriedSenseDataBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SpatialEntityStateBD:
      return "SpatialEntityStateBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::SpatialEntityAnchorCreateInfoBD:
      return "SpatialEntityAnchorCreateInfoBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case StructureType::AnchorSpaceCreateInfoBD:
      return "AnchorSpaceCreateInfoBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_anchor
    case StructureType::SystemSpatialAnchorPropertiesBD:
      return "SystemSpatialAnchorPropertiesBD";
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_anchor
    case StructureType::SpatialAnchorCreateInfoBD:
      return "SpatialAnchorCreateInfoBD";
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_anchor
    case StructureType::SpatialAnchorCreateCompletionBD:
      return "SpatialAnchorCreateCompletionBD";
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_anchor
    case StructureType::SpatialAnchorPersistInfoBD:
      return "SpatialAnchorPersistInfoBD";
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_anchor
    case StructureType::SpatialAnchorUnpersistInfoBD:
      return "SpatialAnchorUnpersistInfoBD";
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_anchor_sharing
    case StructureType::SystemSpatialAnchorSharingPropertiesBD:
      return "SystemSpatialAnchorSharingPropertiesBD";
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_anchor_sharing
    case StructureType::SpatialAnchorShareInfoBD:
      return "SpatialAnchorShareInfoBD";
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_anchor_sharing
    case StructureType::SharedSpatialAnchorDownloadInfoBD:
      return "SharedSpatialAnchorDownloadInfoBD";
#endif  // XR_BD_spatial_anchor_sharing
#ifdef XR_BD_spatial_scene
    case StructureType::SystemSpatialScenePropertiesBD:
      return "SystemSpatialScenePropertiesBD";
#endif  // XR_BD_spatial_scene
#ifdef XR_BD_spatial_scene
    case StructureType::SceneCaptureInfoBD:
      return "SceneCaptureInfoBD";
#endif  // XR_BD_spatial_scene
#ifdef XR_BD_spatial_mesh
    case StructureType::SystemSpatialMeshPropertiesBD:
      return "SystemSpatialMeshPropertiesBD";
#endif  // XR_BD_spatial_mesh
#ifdef XR_BD_spatial_mesh
    case StructureType::SenseDataProviderCreateInfoSpatialMeshBD:
      return "SenseDataProviderCreateInfoSpatialMeshBD";
#endif  // XR_BD_spatial_mesh
#ifdef XR_BD_future_progress
    case StructureType::FuturePollResultProgressBD:
      return "FuturePollResultProgressBD";
#endif  // XR_BD_future_progress
#ifdef XR_BD_spatial_plane
    case StructureType::SystemSpatialPlanePropertiesBD:
      return "SystemSpatialPlanePropertiesBD";
#endif  // XR_BD_spatial_plane
#ifdef XR_BD_spatial_plane
    case StructureType::SpatialEntityComponentDataPlaneOrientationBD:
      return "SpatialEntityComponentDataPlaneOrientationBD";
#endif  // XR_BD_spatial_plane
#ifdef XR_BD_spatial_plane
    case StructureType::SenseDataFilterPlaneOrientationBD:
      return "SenseDataFilterPlaneOrientationBD";
#endif  // XR_BD_spatial_plane
#ifdef XR_EXT_hand_tracking_data_source
    case StructureType::HandTrackingDataSourceInfoEXT:
      return "HandTrackingDataSourceInfoEXT";
#endif  // XR_EXT_hand_tracking_data_source
#ifdef XR_EXT_hand_tracking_data_source
    case StructureType::HandTrackingDataSourceStateEXT:
      return "HandTrackingDataSourceStateEXT";
#endif  // XR_EXT_hand_tracking_data_source
#ifdef XR_EXT_plane_detection
    case StructureType::PlaneDetectorCreateInfoEXT:
      return "PlaneDetectorCreateInfoEXT";
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
    case StructureType::PlaneDetectorBeginInfoEXT:
      return "PlaneDetectorBeginInfoEXT";
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
    case StructureType::PlaneDetectorGetInfoEXT:
      return "PlaneDetectorGetInfoEXT";
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
    case StructureType::PlaneDetectorLocationsEXT:
      return "PlaneDetectorLocationsEXT";
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
    case StructureType::PlaneDetectorLocationEXT:
      return "PlaneDetectorLocationEXT";
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
    case StructureType::PlaneDetectorPolygonBufferEXT:
      return "PlaneDetectorPolygonBufferEXT";
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_plane_detection
    case StructureType::SystemPlaneDetectionPropertiesEXT:
      return "SystemPlaneDetectionPropertiesEXT";
#endif  // XR_EXT_plane_detection
#ifdef XR_EXT_future
    case StructureType::FutureCancelInfoEXT:
      return "FutureCancelInfoEXT";
#endif  // XR_EXT_future
#ifdef XR_EXT_future
    case StructureType::FuturePollInfoEXT:
      return "FuturePollInfoEXT";
#endif  // XR_EXT_future
#ifdef XR_EXT_future
    case StructureType::FutureCompletionEXT:
      return "FutureCompletionEXT";
#endif  // XR_EXT_future
#ifdef XR_EXT_future
    case StructureType::FuturePollResultEXT:
      return "FuturePollResultEXT";
#endif  // XR_EXT_future
#ifdef XR_EXT_user_presence
    case StructureType::EventDataUserPresenceChangedEXT:
      return "EventDataUserPresenceChangedEXT";
#endif  // XR_EXT_user_presence
#ifdef XR_EXT_user_presence
    case StructureType::SystemUserPresencePropertiesEXT:
      return "SystemUserPresencePropertiesEXT";
#endif  // XR_EXT_user_presence
        // SpacesLocateInfoKHR is an alias for SpacesLocateInfo
        // SpaceLocationsKHR is an alias for SpaceLocations
        // SpaceVelocitiesKHR is an alias for SpaceVelocities
#ifdef XR_ML_system_notifications
    case StructureType::SystemNotificationsSetInfoML:
      return "SystemNotificationsSetInfoML";
#endif  // XR_ML_system_notifications
#ifdef dsaXR_ML_world_mesh_detection
    case StructureType::WorldMeshDetectorCreateInfoML:
      return "WorldMeshDetectorCreateInfoML";
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
    case StructureType::WorldMeshStateRequestInfoML:
      return "WorldMeshStateRequestInfoML";
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
    case StructureType::WorldMeshBlockStateML:
      return "WorldMeshBlockStateML";
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
    case StructureType::WorldMeshStateRequestCompletionML:
      return "WorldMeshStateRequestCompletionML";
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
    case StructureType::WorldMeshBufferRecommendedSizeInfoML:
      return "WorldMeshBufferRecommendedSizeInfoML";
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
    case StructureType::WorldMeshBufferSizeML:
      return "WorldMeshBufferSizeML";
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
    case StructureType::WorldMeshBufferML:
      return "WorldMeshBufferML";
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
    case StructureType::WorldMeshBlockRequestML:
      return "WorldMeshBlockRequestML";
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
    case StructureType::WorldMeshGetInfoML:
      return "WorldMeshGetInfoML";
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
    case StructureType::WorldMeshBlockML:
      return "WorldMeshBlockML";
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
    case StructureType::WorldMeshRequestCompletionML:
      return "WorldMeshRequestCompletionML";
#endif  // XR_ML_world_mesh_detection
#ifdef dsaXR_ML_world_mesh_detection
    case StructureType::WorldMeshRequestCompletionInfoML:
      return "WorldMeshRequestCompletionInfoML";
#endif  // XR_ML_world_mesh_detection
#ifdef XR_ML_facial_expression
    case StructureType::SystemFacialExpressionPropertiesML:
      return "SystemFacialExpressionPropertiesML";
#endif  // XR_ML_facial_expression
#ifdef XR_ML_facial_expression
    case StructureType::FacialExpressionClientCreateInfoML:
      return "FacialExpressionClientCreateInfoML";
#endif  // XR_ML_facial_expression
#ifdef XR_ML_facial_expression
    case StructureType::FacialExpressionBlendShapeGetInfoML:
      return "FacialExpressionBlendShapeGetInfoML";
#endif  // XR_ML_facial_expression
#ifdef XR_ML_facial_expression
    case StructureType::FacialExpressionBlendShapePropertiesML:
      return "FacialExpressionBlendShapePropertiesML";
#endif  // XR_ML_facial_expression
#ifdef XR_META_simultaneous_hands_and_controllers
    case StructureType::SystemSimultaneousHandsAndControllersPropertiesMETA:
      return "SystemSimultaneousHandsAndControllersPropertiesMETA";
#endif  // XR_META_simultaneous_hands_and_controllers
#ifdef XR_META_simultaneous_hands_and_controllers
    case StructureType::SimultaneousHandsAndControllersTrackingResumeInfoMETA:
      return "SimultaneousHandsAndControllersTrackingResumeInfoMETA";
#endif  // XR_META_simultaneous_hands_and_controllers
#ifdef XR_META_simultaneous_hands_and_controllers
    case StructureType::SimultaneousHandsAndControllersTrackingPauseInfoMETA:
      return "SimultaneousHandsAndControllersTrackingPauseInfoMETA";
#endif  // XR_META_simultaneous_hands_and_controllers
#ifdef XR_META_colocation_discovery
    case StructureType::ColocationDiscoveryStartInfoMETA:
      return "ColocationDiscoveryStartInfoMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case StructureType::ColocationDiscoveryStopInfoMETA:
      return "ColocationDiscoveryStopInfoMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case StructureType::ColocationAdvertisementStartInfoMETA:
      return "ColocationAdvertisementStartInfoMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case StructureType::ColocationAdvertisementStopInfoMETA:
      return "ColocationAdvertisementStopInfoMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case StructureType::EventDataStartColocationAdvertisementCompleteMETA:
      return "EventDataStartColocationAdvertisementCompleteMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case StructureType::EventDataStopColocationAdvertisementCompleteMETA:
      return "EventDataStopColocationAdvertisementCompleteMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case StructureType::EventDataColocationAdvertisementCompleteMETA:
      return "EventDataColocationAdvertisementCompleteMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case StructureType::EventDataStartColocationDiscoveryCompleteMETA:
      return "EventDataStartColocationDiscoveryCompleteMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case StructureType::EventDataColocationDiscoveryResultMETA:
      return "EventDataColocationDiscoveryResultMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case StructureType::EventDataColocationDiscoveryCompleteMETA:
      return "EventDataColocationDiscoveryCompleteMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case StructureType::EventDataStopColocationDiscoveryCompleteMETA:
      return "EventDataStopColocationDiscoveryCompleteMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_colocation_discovery
    case StructureType::SystemColocationDiscoveryPropertiesMETA:
      return "SystemColocationDiscoveryPropertiesMETA";
#endif  // XR_META_colocation_discovery
#ifdef XR_META_spatial_entity_group_sharing
    case StructureType::ShareSpacesRecipientGroupsMETA:
      return "ShareSpacesRecipientGroupsMETA";
#endif  // XR_META_spatial_entity_group_sharing
#ifdef XR_META_spatial_entity_group_sharing
    case StructureType::SpaceGroupUuidFilterInfoMETA:
      return "SpaceGroupUuidFilterInfoMETA";
#endif  // XR_META_spatial_entity_group_sharing
#ifdef XR_META_spatial_entity_group_sharing
    case StructureType::SystemSpatialEntityGroupSharingPropertiesMETA:
      return "SystemSpatialEntityGroupSharingPropertiesMETA";
#endif  // XR_META_spatial_entity_group_sharing
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialCapabilityComponentTypesEXT:
      return "SpatialCapabilityComponentTypesEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialContextCreateInfoEXT:
      return "SpatialContextCreateInfoEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::CreateSpatialContextCompletionEXT:
      return "CreateSpatialContextCompletionEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialDiscoverySnapshotCreateInfoEXT:
      return "SpatialDiscoverySnapshotCreateInfoEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::CreateSpatialDiscoverySnapshotCompletionInfoEXT:
      return "CreateSpatialDiscoverySnapshotCompletionInfoEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::CreateSpatialDiscoverySnapshotCompletionEXT:
      return "CreateSpatialDiscoverySnapshotCompletionEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialComponentDataQueryConditionEXT:
      return "SpatialComponentDataQueryConditionEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialComponentDataQueryResultEXT:
      return "SpatialComponentDataQueryResultEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialBufferGetInfoEXT:
      return "SpatialBufferGetInfoEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialComponentBounded2DListEXT:
      return "SpatialComponentBounded2DListEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialComponentBounded3DListEXT:
      return "SpatialComponentBounded3DListEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialComponentParentListEXT:
      return "SpatialComponentParentListEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialComponentMesh3DListEXT:
      return "SpatialComponentMesh3DListEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialEntityFromIdCreateInfoEXT:
      return "SpatialEntityFromIdCreateInfoEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialUpdateSnapshotCreateInfoEXT:
      return "SpatialUpdateSnapshotCreateInfoEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::EventDataSpatialDiscoveryRecommendedEXT:
      return "EventDataSpatialDiscoveryRecommendedEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case StructureType::SpatialFilterTrackingStateEXT:
      return "SpatialFilterTrackingStateEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_plane_tracking
    case StructureType::SpatialCapabilityConfigurationPlaneTrackingEXT:
      return "SpatialCapabilityConfigurationPlaneTrackingEXT";
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
    case StructureType::SpatialComponentPlaneAlignmentListEXT:
      return "SpatialComponentPlaneAlignmentListEXT";
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
    case StructureType::SpatialComponentMesh2DListEXT:
      return "SpatialComponentMesh2DListEXT";
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
    case StructureType::SpatialComponentPolygon2DListEXT:
      return "SpatialComponentPolygon2DListEXT";
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
    case StructureType::SpatialComponentPlaneSemanticLabelListEXT:
      return "SpatialComponentPlaneSemanticLabelListEXT";
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case StructureType::SpatialCapabilityConfigurationQrCodeEXT:
      return "SpatialCapabilityConfigurationQrCodeEXT";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case StructureType::SpatialCapabilityConfigurationMicroQrCodeEXT:
      return "SpatialCapabilityConfigurationMicroQrCodeEXT";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case StructureType::SpatialCapabilityConfigurationArucoMarkerEXT:
      return "SpatialCapabilityConfigurationArucoMarkerEXT";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case StructureType::SpatialCapabilityConfigurationAprilTagEXT:
      return "SpatialCapabilityConfigurationAprilTagEXT";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case StructureType::SpatialMarkerSizeEXT:
      return "SpatialMarkerSizeEXT";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case StructureType::SpatialMarkerStaticOptimizationEXT:
      return "SpatialMarkerStaticOptimizationEXT";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case StructureType::SpatialComponentMarkerListEXT:
      return "SpatialComponentMarkerListEXT";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_anchor
    case StructureType::SpatialCapabilityConfigurationAnchorEXT:
      return "SpatialCapabilityConfigurationAnchorEXT";
#endif  // XR_EXT_spatial_anchor
#ifdef XR_EXT_spatial_anchor
    case StructureType::SpatialComponentAnchorListEXT:
      return "SpatialComponentAnchorListEXT";
#endif  // XR_EXT_spatial_anchor
#ifdef XR_EXT_spatial_anchor
    case StructureType::SpatialAnchorCreateInfoEXT:
      return "SpatialAnchorCreateInfoEXT";
#endif  // XR_EXT_spatial_anchor
#ifdef dsaXR_EXT_spatial_persistence
    case StructureType::SpatialPersistenceContextCreateInfoEXT:
      return "SpatialPersistenceContextCreateInfoEXT";
#endif  // XR_EXT_spatial_persistence
#ifdef dsaXR_EXT_spatial_persistence
    case StructureType::CreateSpatialPersistenceContextCompletionEXT:
      return "CreateSpatialPersistenceContextCompletionEXT";
#endif  // XR_EXT_spatial_persistence
#ifdef dsaXR_EXT_spatial_persistence
    case StructureType::SpatialContextPersistenceConfigEXT:
      return "SpatialContextPersistenceConfigEXT";
#endif  // XR_EXT_spatial_persistence
#ifdef dsaXR_EXT_spatial_persistence
    case StructureType::SpatialDiscoveryPersistenceUuidFilterEXT:
      return "SpatialDiscoveryPersistenceUuidFilterEXT";
#endif  // XR_EXT_spatial_persistence
#ifdef dsaXR_EXT_spatial_persistence
    case StructureType::SpatialComponentPersistenceListEXT:
      return "SpatialComponentPersistenceListEXT";
#endif  // XR_EXT_spatial_persistence
#ifdef dsaXR_EXT_spatial_persistence_operations
    case StructureType::SpatialEntityPersistInfoEXT:
      return "SpatialEntityPersistInfoEXT";
#endif  // XR_EXT_spatial_persistence_operations
#ifdef dsaXR_EXT_spatial_persistence_operations
    case StructureType::PersistSpatialEntityCompletionEXT:
      return "PersistSpatialEntityCompletionEXT";
#endif  // XR_EXT_spatial_persistence_operations
#ifdef dsaXR_EXT_spatial_persistence_operations
    case StructureType::SpatialEntityUnpersistInfoEXT:
      return "SpatialEntityUnpersistInfoEXT";
#endif  // XR_EXT_spatial_persistence_operations
#ifdef dsaXR_EXT_spatial_persistence_operations
    case StructureType::UnpersistSpatialEntityCompletionEXT:
      return "UnpersistSpatialEntityCompletionEXT";
#endif  // XR_EXT_spatial_persistence_operations
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a StructureType value as a std::string.
 *
 * @found_by_adl
 * @see StructureType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(StructureType value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrFormFactor
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFormFactor>
 *
 * @xrentity{XrFormFactor}
 */
enum class FormFactor {

  HeadMountedDisplay = XR_FORM_FACTOR_HEAD_MOUNTED_DISPLAY,

  HandheldDisplay = XR_FORM_FACTOR_HANDHELD_DISPLAY,

};
static_assert(sizeof(FormFactor) == sizeof(XrFormFactor),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFormFactor value from a FormFactor.
 *
 * @found_by_adl
 * @see FormFactor
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFormFactor get(FormFactor const& v) {
  return static_cast<XrFormFactor>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFormFactor address from a FormFactor.
 *
 * @found_by_adl
 * @see FormFactor
 */
OPENXR_HPP_INLINE XrFormFactor* put(FormFactor& v) { return reinterpret_cast<XrFormFactor*>(&v); }

/*!
 * @brief Free function for retrieving the string name of a FormFactor value as a const char *.
 *
 * @found_by_adl
 * @see FormFactor
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(FormFactor value) {
  switch (value) {
    case FormFactor::HeadMountedDisplay:
      return "HeadMountedDisplay";

    case FormFactor::HandheldDisplay:
      return "HandheldDisplay";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FormFactor value as a std::string.
 *
 * @found_by_adl
 * @see FormFactor
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FormFactor value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrViewConfigurationType
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationType>
 *
 * @xrentity{XrViewConfigurationType}
 */
enum class ViewConfigurationType {

  PrimaryMono = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_MONO,

  PrimaryStereo = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO,

  PrimaryStereoWithFoveatedInset = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO_WITH_FOVEATED_INSET,

#ifdef XR_VARJO_quad_views
  PrimaryQuadVARJO = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_QUAD_VARJO,
#endif  // XR_VARJO_quad_views
#ifdef XR_MSFT_first_person_observer
  SecondaryMonoFirstPersonObserverMSFT =
      XR_VIEW_CONFIGURATION_TYPE_SECONDARY_MONO_FIRST_PERSON_OBSERVER_MSFT,
#endif  // XR_MSFT_first_person_observer
};
static_assert(sizeof(ViewConfigurationType) == sizeof(XrViewConfigurationType),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrViewConfigurationType value from a
 * ViewConfigurationType.
 *
 * @found_by_adl
 * @see ViewConfigurationType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrViewConfigurationType get(ViewConfigurationType const& v) {
  return static_cast<XrViewConfigurationType>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrViewConfigurationType address from a
 * ViewConfigurationType.
 *
 * @found_by_adl
 * @see ViewConfigurationType
 */
OPENXR_HPP_INLINE XrViewConfigurationType* put(ViewConfigurationType& v) {
  return reinterpret_cast<XrViewConfigurationType*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a ViewConfigurationType value as a const
 * char *.
 *
 * @found_by_adl
 * @see ViewConfigurationType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    ViewConfigurationType value) {
  switch (value) {
    case ViewConfigurationType::PrimaryMono:
      return "PrimaryMono";

    case ViewConfigurationType::PrimaryStereo:
      return "PrimaryStereo";

    case ViewConfigurationType::PrimaryStereoWithFoveatedInset:
      return "PrimaryStereoWithFoveatedInset";

      // PrimaryQuadVARJO is an alias for PrimaryStereoWithFoveatedInset
#ifdef XR_MSFT_first_person_observer
    case ViewConfigurationType::SecondaryMonoFirstPersonObserverMSFT:
      return "SecondaryMonoFirstPersonObserverMSFT";
#endif  // XR_MSFT_first_person_observer
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ViewConfigurationType value as a
 * std::string.
 *
 * @found_by_adl
 * @see ViewConfigurationType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ViewConfigurationType value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrEnvironmentBlendMode
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEnvironmentBlendMode>
 *
 * @xrentity{XrEnvironmentBlendMode}
 */
enum class EnvironmentBlendMode {

  Opaque = XR_ENVIRONMENT_BLEND_MODE_OPAQUE,

  Additive = XR_ENVIRONMENT_BLEND_MODE_ADDITIVE,

  AlphaBlend = XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND,

};
static_assert(sizeof(EnvironmentBlendMode) == sizeof(XrEnvironmentBlendMode),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEnvironmentBlendMode value from a
 * EnvironmentBlendMode.
 *
 * @found_by_adl
 * @see EnvironmentBlendMode
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEnvironmentBlendMode get(EnvironmentBlendMode const& v) {
  return static_cast<XrEnvironmentBlendMode>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEnvironmentBlendMode address from a
 * EnvironmentBlendMode.
 *
 * @found_by_adl
 * @see EnvironmentBlendMode
 */
OPENXR_HPP_INLINE XrEnvironmentBlendMode* put(EnvironmentBlendMode& v) {
  return reinterpret_cast<XrEnvironmentBlendMode*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a EnvironmentBlendMode value as a const
 * char *.
 *
 * @found_by_adl
 * @see EnvironmentBlendMode
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    EnvironmentBlendMode value) {
  switch (value) {
    case EnvironmentBlendMode::Opaque:
      return "Opaque";

    case EnvironmentBlendMode::Additive:
      return "Additive";

    case EnvironmentBlendMode::AlphaBlend:
      return "AlphaBlend";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a EnvironmentBlendMode value as a
 * std::string.
 *
 * @found_by_adl
 * @see EnvironmentBlendMode
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EnvironmentBlendMode value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrReferenceSpaceType
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrReferenceSpaceType>
 *
 * @xrentity{XrReferenceSpaceType}
 */
enum class ReferenceSpaceType {

  View = XR_REFERENCE_SPACE_TYPE_VIEW,

  Local = XR_REFERENCE_SPACE_TYPE_LOCAL,

  Stage = XR_REFERENCE_SPACE_TYPE_STAGE,

  LocalFloor = XR_REFERENCE_SPACE_TYPE_LOCAL_FLOOR,

#ifdef XR_MSFT_unbounded_reference_space
  UnboundedMSFT = XR_REFERENCE_SPACE_TYPE_UNBOUNDED_MSFT,
#endif  // XR_MSFT_unbounded_reference_space
#ifdef XR_VARJO_foveated_rendering
  CombinedEyeVARJO = XR_REFERENCE_SPACE_TYPE_COMBINED_EYE_VARJO,
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_ML_localization_map
  LocalizationMapML = XR_REFERENCE_SPACE_TYPE_LOCALIZATION_MAP_ML,
#endif  // XR_ML_localization_map
#ifdef XR_EXT_local_floor
  LocalFloorEXT = XR_REFERENCE_SPACE_TYPE_LOCAL_FLOOR_EXT,
#endif  // XR_EXT_local_floor
};
static_assert(sizeof(ReferenceSpaceType) == sizeof(XrReferenceSpaceType),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrReferenceSpaceType value from a ReferenceSpaceType.
 *
 * @found_by_adl
 * @see ReferenceSpaceType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrReferenceSpaceType get(ReferenceSpaceType const& v) {
  return static_cast<XrReferenceSpaceType>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrReferenceSpaceType address from a
 * ReferenceSpaceType.
 *
 * @found_by_adl
 * @see ReferenceSpaceType
 */
OPENXR_HPP_INLINE XrReferenceSpaceType* put(ReferenceSpaceType& v) {
  return reinterpret_cast<XrReferenceSpaceType*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a ReferenceSpaceType value as a const char
 * *.
 *
 * @found_by_adl
 * @see ReferenceSpaceType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    ReferenceSpaceType value) {
  switch (value) {
    case ReferenceSpaceType::View:
      return "View";

    case ReferenceSpaceType::Local:
      return "Local";

    case ReferenceSpaceType::Stage:
      return "Stage";

    case ReferenceSpaceType::LocalFloor:
      return "LocalFloor";

#ifdef XR_MSFT_unbounded_reference_space
    case ReferenceSpaceType::UnboundedMSFT:
      return "UnboundedMSFT";
#endif  // XR_MSFT_unbounded_reference_space
#ifdef XR_VARJO_foveated_rendering
    case ReferenceSpaceType::CombinedEyeVARJO:
      return "CombinedEyeVARJO";
#endif  // XR_VARJO_foveated_rendering
#ifdef XR_ML_localization_map
    case ReferenceSpaceType::LocalizationMapML:
      return "LocalizationMapML";
#endif  // XR_ML_localization_map
    // LocalFloorEXT is an alias for LocalFloor
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ReferenceSpaceType value as a
 * std::string.
 *
 * @found_by_adl
 * @see ReferenceSpaceType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ReferenceSpaceType value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrActionType
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionType>
 *
 * @xrentity{XrActionType}
 */
enum class ActionType {

  BooleanInput = XR_ACTION_TYPE_BOOLEAN_INPUT,

  FloatInput = XR_ACTION_TYPE_FLOAT_INPUT,

  Vector2FInput = XR_ACTION_TYPE_VECTOR2F_INPUT,

  PoseInput = XR_ACTION_TYPE_POSE_INPUT,

  VibrationOutput = XR_ACTION_TYPE_VIBRATION_OUTPUT,

};
static_assert(sizeof(ActionType) == sizeof(XrActionType),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrActionType value from a ActionType.
 *
 * @found_by_adl
 * @see ActionType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrActionType get(ActionType const& v) {
  return static_cast<XrActionType>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrActionType address from a ActionType.
 *
 * @found_by_adl
 * @see ActionType
 */
OPENXR_HPP_INLINE XrActionType* put(ActionType& v) { return reinterpret_cast<XrActionType*>(&v); }

/*!
 * @brief Free function for retrieving the string name of a ActionType value as a const char *.
 *
 * @found_by_adl
 * @see ActionType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ActionType value) {
  switch (value) {
    case ActionType::BooleanInput:
      return "BooleanInput";

    case ActionType::FloatInput:
      return "FloatInput";

    case ActionType::Vector2FInput:
      return "Vector2FInput";

    case ActionType::PoseInput:
      return "PoseInput";

    case ActionType::VibrationOutput:
      return "VibrationOutput";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ActionType value as a std::string.
 *
 * @found_by_adl
 * @see ActionType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ActionType value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrEyeVisibility
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeVisibility>
 *
 * @xrentity{XrEyeVisibility}
 */
enum class EyeVisibility {

  Both = XR_EYE_VISIBILITY_BOTH,

  Left = XR_EYE_VISIBILITY_LEFT,

  Right = XR_EYE_VISIBILITY_RIGHT,

};
static_assert(sizeof(EyeVisibility) == sizeof(XrEyeVisibility),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyeVisibility value from a EyeVisibility.
 *
 * @found_by_adl
 * @see EyeVisibility
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEyeVisibility get(EyeVisibility const& v) {
  return static_cast<XrEyeVisibility>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyeVisibility address from a EyeVisibility.
 *
 * @found_by_adl
 * @see EyeVisibility
 */
OPENXR_HPP_INLINE XrEyeVisibility* put(EyeVisibility& v) {
  return reinterpret_cast<XrEyeVisibility*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a EyeVisibility value as a const char *.
 *
 * @found_by_adl
 * @see EyeVisibility
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(EyeVisibility value) {
  switch (value) {
    case EyeVisibility::Both:
      return "Both";

    case EyeVisibility::Left:
      return "Left";

    case EyeVisibility::Right:
      return "Right";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a EyeVisibility value as a std::string.
 *
 * @found_by_adl
 * @see EyeVisibility
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EyeVisibility value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrSessionState
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionState>
 *
 * @xrentity{XrSessionState}
 */
enum class SessionState {

  Unknown = XR_SESSION_STATE_UNKNOWN,

  Idle = XR_SESSION_STATE_IDLE,

  Ready = XR_SESSION_STATE_READY,

  Synchronized = XR_SESSION_STATE_SYNCHRONIZED,

  Visible = XR_SESSION_STATE_VISIBLE,

  Focused = XR_SESSION_STATE_FOCUSED,

  Stopping = XR_SESSION_STATE_STOPPING,

  LossPending = XR_SESSION_STATE_LOSS_PENDING,

  Exiting = XR_SESSION_STATE_EXITING,

};
static_assert(sizeof(SessionState) == sizeof(XrSessionState),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSessionState value from a SessionState.
 *
 * @found_by_adl
 * @see SessionState
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSessionState get(SessionState const& v) {
  return static_cast<XrSessionState>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSessionState address from a SessionState.
 *
 * @found_by_adl
 * @see SessionState
 */
OPENXR_HPP_INLINE XrSessionState* put(SessionState& v) {
  return reinterpret_cast<XrSessionState*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SessionState value as a const char *.
 *
 * @found_by_adl
 * @see SessionState
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(SessionState value) {
  switch (value) {
    case SessionState::Unknown:
      return "Unknown";

    case SessionState::Idle:
      return "Idle";

    case SessionState::Ready:
      return "Ready";

    case SessionState::Synchronized:
      return "Synchronized";

    case SessionState::Visible:
      return "Visible";

    case SessionState::Focused:
      return "Focused";

    case SessionState::Stopping:
      return "Stopping";

    case SessionState::LossPending:
      return "LossPending";

    case SessionState::Exiting:
      return "Exiting";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SessionState value as a std::string.
 *
 * @found_by_adl
 * @see SessionState
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SessionState value) {
  return {to_string_literal(value)};
}
//! @}

/*!
 * @brief Enum class for XrObjectType
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrObjectType>
 *
 * @xrentity{XrObjectType}
 */
enum class ObjectType {

  Unknown = XR_OBJECT_TYPE_UNKNOWN,

  Instance = XR_OBJECT_TYPE_INSTANCE,

  Session = XR_OBJECT_TYPE_SESSION,

  Swapchain = XR_OBJECT_TYPE_SWAPCHAIN,

  Space = XR_OBJECT_TYPE_SPACE,

  ActionSet = XR_OBJECT_TYPE_ACTION_SET,

  Action = XR_OBJECT_TYPE_ACTION,

#ifdef XR_EXT_debug_utils
  DebugUtilsMessengerEXT = XR_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT,
#endif  // XR_EXT_debug_utils
#ifdef XR_MSFT_spatial_anchor
  SpatialAnchorMSFT = XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT,
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_spatial_graph_bridge
  SpatialGraphNodeBindingMSFT = XR_OBJECT_TYPE_SPATIAL_GRAPH_NODE_BINDING_MSFT,
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_EXT_hand_tracking
  HandTrackerEXT = XR_OBJECT_TYPE_HAND_TRACKER_EXT,
#endif  // XR_EXT_hand_tracking
#ifdef XR_FB_body_tracking
  BodyTrackerFB = XR_OBJECT_TYPE_BODY_TRACKER_FB,
#endif  // XR_FB_body_tracking
#ifdef XR_MSFT_scene_understanding
  SceneObserverMSFT = XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  SceneMSFT = XR_OBJECT_TYPE_SCENE_MSFT,
#endif  // XR_MSFT_scene_understanding
#ifdef XR_HTC_facial_tracking
  FacialTrackerHTC = XR_OBJECT_TYPE_FACIAL_TRACKER_HTC,
#endif  // XR_HTC_facial_tracking
#ifdef XR_FB_foveation
  FoveationProfileFB = XR_OBJECT_TYPE_FOVEATION_PROFILE_FB,
#endif  // XR_FB_foveation
#ifdef XR_FB_triangle_mesh
  TriangleMeshFB = XR_OBJECT_TYPE_TRIANGLE_MESH_FB,
#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_passthrough
  PassthroughFB = XR_OBJECT_TYPE_PASSTHROUGH_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  PassthroughLayerFB = XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB,
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  GeometryInstanceFB = XR_OBJECT_TYPE_GEOMETRY_INSTANCE_FB,
#endif  // XR_FB_passthrough
#ifdef XR_ML_marker_understanding
  MarkerDetectorML = XR_OBJECT_TYPE_MARKER_DETECTOR_ML,
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_localization_map
  ExportedLocalizationMapML = XR_OBJECT_TYPE_EXPORTED_LOCALIZATION_MAP_ML,
#endif  // XR_ML_localization_map
#ifdef dsaXR_ML_spatial_anchors_storage
  SpatialAnchorsStorageML = XR_OBJECT_TYPE_SPATIAL_ANCHORS_STORAGE_ML,
#endif  // XR_ML_spatial_anchors_storage
#ifdef XR_MSFT_spatial_anchor_persistence
  SpatialAnchorStoreConnectionMSFT = XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT,
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_FB_face_tracking
  FaceTrackerFB = XR_OBJECT_TYPE_FACE_TRACKER_FB,
#endif  // XR_FB_face_tracking
#ifdef XR_FB_eye_tracking_social
  EyeTrackerFB = XR_OBJECT_TYPE_EYE_TRACKER_FB,
#endif  // XR_FB_eye_tracking_social
#ifdef XR_META_virtual_keyboard
  VirtualKeyboardMETA = XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META,
#endif  // XR_META_virtual_keyboard
#ifdef XR_FB_spatial_entity_user
  SpaceUserFB = XR_OBJECT_TYPE_SPACE_USER_FB,
#endif  // XR_FB_spatial_entity_user
#ifdef XR_META_passthrough_color_lut
  PassthroughColorLutMETA = XR_OBJECT_TYPE_PASSTHROUGH_COLOR_LUT_META,
#endif  // XR_META_passthrough_color_lut
#ifdef XR_FB_face_tracking2
  FaceTracker2FB = XR_OBJECT_TYPE_FACE_TRACKER2_FB,
#endif  // XR_FB_face_tracking2
#ifdef XR_META_environment_depth
  EnvironmentDepthProviderMETA = XR_OBJECT_TYPE_ENVIRONMENT_DEPTH_PROVIDER_META,
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
  EnvironmentDepthSwapchainMETA = XR_OBJECT_TYPE_ENVIRONMENT_DEPTH_SWAPCHAIN_META,
#endif  // XR_META_environment_depth
#ifdef XR_EXT_render_model
  RenderModelEXT = XR_OBJECT_TYPE_RENDER_MODEL_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  RenderModelAssetEXT = XR_OBJECT_TYPE_RENDER_MODEL_ASSET_EXT,
#endif  // XR_EXT_render_model
#ifdef XR_HTC_passthrough
  PassthroughHTC = XR_OBJECT_TYPE_PASSTHROUGH_HTC,
#endif  // XR_HTC_passthrough
#ifdef XR_HTC_body_tracking
  BodyTrackerHTC = XR_OBJECT_TYPE_BODY_TRACKER_HTC,
#endif  // XR_HTC_body_tracking
#ifdef XR_BD_body_tracking
  BodyTrackerBD = XR_OBJECT_TYPE_BODY_TRACKER_BD,
#endif  // XR_BD_body_tracking
#ifdef XR_BD_spatial_sensing
  SenseDataProviderBD = XR_OBJECT_TYPE_SENSE_DATA_PROVIDER_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  SenseDataSnapshotBD = XR_OBJECT_TYPE_SENSE_DATA_SNAPSHOT_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  AnchorBD = XR_OBJECT_TYPE_ANCHOR_BD,
#endif  // XR_BD_spatial_sensing
#ifdef XR_EXT_plane_detection
  PlaneDetectorEXT = XR_OBJECT_TYPE_PLANE_DETECTOR_EXT,
#endif  // XR_EXT_plane_detection
#ifdef dsaXR_ML_world_mesh_detection
  WorldMeshDetectorML = XR_OBJECT_TYPE_WORLD_MESH_DETECTOR_ML,
#endif  // XR_ML_world_mesh_detection
#ifdef XR_ML_facial_expression
  FacialExpressionClientML = XR_OBJECT_TYPE_FACIAL_EXPRESSION_CLIENT_ML,
#endif  // XR_ML_facial_expression
#ifdef XR_EXT_spatial_entity
  SpatialEntityEXT = XR_OBJECT_TYPE_SPATIAL_ENTITY_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialContextEXT = XR_OBJECT_TYPE_SPATIAL_CONTEXT_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  SpatialSnapshotEXT = XR_OBJECT_TYPE_SPATIAL_SNAPSHOT_EXT,
#endif  // XR_EXT_spatial_entity
#ifdef dsaXR_EXT_spatial_persistence
  SpatialPersistenceContextEXT = XR_OBJECT_TYPE_SPATIAL_PERSISTENCE_CONTEXT_EXT,
#endif  // XR_EXT_spatial_persistence
};
static_assert(sizeof(ObjectType) == sizeof(XrObjectType),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrObjectType value from a ObjectType.
 *
 * @found_by_adl
 * @see ObjectType
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrObjectType get(ObjectType const& v) {
  return static_cast<XrObjectType>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrObjectType address from a ObjectType.
 *
 * @found_by_adl
 * @see ObjectType
 */
OPENXR_HPP_INLINE XrObjectType* put(ObjectType& v) { return reinterpret_cast<XrObjectType*>(&v); }

/*!
 * @brief Free function for retrieving the string name of a ObjectType value as a const char *.
 *
 * @found_by_adl
 * @see ObjectType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ObjectType value) {
  switch (value) {
    case ObjectType::Unknown:
      return "Unknown";

    case ObjectType::Instance:
      return "Instance";

    case ObjectType::Session:
      return "Session";

    case ObjectType::Swapchain:
      return "Swapchain";

    case ObjectType::Space:
      return "Space";

    case ObjectType::ActionSet:
      return "ActionSet";

    case ObjectType::Action:
      return "Action";

#ifdef XR_EXT_debug_utils
    case ObjectType::DebugUtilsMessengerEXT:
      return "DebugUtilsMessengerEXT";
#endif  // XR_EXT_debug_utils
#ifdef XR_MSFT_spatial_anchor
    case ObjectType::SpatialAnchorMSFT:
      return "SpatialAnchorMSFT";
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_spatial_graph_bridge
    case ObjectType::SpatialGraphNodeBindingMSFT:
      return "SpatialGraphNodeBindingMSFT";
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_EXT_hand_tracking
    case ObjectType::HandTrackerEXT:
      return "HandTrackerEXT";
#endif  // XR_EXT_hand_tracking
#ifdef XR_FB_body_tracking
    case ObjectType::BodyTrackerFB:
      return "BodyTrackerFB";
#endif  // XR_FB_body_tracking
#ifdef XR_MSFT_scene_understanding
    case ObjectType::SceneObserverMSFT:
      return "SceneObserverMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
    case ObjectType::SceneMSFT:
      return "SceneMSFT";
#endif  // XR_MSFT_scene_understanding
#ifdef XR_HTC_facial_tracking
    case ObjectType::FacialTrackerHTC:
      return "FacialTrackerHTC";
#endif  // XR_HTC_facial_tracking
#ifdef XR_FB_foveation
    case ObjectType::FoveationProfileFB:
      return "FoveationProfileFB";
#endif  // XR_FB_foveation
#ifdef XR_FB_triangle_mesh
    case ObjectType::TriangleMeshFB:
      return "TriangleMeshFB";
#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_passthrough
    case ObjectType::PassthroughFB:
      return "PassthroughFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case ObjectType::PassthroughLayerFB:
      return "PassthroughLayerFB";
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
    case ObjectType::GeometryInstanceFB:
      return "GeometryInstanceFB";
#endif  // XR_FB_passthrough
#ifdef XR_ML_marker_understanding
    case ObjectType::MarkerDetectorML:
      return "MarkerDetectorML";
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_localization_map
    case ObjectType::ExportedLocalizationMapML:
      return "ExportedLocalizationMapML";
#endif  // XR_ML_localization_map
#ifdef dsaXR_ML_spatial_anchors_storage
    case ObjectType::SpatialAnchorsStorageML:
      return "SpatialAnchorsStorageML";
#endif  // XR_ML_spatial_anchors_storage
#ifdef XR_MSFT_spatial_anchor_persistence
    case ObjectType::SpatialAnchorStoreConnectionMSFT:
      return "SpatialAnchorStoreConnectionMSFT";
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_FB_face_tracking
    case ObjectType::FaceTrackerFB:
      return "FaceTrackerFB";
#endif  // XR_FB_face_tracking
#ifdef XR_FB_eye_tracking_social
    case ObjectType::EyeTrackerFB:
      return "EyeTrackerFB";
#endif  // XR_FB_eye_tracking_social
#ifdef XR_META_virtual_keyboard
    case ObjectType::VirtualKeyboardMETA:
      return "VirtualKeyboardMETA";
#endif  // XR_META_virtual_keyboard
#ifdef XR_FB_spatial_entity_user
    case ObjectType::SpaceUserFB:
      return "SpaceUserFB";
#endif  // XR_FB_spatial_entity_user
#ifdef XR_META_passthrough_color_lut
    case ObjectType::PassthroughColorLutMETA:
      return "PassthroughColorLutMETA";
#endif  // XR_META_passthrough_color_lut
#ifdef XR_FB_face_tracking2
    case ObjectType::FaceTracker2FB:
      return "FaceTracker2FB";
#endif  // XR_FB_face_tracking2
#ifdef XR_META_environment_depth
    case ObjectType::EnvironmentDepthProviderMETA:
      return "EnvironmentDepthProviderMETA";
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
    case ObjectType::EnvironmentDepthSwapchainMETA:
      return "EnvironmentDepthSwapchainMETA";
#endif  // XR_META_environment_depth
#ifdef XR_EXT_render_model
    case ObjectType::RenderModelEXT:
      return "RenderModelEXT";
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
    case ObjectType::RenderModelAssetEXT:
      return "RenderModelAssetEXT";
#endif  // XR_EXT_render_model
#ifdef XR_HTC_passthrough
    case ObjectType::PassthroughHTC:
      return "PassthroughHTC";
#endif  // XR_HTC_passthrough
#ifdef XR_HTC_body_tracking
    case ObjectType::BodyTrackerHTC:
      return "BodyTrackerHTC";
#endif  // XR_HTC_body_tracking
#ifdef XR_BD_body_tracking
    case ObjectType::BodyTrackerBD:
      return "BodyTrackerBD";
#endif  // XR_BD_body_tracking
#ifdef XR_BD_spatial_sensing
    case ObjectType::SenseDataProviderBD:
      return "SenseDataProviderBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case ObjectType::SenseDataSnapshotBD:
      return "SenseDataSnapshotBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
    case ObjectType::AnchorBD:
      return "AnchorBD";
#endif  // XR_BD_spatial_sensing
#ifdef XR_EXT_plane_detection
    case ObjectType::PlaneDetectorEXT:
      return "PlaneDetectorEXT";
#endif  // XR_EXT_plane_detection
#ifdef dsaXR_ML_world_mesh_detection
    case ObjectType::WorldMeshDetectorML:
      return "WorldMeshDetectorML";
#endif  // XR_ML_world_mesh_detection
#ifdef XR_ML_facial_expression
    case ObjectType::FacialExpressionClientML:
      return "FacialExpressionClientML";
#endif  // XR_ML_facial_expression
#ifdef XR_EXT_spatial_entity
    case ObjectType::SpatialEntityEXT:
      return "SpatialEntityEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case ObjectType::SpatialContextEXT:
      return "SpatialContextEXT";
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
    case ObjectType::SpatialSnapshotEXT:
      return "SpatialSnapshotEXT";
#endif  // XR_EXT_spatial_entity
#ifdef dsaXR_EXT_spatial_persistence
    case ObjectType::SpatialPersistenceContextEXT:
      return "SpatialPersistenceContextEXT";
#endif  // XR_EXT_spatial_persistence
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ObjectType value as a std::string.
 *
 * @found_by_adl
 * @see ObjectType
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ObjectType value) {
  return {to_string_literal(value)};
}
//! @}

#ifdef XR_LOADER_VERSION_1_0
/*!
 * @brief Enum class for XrLoaderInterfaceStructs
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLoaderInterfaceStructs>
 *
 * @xrentity{XrLoaderInterfaceStructs}
 */
enum class LoaderInterfaceStructs {

  XrLoaderInterfaceStructUnintialized = XR_LOADER_INTERFACE_STRUCT_UNINTIALIZED,

  XrLoaderInterfaceStructLoaderInfo = XR_LOADER_INTERFACE_STRUCT_LOADER_INFO,

  XrLoaderInterfaceStructAPILayerRequest = XR_LOADER_INTERFACE_STRUCT_API_LAYER_REQUEST,

  XrLoaderInterfaceStructRuntimeRequest = XR_LOADER_INTERFACE_STRUCT_RUNTIME_REQUEST,

  XrLoaderInterfaceStructAPILayerCreateInfo = XR_LOADER_INTERFACE_STRUCT_API_LAYER_CREATE_INFO,

  XrLoaderInterfaceStructAPILayerNextInfo = XR_LOADER_INTERFACE_STRUCT_API_LAYER_NEXT_INFO,

};
static_assert(sizeof(LoaderInterfaceStructs) == sizeof(XrLoaderInterfaceStructs),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLoaderInterfaceStructs value from a
 * LoaderInterfaceStructs.
 *
 * @found_by_adl
 * @see LoaderInterfaceStructs
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrLoaderInterfaceStructs
get(LoaderInterfaceStructs const& v) {
  return static_cast<XrLoaderInterfaceStructs>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLoaderInterfaceStructs address from a
 * LoaderInterfaceStructs.
 *
 * @found_by_adl
 * @see LoaderInterfaceStructs
 */
OPENXR_HPP_INLINE XrLoaderInterfaceStructs* put(LoaderInterfaceStructs& v) {
  return reinterpret_cast<XrLoaderInterfaceStructs*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a LoaderInterfaceStructs value as a const
 * char *.
 *
 * @found_by_adl
 * @see LoaderInterfaceStructs
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    LoaderInterfaceStructs value) {
  switch (value) {
    case LoaderInterfaceStructs::XrLoaderInterfaceStructUnintialized:
      return "XrLoaderInterfaceStructUnintialized";

    case LoaderInterfaceStructs::XrLoaderInterfaceStructLoaderInfo:
      return "XrLoaderInterfaceStructLoaderInfo";

    case LoaderInterfaceStructs::XrLoaderInterfaceStructAPILayerRequest:
      return "XrLoaderInterfaceStructAPILayerRequest";

    case LoaderInterfaceStructs::XrLoaderInterfaceStructRuntimeRequest:
      return "XrLoaderInterfaceStructRuntimeRequest";

    case LoaderInterfaceStructs::XrLoaderInterfaceStructAPILayerCreateInfo:
      return "XrLoaderInterfaceStructAPILayerCreateInfo";

    case LoaderInterfaceStructs::XrLoaderInterfaceStructAPILayerNextInfo:
      return "XrLoaderInterfaceStructAPILayerNextInfo";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a LoaderInterfaceStructs value as a
 * std::string.
 *
 * @found_by_adl
 * @see LoaderInterfaceStructs
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(LoaderInterfaceStructs value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_LOADER_VERSION_1_0

#ifdef XR_KHR_android_thread_settings
#if defined(XR_USE_PLATFORM_ANDROID)
/*!
 * @brief Enum class for XrAndroidThreadTypeKHR
 *
 * Provided by the `XR_KHR_android_thread_settings` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrAndroidThreadTypeKHR>
 *
 * @xrentity{XrAndroidThreadTypeKHR}
 */
enum class AndroidThreadTypeKHR {

  ApplicationMain = XR_ANDROID_THREAD_TYPE_APPLICATION_MAIN_KHR,

  ApplicationWorker = XR_ANDROID_THREAD_TYPE_APPLICATION_WORKER_KHR,

  RendererMain = XR_ANDROID_THREAD_TYPE_RENDERER_MAIN_KHR,

  RendererWorker = XR_ANDROID_THREAD_TYPE_RENDERER_WORKER_KHR,

};
static_assert(sizeof(AndroidThreadTypeKHR) == sizeof(XrAndroidThreadTypeKHR),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrAndroidThreadTypeKHR value from a
 * AndroidThreadTypeKHR.
 *
 * @found_by_adl
 * @see AndroidThreadTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrAndroidThreadTypeKHR get(AndroidThreadTypeKHR const& v) {
  return static_cast<XrAndroidThreadTypeKHR>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrAndroidThreadTypeKHR address from a
 * AndroidThreadTypeKHR.
 *
 * @found_by_adl
 * @see AndroidThreadTypeKHR
 */
OPENXR_HPP_INLINE XrAndroidThreadTypeKHR* put(AndroidThreadTypeKHR& v) {
  return reinterpret_cast<XrAndroidThreadTypeKHR*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a AndroidThreadTypeKHR value as a const
 * char *.
 *
 * @found_by_adl
 * @see AndroidThreadTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    AndroidThreadTypeKHR value) {
  switch (value) {
    case AndroidThreadTypeKHR::ApplicationMain:
      return "ApplicationMain";

    case AndroidThreadTypeKHR::ApplicationWorker:
      return "ApplicationWorker";

    case AndroidThreadTypeKHR::RendererMain:
      return "RendererMain";

    case AndroidThreadTypeKHR::RendererWorker:
      return "RendererWorker";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a AndroidThreadTypeKHR value as a
 * std::string.
 *
 * @found_by_adl
 * @see AndroidThreadTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(AndroidThreadTypeKHR value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_thread_settings

#ifdef XR_KHR_visibility_mask
/*!
 * @brief Enum class for XrVisibilityMaskTypeKHR
 *
 * Provided by the `XR_KHR_visibility_mask` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVisibilityMaskTypeKHR>
 *
 * @xrentity{XrVisibilityMaskTypeKHR}
 */
enum class VisibilityMaskTypeKHR {

  HiddenTriangleMesh = XR_VISIBILITY_MASK_TYPE_HIDDEN_TRIANGLE_MESH_KHR,

  VisibleTriangleMesh = XR_VISIBILITY_MASK_TYPE_VISIBLE_TRIANGLE_MESH_KHR,

  LineLoop = XR_VISIBILITY_MASK_TYPE_LINE_LOOP_KHR,

};
static_assert(sizeof(VisibilityMaskTypeKHR) == sizeof(XrVisibilityMaskTypeKHR),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrVisibilityMaskTypeKHR value from a
 * VisibilityMaskTypeKHR.
 *
 * @found_by_adl
 * @see VisibilityMaskTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrVisibilityMaskTypeKHR get(VisibilityMaskTypeKHR const& v) {
  return static_cast<XrVisibilityMaskTypeKHR>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrVisibilityMaskTypeKHR address from a
 * VisibilityMaskTypeKHR.
 *
 * @found_by_adl
 * @see VisibilityMaskTypeKHR
 */
OPENXR_HPP_INLINE XrVisibilityMaskTypeKHR* put(VisibilityMaskTypeKHR& v) {
  return reinterpret_cast<XrVisibilityMaskTypeKHR*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a VisibilityMaskTypeKHR value as a const
 * char *.
 *
 * @found_by_adl
 * @see VisibilityMaskTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    VisibilityMaskTypeKHR value) {
  switch (value) {
    case VisibilityMaskTypeKHR::HiddenTriangleMesh:
      return "HiddenTriangleMesh";

    case VisibilityMaskTypeKHR::VisibleTriangleMesh:
      return "VisibleTriangleMesh";

    case VisibilityMaskTypeKHR::LineLoop:
      return "LineLoop";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a VisibilityMaskTypeKHR value as a
 * std::string.
 *
 * @found_by_adl
 * @see VisibilityMaskTypeKHR
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(VisibilityMaskTypeKHR value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_KHR_visibility_mask

#ifdef XR_EXT_performance_settings
/*!
 * @brief Enum class for XrPerfSettingsDomainEXT
 *
 * Provided by the `XR_EXT_performance_settings` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerfSettingsDomainEXT>
 *
 * @xrentity{XrPerfSettingsDomainEXT}
 */
enum class PerfSettingsDomainEXT {

  Cpu = XR_PERF_SETTINGS_DOMAIN_CPU_EXT,

  Gpu = XR_PERF_SETTINGS_DOMAIN_GPU_EXT,

};
static_assert(sizeof(PerfSettingsDomainEXT) == sizeof(XrPerfSettingsDomainEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsDomainEXT value from a
 * PerfSettingsDomainEXT.
 *
 * @found_by_adl
 * @see PerfSettingsDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerfSettingsDomainEXT get(PerfSettingsDomainEXT const& v) {
  return static_cast<XrPerfSettingsDomainEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsDomainEXT address from a
 * PerfSettingsDomainEXT.
 *
 * @found_by_adl
 * @see PerfSettingsDomainEXT
 */
OPENXR_HPP_INLINE XrPerfSettingsDomainEXT* put(PerfSettingsDomainEXT& v) {
  return reinterpret_cast<XrPerfSettingsDomainEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsDomainEXT value as a const
 * char *.
 *
 * @found_by_adl
 * @see PerfSettingsDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PerfSettingsDomainEXT value) {
  switch (value) {
    case PerfSettingsDomainEXT::Cpu:
      return "Cpu";

    case PerfSettingsDomainEXT::Gpu:
      return "Gpu";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsDomainEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see PerfSettingsDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PerfSettingsDomainEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_performance_settings
/*!
 * @brief Enum class for XrPerfSettingsSubDomainEXT
 *
 * Provided by the `XR_EXT_performance_settings` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerfSettingsSubDomainEXT>
 *
 * @xrentity{XrPerfSettingsSubDomainEXT}
 */
enum class PerfSettingsSubDomainEXT {

  Compositing = XR_PERF_SETTINGS_SUB_DOMAIN_COMPOSITING_EXT,

  Rendering = XR_PERF_SETTINGS_SUB_DOMAIN_RENDERING_EXT,

  Thermal = XR_PERF_SETTINGS_SUB_DOMAIN_THERMAL_EXT,

};
static_assert(sizeof(PerfSettingsSubDomainEXT) == sizeof(XrPerfSettingsSubDomainEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsSubDomainEXT value from a
 * PerfSettingsSubDomainEXT.
 *
 * @found_by_adl
 * @see PerfSettingsSubDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerfSettingsSubDomainEXT
get(PerfSettingsSubDomainEXT const& v) {
  return static_cast<XrPerfSettingsSubDomainEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsSubDomainEXT address from a
 * PerfSettingsSubDomainEXT.
 *
 * @found_by_adl
 * @see PerfSettingsSubDomainEXT
 */
OPENXR_HPP_INLINE XrPerfSettingsSubDomainEXT* put(PerfSettingsSubDomainEXT& v) {
  return reinterpret_cast<XrPerfSettingsSubDomainEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsSubDomainEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see PerfSettingsSubDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PerfSettingsSubDomainEXT value) {
  switch (value) {
    case PerfSettingsSubDomainEXT::Compositing:
      return "Compositing";

    case PerfSettingsSubDomainEXT::Rendering:
      return "Rendering";

    case PerfSettingsSubDomainEXT::Thermal:
      return "Thermal";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsSubDomainEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see PerfSettingsSubDomainEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    PerfSettingsSubDomainEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_performance_settings
/*!
 * @brief Enum class for XrPerfSettingsLevelEXT
 *
 * Provided by the `XR_EXT_performance_settings` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerfSettingsLevelEXT>
 *
 * @xrentity{XrPerfSettingsLevelEXT}
 */
enum class PerfSettingsLevelEXT {

  PowerSavings = XR_PERF_SETTINGS_LEVEL_POWER_SAVINGS_EXT,

  SustainedLow = XR_PERF_SETTINGS_LEVEL_SUSTAINED_LOW_EXT,

  SustainedHigh = XR_PERF_SETTINGS_LEVEL_SUSTAINED_HIGH_EXT,

  Boost = XR_PERF_SETTINGS_LEVEL_BOOST_EXT,

};
static_assert(sizeof(PerfSettingsLevelEXT) == sizeof(XrPerfSettingsLevelEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsLevelEXT value from a
 * PerfSettingsLevelEXT.
 *
 * @found_by_adl
 * @see PerfSettingsLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerfSettingsLevelEXT get(PerfSettingsLevelEXT const& v) {
  return static_cast<XrPerfSettingsLevelEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsLevelEXT address from a
 * PerfSettingsLevelEXT.
 *
 * @found_by_adl
 * @see PerfSettingsLevelEXT
 */
OPENXR_HPP_INLINE XrPerfSettingsLevelEXT* put(PerfSettingsLevelEXT& v) {
  return reinterpret_cast<XrPerfSettingsLevelEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsLevelEXT value as a const
 * char *.
 *
 * @found_by_adl
 * @see PerfSettingsLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PerfSettingsLevelEXT value) {
  switch (value) {
    case PerfSettingsLevelEXT::PowerSavings:
      return "PowerSavings";

    case PerfSettingsLevelEXT::SustainedLow:
      return "SustainedLow";

    case PerfSettingsLevelEXT::SustainedHigh:
      return "SustainedHigh";

    case PerfSettingsLevelEXT::Boost:
      return "Boost";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsLevelEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see PerfSettingsLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PerfSettingsLevelEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_performance_settings
/*!
 * @brief Enum class for XrPerfSettingsNotificationLevelEXT
 *
 * Provided by the `XR_EXT_performance_settings` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerfSettingsNotificationLevelEXT>
 *
 * @xrentity{XrPerfSettingsNotificationLevelEXT}
 */
enum class PerfSettingsNotificationLevelEXT {

  Normal = XR_PERF_SETTINGS_NOTIF_LEVEL_NORMAL_EXT,

  Warning = XR_PERF_SETTINGS_NOTIF_LEVEL_WARNING_EXT,

  Impaired = XR_PERF_SETTINGS_NOTIF_LEVEL_IMPAIRED_EXT,

};
static_assert(sizeof(PerfSettingsNotificationLevelEXT) ==
                  sizeof(XrPerfSettingsNotificationLevelEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsNotificationLevelEXT value from a
 * PerfSettingsNotificationLevelEXT.
 *
 * @found_by_adl
 * @see PerfSettingsNotificationLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerfSettingsNotificationLevelEXT
get(PerfSettingsNotificationLevelEXT const& v) {
  return static_cast<XrPerfSettingsNotificationLevelEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerfSettingsNotificationLevelEXT address from a
 * PerfSettingsNotificationLevelEXT.
 *
 * @found_by_adl
 * @see PerfSettingsNotificationLevelEXT
 */
OPENXR_HPP_INLINE XrPerfSettingsNotificationLevelEXT* put(PerfSettingsNotificationLevelEXT& v) {
  return reinterpret_cast<XrPerfSettingsNotificationLevelEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsNotificationLevelEXT value
 * as a const char *.
 *
 * @found_by_adl
 * @see PerfSettingsNotificationLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PerfSettingsNotificationLevelEXT value) {
  switch (value) {
    case PerfSettingsNotificationLevelEXT::Normal:
      return "Normal";

    case PerfSettingsNotificationLevelEXT::Warning:
      return "Warning";

    case PerfSettingsNotificationLevelEXT::Impaired:
      return "Impaired";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PerfSettingsNotificationLevelEXT value
 * as a std::string.
 *
 * @found_by_adl
 * @see PerfSettingsNotificationLevelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    PerfSettingsNotificationLevelEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_performance_settings

#ifdef XR_FB_composition_layer_alpha_blend
/*!
 * @brief Enum class for XrBlendFactorFB
 *
 * Provided by the `XR_FB_composition_layer_alpha_blend` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBlendFactorFB>
 *
 * @xrentity{XrBlendFactorFB}
 */
enum class BlendFactorFB {

  Zero = XR_BLEND_FACTOR_ZERO_FB,

  One = XR_BLEND_FACTOR_ONE_FB,

  SrcAlpha = XR_BLEND_FACTOR_SRC_ALPHA_FB,

  OneMinusSrcAlpha = XR_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA_FB,

  DstAlpha = XR_BLEND_FACTOR_DST_ALPHA_FB,

  OneMinusDstAlpha = XR_BLEND_FACTOR_ONE_MINUS_DST_ALPHA_FB,

};
static_assert(sizeof(BlendFactorFB) == sizeof(XrBlendFactorFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBlendFactorFB value from a BlendFactorFB.
 *
 * @found_by_adl
 * @see BlendFactorFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrBlendFactorFB get(BlendFactorFB const& v) {
  return static_cast<XrBlendFactorFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBlendFactorFB address from a BlendFactorFB.
 *
 * @found_by_adl
 * @see BlendFactorFB
 */
OPENXR_HPP_INLINE XrBlendFactorFB* put(BlendFactorFB& v) {
  return reinterpret_cast<XrBlendFactorFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a BlendFactorFB value as a const char *.
 *
 * @found_by_adl
 * @see BlendFactorFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(BlendFactorFB value) {
  switch (value) {
    case BlendFactorFB::Zero:
      return "Zero";

    case BlendFactorFB::One:
      return "One";

    case BlendFactorFB::SrcAlpha:
      return "SrcAlpha";

    case BlendFactorFB::OneMinusSrcAlpha:
      return "OneMinusSrcAlpha";

    case BlendFactorFB::DstAlpha:
      return "DstAlpha";

    case BlendFactorFB::OneMinusDstAlpha:
      return "OneMinusDstAlpha";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a BlendFactorFB value as a std::string.
 *
 * @found_by_adl
 * @see BlendFactorFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(BlendFactorFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_composition_layer_alpha_blend

#ifdef XR_MSFT_spatial_graph_bridge
/*!
 * @brief Enum class for XrSpatialGraphNodeTypeMSFT
 *
 * Provided by the `XR_MSFT_spatial_graph_bridge` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialGraphNodeTypeMSFT>
 *
 * @xrentity{XrSpatialGraphNodeTypeMSFT}
 */
enum class SpatialGraphNodeTypeMSFT {

  Static = XR_SPATIAL_GRAPH_NODE_TYPE_STATIC_MSFT,

  Dynamic = XR_SPATIAL_GRAPH_NODE_TYPE_DYNAMIC_MSFT,

};
static_assert(sizeof(SpatialGraphNodeTypeMSFT) == sizeof(XrSpatialGraphNodeTypeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialGraphNodeTypeMSFT value from a
 * SpatialGraphNodeTypeMSFT.
 *
 * @found_by_adl
 * @see SpatialGraphNodeTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialGraphNodeTypeMSFT
get(SpatialGraphNodeTypeMSFT const& v) {
  return static_cast<XrSpatialGraphNodeTypeMSFT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialGraphNodeTypeMSFT address from a
 * SpatialGraphNodeTypeMSFT.
 *
 * @found_by_adl
 * @see SpatialGraphNodeTypeMSFT
 */
OPENXR_HPP_INLINE XrSpatialGraphNodeTypeMSFT* put(SpatialGraphNodeTypeMSFT& v) {
  return reinterpret_cast<XrSpatialGraphNodeTypeMSFT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialGraphNodeTypeMSFT value as a
 * const char *.
 *
 * @found_by_adl
 * @see SpatialGraphNodeTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialGraphNodeTypeMSFT value) {
  switch (value) {
    case SpatialGraphNodeTypeMSFT::Static:
      return "Static";

    case SpatialGraphNodeTypeMSFT::Dynamic:
      return "Dynamic";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialGraphNodeTypeMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialGraphNodeTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SpatialGraphNodeTypeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_spatial_graph_bridge

#ifdef XR_EXT_hand_tracking
/*!
 * @brief Enum class for XrHandEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandEXT>
 *
 * @xrentity{XrHandEXT}
 */
enum class HandEXT {

  Left = XR_HAND_LEFT_EXT,

  Right = XR_HAND_RIGHT_EXT,

};
static_assert(sizeof(HandEXT) == sizeof(XrHandEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandEXT value from a HandEXT.
 *
 * @found_by_adl
 * @see HandEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandEXT get(HandEXT const& v) {
  return static_cast<XrHandEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandEXT address from a HandEXT.
 *
 * @found_by_adl
 * @see HandEXT
 */
OPENXR_HPP_INLINE XrHandEXT* put(HandEXT& v) { return reinterpret_cast<XrHandEXT*>(&v); }

/*!
 * @brief Free function for retrieving the string name of a HandEXT value as a const char *.
 *
 * @found_by_adl
 * @see HandEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandEXT value) {
  switch (value) {
    case HandEXT::Left:
      return "Left";

    case HandEXT::Right:
      return "Right";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HandEXT value as a std::string.
 *
 * @found_by_adl
 * @see HandEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * @brief Enum class for XrHandJointEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointEXT>
 *
 * @xrentity{XrHandJointEXT}
 */
enum class HandJointEXT {

  Palm = XR_HAND_JOINT_PALM_EXT,

  Wrist = XR_HAND_JOINT_WRIST_EXT,

  ThumbMetacarpal = XR_HAND_JOINT_THUMB_METACARPAL_EXT,

  ThumbProximal = XR_HAND_JOINT_THUMB_PROXIMAL_EXT,

  ThumbDistal = XR_HAND_JOINT_THUMB_DISTAL_EXT,

  ThumbTip = XR_HAND_JOINT_THUMB_TIP_EXT,

  IndexMetacarpal = XR_HAND_JOINT_INDEX_METACARPAL_EXT,

  IndexProximal = XR_HAND_JOINT_INDEX_PROXIMAL_EXT,

  IndexIntermediate = XR_HAND_JOINT_INDEX_INTERMEDIATE_EXT,

  IndexDistal = XR_HAND_JOINT_INDEX_DISTAL_EXT,

  IndexTip = XR_HAND_JOINT_INDEX_TIP_EXT,

  MiddleMetacarpal = XR_HAND_JOINT_MIDDLE_METACARPAL_EXT,

  MiddleProximal = XR_HAND_JOINT_MIDDLE_PROXIMAL_EXT,

  MiddleIntermediate = XR_HAND_JOINT_MIDDLE_INTERMEDIATE_EXT,

  MiddleDistal = XR_HAND_JOINT_MIDDLE_DISTAL_EXT,

  MiddleTip = XR_HAND_JOINT_MIDDLE_TIP_EXT,

  RingMetacarpal = XR_HAND_JOINT_RING_METACARPAL_EXT,

  RingProximal = XR_HAND_JOINT_RING_PROXIMAL_EXT,

  RingIntermediate = XR_HAND_JOINT_RING_INTERMEDIATE_EXT,

  RingDistal = XR_HAND_JOINT_RING_DISTAL_EXT,

  RingTip = XR_HAND_JOINT_RING_TIP_EXT,

  LittleMetacarpal = XR_HAND_JOINT_LITTLE_METACARPAL_EXT,

  LittleProximal = XR_HAND_JOINT_LITTLE_PROXIMAL_EXT,

  LittleIntermediate = XR_HAND_JOINT_LITTLE_INTERMEDIATE_EXT,

  LittleDistal = XR_HAND_JOINT_LITTLE_DISTAL_EXT,

  LittleTip = XR_HAND_JOINT_LITTLE_TIP_EXT,

};
static_assert(sizeof(HandJointEXT) == sizeof(XrHandJointEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandJointEXT value from a HandJointEXT.
 *
 * @found_by_adl
 * @see HandJointEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandJointEXT get(HandJointEXT const& v) {
  return static_cast<XrHandJointEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandJointEXT address from a HandJointEXT.
 *
 * @found_by_adl
 * @see HandJointEXT
 */
OPENXR_HPP_INLINE XrHandJointEXT* put(HandJointEXT& v) {
  return reinterpret_cast<XrHandJointEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a HandJointEXT value as a const char *.
 *
 * @found_by_adl
 * @see HandJointEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandJointEXT value) {
  switch (value) {
    case HandJointEXT::Palm:
      return "Palm";

    case HandJointEXT::Wrist:
      return "Wrist";

    case HandJointEXT::ThumbMetacarpal:
      return "ThumbMetacarpal";

    case HandJointEXT::ThumbProximal:
      return "ThumbProximal";

    case HandJointEXT::ThumbDistal:
      return "ThumbDistal";

    case HandJointEXT::ThumbTip:
      return "ThumbTip";

    case HandJointEXT::IndexMetacarpal:
      return "IndexMetacarpal";

    case HandJointEXT::IndexProximal:
      return "IndexProximal";

    case HandJointEXT::IndexIntermediate:
      return "IndexIntermediate";

    case HandJointEXT::IndexDistal:
      return "IndexDistal";

    case HandJointEXT::IndexTip:
      return "IndexTip";

    case HandJointEXT::MiddleMetacarpal:
      return "MiddleMetacarpal";

    case HandJointEXT::MiddleProximal:
      return "MiddleProximal";

    case HandJointEXT::MiddleIntermediate:
      return "MiddleIntermediate";

    case HandJointEXT::MiddleDistal:
      return "MiddleDistal";

    case HandJointEXT::MiddleTip:
      return "MiddleTip";

    case HandJointEXT::RingMetacarpal:
      return "RingMetacarpal";

    case HandJointEXT::RingProximal:
      return "RingProximal";

    case HandJointEXT::RingIntermediate:
      return "RingIntermediate";

    case HandJointEXT::RingDistal:
      return "RingDistal";

    case HandJointEXT::RingTip:
      return "RingTip";

    case HandJointEXT::LittleMetacarpal:
      return "LittleMetacarpal";

    case HandJointEXT::LittleProximal:
      return "LittleProximal";

    case HandJointEXT::LittleIntermediate:
      return "LittleIntermediate";

    case HandJointEXT::LittleDistal:
      return "LittleDistal";

    case HandJointEXT::LittleTip:
      return "LittleTip";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HandJointEXT value as a std::string.
 *
 * @found_by_adl
 * @see HandJointEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandJointEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * @brief Enum class for XrHandJointSetEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointSetEXT>
 *
 * @xrentity{XrHandJointSetEXT}
 */
enum class HandJointSetEXT {

  Default = XR_HAND_JOINT_SET_DEFAULT_EXT,

#ifdef XR_ULTRALEAP_hand_tracking_forearm
  HandWithForearmULTRALEAP = XR_HAND_JOINT_SET_HAND_WITH_FOREARM_ULTRALEAP,
#endif  // XR_ULTRALEAP_hand_tracking_forearm
};
static_assert(sizeof(HandJointSetEXT) == sizeof(XrHandJointSetEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandJointSetEXT value from a HandJointSetEXT.
 *
 * @found_by_adl
 * @see HandJointSetEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandJointSetEXT get(HandJointSetEXT const& v) {
  return static_cast<XrHandJointSetEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandJointSetEXT address from a HandJointSetEXT.
 *
 * @found_by_adl
 * @see HandJointSetEXT
 */
OPENXR_HPP_INLINE XrHandJointSetEXT* put(HandJointSetEXT& v) {
  return reinterpret_cast<XrHandJointSetEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a HandJointSetEXT value as a const char *.
 *
 * @found_by_adl
 * @see HandJointSetEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(HandJointSetEXT value) {
  switch (value) {
    case HandJointSetEXT::Default:
      return "Default";

#ifdef XR_ULTRALEAP_hand_tracking_forearm
    case HandJointSetEXT::HandWithForearmULTRALEAP:
      return "HandWithForearmULTRALEAP";
#endif  // XR_ULTRALEAP_hand_tracking_forearm
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HandJointSetEXT value as a std::string.
 *
 * @found_by_adl
 * @see HandJointSetEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandJointSetEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_tracking

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * @brief Enum class for XrHandPoseTypeMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandPoseTypeMSFT>
 *
 * @xrentity{XrHandPoseTypeMSFT}
 */
enum class HandPoseTypeMSFT {

  Tracked = XR_HAND_POSE_TYPE_TRACKED_MSFT,

  ReferenceOpenPalm = XR_HAND_POSE_TYPE_REFERENCE_OPEN_PALM_MSFT,

};
static_assert(sizeof(HandPoseTypeMSFT) == sizeof(XrHandPoseTypeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandPoseTypeMSFT value from a HandPoseTypeMSFT.
 *
 * @found_by_adl
 * @see HandPoseTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandPoseTypeMSFT get(HandPoseTypeMSFT const& v) {
  return static_cast<XrHandPoseTypeMSFT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandPoseTypeMSFT address from a HandPoseTypeMSFT.
 *
 * @found_by_adl
 * @see HandPoseTypeMSFT
 */
OPENXR_HPP_INLINE XrHandPoseTypeMSFT* put(HandPoseTypeMSFT& v) {
  return reinterpret_cast<XrHandPoseTypeMSFT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a HandPoseTypeMSFT value as a const char
 * *.
 *
 * @found_by_adl
 * @see HandPoseTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    HandPoseTypeMSFT value) {
  switch (value) {
    case HandPoseTypeMSFT::Tracked:
      return "Tracked";

    case HandPoseTypeMSFT::ReferenceOpenPalm:
      return "ReferenceOpenPalm";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HandPoseTypeMSFT value as a std::string.
 *
 * @found_by_adl
 * @see HandPoseTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HandPoseTypeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_composition_layer_reprojection
/*!
 * @brief Enum class for XrReprojectionModeMSFT
 *
 * Provided by the `XR_MSFT_composition_layer_reprojection` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrReprojectionModeMSFT>
 *
 * @xrentity{XrReprojectionModeMSFT}
 */
enum class ReprojectionModeMSFT {

  Depth = XR_REPROJECTION_MODE_DEPTH_MSFT,

  PlanarFromDepth = XR_REPROJECTION_MODE_PLANAR_FROM_DEPTH_MSFT,

  PlanarManual = XR_REPROJECTION_MODE_PLANAR_MANUAL_MSFT,

  OrientationOnly = XR_REPROJECTION_MODE_ORIENTATION_ONLY_MSFT,

};
static_assert(sizeof(ReprojectionModeMSFT) == sizeof(XrReprojectionModeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrReprojectionModeMSFT value from a
 * ReprojectionModeMSFT.
 *
 * @found_by_adl
 * @see ReprojectionModeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrReprojectionModeMSFT get(ReprojectionModeMSFT const& v) {
  return static_cast<XrReprojectionModeMSFT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrReprojectionModeMSFT address from a
 * ReprojectionModeMSFT.
 *
 * @found_by_adl
 * @see ReprojectionModeMSFT
 */
OPENXR_HPP_INLINE XrReprojectionModeMSFT* put(ReprojectionModeMSFT& v) {
  return reinterpret_cast<XrReprojectionModeMSFT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a ReprojectionModeMSFT value as a const
 * char *.
 *
 * @found_by_adl
 * @see ReprojectionModeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    ReprojectionModeMSFT value) {
  switch (value) {
    case ReprojectionModeMSFT::Depth:
      return "Depth";

    case ReprojectionModeMSFT::PlanarFromDepth:
      return "PlanarFromDepth";

    case ReprojectionModeMSFT::PlanarManual:
      return "PlanarManual";

    case ReprojectionModeMSFT::OrientationOnly:
      return "OrientationOnly";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ReprojectionModeMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see ReprojectionModeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ReprojectionModeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_composition_layer_reprojection

#ifdef XR_FB_body_tracking
/*!
 * @brief Enum class for XrBodyJointFB
 *
 * Provided by the `XR_FB_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointFB>
 *
 * @xrentity{XrBodyJointFB}
 */
enum class BodyJointFB {

  Root = XR_BODY_JOINT_ROOT_FB,

  Hips = XR_BODY_JOINT_HIPS_FB,

  SpineLower = XR_BODY_JOINT_SPINE_LOWER_FB,

  SpineMiddle = XR_BODY_JOINT_SPINE_MIDDLE_FB,

  SpineUpper = XR_BODY_JOINT_SPINE_UPPER_FB,

  Chest = XR_BODY_JOINT_CHEST_FB,

  Neck = XR_BODY_JOINT_NECK_FB,

  Head = XR_BODY_JOINT_HEAD_FB,

  LeftShoulder = XR_BODY_JOINT_LEFT_SHOULDER_FB,

  LeftScapula = XR_BODY_JOINT_LEFT_SCAPULA_FB,

  LeftArmUpper = XR_BODY_JOINT_LEFT_ARM_UPPER_FB,

  LeftArmLower = XR_BODY_JOINT_LEFT_ARM_LOWER_FB,

  LeftHandWristTwist = XR_BODY_JOINT_LEFT_HAND_WRIST_TWIST_FB,

  RightShoulder = XR_BODY_JOINT_RIGHT_SHOULDER_FB,

  RightScapula = XR_BODY_JOINT_RIGHT_SCAPULA_FB,

  RightArmUpper = XR_BODY_JOINT_RIGHT_ARM_UPPER_FB,

  RightArmLower = XR_BODY_JOINT_RIGHT_ARM_LOWER_FB,

  RightHandWristTwist = XR_BODY_JOINT_RIGHT_HAND_WRIST_TWIST_FB,

  LeftHandPalm = XR_BODY_JOINT_LEFT_HAND_PALM_FB,

  LeftHandWrist = XR_BODY_JOINT_LEFT_HAND_WRIST_FB,

  LeftHandThumbMetacarpal = XR_BODY_JOINT_LEFT_HAND_THUMB_METACARPAL_FB,

  LeftHandThumbProximal = XR_BODY_JOINT_LEFT_HAND_THUMB_PROXIMAL_FB,

  LeftHandThumbDistal = XR_BODY_JOINT_LEFT_HAND_THUMB_DISTAL_FB,

  LeftHandThumbTip = XR_BODY_JOINT_LEFT_HAND_THUMB_TIP_FB,

  LeftHandIndexMetacarpal = XR_BODY_JOINT_LEFT_HAND_INDEX_METACARPAL_FB,

  LeftHandIndexProximal = XR_BODY_JOINT_LEFT_HAND_INDEX_PROXIMAL_FB,

  LeftHandIndexIntermediate = XR_BODY_JOINT_LEFT_HAND_INDEX_INTERMEDIATE_FB,

  LeftHandIndexDistal = XR_BODY_JOINT_LEFT_HAND_INDEX_DISTAL_FB,

  LeftHandIndexTip = XR_BODY_JOINT_LEFT_HAND_INDEX_TIP_FB,

  LeftHandMiddleMetacarpal = XR_BODY_JOINT_LEFT_HAND_MIDDLE_METACARPAL_FB,

  LeftHandMiddleProximal = XR_BODY_JOINT_LEFT_HAND_MIDDLE_PROXIMAL_FB,

  LeftHandMiddleIntermediate = XR_BODY_JOINT_LEFT_HAND_MIDDLE_INTERMEDIATE_FB,

  LeftHandMiddleDistal = XR_BODY_JOINT_LEFT_HAND_MIDDLE_DISTAL_FB,

  LeftHandMiddleTip = XR_BODY_JOINT_LEFT_HAND_MIDDLE_TIP_FB,

  LeftHandRingMetacarpal = XR_BODY_JOINT_LEFT_HAND_RING_METACARPAL_FB,

  LeftHandRingProximal = XR_BODY_JOINT_LEFT_HAND_RING_PROXIMAL_FB,

  LeftHandRingIntermediate = XR_BODY_JOINT_LEFT_HAND_RING_INTERMEDIATE_FB,

  LeftHandRingDistal = XR_BODY_JOINT_LEFT_HAND_RING_DISTAL_FB,

  LeftHandRingTip = XR_BODY_JOINT_LEFT_HAND_RING_TIP_FB,

  LeftHandLittleMetacarpal = XR_BODY_JOINT_LEFT_HAND_LITTLE_METACARPAL_FB,

  LeftHandLittleProximal = XR_BODY_JOINT_LEFT_HAND_LITTLE_PROXIMAL_FB,

  LeftHandLittleIntermediate = XR_BODY_JOINT_LEFT_HAND_LITTLE_INTERMEDIATE_FB,

  LeftHandLittleDistal = XR_BODY_JOINT_LEFT_HAND_LITTLE_DISTAL_FB,

  LeftHandLittleTip = XR_BODY_JOINT_LEFT_HAND_LITTLE_TIP_FB,

  RightHandPalm = XR_BODY_JOINT_RIGHT_HAND_PALM_FB,

  RightHandWrist = XR_BODY_JOINT_RIGHT_HAND_WRIST_FB,

  RightHandThumbMetacarpal = XR_BODY_JOINT_RIGHT_HAND_THUMB_METACARPAL_FB,

  RightHandThumbProximal = XR_BODY_JOINT_RIGHT_HAND_THUMB_PROXIMAL_FB,

  RightHandThumbDistal = XR_BODY_JOINT_RIGHT_HAND_THUMB_DISTAL_FB,

  RightHandThumbTip = XR_BODY_JOINT_RIGHT_HAND_THUMB_TIP_FB,

  RightHandIndexMetacarpal = XR_BODY_JOINT_RIGHT_HAND_INDEX_METACARPAL_FB,

  RightHandIndexProximal = XR_BODY_JOINT_RIGHT_HAND_INDEX_PROXIMAL_FB,

  RightHandIndexIntermediate = XR_BODY_JOINT_RIGHT_HAND_INDEX_INTERMEDIATE_FB,

  RightHandIndexDistal = XR_BODY_JOINT_RIGHT_HAND_INDEX_DISTAL_FB,

  RightHandIndexTip = XR_BODY_JOINT_RIGHT_HAND_INDEX_TIP_FB,

  RightHandMiddleMetacarpal = XR_BODY_JOINT_RIGHT_HAND_MIDDLE_METACARPAL_FB,

  RightHandMiddleProximal = XR_BODY_JOINT_RIGHT_HAND_MIDDLE_PROXIMAL_FB,

  RightHandMiddleIntermediate = XR_BODY_JOINT_RIGHT_HAND_MIDDLE_INTERMEDIATE_FB,

  RightHandMiddleDistal = XR_BODY_JOINT_RIGHT_HAND_MIDDLE_DISTAL_FB,

  RightHandMiddleTip = XR_BODY_JOINT_RIGHT_HAND_MIDDLE_TIP_FB,

  RightHandRingMetacarpal = XR_BODY_JOINT_RIGHT_HAND_RING_METACARPAL_FB,

  RightHandRingProximal = XR_BODY_JOINT_RIGHT_HAND_RING_PROXIMAL_FB,

  RightHandRingIntermediate = XR_BODY_JOINT_RIGHT_HAND_RING_INTERMEDIATE_FB,

  RightHandRingDistal = XR_BODY_JOINT_RIGHT_HAND_RING_DISTAL_FB,

  RightHandRingTip = XR_BODY_JOINT_RIGHT_HAND_RING_TIP_FB,

  RightHandLittleMetacarpal = XR_BODY_JOINT_RIGHT_HAND_LITTLE_METACARPAL_FB,

  RightHandLittleProximal = XR_BODY_JOINT_RIGHT_HAND_LITTLE_PROXIMAL_FB,

  RightHandLittleIntermediate = XR_BODY_JOINT_RIGHT_HAND_LITTLE_INTERMEDIATE_FB,

  RightHandLittleDistal = XR_BODY_JOINT_RIGHT_HAND_LITTLE_DISTAL_FB,

  RightHandLittleTip = XR_BODY_JOINT_RIGHT_HAND_LITTLE_TIP_FB,

  Count = XR_BODY_JOINT_COUNT_FB,

  None = XR_BODY_JOINT_NONE_FB,

};
static_assert(sizeof(BodyJointFB) == sizeof(XrBodyJointFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointFB value from a BodyJointFB.
 *
 * @found_by_adl
 * @see BodyJointFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrBodyJointFB get(BodyJointFB const& v) {
  return static_cast<XrBodyJointFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointFB address from a BodyJointFB.
 *
 * @found_by_adl
 * @see BodyJointFB
 */
OPENXR_HPP_INLINE XrBodyJointFB* put(BodyJointFB& v) {
  return reinterpret_cast<XrBodyJointFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointFB value as a const char *.
 *
 * @found_by_adl
 * @see BodyJointFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(BodyJointFB value) {
  switch (value) {
    case BodyJointFB::Root:
      return "Root";

    case BodyJointFB::Hips:
      return "Hips";

    case BodyJointFB::SpineLower:
      return "SpineLower";

    case BodyJointFB::SpineMiddle:
      return "SpineMiddle";

    case BodyJointFB::SpineUpper:
      return "SpineUpper";

    case BodyJointFB::Chest:
      return "Chest";

    case BodyJointFB::Neck:
      return "Neck";

    case BodyJointFB::Head:
      return "Head";

    case BodyJointFB::LeftShoulder:
      return "LeftShoulder";

    case BodyJointFB::LeftScapula:
      return "LeftScapula";

    case BodyJointFB::LeftArmUpper:
      return "LeftArmUpper";

    case BodyJointFB::LeftArmLower:
      return "LeftArmLower";

    case BodyJointFB::LeftHandWristTwist:
      return "LeftHandWristTwist";

    case BodyJointFB::RightShoulder:
      return "RightShoulder";

    case BodyJointFB::RightScapula:
      return "RightScapula";

    case BodyJointFB::RightArmUpper:
      return "RightArmUpper";

    case BodyJointFB::RightArmLower:
      return "RightArmLower";

    case BodyJointFB::RightHandWristTwist:
      return "RightHandWristTwist";

    case BodyJointFB::LeftHandPalm:
      return "LeftHandPalm";

    case BodyJointFB::LeftHandWrist:
      return "LeftHandWrist";

    case BodyJointFB::LeftHandThumbMetacarpal:
      return "LeftHandThumbMetacarpal";

    case BodyJointFB::LeftHandThumbProximal:
      return "LeftHandThumbProximal";

    case BodyJointFB::LeftHandThumbDistal:
      return "LeftHandThumbDistal";

    case BodyJointFB::LeftHandThumbTip:
      return "LeftHandThumbTip";

    case BodyJointFB::LeftHandIndexMetacarpal:
      return "LeftHandIndexMetacarpal";

    case BodyJointFB::LeftHandIndexProximal:
      return "LeftHandIndexProximal";

    case BodyJointFB::LeftHandIndexIntermediate:
      return "LeftHandIndexIntermediate";

    case BodyJointFB::LeftHandIndexDistal:
      return "LeftHandIndexDistal";

    case BodyJointFB::LeftHandIndexTip:
      return "LeftHandIndexTip";

    case BodyJointFB::LeftHandMiddleMetacarpal:
      return "LeftHandMiddleMetacarpal";

    case BodyJointFB::LeftHandMiddleProximal:
      return "LeftHandMiddleProximal";

    case BodyJointFB::LeftHandMiddleIntermediate:
      return "LeftHandMiddleIntermediate";

    case BodyJointFB::LeftHandMiddleDistal:
      return "LeftHandMiddleDistal";

    case BodyJointFB::LeftHandMiddleTip:
      return "LeftHandMiddleTip";

    case BodyJointFB::LeftHandRingMetacarpal:
      return "LeftHandRingMetacarpal";

    case BodyJointFB::LeftHandRingProximal:
      return "LeftHandRingProximal";

    case BodyJointFB::LeftHandRingIntermediate:
      return "LeftHandRingIntermediate";

    case BodyJointFB::LeftHandRingDistal:
      return "LeftHandRingDistal";

    case BodyJointFB::LeftHandRingTip:
      return "LeftHandRingTip";

    case BodyJointFB::LeftHandLittleMetacarpal:
      return "LeftHandLittleMetacarpal";

    case BodyJointFB::LeftHandLittleProximal:
      return "LeftHandLittleProximal";

    case BodyJointFB::LeftHandLittleIntermediate:
      return "LeftHandLittleIntermediate";

    case BodyJointFB::LeftHandLittleDistal:
      return "LeftHandLittleDistal";

    case BodyJointFB::LeftHandLittleTip:
      return "LeftHandLittleTip";

    case BodyJointFB::RightHandPalm:
      return "RightHandPalm";

    case BodyJointFB::RightHandWrist:
      return "RightHandWrist";

    case BodyJointFB::RightHandThumbMetacarpal:
      return "RightHandThumbMetacarpal";

    case BodyJointFB::RightHandThumbProximal:
      return "RightHandThumbProximal";

    case BodyJointFB::RightHandThumbDistal:
      return "RightHandThumbDistal";

    case BodyJointFB::RightHandThumbTip:
      return "RightHandThumbTip";

    case BodyJointFB::RightHandIndexMetacarpal:
      return "RightHandIndexMetacarpal";

    case BodyJointFB::RightHandIndexProximal:
      return "RightHandIndexProximal";

    case BodyJointFB::RightHandIndexIntermediate:
      return "RightHandIndexIntermediate";

    case BodyJointFB::RightHandIndexDistal:
      return "RightHandIndexDistal";

    case BodyJointFB::RightHandIndexTip:
      return "RightHandIndexTip";

    case BodyJointFB::RightHandMiddleMetacarpal:
      return "RightHandMiddleMetacarpal";

    case BodyJointFB::RightHandMiddleProximal:
      return "RightHandMiddleProximal";

    case BodyJointFB::RightHandMiddleIntermediate:
      return "RightHandMiddleIntermediate";

    case BodyJointFB::RightHandMiddleDistal:
      return "RightHandMiddleDistal";

    case BodyJointFB::RightHandMiddleTip:
      return "RightHandMiddleTip";

    case BodyJointFB::RightHandRingMetacarpal:
      return "RightHandRingMetacarpal";

    case BodyJointFB::RightHandRingProximal:
      return "RightHandRingProximal";

    case BodyJointFB::RightHandRingIntermediate:
      return "RightHandRingIntermediate";

    case BodyJointFB::RightHandRingDistal:
      return "RightHandRingDistal";

    case BodyJointFB::RightHandRingTip:
      return "RightHandRingTip";

    case BodyJointFB::RightHandLittleMetacarpal:
      return "RightHandLittleMetacarpal";

    case BodyJointFB::RightHandLittleProximal:
      return "RightHandLittleProximal";

    case BodyJointFB::RightHandLittleIntermediate:
      return "RightHandLittleIntermediate";

    case BodyJointFB::RightHandLittleDistal:
      return "RightHandLittleDistal";

    case BodyJointFB::RightHandLittleTip:
      return "RightHandLittleTip";

    case BodyJointFB::Count:
      return "Count";

    case BodyJointFB::None:
      return "None";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointFB value as a std::string.
 *
 * @found_by_adl
 * @see BodyJointFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(BodyJointFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_body_tracking

#ifdef XR_FB_body_tracking
/*!
 * @brief Enum class for XrBodyJointSetFB
 *
 * Provided by the `XR_FB_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointSetFB>
 *
 * @xrentity{XrBodyJointSetFB}
 */
enum class BodyJointSetFB {

  Default = XR_BODY_JOINT_SET_DEFAULT_FB,

#ifdef XR_META_body_tracking_full_body
  FullBodyMETA = XR_BODY_JOINT_SET_FULL_BODY_META,
#endif  // XR_META_body_tracking_full_body
};
static_assert(sizeof(BodyJointSetFB) == sizeof(XrBodyJointSetFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointSetFB value from a BodyJointSetFB.
 *
 * @found_by_adl
 * @see BodyJointSetFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrBodyJointSetFB get(BodyJointSetFB const& v) {
  return static_cast<XrBodyJointSetFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointSetFB address from a BodyJointSetFB.
 *
 * @found_by_adl
 * @see BodyJointSetFB
 */
OPENXR_HPP_INLINE XrBodyJointSetFB* put(BodyJointSetFB& v) {
  return reinterpret_cast<XrBodyJointSetFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointSetFB value as a const char *.
 *
 * @found_by_adl
 * @see BodyJointSetFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(BodyJointSetFB value) {
  switch (value) {
    case BodyJointSetFB::Default:
      return "Default";

#ifdef XR_META_body_tracking_full_body
    case BodyJointSetFB::FullBodyMETA:
      return "FullBodyMETA";
#endif  // XR_META_body_tracking_full_body
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointSetFB value as a std::string.
 *
 * @found_by_adl
 * @see BodyJointSetFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(BodyJointSetFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_body_tracking

#ifdef XR_EXT_hand_joints_motion_range
/*!
 * @brief Enum class for XrHandJointsMotionRangeEXT
 *
 * Provided by the `XR_EXT_hand_joints_motion_range` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointsMotionRangeEXT>
 *
 * @xrentity{XrHandJointsMotionRangeEXT}
 */
enum class HandJointsMotionRangeEXT {

  Unobstructed = XR_HAND_JOINTS_MOTION_RANGE_UNOBSTRUCTED_EXT,

  ConformingToController = XR_HAND_JOINTS_MOTION_RANGE_CONFORMING_TO_CONTROLLER_EXT,

};
static_assert(sizeof(HandJointsMotionRangeEXT) == sizeof(XrHandJointsMotionRangeEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandJointsMotionRangeEXT value from a
 * HandJointsMotionRangeEXT.
 *
 * @found_by_adl
 * @see HandJointsMotionRangeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandJointsMotionRangeEXT
get(HandJointsMotionRangeEXT const& v) {
  return static_cast<XrHandJointsMotionRangeEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandJointsMotionRangeEXT address from a
 * HandJointsMotionRangeEXT.
 *
 * @found_by_adl
 * @see HandJointsMotionRangeEXT
 */
OPENXR_HPP_INLINE XrHandJointsMotionRangeEXT* put(HandJointsMotionRangeEXT& v) {
  return reinterpret_cast<XrHandJointsMotionRangeEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a HandJointsMotionRangeEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see HandJointsMotionRangeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    HandJointsMotionRangeEXT value) {
  switch (value) {
    case HandJointsMotionRangeEXT::Unobstructed:
      return "Unobstructed";

    case HandJointsMotionRangeEXT::ConformingToController:
      return "ConformingToController";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HandJointsMotionRangeEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see HandJointsMotionRangeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    HandJointsMotionRangeEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_joints_motion_range

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrSceneComputeFeatureMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComputeFeatureMSFT>
 *
 * @xrentity{XrSceneComputeFeatureMSFT}
 */
enum class SceneComputeFeatureMSFT {

  Plane = XR_SCENE_COMPUTE_FEATURE_PLANE_MSFT,

  PlaneMesh = XR_SCENE_COMPUTE_FEATURE_PLANE_MESH_MSFT,

  VisualMesh = XR_SCENE_COMPUTE_FEATURE_VISUAL_MESH_MSFT,

  ColliderMesh = XR_SCENE_COMPUTE_FEATURE_COLLIDER_MESH_MSFT,

#ifdef XR_MSFT_scene_understanding_serialization
  SerializeScene = XR_SCENE_COMPUTE_FEATURE_SERIALIZE_SCENE_MSFT,
#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_MSFT_scene_marker
  Marker = XR_SCENE_COMPUTE_FEATURE_MARKER_MSFT,
#endif  // XR_MSFT_scene_marker
};
static_assert(sizeof(SceneComputeFeatureMSFT) == sizeof(XrSceneComputeFeatureMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneComputeFeatureMSFT value from a
 * SceneComputeFeatureMSFT.
 *
 * @found_by_adl
 * @see SceneComputeFeatureMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneComputeFeatureMSFT
get(SceneComputeFeatureMSFT const& v) {
  return static_cast<XrSceneComputeFeatureMSFT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneComputeFeatureMSFT address from a
 * SceneComputeFeatureMSFT.
 *
 * @found_by_adl
 * @see SceneComputeFeatureMSFT
 */
OPENXR_HPP_INLINE XrSceneComputeFeatureMSFT* put(SceneComputeFeatureMSFT& v) {
  return reinterpret_cast<XrSceneComputeFeatureMSFT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneComputeFeatureMSFT value as a const
 * char *.
 *
 * @found_by_adl
 * @see SceneComputeFeatureMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SceneComputeFeatureMSFT value) {
  switch (value) {
    case SceneComputeFeatureMSFT::Plane:
      return "Plane";

    case SceneComputeFeatureMSFT::PlaneMesh:
      return "PlaneMesh";

    case SceneComputeFeatureMSFT::VisualMesh:
      return "VisualMesh";

    case SceneComputeFeatureMSFT::ColliderMesh:
      return "ColliderMesh";

#ifdef XR_MSFT_scene_understanding_serialization
    case SceneComputeFeatureMSFT::SerializeScene:
      return "SerializeScene";
#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_MSFT_scene_marker
    case SceneComputeFeatureMSFT::Marker:
      return "Marker";
#endif  // XR_MSFT_scene_marker
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SceneComputeFeatureMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SceneComputeFeatureMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SceneComputeFeatureMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrSceneComputeConsistencyMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComputeConsistencyMSFT>
 *
 * @xrentity{XrSceneComputeConsistencyMSFT}
 */
enum class SceneComputeConsistencyMSFT {

  SnapshotComplete = XR_SCENE_COMPUTE_CONSISTENCY_SNAPSHOT_COMPLETE_MSFT,

  SnapshotIncompleteFast = XR_SCENE_COMPUTE_CONSISTENCY_SNAPSHOT_INCOMPLETE_FAST_MSFT,

  OcclusionOptimized = XR_SCENE_COMPUTE_CONSISTENCY_OCCLUSION_OPTIMIZED_MSFT,

};
static_assert(sizeof(SceneComputeConsistencyMSFT) == sizeof(XrSceneComputeConsistencyMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneComputeConsistencyMSFT value from a
 * SceneComputeConsistencyMSFT.
 *
 * @found_by_adl
 * @see SceneComputeConsistencyMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneComputeConsistencyMSFT
get(SceneComputeConsistencyMSFT const& v) {
  return static_cast<XrSceneComputeConsistencyMSFT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneComputeConsistencyMSFT address from a
 * SceneComputeConsistencyMSFT.
 *
 * @found_by_adl
 * @see SceneComputeConsistencyMSFT
 */
OPENXR_HPP_INLINE XrSceneComputeConsistencyMSFT* put(SceneComputeConsistencyMSFT& v) {
  return reinterpret_cast<XrSceneComputeConsistencyMSFT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneComputeConsistencyMSFT value as a
 * const char *.
 *
 * @found_by_adl
 * @see SceneComputeConsistencyMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SceneComputeConsistencyMSFT value) {
  switch (value) {
    case SceneComputeConsistencyMSFT::SnapshotComplete:
      return "SnapshotComplete";

    case SceneComputeConsistencyMSFT::SnapshotIncompleteFast:
      return "SnapshotIncompleteFast";

    case SceneComputeConsistencyMSFT::OcclusionOptimized:
      return "OcclusionOptimized";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SceneComputeConsistencyMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SceneComputeConsistencyMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SceneComputeConsistencyMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrMeshComputeLodMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMeshComputeLodMSFT>
 *
 * @xrentity{XrMeshComputeLodMSFT}
 */
enum class MeshComputeLodMSFT {

  Coarse = XR_MESH_COMPUTE_LOD_COARSE_MSFT,

  Medium = XR_MESH_COMPUTE_LOD_MEDIUM_MSFT,

  Fine = XR_MESH_COMPUTE_LOD_FINE_MSFT,

  Unlimited = XR_MESH_COMPUTE_LOD_UNLIMITED_MSFT,

};
static_assert(sizeof(MeshComputeLodMSFT) == sizeof(XrMeshComputeLodMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMeshComputeLodMSFT value from a MeshComputeLodMSFT.
 *
 * @found_by_adl
 * @see MeshComputeLodMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrMeshComputeLodMSFT get(MeshComputeLodMSFT const& v) {
  return static_cast<XrMeshComputeLodMSFT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMeshComputeLodMSFT address from a
 * MeshComputeLodMSFT.
 *
 * @found_by_adl
 * @see MeshComputeLodMSFT
 */
OPENXR_HPP_INLINE XrMeshComputeLodMSFT* put(MeshComputeLodMSFT& v) {
  return reinterpret_cast<XrMeshComputeLodMSFT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a MeshComputeLodMSFT value as a const char
 * *.
 *
 * @found_by_adl
 * @see MeshComputeLodMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    MeshComputeLodMSFT value) {
  switch (value) {
    case MeshComputeLodMSFT::Coarse:
      return "Coarse";

    case MeshComputeLodMSFT::Medium:
      return "Medium";

    case MeshComputeLodMSFT::Fine:
      return "Fine";

    case MeshComputeLodMSFT::Unlimited:
      return "Unlimited";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a MeshComputeLodMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see MeshComputeLodMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(MeshComputeLodMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrSceneComponentTypeMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentTypeMSFT>
 *
 * @xrentity{XrSceneComponentTypeMSFT}
 */
enum class SceneComponentTypeMSFT {

  Invalid = XR_SCENE_COMPONENT_TYPE_INVALID_MSFT,

  Object = XR_SCENE_COMPONENT_TYPE_OBJECT_MSFT,

  Plane = XR_SCENE_COMPONENT_TYPE_PLANE_MSFT,

  VisualMesh = XR_SCENE_COMPONENT_TYPE_VISUAL_MESH_MSFT,

  ColliderMesh = XR_SCENE_COMPONENT_TYPE_COLLIDER_MESH_MSFT,

#ifdef XR_MSFT_scene_understanding_serialization
  SerializedSceneFragment = XR_SCENE_COMPONENT_TYPE_SERIALIZED_SCENE_FRAGMENT_MSFT,
#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_MSFT_scene_marker
  Marker = XR_SCENE_COMPONENT_TYPE_MARKER_MSFT,
#endif  // XR_MSFT_scene_marker
};
static_assert(sizeof(SceneComponentTypeMSFT) == sizeof(XrSceneComponentTypeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneComponentTypeMSFT value from a
 * SceneComponentTypeMSFT.
 *
 * @found_by_adl
 * @see SceneComponentTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneComponentTypeMSFT
get(SceneComponentTypeMSFT const& v) {
  return static_cast<XrSceneComponentTypeMSFT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneComponentTypeMSFT address from a
 * SceneComponentTypeMSFT.
 *
 * @found_by_adl
 * @see SceneComponentTypeMSFT
 */
OPENXR_HPP_INLINE XrSceneComponentTypeMSFT* put(SceneComponentTypeMSFT& v) {
  return reinterpret_cast<XrSceneComponentTypeMSFT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneComponentTypeMSFT value as a const
 * char *.
 *
 * @found_by_adl
 * @see SceneComponentTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SceneComponentTypeMSFT value) {
  switch (value) {
    case SceneComponentTypeMSFT::Invalid:
      return "Invalid";

    case SceneComponentTypeMSFT::Object:
      return "Object";

    case SceneComponentTypeMSFT::Plane:
      return "Plane";

    case SceneComponentTypeMSFT::VisualMesh:
      return "VisualMesh";

    case SceneComponentTypeMSFT::ColliderMesh:
      return "ColliderMesh";

#ifdef XR_MSFT_scene_understanding_serialization
    case SceneComponentTypeMSFT::SerializedSceneFragment:
      return "SerializedSceneFragment";
#endif  // XR_MSFT_scene_understanding_serialization
#ifdef XR_MSFT_scene_marker
    case SceneComponentTypeMSFT::Marker:
      return "Marker";
#endif  // XR_MSFT_scene_marker
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SceneComponentTypeMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SceneComponentTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SceneComponentTypeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrSceneObjectTypeMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneObjectTypeMSFT>
 *
 * @xrentity{XrSceneObjectTypeMSFT}
 */
enum class SceneObjectTypeMSFT {

  Uncategorized = XR_SCENE_OBJECT_TYPE_UNCATEGORIZED_MSFT,

  Background = XR_SCENE_OBJECT_TYPE_BACKGROUND_MSFT,

  Wall = XR_SCENE_OBJECT_TYPE_WALL_MSFT,

  Floor = XR_SCENE_OBJECT_TYPE_FLOOR_MSFT,

  Ceiling = XR_SCENE_OBJECT_TYPE_CEILING_MSFT,

  Platform = XR_SCENE_OBJECT_TYPE_PLATFORM_MSFT,

  Inferred = XR_SCENE_OBJECT_TYPE_INFERRED_MSFT,

};
static_assert(sizeof(SceneObjectTypeMSFT) == sizeof(XrSceneObjectTypeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneObjectTypeMSFT value from a
 * SceneObjectTypeMSFT.
 *
 * @found_by_adl
 * @see SceneObjectTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneObjectTypeMSFT get(SceneObjectTypeMSFT const& v) {
  return static_cast<XrSceneObjectTypeMSFT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneObjectTypeMSFT address from a
 * SceneObjectTypeMSFT.
 *
 * @found_by_adl
 * @see SceneObjectTypeMSFT
 */
OPENXR_HPP_INLINE XrSceneObjectTypeMSFT* put(SceneObjectTypeMSFT& v) {
  return reinterpret_cast<XrSceneObjectTypeMSFT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneObjectTypeMSFT value as a const
 * char *.
 *
 * @found_by_adl
 * @see SceneObjectTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SceneObjectTypeMSFT value) {
  switch (value) {
    case SceneObjectTypeMSFT::Uncategorized:
      return "Uncategorized";

    case SceneObjectTypeMSFT::Background:
      return "Background";

    case SceneObjectTypeMSFT::Wall:
      return "Wall";

    case SceneObjectTypeMSFT::Floor:
      return "Floor";

    case SceneObjectTypeMSFT::Ceiling:
      return "Ceiling";

    case SceneObjectTypeMSFT::Platform:
      return "Platform";

    case SceneObjectTypeMSFT::Inferred:
      return "Inferred";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SceneObjectTypeMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SceneObjectTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SceneObjectTypeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrScenePlaneAlignmentTypeMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrScenePlaneAlignmentTypeMSFT>
 *
 * @xrentity{XrScenePlaneAlignmentTypeMSFT}
 */
enum class ScenePlaneAlignmentTypeMSFT {

  NonOrthogonal = XR_SCENE_PLANE_ALIGNMENT_TYPE_NON_ORTHOGONAL_MSFT,

  Horizontal = XR_SCENE_PLANE_ALIGNMENT_TYPE_HORIZONTAL_MSFT,

  Vertical = XR_SCENE_PLANE_ALIGNMENT_TYPE_VERTICAL_MSFT,

};
static_assert(sizeof(ScenePlaneAlignmentTypeMSFT) == sizeof(XrScenePlaneAlignmentTypeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrScenePlaneAlignmentTypeMSFT value from a
 * ScenePlaneAlignmentTypeMSFT.
 *
 * @found_by_adl
 * @see ScenePlaneAlignmentTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrScenePlaneAlignmentTypeMSFT
get(ScenePlaneAlignmentTypeMSFT const& v) {
  return static_cast<XrScenePlaneAlignmentTypeMSFT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrScenePlaneAlignmentTypeMSFT address from a
 * ScenePlaneAlignmentTypeMSFT.
 *
 * @found_by_adl
 * @see ScenePlaneAlignmentTypeMSFT
 */
OPENXR_HPP_INLINE XrScenePlaneAlignmentTypeMSFT* put(ScenePlaneAlignmentTypeMSFT& v) {
  return reinterpret_cast<XrScenePlaneAlignmentTypeMSFT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a ScenePlaneAlignmentTypeMSFT value as a
 * const char *.
 *
 * @found_by_adl
 * @see ScenePlaneAlignmentTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    ScenePlaneAlignmentTypeMSFT value) {
  switch (value) {
    case ScenePlaneAlignmentTypeMSFT::NonOrthogonal:
      return "NonOrthogonal";

    case ScenePlaneAlignmentTypeMSFT::Horizontal:
      return "Horizontal";

    case ScenePlaneAlignmentTypeMSFT::Vertical:
      return "Vertical";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ScenePlaneAlignmentTypeMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see ScenePlaneAlignmentTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    ScenePlaneAlignmentTypeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * @brief Enum class for XrSceneComputeStateMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComputeStateMSFT>
 *
 * @xrentity{XrSceneComputeStateMSFT}
 */
enum class SceneComputeStateMSFT {

  None = XR_SCENE_COMPUTE_STATE_NONE_MSFT,

  Updating = XR_SCENE_COMPUTE_STATE_UPDATING_MSFT,

  Completed = XR_SCENE_COMPUTE_STATE_COMPLETED_MSFT,

  CompletedWithError = XR_SCENE_COMPUTE_STATE_COMPLETED_WITH_ERROR_MSFT,

};
static_assert(sizeof(SceneComputeStateMSFT) == sizeof(XrSceneComputeStateMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneComputeStateMSFT value from a
 * SceneComputeStateMSFT.
 *
 * @found_by_adl
 * @see SceneComputeStateMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneComputeStateMSFT get(SceneComputeStateMSFT const& v) {
  return static_cast<XrSceneComputeStateMSFT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneComputeStateMSFT address from a
 * SceneComputeStateMSFT.
 *
 * @found_by_adl
 * @see SceneComputeStateMSFT
 */
OPENXR_HPP_INLINE XrSceneComputeStateMSFT* put(SceneComputeStateMSFT& v) {
  return reinterpret_cast<XrSceneComputeStateMSFT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneComputeStateMSFT value as a const
 * char *.
 *
 * @found_by_adl
 * @see SceneComputeStateMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SceneComputeStateMSFT value) {
  switch (value) {
    case SceneComputeStateMSFT::None:
      return "None";

    case SceneComputeStateMSFT::Updating:
      return "Updating";

    case SceneComputeStateMSFT::Completed:
      return "Completed";

    case SceneComputeStateMSFT::CompletedWithError:
      return "CompletedWithError";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SceneComputeStateMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SceneComputeStateMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SceneComputeStateMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_understanding

#ifdef XR_HTC_facial_tracking
/*!
 * @brief Enum class for XrEyeExpressionHTC
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeExpressionHTC>
 *
 * @xrentity{XrEyeExpressionHTC}
 */
enum class EyeExpressionHTC {

  LeftBlink = XR_EYE_EXPRESSION_LEFT_BLINK_HTC,

  LeftWide = XR_EYE_EXPRESSION_LEFT_WIDE_HTC,

  RightBlink = XR_EYE_EXPRESSION_RIGHT_BLINK_HTC,

  RightWide = XR_EYE_EXPRESSION_RIGHT_WIDE_HTC,

  LeftSqueeze = XR_EYE_EXPRESSION_LEFT_SQUEEZE_HTC,

  RightSqueeze = XR_EYE_EXPRESSION_RIGHT_SQUEEZE_HTC,

  LeftDown = XR_EYE_EXPRESSION_LEFT_DOWN_HTC,

  RightDown = XR_EYE_EXPRESSION_RIGHT_DOWN_HTC,

  LeftOut = XR_EYE_EXPRESSION_LEFT_OUT_HTC,

  RightIn = XR_EYE_EXPRESSION_RIGHT_IN_HTC,

  LeftIn = XR_EYE_EXPRESSION_LEFT_IN_HTC,

  RightOut = XR_EYE_EXPRESSION_RIGHT_OUT_HTC,

  LeftUp = XR_EYE_EXPRESSION_LEFT_UP_HTC,

  RightUp = XR_EYE_EXPRESSION_RIGHT_UP_HTC,

};
static_assert(sizeof(EyeExpressionHTC) == sizeof(XrEyeExpressionHTC),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyeExpressionHTC value from a EyeExpressionHTC.
 *
 * @found_by_adl
 * @see EyeExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEyeExpressionHTC get(EyeExpressionHTC const& v) {
  return static_cast<XrEyeExpressionHTC>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyeExpressionHTC address from a EyeExpressionHTC.
 *
 * @found_by_adl
 * @see EyeExpressionHTC
 */
OPENXR_HPP_INLINE XrEyeExpressionHTC* put(EyeExpressionHTC& v) {
  return reinterpret_cast<XrEyeExpressionHTC*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a EyeExpressionHTC value as a const char
 * *.
 *
 * @found_by_adl
 * @see EyeExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    EyeExpressionHTC value) {
  switch (value) {
    case EyeExpressionHTC::LeftBlink:
      return "LeftBlink";

    case EyeExpressionHTC::LeftWide:
      return "LeftWide";

    case EyeExpressionHTC::RightBlink:
      return "RightBlink";

    case EyeExpressionHTC::RightWide:
      return "RightWide";

    case EyeExpressionHTC::LeftSqueeze:
      return "LeftSqueeze";

    case EyeExpressionHTC::RightSqueeze:
      return "RightSqueeze";

    case EyeExpressionHTC::LeftDown:
      return "LeftDown";

    case EyeExpressionHTC::RightDown:
      return "RightDown";

    case EyeExpressionHTC::LeftOut:
      return "LeftOut";

    case EyeExpressionHTC::RightIn:
      return "RightIn";

    case EyeExpressionHTC::LeftIn:
      return "LeftIn";

    case EyeExpressionHTC::RightOut:
      return "RightOut";

    case EyeExpressionHTC::LeftUp:
      return "LeftUp";

    case EyeExpressionHTC::RightUp:
      return "RightUp";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a EyeExpressionHTC value as a std::string.
 *
 * @found_by_adl
 * @see EyeExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EyeExpressionHTC value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_facial_tracking

#ifdef XR_HTC_facial_tracking
/*!
 * @brief Enum class for XrLipExpressionHTC
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLipExpressionHTC>
 *
 * @xrentity{XrLipExpressionHTC}
 */
enum class LipExpressionHTC {

  JawRight = XR_LIP_EXPRESSION_JAW_RIGHT_HTC,

  JawLeft = XR_LIP_EXPRESSION_JAW_LEFT_HTC,

  JawForward = XR_LIP_EXPRESSION_JAW_FORWARD_HTC,

  JawOpen = XR_LIP_EXPRESSION_JAW_OPEN_HTC,

  MouthApeShape = XR_LIP_EXPRESSION_MOUTH_APE_SHAPE_HTC,

  MouthUpperRight = XR_LIP_EXPRESSION_MOUTH_UPPER_RIGHT_HTC,

  MouthUpperLeft = XR_LIP_EXPRESSION_MOUTH_UPPER_LEFT_HTC,

  MouthLowerRight = XR_LIP_EXPRESSION_MOUTH_LOWER_RIGHT_HTC,

  MouthLowerLeft = XR_LIP_EXPRESSION_MOUTH_LOWER_LEFT_HTC,

  MouthUpperOverturn = XR_LIP_EXPRESSION_MOUTH_UPPER_OVERTURN_HTC,

  MouthLowerOverturn = XR_LIP_EXPRESSION_MOUTH_LOWER_OVERTURN_HTC,

  MouthPout = XR_LIP_EXPRESSION_MOUTH_POUT_HTC,

  MouthRaiserRight = XR_LIP_EXPRESSION_MOUTH_RAISER_RIGHT_HTC,

  MouthRaiserLeft = XR_LIP_EXPRESSION_MOUTH_RAISER_LEFT_HTC,

  MouthStretcherRight = XR_LIP_EXPRESSION_MOUTH_STRETCHER_RIGHT_HTC,

  MouthStretcherLeft = XR_LIP_EXPRESSION_MOUTH_STRETCHER_LEFT_HTC,

  CheekPuffRight = XR_LIP_EXPRESSION_CHEEK_PUFF_RIGHT_HTC,

  CheekPuffLeft = XR_LIP_EXPRESSION_CHEEK_PUFF_LEFT_HTC,

  CheekSuck = XR_LIP_EXPRESSION_CHEEK_SUCK_HTC,

  MouthUpperUpright = XR_LIP_EXPRESSION_MOUTH_UPPER_UPRIGHT_HTC,

  MouthUpperUpleft = XR_LIP_EXPRESSION_MOUTH_UPPER_UPLEFT_HTC,

  MouthLowerDownright = XR_LIP_EXPRESSION_MOUTH_LOWER_DOWNRIGHT_HTC,

  MouthLowerDownleft = XR_LIP_EXPRESSION_MOUTH_LOWER_DOWNLEFT_HTC,

  MouthUpperInside = XR_LIP_EXPRESSION_MOUTH_UPPER_INSIDE_HTC,

  MouthLowerInside = XR_LIP_EXPRESSION_MOUTH_LOWER_INSIDE_HTC,

  MouthLowerOverlay = XR_LIP_EXPRESSION_MOUTH_LOWER_OVERLAY_HTC,

  TongueLongstep1 = XR_LIP_EXPRESSION_TONGUE_LONGSTEP1_HTC,

  TongueLeft = XR_LIP_EXPRESSION_TONGUE_LEFT_HTC,

  TongueRight = XR_LIP_EXPRESSION_TONGUE_RIGHT_HTC,

  TongueUp = XR_LIP_EXPRESSION_TONGUE_UP_HTC,

  TongueDown = XR_LIP_EXPRESSION_TONGUE_DOWN_HTC,

  TongueRoll = XR_LIP_EXPRESSION_TONGUE_ROLL_HTC,

  TongueLongstep2 = XR_LIP_EXPRESSION_TONGUE_LONGSTEP2_HTC,

  TongueUprightMorph = XR_LIP_EXPRESSION_TONGUE_UPRIGHT_MORPH_HTC,

  TongueUpleftMorph = XR_LIP_EXPRESSION_TONGUE_UPLEFT_MORPH_HTC,

  TongueDownrightMorph = XR_LIP_EXPRESSION_TONGUE_DOWNRIGHT_MORPH_HTC,

  TongueDownleftMorph = XR_LIP_EXPRESSION_TONGUE_DOWNLEFT_MORPH_HTC,

  MouthSmileRight = XR_LIP_EXPRESSION_MOUTH_SMILE_RIGHT_HTC,

  MouthSmileLeft = XR_LIP_EXPRESSION_MOUTH_SMILE_LEFT_HTC,

  MouthSadRight = XR_LIP_EXPRESSION_MOUTH_SAD_RIGHT_HTC,

  MouthSadLeft = XR_LIP_EXPRESSION_MOUTH_SAD_LEFT_HTC,

};
static_assert(sizeof(LipExpressionHTC) == sizeof(XrLipExpressionHTC),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLipExpressionHTC value from a LipExpressionHTC.
 *
 * @found_by_adl
 * @see LipExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrLipExpressionHTC get(LipExpressionHTC const& v) {
  return static_cast<XrLipExpressionHTC>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLipExpressionHTC address from a LipExpressionHTC.
 *
 * @found_by_adl
 * @see LipExpressionHTC
 */
OPENXR_HPP_INLINE XrLipExpressionHTC* put(LipExpressionHTC& v) {
  return reinterpret_cast<XrLipExpressionHTC*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a LipExpressionHTC value as a const char
 * *.
 *
 * @found_by_adl
 * @see LipExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    LipExpressionHTC value) {
  switch (value) {
    case LipExpressionHTC::JawRight:
      return "JawRight";

    case LipExpressionHTC::JawLeft:
      return "JawLeft";

    case LipExpressionHTC::JawForward:
      return "JawForward";

    case LipExpressionHTC::JawOpen:
      return "JawOpen";

    case LipExpressionHTC::MouthApeShape:
      return "MouthApeShape";

    case LipExpressionHTC::MouthUpperRight:
      return "MouthUpperRight";

    case LipExpressionHTC::MouthUpperLeft:
      return "MouthUpperLeft";

    case LipExpressionHTC::MouthLowerRight:
      return "MouthLowerRight";

    case LipExpressionHTC::MouthLowerLeft:
      return "MouthLowerLeft";

    case LipExpressionHTC::MouthUpperOverturn:
      return "MouthUpperOverturn";

    case LipExpressionHTC::MouthLowerOverturn:
      return "MouthLowerOverturn";

    case LipExpressionHTC::MouthPout:
      return "MouthPout";

    case LipExpressionHTC::MouthRaiserRight:
      return "MouthRaiserRight";

    case LipExpressionHTC::MouthRaiserLeft:
      return "MouthRaiserLeft";

    case LipExpressionHTC::MouthStretcherRight:
      return "MouthStretcherRight";

    case LipExpressionHTC::MouthStretcherLeft:
      return "MouthStretcherLeft";

    case LipExpressionHTC::CheekPuffRight:
      return "CheekPuffRight";

    case LipExpressionHTC::CheekPuffLeft:
      return "CheekPuffLeft";

    case LipExpressionHTC::CheekSuck:
      return "CheekSuck";

    case LipExpressionHTC::MouthUpperUpright:
      return "MouthUpperUpright";

    case LipExpressionHTC::MouthUpperUpleft:
      return "MouthUpperUpleft";

    case LipExpressionHTC::MouthLowerDownright:
      return "MouthLowerDownright";

    case LipExpressionHTC::MouthLowerDownleft:
      return "MouthLowerDownleft";

    case LipExpressionHTC::MouthUpperInside:
      return "MouthUpperInside";

    case LipExpressionHTC::MouthLowerInside:
      return "MouthLowerInside";

    case LipExpressionHTC::MouthLowerOverlay:
      return "MouthLowerOverlay";

    case LipExpressionHTC::TongueLongstep1:
      return "TongueLongstep1";

    case LipExpressionHTC::TongueLeft:
      return "TongueLeft";

    case LipExpressionHTC::TongueRight:
      return "TongueRight";

    case LipExpressionHTC::TongueUp:
      return "TongueUp";

    case LipExpressionHTC::TongueDown:
      return "TongueDown";

    case LipExpressionHTC::TongueRoll:
      return "TongueRoll";

    case LipExpressionHTC::TongueLongstep2:
      return "TongueLongstep2";

    case LipExpressionHTC::TongueUprightMorph:
      return "TongueUprightMorph";

    case LipExpressionHTC::TongueUpleftMorph:
      return "TongueUpleftMorph";

    case LipExpressionHTC::TongueDownrightMorph:
      return "TongueDownrightMorph";

    case LipExpressionHTC::TongueDownleftMorph:
      return "TongueDownleftMorph";

    // MouthSmileRight is an alias for MouthRaiserRight
    // MouthSmileLeft is an alias for MouthRaiserLeft
    // MouthSadRight is an alias for MouthStretcherRight
    // MouthSadLeft is an alias for MouthStretcherLeft
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a LipExpressionHTC value as a std::string.
 *
 * @found_by_adl
 * @see LipExpressionHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(LipExpressionHTC value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_facial_tracking

#ifdef XR_HTC_facial_tracking
/*!
 * @brief Enum class for XrFacialTrackingTypeHTC
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialTrackingTypeHTC>
 *
 * @xrentity{XrFacialTrackingTypeHTC}
 */
enum class FacialTrackingTypeHTC {

  EyeDefault = XR_FACIAL_TRACKING_TYPE_EYE_DEFAULT_HTC,

  LipDefault = XR_FACIAL_TRACKING_TYPE_LIP_DEFAULT_HTC,

};
static_assert(sizeof(FacialTrackingTypeHTC) == sizeof(XrFacialTrackingTypeHTC),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFacialTrackingTypeHTC value from a
 * FacialTrackingTypeHTC.
 *
 * @found_by_adl
 * @see FacialTrackingTypeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFacialTrackingTypeHTC get(FacialTrackingTypeHTC const& v) {
  return static_cast<XrFacialTrackingTypeHTC>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFacialTrackingTypeHTC address from a
 * FacialTrackingTypeHTC.
 *
 * @found_by_adl
 * @see FacialTrackingTypeHTC
 */
OPENXR_HPP_INLINE XrFacialTrackingTypeHTC* put(FacialTrackingTypeHTC& v) {
  return reinterpret_cast<XrFacialTrackingTypeHTC*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FacialTrackingTypeHTC value as a const
 * char *.
 *
 * @found_by_adl
 * @see FacialTrackingTypeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FacialTrackingTypeHTC value) {
  switch (value) {
    case FacialTrackingTypeHTC::EyeDefault:
      return "EyeDefault";

    case FacialTrackingTypeHTC::LipDefault:
      return "LipDefault";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FacialTrackingTypeHTC value as a
 * std::string.
 *
 * @found_by_adl
 * @see FacialTrackingTypeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FacialTrackingTypeHTC value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_facial_tracking

#ifdef XR_FB_color_space
/*!
 * @brief Enum class for XrColorSpaceFB
 *
 * Provided by the `XR_FB_color_space` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrColorSpaceFB>
 *
 * @xrentity{XrColorSpaceFB}
 */
enum class ColorSpaceFB {

  Unmanaged = XR_COLOR_SPACE_UNMANAGED_FB,

  Rec2020 = XR_COLOR_SPACE_REC2020_FB,

  Rec709 = XR_COLOR_SPACE_REC709_FB,

  RiftCV1 = XR_COLOR_SPACE_RIFT_CV1_FB,

  RiftS = XR_COLOR_SPACE_RIFT_S_FB,

  Quest = XR_COLOR_SPACE_QUEST_FB,

  P3 = XR_COLOR_SPACE_P3_FB,

  AdobeRGB = XR_COLOR_SPACE_ADOBE_RGB_FB,

};
static_assert(sizeof(ColorSpaceFB) == sizeof(XrColorSpaceFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrColorSpaceFB value from a ColorSpaceFB.
 *
 * @found_by_adl
 * @see ColorSpaceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrColorSpaceFB get(ColorSpaceFB const& v) {
  return static_cast<XrColorSpaceFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrColorSpaceFB address from a ColorSpaceFB.
 *
 * @found_by_adl
 * @see ColorSpaceFB
 */
OPENXR_HPP_INLINE XrColorSpaceFB* put(ColorSpaceFB& v) {
  return reinterpret_cast<XrColorSpaceFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a ColorSpaceFB value as a const char *.
 *
 * @found_by_adl
 * @see ColorSpaceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(ColorSpaceFB value) {
  switch (value) {
    case ColorSpaceFB::Unmanaged:
      return "Unmanaged";

    case ColorSpaceFB::Rec2020:
      return "Rec2020";

    case ColorSpaceFB::Rec709:
      return "Rec709";

    case ColorSpaceFB::RiftCV1:
      return "RiftCV1";

    case ColorSpaceFB::RiftS:
      return "RiftS";

    case ColorSpaceFB::Quest:
      return "Quest";

    case ColorSpaceFB::P3:
      return "P3";

    case ColorSpaceFB::AdobeRGB:
      return "AdobeRGB";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ColorSpaceFB value as a std::string.
 *
 * @found_by_adl
 * @see ColorSpaceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(ColorSpaceFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_color_space

#ifdef XR_FB_spatial_entity
/*!
 * @brief Enum class for XrSpaceComponentTypeFB
 *
 * Provided by the `XR_FB_spatial_entity` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceComponentTypeFB>
 *
 * @xrentity{XrSpaceComponentTypeFB}
 */
enum class SpaceComponentTypeFB {

  Locatable = XR_SPACE_COMPONENT_TYPE_LOCATABLE_FB,

  Storable = XR_SPACE_COMPONENT_TYPE_STORABLE_FB,

  Sharable = XR_SPACE_COMPONENT_TYPE_SHARABLE_FB,

  Bounded2D = XR_SPACE_COMPONENT_TYPE_BOUNDED_2D_FB,

  Bounded3D = XR_SPACE_COMPONENT_TYPE_BOUNDED_3D_FB,

  SemanticLabels = XR_SPACE_COMPONENT_TYPE_SEMANTIC_LABELS_FB,

  RoomLayout = XR_SPACE_COMPONENT_TYPE_ROOM_LAYOUT_FB,

  SpaceContainer = XR_SPACE_COMPONENT_TYPE_SPACE_CONTAINER_FB,

#ifdef XR_META_spatial_entity_mesh
  TriangleMeshMETA = XR_SPACE_COMPONENT_TYPE_TRIANGLE_MESH_META,
#endif  // XR_META_spatial_entity_mesh
};
static_assert(sizeof(SpaceComponentTypeFB) == sizeof(XrSpaceComponentTypeFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpaceComponentTypeFB value from a
 * SpaceComponentTypeFB.
 *
 * @found_by_adl
 * @see SpaceComponentTypeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpaceComponentTypeFB get(SpaceComponentTypeFB const& v) {
  return static_cast<XrSpaceComponentTypeFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpaceComponentTypeFB address from a
 * SpaceComponentTypeFB.
 *
 * @found_by_adl
 * @see SpaceComponentTypeFB
 */
OPENXR_HPP_INLINE XrSpaceComponentTypeFB* put(SpaceComponentTypeFB& v) {
  return reinterpret_cast<XrSpaceComponentTypeFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpaceComponentTypeFB value as a const
 * char *.
 *
 * @found_by_adl
 * @see SpaceComponentTypeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpaceComponentTypeFB value) {
  switch (value) {
    case SpaceComponentTypeFB::Locatable:
      return "Locatable";

    case SpaceComponentTypeFB::Storable:
      return "Storable";

    case SpaceComponentTypeFB::Sharable:
      return "Sharable";

    case SpaceComponentTypeFB::Bounded2D:
      return "Bounded2D";

    case SpaceComponentTypeFB::Bounded3D:
      return "Bounded3D";

    case SpaceComponentTypeFB::SemanticLabels:
      return "SemanticLabels";

    case SpaceComponentTypeFB::RoomLayout:
      return "RoomLayout";

    case SpaceComponentTypeFB::SpaceContainer:
      return "SpaceContainer";

#ifdef XR_META_spatial_entity_mesh
    case SpaceComponentTypeFB::TriangleMeshMETA:
      return "TriangleMeshMETA";
#endif  // XR_META_spatial_entity_mesh
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpaceComponentTypeFB value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpaceComponentTypeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SpaceComponentTypeFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_spatial_entity

#ifdef XR_FB_foveation_configuration
/*!
 * @brief Enum class for XrFoveationLevelFB
 *
 * Provided by the `XR_FB_foveation_configuration` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationLevelFB>
 *
 * @xrentity{XrFoveationLevelFB}
 */
enum class FoveationLevelFB {

  None = XR_FOVEATION_LEVEL_NONE_FB,

  Low = XR_FOVEATION_LEVEL_LOW_FB,

  Medium = XR_FOVEATION_LEVEL_MEDIUM_FB,

  High = XR_FOVEATION_LEVEL_HIGH_FB,

};
static_assert(sizeof(FoveationLevelFB) == sizeof(XrFoveationLevelFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationLevelFB value from a FoveationLevelFB.
 *
 * @found_by_adl
 * @see FoveationLevelFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFoveationLevelFB get(FoveationLevelFB const& v) {
  return static_cast<XrFoveationLevelFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationLevelFB address from a FoveationLevelFB.
 *
 * @found_by_adl
 * @see FoveationLevelFB
 */
OPENXR_HPP_INLINE XrFoveationLevelFB* put(FoveationLevelFB& v) {
  return reinterpret_cast<XrFoveationLevelFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FoveationLevelFB value as a const char
 * *.
 *
 * @found_by_adl
 * @see FoveationLevelFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FoveationLevelFB value) {
  switch (value) {
    case FoveationLevelFB::None:
      return "None";

    case FoveationLevelFB::Low:
      return "Low";

    case FoveationLevelFB::Medium:
      return "Medium";

    case FoveationLevelFB::High:
      return "High";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FoveationLevelFB value as a std::string.
 *
 * @found_by_adl
 * @see FoveationLevelFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FoveationLevelFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_foveation_configuration

#ifdef XR_FB_foveation_configuration
/*!
 * @brief Enum class for XrFoveationDynamicFB
 *
 * Provided by the `XR_FB_foveation_configuration` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationDynamicFB>
 *
 * @xrentity{XrFoveationDynamicFB}
 */
enum class FoveationDynamicFB {

  Disabled = XR_FOVEATION_DYNAMIC_DISABLED_FB,

  LevelEnabled = XR_FOVEATION_DYNAMIC_LEVEL_ENABLED_FB,

};
static_assert(sizeof(FoveationDynamicFB) == sizeof(XrFoveationDynamicFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationDynamicFB value from a FoveationDynamicFB.
 *
 * @found_by_adl
 * @see FoveationDynamicFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFoveationDynamicFB get(FoveationDynamicFB const& v) {
  return static_cast<XrFoveationDynamicFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationDynamicFB address from a
 * FoveationDynamicFB.
 *
 * @found_by_adl
 * @see FoveationDynamicFB
 */
OPENXR_HPP_INLINE XrFoveationDynamicFB* put(FoveationDynamicFB& v) {
  return reinterpret_cast<XrFoveationDynamicFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FoveationDynamicFB value as a const char
 * *.
 *
 * @found_by_adl
 * @see FoveationDynamicFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FoveationDynamicFB value) {
  switch (value) {
    case FoveationDynamicFB::Disabled:
      return "Disabled";

    case FoveationDynamicFB::LevelEnabled:
      return "LevelEnabled";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FoveationDynamicFB value as a
 * std::string.
 *
 * @found_by_adl
 * @see FoveationDynamicFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FoveationDynamicFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_foveation_configuration

#ifdef XR_FB_triangle_mesh
/*!
 * @brief Enum class for XrWindingOrderFB
 *
 * Provided by the `XR_FB_triangle_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWindingOrderFB>
 *
 * @xrentity{XrWindingOrderFB}
 */
enum class WindingOrderFB {

  Unknown = XR_WINDING_ORDER_UNKNOWN_FB,

  CW = XR_WINDING_ORDER_CW_FB,

  CCW = XR_WINDING_ORDER_CCW_FB,

};
static_assert(sizeof(WindingOrderFB) == sizeof(XrWindingOrderFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrWindingOrderFB value from a WindingOrderFB.
 *
 * @found_by_adl
 * @see WindingOrderFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrWindingOrderFB get(WindingOrderFB const& v) {
  return static_cast<XrWindingOrderFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrWindingOrderFB address from a WindingOrderFB.
 *
 * @found_by_adl
 * @see WindingOrderFB
 */
OPENXR_HPP_INLINE XrWindingOrderFB* put(WindingOrderFB& v) {
  return reinterpret_cast<XrWindingOrderFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a WindingOrderFB value as a const char *.
 *
 * @found_by_adl
 * @see WindingOrderFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(WindingOrderFB value) {
  switch (value) {
    case WindingOrderFB::Unknown:
      return "Unknown";

    case WindingOrderFB::CW:
      return "CW";

    case WindingOrderFB::CCW:
      return "CCW";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a WindingOrderFB value as a std::string.
 *
 * @found_by_adl
 * @see WindingOrderFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(WindingOrderFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_passthrough
/*!
 * @brief Enum class for XrPassthroughLayerPurposeFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughLayerPurposeFB>
 *
 * @xrentity{XrPassthroughLayerPurposeFB}
 */
enum class PassthroughLayerPurposeFB {

  Reconstruction = XR_PASSTHROUGH_LAYER_PURPOSE_RECONSTRUCTION_FB,

  Projected = XR_PASSTHROUGH_LAYER_PURPOSE_PROJECTED_FB,

#ifdef XR_FB_passthrough_keyboard_hands
  TrackedKeyboardHands = XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_HANDS_FB,
#endif  // XR_FB_passthrough_keyboard_hands
#ifdef XR_FB_passthrough_keyboard_hands
  TrackedKeyboardMaskedHands = XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_MASKED_HANDS_FB,
#endif  // XR_FB_passthrough_keyboard_hands
};
static_assert(sizeof(PassthroughLayerPurposeFB) == sizeof(XrPassthroughLayerPurposeFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPassthroughLayerPurposeFB value from a
 * PassthroughLayerPurposeFB.
 *
 * @found_by_adl
 * @see PassthroughLayerPurposeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPassthroughLayerPurposeFB
get(PassthroughLayerPurposeFB const& v) {
  return static_cast<XrPassthroughLayerPurposeFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPassthroughLayerPurposeFB address from a
 * PassthroughLayerPurposeFB.
 *
 * @found_by_adl
 * @see PassthroughLayerPurposeFB
 */
OPENXR_HPP_INLINE XrPassthroughLayerPurposeFB* put(PassthroughLayerPurposeFB& v) {
  return reinterpret_cast<XrPassthroughLayerPurposeFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughLayerPurposeFB value as a
 * const char *.
 *
 * @found_by_adl
 * @see PassthroughLayerPurposeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PassthroughLayerPurposeFB value) {
  switch (value) {
    case PassthroughLayerPurposeFB::Reconstruction:
      return "Reconstruction";

    case PassthroughLayerPurposeFB::Projected:
      return "Projected";

#ifdef XR_FB_passthrough_keyboard_hands
    case PassthroughLayerPurposeFB::TrackedKeyboardHands:
      return "TrackedKeyboardHands";
#endif  // XR_FB_passthrough_keyboard_hands
#ifdef XR_FB_passthrough_keyboard_hands
    case PassthroughLayerPurposeFB::TrackedKeyboardMaskedHands:
      return "TrackedKeyboardMaskedHands";
#endif  // XR_FB_passthrough_keyboard_hands
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughLayerPurposeFB value as a
 * std::string.
 *
 * @found_by_adl
 * @see PassthroughLayerPurposeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    PassthroughLayerPurposeFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_passthrough

#ifdef XR_ML_marker_understanding
/*!
 * @brief Enum class for XrMarkerDetectorProfileML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorProfileML>
 *
 * @xrentity{XrMarkerDetectorProfileML}
 */
enum class MarkerDetectorProfileML {

  Default = XR_MARKER_DETECTOR_PROFILE_DEFAULT_ML,

  Speed = XR_MARKER_DETECTOR_PROFILE_SPEED_ML,

  Accuracy = XR_MARKER_DETECTOR_PROFILE_ACCURACY_ML,

  SmallTargets = XR_MARKER_DETECTOR_PROFILE_SMALL_TARGETS_ML,

  LargeFov = XR_MARKER_DETECTOR_PROFILE_LARGE_FOV_ML,

  Custom = XR_MARKER_DETECTOR_PROFILE_CUSTOM_ML,

};
static_assert(sizeof(MarkerDetectorProfileML) == sizeof(XrMarkerDetectorProfileML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorProfileML value from a
 * MarkerDetectorProfileML.
 *
 * @found_by_adl
 * @see MarkerDetectorProfileML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrMarkerDetectorProfileML
get(MarkerDetectorProfileML const& v) {
  return static_cast<XrMarkerDetectorProfileML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorProfileML address from a
 * MarkerDetectorProfileML.
 *
 * @found_by_adl
 * @see MarkerDetectorProfileML
 */
OPENXR_HPP_INLINE XrMarkerDetectorProfileML* put(MarkerDetectorProfileML& v) {
  return reinterpret_cast<XrMarkerDetectorProfileML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorProfileML value as a const
 * char *.
 *
 * @found_by_adl
 * @see MarkerDetectorProfileML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    MarkerDetectorProfileML value) {
  switch (value) {
    case MarkerDetectorProfileML::Default:
      return "Default";

    case MarkerDetectorProfileML::Speed:
      return "Speed";

    case MarkerDetectorProfileML::Accuracy:
      return "Accuracy";

    case MarkerDetectorProfileML::SmallTargets:
      return "SmallTargets";

    case MarkerDetectorProfileML::LargeFov:
      return "LargeFov";

    case MarkerDetectorProfileML::Custom:
      return "Custom";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorProfileML value as a
 * std::string.
 *
 * @found_by_adl
 * @see MarkerDetectorProfileML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(MarkerDetectorProfileML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * @brief Enum class for XrMarkerTypeML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerTypeML>
 *
 * @xrentity{XrMarkerTypeML}
 */
enum class MarkerTypeML {

  Aruco = XR_MARKER_TYPE_ARUCO_ML,

  AprilTag = XR_MARKER_TYPE_APRIL_TAG_ML,

  Qr = XR_MARKER_TYPE_QR_ML,

  Ean13 = XR_MARKER_TYPE_EAN_13_ML,

  UpcA = XR_MARKER_TYPE_UPC_A_ML,

  Code128 = XR_MARKER_TYPE_CODE_128_ML,

};
static_assert(sizeof(MarkerTypeML) == sizeof(XrMarkerTypeML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerTypeML value from a MarkerTypeML.
 *
 * @found_by_adl
 * @see MarkerTypeML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrMarkerTypeML get(MarkerTypeML const& v) {
  return static_cast<XrMarkerTypeML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerTypeML address from a MarkerTypeML.
 *
 * @found_by_adl
 * @see MarkerTypeML
 */
OPENXR_HPP_INLINE XrMarkerTypeML* put(MarkerTypeML& v) {
  return reinterpret_cast<XrMarkerTypeML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a MarkerTypeML value as a const char *.
 *
 * @found_by_adl
 * @see MarkerTypeML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(MarkerTypeML value) {
  switch (value) {
    case MarkerTypeML::Aruco:
      return "Aruco";

    case MarkerTypeML::AprilTag:
      return "AprilTag";

    case MarkerTypeML::Qr:
      return "Qr";

    case MarkerTypeML::Ean13:
      return "Ean13";

    case MarkerTypeML::UpcA:
      return "UpcA";

    case MarkerTypeML::Code128:
      return "Code128";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a MarkerTypeML value as a std::string.
 *
 * @found_by_adl
 * @see MarkerTypeML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(MarkerTypeML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * @brief Enum class for XrMarkerArucoDictML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerArucoDictML>
 *
 * @xrentity{XrMarkerArucoDictML}
 */
enum class MarkerArucoDictML {

  _4X450 = XR_MARKER_ARUCO_DICT_4X4_50_ML,

  _4X4100 = XR_MARKER_ARUCO_DICT_4X4_100_ML,

  _4X4250 = XR_MARKER_ARUCO_DICT_4X4_250_ML,

  _4X41000 = XR_MARKER_ARUCO_DICT_4X4_1000_ML,

  _5X550 = XR_MARKER_ARUCO_DICT_5X5_50_ML,

  _5X5100 = XR_MARKER_ARUCO_DICT_5X5_100_ML,

  _5X5250 = XR_MARKER_ARUCO_DICT_5X5_250_ML,

  _5X51000 = XR_MARKER_ARUCO_DICT_5X5_1000_ML,

  _6X650 = XR_MARKER_ARUCO_DICT_6X6_50_ML,

  _6X6100 = XR_MARKER_ARUCO_DICT_6X6_100_ML,

  _6X6250 = XR_MARKER_ARUCO_DICT_6X6_250_ML,

  _6X61000 = XR_MARKER_ARUCO_DICT_6X6_1000_ML,

  _7X750 = XR_MARKER_ARUCO_DICT_7X7_50_ML,

  _7X7100 = XR_MARKER_ARUCO_DICT_7X7_100_ML,

  _7X7250 = XR_MARKER_ARUCO_DICT_7X7_250_ML,

  _7X71000 = XR_MARKER_ARUCO_DICT_7X7_1000_ML,

};
static_assert(sizeof(MarkerArucoDictML) == sizeof(XrMarkerArucoDictML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerArucoDictML value from a MarkerArucoDictML.
 *
 * @found_by_adl
 * @see MarkerArucoDictML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrMarkerArucoDictML get(MarkerArucoDictML const& v) {
  return static_cast<XrMarkerArucoDictML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerArucoDictML address from a MarkerArucoDictML.
 *
 * @found_by_adl
 * @see MarkerArucoDictML
 */
OPENXR_HPP_INLINE XrMarkerArucoDictML* put(MarkerArucoDictML& v) {
  return reinterpret_cast<XrMarkerArucoDictML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a MarkerArucoDictML value as a const char
 * *.
 *
 * @found_by_adl
 * @see MarkerArucoDictML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    MarkerArucoDictML value) {
  switch (value) {
    case MarkerArucoDictML::_4X450:
      return "_4X450";

    case MarkerArucoDictML::_4X4100:
      return "_4X4100";

    case MarkerArucoDictML::_4X4250:
      return "_4X4250";

    case MarkerArucoDictML::_4X41000:
      return "_4X41000";

    case MarkerArucoDictML::_5X550:
      return "_5X550";

    case MarkerArucoDictML::_5X5100:
      return "_5X5100";

    case MarkerArucoDictML::_5X5250:
      return "_5X5250";

    case MarkerArucoDictML::_5X51000:
      return "_5X51000";

    case MarkerArucoDictML::_6X650:
      return "_6X650";

    case MarkerArucoDictML::_6X6100:
      return "_6X6100";

    case MarkerArucoDictML::_6X6250:
      return "_6X6250";

    case MarkerArucoDictML::_6X61000:
      return "_6X61000";

    case MarkerArucoDictML::_7X750:
      return "_7X750";

    case MarkerArucoDictML::_7X7100:
      return "_7X7100";

    case MarkerArucoDictML::_7X7250:
      return "_7X7250";

    case MarkerArucoDictML::_7X71000:
      return "_7X71000";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a MarkerArucoDictML value as a
 * std::string.
 *
 * @found_by_adl
 * @see MarkerArucoDictML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(MarkerArucoDictML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * @brief Enum class for XrMarkerAprilTagDictML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerAprilTagDictML>
 *
 * @xrentity{XrMarkerAprilTagDictML}
 */
enum class MarkerAprilTagDictML {

  _16H5 = XR_MARKER_APRIL_TAG_DICT_16H5_ML,

  _25H9 = XR_MARKER_APRIL_TAG_DICT_25H9_ML,

  _36H10 = XR_MARKER_APRIL_TAG_DICT_36H10_ML,

  _36H11 = XR_MARKER_APRIL_TAG_DICT_36H11_ML,

};
static_assert(sizeof(MarkerAprilTagDictML) == sizeof(XrMarkerAprilTagDictML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerAprilTagDictML value from a
 * MarkerAprilTagDictML.
 *
 * @found_by_adl
 * @see MarkerAprilTagDictML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrMarkerAprilTagDictML get(MarkerAprilTagDictML const& v) {
  return static_cast<XrMarkerAprilTagDictML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerAprilTagDictML address from a
 * MarkerAprilTagDictML.
 *
 * @found_by_adl
 * @see MarkerAprilTagDictML
 */
OPENXR_HPP_INLINE XrMarkerAprilTagDictML* put(MarkerAprilTagDictML& v) {
  return reinterpret_cast<XrMarkerAprilTagDictML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a MarkerAprilTagDictML value as a const
 * char *.
 *
 * @found_by_adl
 * @see MarkerAprilTagDictML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    MarkerAprilTagDictML value) {
  switch (value) {
    case MarkerAprilTagDictML::_16H5:
      return "_16H5";

    case MarkerAprilTagDictML::_25H9:
      return "_25H9";

    case MarkerAprilTagDictML::_36H10:
      return "_36H10";

    case MarkerAprilTagDictML::_36H11:
      return "_36H11";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a MarkerAprilTagDictML value as a
 * std::string.
 *
 * @found_by_adl
 * @see MarkerAprilTagDictML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(MarkerAprilTagDictML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * @brief Enum class for XrMarkerDetectorFpsML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorFpsML>
 *
 * @xrentity{XrMarkerDetectorFpsML}
 */
enum class MarkerDetectorFpsML {

  Low = XR_MARKER_DETECTOR_FPS_LOW_ML,

  Medium = XR_MARKER_DETECTOR_FPS_MEDIUM_ML,

  High = XR_MARKER_DETECTOR_FPS_HIGH_ML,

  Max = XR_MARKER_DETECTOR_FPS_MAX_ML,

};
static_assert(sizeof(MarkerDetectorFpsML) == sizeof(XrMarkerDetectorFpsML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorFpsML value from a
 * MarkerDetectorFpsML.
 *
 * @found_by_adl
 * @see MarkerDetectorFpsML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrMarkerDetectorFpsML get(MarkerDetectorFpsML const& v) {
  return static_cast<XrMarkerDetectorFpsML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorFpsML address from a
 * MarkerDetectorFpsML.
 *
 * @found_by_adl
 * @see MarkerDetectorFpsML
 */
OPENXR_HPP_INLINE XrMarkerDetectorFpsML* put(MarkerDetectorFpsML& v) {
  return reinterpret_cast<XrMarkerDetectorFpsML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorFpsML value as a const
 * char *.
 *
 * @found_by_adl
 * @see MarkerDetectorFpsML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    MarkerDetectorFpsML value) {
  switch (value) {
    case MarkerDetectorFpsML::Low:
      return "Low";

    case MarkerDetectorFpsML::Medium:
      return "Medium";

    case MarkerDetectorFpsML::High:
      return "High";

    case MarkerDetectorFpsML::Max:
      return "Max";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorFpsML value as a
 * std::string.
 *
 * @found_by_adl
 * @see MarkerDetectorFpsML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(MarkerDetectorFpsML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * @brief Enum class for XrMarkerDetectorResolutionML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorResolutionML>
 *
 * @xrentity{XrMarkerDetectorResolutionML}
 */
enum class MarkerDetectorResolutionML {

  Low = XR_MARKER_DETECTOR_RESOLUTION_LOW_ML,

  Medium = XR_MARKER_DETECTOR_RESOLUTION_MEDIUM_ML,

  High = XR_MARKER_DETECTOR_RESOLUTION_HIGH_ML,

};
static_assert(sizeof(MarkerDetectorResolutionML) == sizeof(XrMarkerDetectorResolutionML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorResolutionML value from a
 * MarkerDetectorResolutionML.
 *
 * @found_by_adl
 * @see MarkerDetectorResolutionML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrMarkerDetectorResolutionML
get(MarkerDetectorResolutionML const& v) {
  return static_cast<XrMarkerDetectorResolutionML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorResolutionML address from a
 * MarkerDetectorResolutionML.
 *
 * @found_by_adl
 * @see MarkerDetectorResolutionML
 */
OPENXR_HPP_INLINE XrMarkerDetectorResolutionML* put(MarkerDetectorResolutionML& v) {
  return reinterpret_cast<XrMarkerDetectorResolutionML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorResolutionML value as a
 * const char *.
 *
 * @found_by_adl
 * @see MarkerDetectorResolutionML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    MarkerDetectorResolutionML value) {
  switch (value) {
    case MarkerDetectorResolutionML::Low:
      return "Low";

    case MarkerDetectorResolutionML::Medium:
      return "Medium";

    case MarkerDetectorResolutionML::High:
      return "High";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorResolutionML value as a
 * std::string.
 *
 * @found_by_adl
 * @see MarkerDetectorResolutionML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    MarkerDetectorResolutionML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * @brief Enum class for XrMarkerDetectorCameraML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorCameraML>
 *
 * @xrentity{XrMarkerDetectorCameraML}
 */
enum class MarkerDetectorCameraML {

  RGBCamera = XR_MARKER_DETECTOR_CAMERA_RGB_CAMERA_ML,

  WorldCameras = XR_MARKER_DETECTOR_CAMERA_WORLD_CAMERAS_ML,

};
static_assert(sizeof(MarkerDetectorCameraML) == sizeof(XrMarkerDetectorCameraML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorCameraML value from a
 * MarkerDetectorCameraML.
 *
 * @found_by_adl
 * @see MarkerDetectorCameraML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrMarkerDetectorCameraML
get(MarkerDetectorCameraML const& v) {
  return static_cast<XrMarkerDetectorCameraML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorCameraML address from a
 * MarkerDetectorCameraML.
 *
 * @found_by_adl
 * @see MarkerDetectorCameraML
 */
OPENXR_HPP_INLINE XrMarkerDetectorCameraML* put(MarkerDetectorCameraML& v) {
  return reinterpret_cast<XrMarkerDetectorCameraML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorCameraML value as a const
 * char *.
 *
 * @found_by_adl
 * @see MarkerDetectorCameraML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    MarkerDetectorCameraML value) {
  switch (value) {
    case MarkerDetectorCameraML::RGBCamera:
      return "RGBCamera";

    case MarkerDetectorCameraML::WorldCameras:
      return "WorldCameras";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorCameraML value as a
 * std::string.
 *
 * @found_by_adl
 * @see MarkerDetectorCameraML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(MarkerDetectorCameraML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * @brief Enum class for XrMarkerDetectorCornerRefineMethodML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorCornerRefineMethodML>
 *
 * @xrentity{XrMarkerDetectorCornerRefineMethodML}
 */
enum class MarkerDetectorCornerRefineMethodML {

  None = XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_NONE_ML,

  Subpix = XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_SUBPIX_ML,

  Contour = XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_CONTOUR_ML,

  AprilTag = XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_APRIL_TAG_ML,

};
static_assert(sizeof(MarkerDetectorCornerRefineMethodML) ==
                  sizeof(XrMarkerDetectorCornerRefineMethodML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorCornerRefineMethodML value from a
 * MarkerDetectorCornerRefineMethodML.
 *
 * @found_by_adl
 * @see MarkerDetectorCornerRefineMethodML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrMarkerDetectorCornerRefineMethodML
get(MarkerDetectorCornerRefineMethodML const& v) {
  return static_cast<XrMarkerDetectorCornerRefineMethodML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorCornerRefineMethodML address from a
 * MarkerDetectorCornerRefineMethodML.
 *
 * @found_by_adl
 * @see MarkerDetectorCornerRefineMethodML
 */
OPENXR_HPP_INLINE XrMarkerDetectorCornerRefineMethodML* put(MarkerDetectorCornerRefineMethodML& v) {
  return reinterpret_cast<XrMarkerDetectorCornerRefineMethodML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorCornerRefineMethodML value
 * as a const char *.
 *
 * @found_by_adl
 * @see MarkerDetectorCornerRefineMethodML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    MarkerDetectorCornerRefineMethodML value) {
  switch (value) {
    case MarkerDetectorCornerRefineMethodML::None:
      return "None";

    case MarkerDetectorCornerRefineMethodML::Subpix:
      return "Subpix";

    case MarkerDetectorCornerRefineMethodML::Contour:
      return "Contour";

    case MarkerDetectorCornerRefineMethodML::AprilTag:
      return "AprilTag";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorCornerRefineMethodML value
 * as a std::string.
 *
 * @found_by_adl
 * @see MarkerDetectorCornerRefineMethodML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    MarkerDetectorCornerRefineMethodML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * @brief Enum class for XrMarkerDetectorFullAnalysisIntervalML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorFullAnalysisIntervalML>
 *
 * @xrentity{XrMarkerDetectorFullAnalysisIntervalML}
 */
enum class MarkerDetectorFullAnalysisIntervalML {

  Max = XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_MAX_ML,

  Fast = XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_FAST_ML,

  Medium = XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_MEDIUM_ML,

  Slow = XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_SLOW_ML,

};
static_assert(sizeof(MarkerDetectorFullAnalysisIntervalML) ==
                  sizeof(XrMarkerDetectorFullAnalysisIntervalML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorFullAnalysisIntervalML value from a
 * MarkerDetectorFullAnalysisIntervalML.
 *
 * @found_by_adl
 * @see MarkerDetectorFullAnalysisIntervalML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrMarkerDetectorFullAnalysisIntervalML
get(MarkerDetectorFullAnalysisIntervalML const& v) {
  return static_cast<XrMarkerDetectorFullAnalysisIntervalML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorFullAnalysisIntervalML address from a
 * MarkerDetectorFullAnalysisIntervalML.
 *
 * @found_by_adl
 * @see MarkerDetectorFullAnalysisIntervalML
 */
OPENXR_HPP_INLINE XrMarkerDetectorFullAnalysisIntervalML* put(
    MarkerDetectorFullAnalysisIntervalML& v) {
  return reinterpret_cast<XrMarkerDetectorFullAnalysisIntervalML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorFullAnalysisIntervalML
 * value as a const char *.
 *
 * @found_by_adl
 * @see MarkerDetectorFullAnalysisIntervalML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    MarkerDetectorFullAnalysisIntervalML value) {
  switch (value) {
    case MarkerDetectorFullAnalysisIntervalML::Max:
      return "Max";

    case MarkerDetectorFullAnalysisIntervalML::Fast:
      return "Fast";

    case MarkerDetectorFullAnalysisIntervalML::Medium:
      return "Medium";

    case MarkerDetectorFullAnalysisIntervalML::Slow:
      return "Slow";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorFullAnalysisIntervalML
 * value as a std::string.
 *
 * @found_by_adl
 * @see MarkerDetectorFullAnalysisIntervalML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    MarkerDetectorFullAnalysisIntervalML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * @brief Enum class for XrMarkerDetectorStatusML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorStatusML>
 *
 * @xrentity{XrMarkerDetectorStatusML}
 */
enum class MarkerDetectorStatusML {

  Pending = XR_MARKER_DETECTOR_STATUS_PENDING_ML,

  Ready = XR_MARKER_DETECTOR_STATUS_READY_ML,

  Error = XR_MARKER_DETECTOR_STATUS_ERROR_ML,

};
static_assert(sizeof(MarkerDetectorStatusML) == sizeof(XrMarkerDetectorStatusML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorStatusML value from a
 * MarkerDetectorStatusML.
 *
 * @found_by_adl
 * @see MarkerDetectorStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrMarkerDetectorStatusML
get(MarkerDetectorStatusML const& v) {
  return static_cast<XrMarkerDetectorStatusML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrMarkerDetectorStatusML address from a
 * MarkerDetectorStatusML.
 *
 * @found_by_adl
 * @see MarkerDetectorStatusML
 */
OPENXR_HPP_INLINE XrMarkerDetectorStatusML* put(MarkerDetectorStatusML& v) {
  return reinterpret_cast<XrMarkerDetectorStatusML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorStatusML value as a const
 * char *.
 *
 * @found_by_adl
 * @see MarkerDetectorStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    MarkerDetectorStatusML value) {
  switch (value) {
    case MarkerDetectorStatusML::Pending:
      return "Pending";

    case MarkerDetectorStatusML::Ready:
      return "Ready";

    case MarkerDetectorStatusML::Error:
      return "Error";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a MarkerDetectorStatusML value as a
 * std::string.
 *
 * @found_by_adl
 * @see MarkerDetectorStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(MarkerDetectorStatusML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_marker_understanding

#ifdef XR_ML_localization_map
/*!
 * @brief Enum class for XrLocalizationMapStateML
 *
 * Provided by the `XR_ML_localization_map` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLocalizationMapStateML>
 *
 * @xrentity{XrLocalizationMapStateML}
 */
enum class LocalizationMapStateML {

  NotLocalized = XR_LOCALIZATION_MAP_STATE_NOT_LOCALIZED_ML,

  Localized = XR_LOCALIZATION_MAP_STATE_LOCALIZED_ML,

  LocalizationPending = XR_LOCALIZATION_MAP_STATE_LOCALIZATION_PENDING_ML,

  LocalizationSleepingBeforeRetry = XR_LOCALIZATION_MAP_STATE_LOCALIZATION_SLEEPING_BEFORE_RETRY_ML,

};
static_assert(sizeof(LocalizationMapStateML) == sizeof(XrLocalizationMapStateML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLocalizationMapStateML value from a
 * LocalizationMapStateML.
 *
 * @found_by_adl
 * @see LocalizationMapStateML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrLocalizationMapStateML
get(LocalizationMapStateML const& v) {
  return static_cast<XrLocalizationMapStateML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLocalizationMapStateML address from a
 * LocalizationMapStateML.
 *
 * @found_by_adl
 * @see LocalizationMapStateML
 */
OPENXR_HPP_INLINE XrLocalizationMapStateML* put(LocalizationMapStateML& v) {
  return reinterpret_cast<XrLocalizationMapStateML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a LocalizationMapStateML value as a const
 * char *.
 *
 * @found_by_adl
 * @see LocalizationMapStateML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    LocalizationMapStateML value) {
  switch (value) {
    case LocalizationMapStateML::NotLocalized:
      return "NotLocalized";

    case LocalizationMapStateML::Localized:
      return "Localized";

    case LocalizationMapStateML::LocalizationPending:
      return "LocalizationPending";

    case LocalizationMapStateML::LocalizationSleepingBeforeRetry:
      return "LocalizationSleepingBeforeRetry";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a LocalizationMapStateML value as a
 * std::string.
 *
 * @found_by_adl
 * @see LocalizationMapStateML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(LocalizationMapStateML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_localization_map

#ifdef XR_ML_localization_map
/*!
 * @brief Enum class for XrLocalizationMapTypeML
 *
 * Provided by the `XR_ML_localization_map` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLocalizationMapTypeML>
 *
 * @xrentity{XrLocalizationMapTypeML}
 */
enum class LocalizationMapTypeML {

  OnDevice = XR_LOCALIZATION_MAP_TYPE_ON_DEVICE_ML,

  Cloud = XR_LOCALIZATION_MAP_TYPE_CLOUD_ML,

};
static_assert(sizeof(LocalizationMapTypeML) == sizeof(XrLocalizationMapTypeML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLocalizationMapTypeML value from a
 * LocalizationMapTypeML.
 *
 * @found_by_adl
 * @see LocalizationMapTypeML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrLocalizationMapTypeML get(LocalizationMapTypeML const& v) {
  return static_cast<XrLocalizationMapTypeML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLocalizationMapTypeML address from a
 * LocalizationMapTypeML.
 *
 * @found_by_adl
 * @see LocalizationMapTypeML
 */
OPENXR_HPP_INLINE XrLocalizationMapTypeML* put(LocalizationMapTypeML& v) {
  return reinterpret_cast<XrLocalizationMapTypeML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a LocalizationMapTypeML value as a const
 * char *.
 *
 * @found_by_adl
 * @see LocalizationMapTypeML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    LocalizationMapTypeML value) {
  switch (value) {
    case LocalizationMapTypeML::OnDevice:
      return "OnDevice";

    case LocalizationMapTypeML::Cloud:
      return "Cloud";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a LocalizationMapTypeML value as a
 * std::string.
 *
 * @found_by_adl
 * @see LocalizationMapTypeML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(LocalizationMapTypeML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_localization_map

#ifdef XR_ML_localization_map
/*!
 * @brief Enum class for XrLocalizationMapConfidenceML
 *
 * Provided by the `XR_ML_localization_map` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLocalizationMapConfidenceML>
 *
 * @xrentity{XrLocalizationMapConfidenceML}
 */
enum class LocalizationMapConfidenceML {

  Poor = XR_LOCALIZATION_MAP_CONFIDENCE_POOR_ML,

  Fair = XR_LOCALIZATION_MAP_CONFIDENCE_FAIR_ML,

  Good = XR_LOCALIZATION_MAP_CONFIDENCE_GOOD_ML,

  Excellent = XR_LOCALIZATION_MAP_CONFIDENCE_EXCELLENT_ML,

};
static_assert(sizeof(LocalizationMapConfidenceML) == sizeof(XrLocalizationMapConfidenceML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLocalizationMapConfidenceML value from a
 * LocalizationMapConfidenceML.
 *
 * @found_by_adl
 * @see LocalizationMapConfidenceML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrLocalizationMapConfidenceML
get(LocalizationMapConfidenceML const& v) {
  return static_cast<XrLocalizationMapConfidenceML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLocalizationMapConfidenceML address from a
 * LocalizationMapConfidenceML.
 *
 * @found_by_adl
 * @see LocalizationMapConfidenceML
 */
OPENXR_HPP_INLINE XrLocalizationMapConfidenceML* put(LocalizationMapConfidenceML& v) {
  return reinterpret_cast<XrLocalizationMapConfidenceML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a LocalizationMapConfidenceML value as a
 * const char *.
 *
 * @found_by_adl
 * @see LocalizationMapConfidenceML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    LocalizationMapConfidenceML value) {
  switch (value) {
    case LocalizationMapConfidenceML::Poor:
      return "Poor";

    case LocalizationMapConfidenceML::Fair:
      return "Fair";

    case LocalizationMapConfidenceML::Good:
      return "Good";

    case LocalizationMapConfidenceML::Excellent:
      return "Excellent";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a LocalizationMapConfidenceML value as a
 * std::string.
 *
 * @found_by_adl
 * @see LocalizationMapConfidenceML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    LocalizationMapConfidenceML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_localization_map

#ifdef dsaXR_ML_spatial_anchors
/*!
 * @brief Enum class for XrSpatialAnchorConfidenceML
 *
 * Provided by the `XR_ML_spatial_anchors` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorConfidenceML>
 *
 * @xrentity{XrSpatialAnchorConfidenceML}
 */
enum class SpatialAnchorConfidenceML {

  Low = XR_SPATIAL_ANCHOR_CONFIDENCE_LOW_ML,

  Medium = XR_SPATIAL_ANCHOR_CONFIDENCE_MEDIUM_ML,

  High = XR_SPATIAL_ANCHOR_CONFIDENCE_HIGH_ML,

};
static_assert(sizeof(SpatialAnchorConfidenceML) == sizeof(XrSpatialAnchorConfidenceML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialAnchorConfidenceML value from a
 * SpatialAnchorConfidenceML.
 *
 * @found_by_adl
 * @see SpatialAnchorConfidenceML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialAnchorConfidenceML
get(SpatialAnchorConfidenceML const& v) {
  return static_cast<XrSpatialAnchorConfidenceML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialAnchorConfidenceML address from a
 * SpatialAnchorConfidenceML.
 *
 * @found_by_adl
 * @see SpatialAnchorConfidenceML
 */
OPENXR_HPP_INLINE XrSpatialAnchorConfidenceML* put(SpatialAnchorConfidenceML& v) {
  return reinterpret_cast<XrSpatialAnchorConfidenceML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialAnchorConfidenceML value as a
 * const char *.
 *
 * @found_by_adl
 * @see SpatialAnchorConfidenceML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialAnchorConfidenceML value) {
  switch (value) {
    case SpatialAnchorConfidenceML::Low:
      return "Low";

    case SpatialAnchorConfidenceML::Medium:
      return "Medium";

    case SpatialAnchorConfidenceML::High:
      return "High";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialAnchorConfidenceML value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialAnchorConfidenceML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SpatialAnchorConfidenceML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_spatial_anchors

#ifdef XR_MSFT_scene_marker
/*!
 * @brief Enum class for XrSceneMarkerTypeMSFT
 *
 * Provided by the `XR_MSFT_scene_marker` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkerTypeMSFT>
 *
 * @xrentity{XrSceneMarkerTypeMSFT}
 */
enum class SceneMarkerTypeMSFT {

  QrCode = XR_SCENE_MARKER_TYPE_QR_CODE_MSFT,

};
static_assert(sizeof(SceneMarkerTypeMSFT) == sizeof(XrSceneMarkerTypeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneMarkerTypeMSFT value from a
 * SceneMarkerTypeMSFT.
 *
 * @found_by_adl
 * @see SceneMarkerTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneMarkerTypeMSFT get(SceneMarkerTypeMSFT const& v) {
  return static_cast<XrSceneMarkerTypeMSFT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneMarkerTypeMSFT address from a
 * SceneMarkerTypeMSFT.
 *
 * @found_by_adl
 * @see SceneMarkerTypeMSFT
 */
OPENXR_HPP_INLINE XrSceneMarkerTypeMSFT* put(SceneMarkerTypeMSFT& v) {
  return reinterpret_cast<XrSceneMarkerTypeMSFT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneMarkerTypeMSFT value as a const
 * char *.
 *
 * @found_by_adl
 * @see SceneMarkerTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SceneMarkerTypeMSFT value) {
  switch (value) {
    case SceneMarkerTypeMSFT::QrCode:
      return "QrCode";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SceneMarkerTypeMSFT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SceneMarkerTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SceneMarkerTypeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_marker

#ifdef XR_MSFT_scene_marker
/*!
 * @brief Enum class for XrSceneMarkerQRCodeSymbolTypeMSFT
 *
 * Provided by the `XR_MSFT_scene_marker` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkerQRCodeSymbolTypeMSFT>
 *
 * @xrentity{XrSceneMarkerQRCodeSymbolTypeMSFT}
 */
enum class SceneMarkerQRCodeSymbolTypeMSFT {

  QrCode = XR_SCENE_MARKER_QR_CODE_SYMBOL_TYPE_QR_CODE_MSFT,

  MicroQrCode = XR_SCENE_MARKER_QR_CODE_SYMBOL_TYPE_MICRO_QR_CODE_MSFT,

};
static_assert(sizeof(SceneMarkerQRCodeSymbolTypeMSFT) == sizeof(XrSceneMarkerQRCodeSymbolTypeMSFT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneMarkerQRCodeSymbolTypeMSFT value from a
 * SceneMarkerQRCodeSymbolTypeMSFT.
 *
 * @found_by_adl
 * @see SceneMarkerQRCodeSymbolTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSceneMarkerQRCodeSymbolTypeMSFT
get(SceneMarkerQRCodeSymbolTypeMSFT const& v) {
  return static_cast<XrSceneMarkerQRCodeSymbolTypeMSFT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSceneMarkerQRCodeSymbolTypeMSFT address from a
 * SceneMarkerQRCodeSymbolTypeMSFT.
 *
 * @found_by_adl
 * @see SceneMarkerQRCodeSymbolTypeMSFT
 */
OPENXR_HPP_INLINE XrSceneMarkerQRCodeSymbolTypeMSFT* put(SceneMarkerQRCodeSymbolTypeMSFT& v) {
  return reinterpret_cast<XrSceneMarkerQRCodeSymbolTypeMSFT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SceneMarkerQRCodeSymbolTypeMSFT value as
 * a const char *.
 *
 * @found_by_adl
 * @see SceneMarkerQRCodeSymbolTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SceneMarkerQRCodeSymbolTypeMSFT value) {
  switch (value) {
    case SceneMarkerQRCodeSymbolTypeMSFT::QrCode:
      return "QrCode";

    case SceneMarkerQRCodeSymbolTypeMSFT::MicroQrCode:
      return "MicroQrCode";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SceneMarkerQRCodeSymbolTypeMSFT value as
 * a std::string.
 *
 * @found_by_adl
 * @see SceneMarkerQRCodeSymbolTypeMSFT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SceneMarkerQRCodeSymbolTypeMSFT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MSFT_scene_marker

#ifdef XR_ULTRALEAP_hand_tracking_forearm
/*!
 * @brief Enum class for XrHandForearmJointULTRALEAP
 *
 * Provided by the `XR_ULTRALEAP_hand_tracking_forearm` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandForearmJointULTRALEAP>
 *
 * @xrentity{XrHandForearmJointULTRALEAP}
 */
enum class HandForearmJointULTRALEAP {

  Palm = XR_HAND_FOREARM_JOINT_PALM_ULTRALEAP,

  Wrist = XR_HAND_FOREARM_JOINT_WRIST_ULTRALEAP,

  ThumbMetacarpal = XR_HAND_FOREARM_JOINT_THUMB_METACARPAL_ULTRALEAP,

  ThumbProximal = XR_HAND_FOREARM_JOINT_THUMB_PROXIMAL_ULTRALEAP,

  ThumbDistal = XR_HAND_FOREARM_JOINT_THUMB_DISTAL_ULTRALEAP,

  ThumbTip = XR_HAND_FOREARM_JOINT_THUMB_TIP_ULTRALEAP,

  IndexMetacarpal = XR_HAND_FOREARM_JOINT_INDEX_METACARPAL_ULTRALEAP,

  IndexProximal = XR_HAND_FOREARM_JOINT_INDEX_PROXIMAL_ULTRALEAP,

  IndexIntermediate = XR_HAND_FOREARM_JOINT_INDEX_INTERMEDIATE_ULTRALEAP,

  IndexDistal = XR_HAND_FOREARM_JOINT_INDEX_DISTAL_ULTRALEAP,

  IndexTip = XR_HAND_FOREARM_JOINT_INDEX_TIP_ULTRALEAP,

  MiddleMetacarpal = XR_HAND_FOREARM_JOINT_MIDDLE_METACARPAL_ULTRALEAP,

  MiddleProximal = XR_HAND_FOREARM_JOINT_MIDDLE_PROXIMAL_ULTRALEAP,

  MiddleIntermediate = XR_HAND_FOREARM_JOINT_MIDDLE_INTERMEDIATE_ULTRALEAP,

  MiddleDistal = XR_HAND_FOREARM_JOINT_MIDDLE_DISTAL_ULTRALEAP,

  MiddleTip = XR_HAND_FOREARM_JOINT_MIDDLE_TIP_ULTRALEAP,

  RingMetacarpal = XR_HAND_FOREARM_JOINT_RING_METACARPAL_ULTRALEAP,

  RingProximal = XR_HAND_FOREARM_JOINT_RING_PROXIMAL_ULTRALEAP,

  RingIntermediate = XR_HAND_FOREARM_JOINT_RING_INTERMEDIATE_ULTRALEAP,

  RingDistal = XR_HAND_FOREARM_JOINT_RING_DISTAL_ULTRALEAP,

  RingTip = XR_HAND_FOREARM_JOINT_RING_TIP_ULTRALEAP,

  LittleMetacarpal = XR_HAND_FOREARM_JOINT_LITTLE_METACARPAL_ULTRALEAP,

  LittleProximal = XR_HAND_FOREARM_JOINT_LITTLE_PROXIMAL_ULTRALEAP,

  LittleIntermediate = XR_HAND_FOREARM_JOINT_LITTLE_INTERMEDIATE_ULTRALEAP,

  LittleDistal = XR_HAND_FOREARM_JOINT_LITTLE_DISTAL_ULTRALEAP,

  LittleTip = XR_HAND_FOREARM_JOINT_LITTLE_TIP_ULTRALEAP,

  Elbow = XR_HAND_FOREARM_JOINT_ELBOW_ULTRALEAP,

};
static_assert(sizeof(HandForearmJointULTRALEAP) == sizeof(XrHandForearmJointULTRALEAP),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandForearmJointULTRALEAP value from a
 * HandForearmJointULTRALEAP.
 *
 * @found_by_adl
 * @see HandForearmJointULTRALEAP
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandForearmJointULTRALEAP
get(HandForearmJointULTRALEAP const& v) {
  return static_cast<XrHandForearmJointULTRALEAP>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandForearmJointULTRALEAP address from a
 * HandForearmJointULTRALEAP.
 *
 * @found_by_adl
 * @see HandForearmJointULTRALEAP
 */
OPENXR_HPP_INLINE XrHandForearmJointULTRALEAP* put(HandForearmJointULTRALEAP& v) {
  return reinterpret_cast<XrHandForearmJointULTRALEAP*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a HandForearmJointULTRALEAP value as a
 * const char *.
 *
 * @found_by_adl
 * @see HandForearmJointULTRALEAP
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    HandForearmJointULTRALEAP value) {
  switch (value) {
    case HandForearmJointULTRALEAP::Palm:
      return "Palm";

    case HandForearmJointULTRALEAP::Wrist:
      return "Wrist";

    case HandForearmJointULTRALEAP::ThumbMetacarpal:
      return "ThumbMetacarpal";

    case HandForearmJointULTRALEAP::ThumbProximal:
      return "ThumbProximal";

    case HandForearmJointULTRALEAP::ThumbDistal:
      return "ThumbDistal";

    case HandForearmJointULTRALEAP::ThumbTip:
      return "ThumbTip";

    case HandForearmJointULTRALEAP::IndexMetacarpal:
      return "IndexMetacarpal";

    case HandForearmJointULTRALEAP::IndexProximal:
      return "IndexProximal";

    case HandForearmJointULTRALEAP::IndexIntermediate:
      return "IndexIntermediate";

    case HandForearmJointULTRALEAP::IndexDistal:
      return "IndexDistal";

    case HandForearmJointULTRALEAP::IndexTip:
      return "IndexTip";

    case HandForearmJointULTRALEAP::MiddleMetacarpal:
      return "MiddleMetacarpal";

    case HandForearmJointULTRALEAP::MiddleProximal:
      return "MiddleProximal";

    case HandForearmJointULTRALEAP::MiddleIntermediate:
      return "MiddleIntermediate";

    case HandForearmJointULTRALEAP::MiddleDistal:
      return "MiddleDistal";

    case HandForearmJointULTRALEAP::MiddleTip:
      return "MiddleTip";

    case HandForearmJointULTRALEAP::RingMetacarpal:
      return "RingMetacarpal";

    case HandForearmJointULTRALEAP::RingProximal:
      return "RingProximal";

    case HandForearmJointULTRALEAP::RingIntermediate:
      return "RingIntermediate";

    case HandForearmJointULTRALEAP::RingDistal:
      return "RingDistal";

    case HandForearmJointULTRALEAP::RingTip:
      return "RingTip";

    case HandForearmJointULTRALEAP::LittleMetacarpal:
      return "LittleMetacarpal";

    case HandForearmJointULTRALEAP::LittleProximal:
      return "LittleProximal";

    case HandForearmJointULTRALEAP::LittleIntermediate:
      return "LittleIntermediate";

    case HandForearmJointULTRALEAP::LittleDistal:
      return "LittleDistal";

    case HandForearmJointULTRALEAP::LittleTip:
      return "LittleTip";

    case HandForearmJointULTRALEAP::Elbow:
      return "Elbow";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HandForearmJointULTRALEAP value as a
 * std::string.
 *
 * @found_by_adl
 * @see HandForearmJointULTRALEAP
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    HandForearmJointULTRALEAP value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ULTRALEAP_hand_tracking_forearm

#ifdef XR_FB_spatial_entity_query
/*!
 * @brief Enum class for XrSpaceQueryActionFB
 *
 * Provided by the `XR_FB_spatial_entity_query` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceQueryActionFB>
 *
 * @xrentity{XrSpaceQueryActionFB}
 */
enum class SpaceQueryActionFB {

  Load = XR_SPACE_QUERY_ACTION_LOAD_FB,

};
static_assert(sizeof(SpaceQueryActionFB) == sizeof(XrSpaceQueryActionFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpaceQueryActionFB value from a SpaceQueryActionFB.
 *
 * @found_by_adl
 * @see SpaceQueryActionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpaceQueryActionFB get(SpaceQueryActionFB const& v) {
  return static_cast<XrSpaceQueryActionFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpaceQueryActionFB address from a
 * SpaceQueryActionFB.
 *
 * @found_by_adl
 * @see SpaceQueryActionFB
 */
OPENXR_HPP_INLINE XrSpaceQueryActionFB* put(SpaceQueryActionFB& v) {
  return reinterpret_cast<XrSpaceQueryActionFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpaceQueryActionFB value as a const char
 * *.
 *
 * @found_by_adl
 * @see SpaceQueryActionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpaceQueryActionFB value) {
  switch (value) {
    case SpaceQueryActionFB::Load:
      return "Load";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpaceQueryActionFB value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpaceQueryActionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SpaceQueryActionFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_query
/*!
 * @brief Enum class for XrSpaceStorageLocationFB
 *
 * Provided by the `XR_FB_spatial_entity_query` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceStorageLocationFB>
 *
 * @xrentity{XrSpaceStorageLocationFB}
 */
enum class SpaceStorageLocationFB {

  Invalid = XR_SPACE_STORAGE_LOCATION_INVALID_FB,

  Local = XR_SPACE_STORAGE_LOCATION_LOCAL_FB,

  Cloud = XR_SPACE_STORAGE_LOCATION_CLOUD_FB,

};
static_assert(sizeof(SpaceStorageLocationFB) == sizeof(XrSpaceStorageLocationFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpaceStorageLocationFB value from a
 * SpaceStorageLocationFB.
 *
 * @found_by_adl
 * @see SpaceStorageLocationFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpaceStorageLocationFB
get(SpaceStorageLocationFB const& v) {
  return static_cast<XrSpaceStorageLocationFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpaceStorageLocationFB address from a
 * SpaceStorageLocationFB.
 *
 * @found_by_adl
 * @see SpaceStorageLocationFB
 */
OPENXR_HPP_INLINE XrSpaceStorageLocationFB* put(SpaceStorageLocationFB& v) {
  return reinterpret_cast<XrSpaceStorageLocationFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpaceStorageLocationFB value as a const
 * char *.
 *
 * @found_by_adl
 * @see SpaceStorageLocationFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpaceStorageLocationFB value) {
  switch (value) {
    case SpaceStorageLocationFB::Invalid:
      return "Invalid";

    case SpaceStorageLocationFB::Local:
      return "Local";

    case SpaceStorageLocationFB::Cloud:
      return "Cloud";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpaceStorageLocationFB value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpaceStorageLocationFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SpaceStorageLocationFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_storage
/*!
 * @brief Enum class for XrSpacePersistenceModeFB
 *
 * Provided by the `XR_FB_spatial_entity_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpacePersistenceModeFB>
 *
 * @xrentity{XrSpacePersistenceModeFB}
 */
enum class SpacePersistenceModeFB {

  Invalid = XR_SPACE_PERSISTENCE_MODE_INVALID_FB,

  Indefinite = XR_SPACE_PERSISTENCE_MODE_INDEFINITE_FB,

};
static_assert(sizeof(SpacePersistenceModeFB) == sizeof(XrSpacePersistenceModeFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpacePersistenceModeFB value from a
 * SpacePersistenceModeFB.
 *
 * @found_by_adl
 * @see SpacePersistenceModeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpacePersistenceModeFB
get(SpacePersistenceModeFB const& v) {
  return static_cast<XrSpacePersistenceModeFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpacePersistenceModeFB address from a
 * SpacePersistenceModeFB.
 *
 * @found_by_adl
 * @see SpacePersistenceModeFB
 */
OPENXR_HPP_INLINE XrSpacePersistenceModeFB* put(SpacePersistenceModeFB& v) {
  return reinterpret_cast<XrSpacePersistenceModeFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpacePersistenceModeFB value as a const
 * char *.
 *
 * @found_by_adl
 * @see SpacePersistenceModeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpacePersistenceModeFB value) {
  switch (value) {
    case SpacePersistenceModeFB::Invalid:
      return "Invalid";

    case SpacePersistenceModeFB::Indefinite:
      return "Indefinite";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpacePersistenceModeFB value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpacePersistenceModeFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SpacePersistenceModeFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_spatial_entity_storage

#ifdef XR_FB_face_tracking
/*!
 * @brief Enum class for XrFaceExpressionFB
 *
 * Provided by the `XR_FB_face_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionFB>
 *
 * @xrentity{XrFaceExpressionFB}
 */
enum class FaceExpressionFB {

  BrowLowererL = XR_FACE_EXPRESSION_BROW_LOWERER_L_FB,

  BrowLowererR = XR_FACE_EXPRESSION_BROW_LOWERER_R_FB,

  CheekPuffL = XR_FACE_EXPRESSION_CHEEK_PUFF_L_FB,

  CheekPuffR = XR_FACE_EXPRESSION_CHEEK_PUFF_R_FB,

  CheekRaiserL = XR_FACE_EXPRESSION_CHEEK_RAISER_L_FB,

  CheekRaiserR = XR_FACE_EXPRESSION_CHEEK_RAISER_R_FB,

  CheekSuckL = XR_FACE_EXPRESSION_CHEEK_SUCK_L_FB,

  CheekSuckR = XR_FACE_EXPRESSION_CHEEK_SUCK_R_FB,

  ChinRaiserB = XR_FACE_EXPRESSION_CHIN_RAISER_B_FB,

  ChinRaiserT = XR_FACE_EXPRESSION_CHIN_RAISER_T_FB,

  DimplerL = XR_FACE_EXPRESSION_DIMPLER_L_FB,

  DimplerR = XR_FACE_EXPRESSION_DIMPLER_R_FB,

  EyesClosedL = XR_FACE_EXPRESSION_EYES_CLOSED_L_FB,

  EyesClosedR = XR_FACE_EXPRESSION_EYES_CLOSED_R_FB,

  EyesLookDownL = XR_FACE_EXPRESSION_EYES_LOOK_DOWN_L_FB,

  EyesLookDownR = XR_FACE_EXPRESSION_EYES_LOOK_DOWN_R_FB,

  EyesLookLeftL = XR_FACE_EXPRESSION_EYES_LOOK_LEFT_L_FB,

  EyesLookLeftR = XR_FACE_EXPRESSION_EYES_LOOK_LEFT_R_FB,

  EyesLookRightL = XR_FACE_EXPRESSION_EYES_LOOK_RIGHT_L_FB,

  EyesLookRightR = XR_FACE_EXPRESSION_EYES_LOOK_RIGHT_R_FB,

  EyesLookUpL = XR_FACE_EXPRESSION_EYES_LOOK_UP_L_FB,

  EyesLookUpR = XR_FACE_EXPRESSION_EYES_LOOK_UP_R_FB,

  InnerBrowRaiserL = XR_FACE_EXPRESSION_INNER_BROW_RAISER_L_FB,

  InnerBrowRaiserR = XR_FACE_EXPRESSION_INNER_BROW_RAISER_R_FB,

  JawDrop = XR_FACE_EXPRESSION_JAW_DROP_FB,

  JawSidewaysLeft = XR_FACE_EXPRESSION_JAW_SIDEWAYS_LEFT_FB,

  JawSidewaysRight = XR_FACE_EXPRESSION_JAW_SIDEWAYS_RIGHT_FB,

  JawThrust = XR_FACE_EXPRESSION_JAW_THRUST_FB,

  LidTightenerL = XR_FACE_EXPRESSION_LID_TIGHTENER_L_FB,

  LidTightenerR = XR_FACE_EXPRESSION_LID_TIGHTENER_R_FB,

  LipCornerDepressorL = XR_FACE_EXPRESSION_LIP_CORNER_DEPRESSOR_L_FB,

  LipCornerDepressorR = XR_FACE_EXPRESSION_LIP_CORNER_DEPRESSOR_R_FB,

  LipCornerPullerL = XR_FACE_EXPRESSION_LIP_CORNER_PULLER_L_FB,

  LipCornerPullerR = XR_FACE_EXPRESSION_LIP_CORNER_PULLER_R_FB,

  LipFunnelerLb = XR_FACE_EXPRESSION_LIP_FUNNELER_LB_FB,

  LipFunnelerLt = XR_FACE_EXPRESSION_LIP_FUNNELER_LT_FB,

  LipFunnelerRb = XR_FACE_EXPRESSION_LIP_FUNNELER_RB_FB,

  LipFunnelerRt = XR_FACE_EXPRESSION_LIP_FUNNELER_RT_FB,

  LipPressorL = XR_FACE_EXPRESSION_LIP_PRESSOR_L_FB,

  LipPressorR = XR_FACE_EXPRESSION_LIP_PRESSOR_R_FB,

  LipPuckerL = XR_FACE_EXPRESSION_LIP_PUCKER_L_FB,

  LipPuckerR = XR_FACE_EXPRESSION_LIP_PUCKER_R_FB,

  LipStretcherL = XR_FACE_EXPRESSION_LIP_STRETCHER_L_FB,

  LipStretcherR = XR_FACE_EXPRESSION_LIP_STRETCHER_R_FB,

  LipSuckLb = XR_FACE_EXPRESSION_LIP_SUCK_LB_FB,

  LipSuckLt = XR_FACE_EXPRESSION_LIP_SUCK_LT_FB,

  LipSuckRb = XR_FACE_EXPRESSION_LIP_SUCK_RB_FB,

  LipSuckRt = XR_FACE_EXPRESSION_LIP_SUCK_RT_FB,

  LipTightenerL = XR_FACE_EXPRESSION_LIP_TIGHTENER_L_FB,

  LipTightenerR = XR_FACE_EXPRESSION_LIP_TIGHTENER_R_FB,

  LipsToward = XR_FACE_EXPRESSION_LIPS_TOWARD_FB,

  LowerLipDepressorL = XR_FACE_EXPRESSION_LOWER_LIP_DEPRESSOR_L_FB,

  LowerLipDepressorR = XR_FACE_EXPRESSION_LOWER_LIP_DEPRESSOR_R_FB,

  MouthLeft = XR_FACE_EXPRESSION_MOUTH_LEFT_FB,

  MouthRight = XR_FACE_EXPRESSION_MOUTH_RIGHT_FB,

  NoseWrinklerL = XR_FACE_EXPRESSION_NOSE_WRINKLER_L_FB,

  NoseWrinklerR = XR_FACE_EXPRESSION_NOSE_WRINKLER_R_FB,

  OuterBrowRaiserL = XR_FACE_EXPRESSION_OUTER_BROW_RAISER_L_FB,

  OuterBrowRaiserR = XR_FACE_EXPRESSION_OUTER_BROW_RAISER_R_FB,

  UpperLidRaiserL = XR_FACE_EXPRESSION_UPPER_LID_RAISER_L_FB,

  UpperLidRaiserR = XR_FACE_EXPRESSION_UPPER_LID_RAISER_R_FB,

  UpperLipRaiserL = XR_FACE_EXPRESSION_UPPER_LIP_RAISER_L_FB,

  UpperLipRaiserR = XR_FACE_EXPRESSION_UPPER_LIP_RAISER_R_FB,

  Count = XR_FACE_EXPRESSION_COUNT_FB,

};
static_assert(sizeof(FaceExpressionFB) == sizeof(XrFaceExpressionFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceExpressionFB value from a FaceExpressionFB.
 *
 * @found_by_adl
 * @see FaceExpressionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFaceExpressionFB get(FaceExpressionFB const& v) {
  return static_cast<XrFaceExpressionFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceExpressionFB address from a FaceExpressionFB.
 *
 * @found_by_adl
 * @see FaceExpressionFB
 */
OPENXR_HPP_INLINE XrFaceExpressionFB* put(FaceExpressionFB& v) {
  return reinterpret_cast<XrFaceExpressionFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FaceExpressionFB value as a const char
 * *.
 *
 * @found_by_adl
 * @see FaceExpressionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FaceExpressionFB value) {
  switch (value) {
    case FaceExpressionFB::BrowLowererL:
      return "BrowLowererL";

    case FaceExpressionFB::BrowLowererR:
      return "BrowLowererR";

    case FaceExpressionFB::CheekPuffL:
      return "CheekPuffL";

    case FaceExpressionFB::CheekPuffR:
      return "CheekPuffR";

    case FaceExpressionFB::CheekRaiserL:
      return "CheekRaiserL";

    case FaceExpressionFB::CheekRaiserR:
      return "CheekRaiserR";

    case FaceExpressionFB::CheekSuckL:
      return "CheekSuckL";

    case FaceExpressionFB::CheekSuckR:
      return "CheekSuckR";

    case FaceExpressionFB::ChinRaiserB:
      return "ChinRaiserB";

    case FaceExpressionFB::ChinRaiserT:
      return "ChinRaiserT";

    case FaceExpressionFB::DimplerL:
      return "DimplerL";

    case FaceExpressionFB::DimplerR:
      return "DimplerR";

    case FaceExpressionFB::EyesClosedL:
      return "EyesClosedL";

    case FaceExpressionFB::EyesClosedR:
      return "EyesClosedR";

    case FaceExpressionFB::EyesLookDownL:
      return "EyesLookDownL";

    case FaceExpressionFB::EyesLookDownR:
      return "EyesLookDownR";

    case FaceExpressionFB::EyesLookLeftL:
      return "EyesLookLeftL";

    case FaceExpressionFB::EyesLookLeftR:
      return "EyesLookLeftR";

    case FaceExpressionFB::EyesLookRightL:
      return "EyesLookRightL";

    case FaceExpressionFB::EyesLookRightR:
      return "EyesLookRightR";

    case FaceExpressionFB::EyesLookUpL:
      return "EyesLookUpL";

    case FaceExpressionFB::EyesLookUpR:
      return "EyesLookUpR";

    case FaceExpressionFB::InnerBrowRaiserL:
      return "InnerBrowRaiserL";

    case FaceExpressionFB::InnerBrowRaiserR:
      return "InnerBrowRaiserR";

    case FaceExpressionFB::JawDrop:
      return "JawDrop";

    case FaceExpressionFB::JawSidewaysLeft:
      return "JawSidewaysLeft";

    case FaceExpressionFB::JawSidewaysRight:
      return "JawSidewaysRight";

    case FaceExpressionFB::JawThrust:
      return "JawThrust";

    case FaceExpressionFB::LidTightenerL:
      return "LidTightenerL";

    case FaceExpressionFB::LidTightenerR:
      return "LidTightenerR";

    case FaceExpressionFB::LipCornerDepressorL:
      return "LipCornerDepressorL";

    case FaceExpressionFB::LipCornerDepressorR:
      return "LipCornerDepressorR";

    case FaceExpressionFB::LipCornerPullerL:
      return "LipCornerPullerL";

    case FaceExpressionFB::LipCornerPullerR:
      return "LipCornerPullerR";

    case FaceExpressionFB::LipFunnelerLb:
      return "LipFunnelerLb";

    case FaceExpressionFB::LipFunnelerLt:
      return "LipFunnelerLt";

    case FaceExpressionFB::LipFunnelerRb:
      return "LipFunnelerRb";

    case FaceExpressionFB::LipFunnelerRt:
      return "LipFunnelerRt";

    case FaceExpressionFB::LipPressorL:
      return "LipPressorL";

    case FaceExpressionFB::LipPressorR:
      return "LipPressorR";

    case FaceExpressionFB::LipPuckerL:
      return "LipPuckerL";

    case FaceExpressionFB::LipPuckerR:
      return "LipPuckerR";

    case FaceExpressionFB::LipStretcherL:
      return "LipStretcherL";

    case FaceExpressionFB::LipStretcherR:
      return "LipStretcherR";

    case FaceExpressionFB::LipSuckLb:
      return "LipSuckLb";

    case FaceExpressionFB::LipSuckLt:
      return "LipSuckLt";

    case FaceExpressionFB::LipSuckRb:
      return "LipSuckRb";

    case FaceExpressionFB::LipSuckRt:
      return "LipSuckRt";

    case FaceExpressionFB::LipTightenerL:
      return "LipTightenerL";

    case FaceExpressionFB::LipTightenerR:
      return "LipTightenerR";

    case FaceExpressionFB::LipsToward:
      return "LipsToward";

    case FaceExpressionFB::LowerLipDepressorL:
      return "LowerLipDepressorL";

    case FaceExpressionFB::LowerLipDepressorR:
      return "LowerLipDepressorR";

    case FaceExpressionFB::MouthLeft:
      return "MouthLeft";

    case FaceExpressionFB::MouthRight:
      return "MouthRight";

    case FaceExpressionFB::NoseWrinklerL:
      return "NoseWrinklerL";

    case FaceExpressionFB::NoseWrinklerR:
      return "NoseWrinklerR";

    case FaceExpressionFB::OuterBrowRaiserL:
      return "OuterBrowRaiserL";

    case FaceExpressionFB::OuterBrowRaiserR:
      return "OuterBrowRaiserR";

    case FaceExpressionFB::UpperLidRaiserL:
      return "UpperLidRaiserL";

    case FaceExpressionFB::UpperLidRaiserR:
      return "UpperLidRaiserR";

    case FaceExpressionFB::UpperLipRaiserL:
      return "UpperLipRaiserL";

    case FaceExpressionFB::UpperLipRaiserR:
      return "UpperLipRaiserR";

    case FaceExpressionFB::Count:
      return "Count";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FaceExpressionFB value as a std::string.
 *
 * @found_by_adl
 * @see FaceExpressionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FaceExpressionFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_face_tracking

#ifdef XR_FB_face_tracking
/*!
 * @brief Enum class for XrFaceExpressionSetFB
 *
 * Provided by the `XR_FB_face_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionSetFB>
 *
 * @xrentity{XrFaceExpressionSetFB}
 */
enum class FaceExpressionSetFB {

  Default = XR_FACE_EXPRESSION_SET_DEFAULT_FB,

};
static_assert(sizeof(FaceExpressionSetFB) == sizeof(XrFaceExpressionSetFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceExpressionSetFB value from a
 * FaceExpressionSetFB.
 *
 * @found_by_adl
 * @see FaceExpressionSetFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFaceExpressionSetFB get(FaceExpressionSetFB const& v) {
  return static_cast<XrFaceExpressionSetFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceExpressionSetFB address from a
 * FaceExpressionSetFB.
 *
 * @found_by_adl
 * @see FaceExpressionSetFB
 */
OPENXR_HPP_INLINE XrFaceExpressionSetFB* put(FaceExpressionSetFB& v) {
  return reinterpret_cast<XrFaceExpressionSetFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FaceExpressionSetFB value as a const
 * char *.
 *
 * @found_by_adl
 * @see FaceExpressionSetFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FaceExpressionSetFB value) {
  switch (value) {
    case FaceExpressionSetFB::Default:
      return "Default";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FaceExpressionSetFB value as a
 * std::string.
 *
 * @found_by_adl
 * @see FaceExpressionSetFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FaceExpressionSetFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_face_tracking

#ifdef XR_FB_face_tracking
/*!
 * @brief Enum class for XrFaceConfidenceFB
 *
 * Provided by the `XR_FB_face_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceConfidenceFB>
 *
 * @xrentity{XrFaceConfidenceFB}
 */
enum class FaceConfidenceFB {

  LowerFace = XR_FACE_CONFIDENCE_LOWER_FACE_FB,

  UpperFace = XR_FACE_CONFIDENCE_UPPER_FACE_FB,

  Count = XR_FACE_CONFIDENCE_COUNT_FB,

};
static_assert(sizeof(FaceConfidenceFB) == sizeof(XrFaceConfidenceFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceConfidenceFB value from a FaceConfidenceFB.
 *
 * @found_by_adl
 * @see FaceConfidenceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFaceConfidenceFB get(FaceConfidenceFB const& v) {
  return static_cast<XrFaceConfidenceFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceConfidenceFB address from a FaceConfidenceFB.
 *
 * @found_by_adl
 * @see FaceConfidenceFB
 */
OPENXR_HPP_INLINE XrFaceConfidenceFB* put(FaceConfidenceFB& v) {
  return reinterpret_cast<XrFaceConfidenceFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FaceConfidenceFB value as a const char
 * *.
 *
 * @found_by_adl
 * @see FaceConfidenceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FaceConfidenceFB value) {
  switch (value) {
    case FaceConfidenceFB::LowerFace:
      return "LowerFace";

    case FaceConfidenceFB::UpperFace:
      return "UpperFace";

    case FaceConfidenceFB::Count:
      return "Count";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FaceConfidenceFB value as a std::string.
 *
 * @found_by_adl
 * @see FaceConfidenceFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FaceConfidenceFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_face_tracking

#ifdef XR_FB_eye_tracking_social
/*!
 * @brief Enum class for XrEyePositionFB
 *
 * Provided by the `XR_FB_eye_tracking_social` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyePositionFB>
 *
 * @xrentity{XrEyePositionFB}
 */
enum class EyePositionFB {

  Left = XR_EYE_POSITION_LEFT_FB,

  Right = XR_EYE_POSITION_RIGHT_FB,

  Count = XR_EYE_POSITION_COUNT_FB,

};
static_assert(sizeof(EyePositionFB) == sizeof(XrEyePositionFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyePositionFB value from a EyePositionFB.
 *
 * @found_by_adl
 * @see EyePositionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEyePositionFB get(EyePositionFB const& v) {
  return static_cast<XrEyePositionFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyePositionFB address from a EyePositionFB.
 *
 * @found_by_adl
 * @see EyePositionFB
 */
OPENXR_HPP_INLINE XrEyePositionFB* put(EyePositionFB& v) {
  return reinterpret_cast<XrEyePositionFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a EyePositionFB value as a const char *.
 *
 * @found_by_adl
 * @see EyePositionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(EyePositionFB value) {
  switch (value) {
    case EyePositionFB::Left:
      return "Left";

    case EyePositionFB::Right:
      return "Right";

    case EyePositionFB::Count:
      return "Count";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a EyePositionFB value as a std::string.
 *
 * @found_by_adl
 * @see EyePositionFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EyePositionFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_eye_tracking_social

#ifdef XR_FB_composition_layer_depth_test
/*!
 * @brief Enum class for XrCompareOpFB
 *
 * Provided by the `XR_FB_composition_layer_depth_test` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompareOpFB>
 *
 * @xrentity{XrCompareOpFB}
 */
enum class CompareOpFB {

  Never = XR_COMPARE_OP_NEVER_FB,

  Less = XR_COMPARE_OP_LESS_FB,

  Equal = XR_COMPARE_OP_EQUAL_FB,

  LessOrEqual = XR_COMPARE_OP_LESS_OR_EQUAL_FB,

  Greater = XR_COMPARE_OP_GREATER_FB,

  NotEqual = XR_COMPARE_OP_NOT_EQUAL_FB,

  GreaterOrEqual = XR_COMPARE_OP_GREATER_OR_EQUAL_FB,

  Always = XR_COMPARE_OP_ALWAYS_FB,

};
static_assert(sizeof(CompareOpFB) == sizeof(XrCompareOpFB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrCompareOpFB value from a CompareOpFB.
 *
 * @found_by_adl
 * @see CompareOpFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrCompareOpFB get(CompareOpFB const& v) {
  return static_cast<XrCompareOpFB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrCompareOpFB address from a CompareOpFB.
 *
 * @found_by_adl
 * @see CompareOpFB
 */
OPENXR_HPP_INLINE XrCompareOpFB* put(CompareOpFB& v) {
  return reinterpret_cast<XrCompareOpFB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a CompareOpFB value as a const char *.
 *
 * @found_by_adl
 * @see CompareOpFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(CompareOpFB value) {
  switch (value) {
    case CompareOpFB::Never:
      return "Never";

    case CompareOpFB::Less:
      return "Less";

    case CompareOpFB::Equal:
      return "Equal";

    case CompareOpFB::LessOrEqual:
      return "LessOrEqual";

    case CompareOpFB::Greater:
      return "Greater";

    case CompareOpFB::NotEqual:
      return "NotEqual";

    case CompareOpFB::GreaterOrEqual:
      return "GreaterOrEqual";

    case CompareOpFB::Always:
      return "Always";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a CompareOpFB value as a std::string.
 *
 * @found_by_adl
 * @see CompareOpFB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(CompareOpFB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_composition_layer_depth_test

#ifdef XR_META_local_dimming
/*!
 * @brief Enum class for XrLocalDimmingModeMETA
 *
 * Provided by the `XR_META_local_dimming` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLocalDimmingModeMETA>
 *
 * @xrentity{XrLocalDimmingModeMETA}
 */
enum class LocalDimmingModeMETA {

  Off = XR_LOCAL_DIMMING_MODE_OFF_META,

  On = XR_LOCAL_DIMMING_MODE_ON_META,

};
static_assert(sizeof(LocalDimmingModeMETA) == sizeof(XrLocalDimmingModeMETA),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLocalDimmingModeMETA value from a
 * LocalDimmingModeMETA.
 *
 * @found_by_adl
 * @see LocalDimmingModeMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrLocalDimmingModeMETA get(LocalDimmingModeMETA const& v) {
  return static_cast<XrLocalDimmingModeMETA>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrLocalDimmingModeMETA address from a
 * LocalDimmingModeMETA.
 *
 * @found_by_adl
 * @see LocalDimmingModeMETA
 */
OPENXR_HPP_INLINE XrLocalDimmingModeMETA* put(LocalDimmingModeMETA& v) {
  return reinterpret_cast<XrLocalDimmingModeMETA*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a LocalDimmingModeMETA value as a const
 * char *.
 *
 * @found_by_adl
 * @see LocalDimmingModeMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    LocalDimmingModeMETA value) {
  switch (value) {
    case LocalDimmingModeMETA::Off:
      return "Off";

    case LocalDimmingModeMETA::On:
      return "On";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a LocalDimmingModeMETA value as a
 * std::string.
 *
 * @found_by_adl
 * @see LocalDimmingModeMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(LocalDimmingModeMETA value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_META_local_dimming

#ifdef XR_META_virtual_keyboard
/*!
 * @brief Enum class for XrVirtualKeyboardLocationTypeMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardLocationTypeMETA>
 *
 * @xrentity{XrVirtualKeyboardLocationTypeMETA}
 */
enum class VirtualKeyboardLocationTypeMETA {

  Custom = XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_CUSTOM_META,

  Far = XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_FAR_META,

  Direct = XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_DIRECT_META,

};
static_assert(sizeof(VirtualKeyboardLocationTypeMETA) == sizeof(XrVirtualKeyboardLocationTypeMETA),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrVirtualKeyboardLocationTypeMETA value from a
 * VirtualKeyboardLocationTypeMETA.
 *
 * @found_by_adl
 * @see VirtualKeyboardLocationTypeMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrVirtualKeyboardLocationTypeMETA
get(VirtualKeyboardLocationTypeMETA const& v) {
  return static_cast<XrVirtualKeyboardLocationTypeMETA>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrVirtualKeyboardLocationTypeMETA address from a
 * VirtualKeyboardLocationTypeMETA.
 *
 * @found_by_adl
 * @see VirtualKeyboardLocationTypeMETA
 */
OPENXR_HPP_INLINE XrVirtualKeyboardLocationTypeMETA* put(VirtualKeyboardLocationTypeMETA& v) {
  return reinterpret_cast<XrVirtualKeyboardLocationTypeMETA*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a VirtualKeyboardLocationTypeMETA value as
 * a const char *.
 *
 * @found_by_adl
 * @see VirtualKeyboardLocationTypeMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    VirtualKeyboardLocationTypeMETA value) {
  switch (value) {
    case VirtualKeyboardLocationTypeMETA::Custom:
      return "Custom";

    case VirtualKeyboardLocationTypeMETA::Far:
      return "Far";

    case VirtualKeyboardLocationTypeMETA::Direct:
      return "Direct";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a VirtualKeyboardLocationTypeMETA value as
 * a std::string.
 *
 * @found_by_adl
 * @see VirtualKeyboardLocationTypeMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    VirtualKeyboardLocationTypeMETA value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * @brief Enum class for XrVirtualKeyboardInputSourceMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardInputSourceMETA>
 *
 * @xrentity{XrVirtualKeyboardInputSourceMETA}
 */
enum class VirtualKeyboardInputSourceMETA {

  ControllerRayLeft = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_RAY_LEFT_META,

  ControllerRayRight = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_RAY_RIGHT_META,

  HandRayLeft = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_RAY_LEFT_META,

  HandRayRight = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_RAY_RIGHT_META,

  ControllerDirectLeft = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_DIRECT_LEFT_META,

  ControllerDirectRight = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_DIRECT_RIGHT_META,

  HandDirectIndexTipLeft = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_DIRECT_INDEX_TIP_LEFT_META,

  HandDirectIndexTipRight = XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_DIRECT_INDEX_TIP_RIGHT_META,

};
static_assert(sizeof(VirtualKeyboardInputSourceMETA) == sizeof(XrVirtualKeyboardInputSourceMETA),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrVirtualKeyboardInputSourceMETA value from a
 * VirtualKeyboardInputSourceMETA.
 *
 * @found_by_adl
 * @see VirtualKeyboardInputSourceMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrVirtualKeyboardInputSourceMETA
get(VirtualKeyboardInputSourceMETA const& v) {
  return static_cast<XrVirtualKeyboardInputSourceMETA>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrVirtualKeyboardInputSourceMETA address from a
 * VirtualKeyboardInputSourceMETA.
 *
 * @found_by_adl
 * @see VirtualKeyboardInputSourceMETA
 */
OPENXR_HPP_INLINE XrVirtualKeyboardInputSourceMETA* put(VirtualKeyboardInputSourceMETA& v) {
  return reinterpret_cast<XrVirtualKeyboardInputSourceMETA*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a VirtualKeyboardInputSourceMETA value as
 * a const char *.
 *
 * @found_by_adl
 * @see VirtualKeyboardInputSourceMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    VirtualKeyboardInputSourceMETA value) {
  switch (value) {
    case VirtualKeyboardInputSourceMETA::ControllerRayLeft:
      return "ControllerRayLeft";

    case VirtualKeyboardInputSourceMETA::ControllerRayRight:
      return "ControllerRayRight";

    case VirtualKeyboardInputSourceMETA::HandRayLeft:
      return "HandRayLeft";

    case VirtualKeyboardInputSourceMETA::HandRayRight:
      return "HandRayRight";

    case VirtualKeyboardInputSourceMETA::ControllerDirectLeft:
      return "ControllerDirectLeft";

    case VirtualKeyboardInputSourceMETA::ControllerDirectRight:
      return "ControllerDirectRight";

    case VirtualKeyboardInputSourceMETA::HandDirectIndexTipLeft:
      return "HandDirectIndexTipLeft";

    case VirtualKeyboardInputSourceMETA::HandDirectIndexTipRight:
      return "HandDirectIndexTipRight";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a VirtualKeyboardInputSourceMETA value as
 * a std::string.
 *
 * @found_by_adl
 * @see VirtualKeyboardInputSourceMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    VirtualKeyboardInputSourceMETA value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_META_virtual_keyboard

#ifdef XR_OCULUS_external_camera
/*!
 * @brief Enum class for XrExternalCameraAttachedToDeviceOCULUS
 *
 * Provided by the `XR_OCULUS_external_camera` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExternalCameraAttachedToDeviceOCULUS>
 *
 * @xrentity{XrExternalCameraAttachedToDeviceOCULUS}
 */
enum class ExternalCameraAttachedToDeviceOCULUS {

  None = XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_NONE_OCULUS,

  Hmd = XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_HMD_OCULUS,

  Ltouch = XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_LTOUCH_OCULUS,

  Rtouch = XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_RTOUCH_OCULUS,

};
static_assert(sizeof(ExternalCameraAttachedToDeviceOCULUS) ==
                  sizeof(XrExternalCameraAttachedToDeviceOCULUS),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrExternalCameraAttachedToDeviceOCULUS value from a
 * ExternalCameraAttachedToDeviceOCULUS.
 *
 * @found_by_adl
 * @see ExternalCameraAttachedToDeviceOCULUS
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrExternalCameraAttachedToDeviceOCULUS
get(ExternalCameraAttachedToDeviceOCULUS const& v) {
  return static_cast<XrExternalCameraAttachedToDeviceOCULUS>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrExternalCameraAttachedToDeviceOCULUS address from a
 * ExternalCameraAttachedToDeviceOCULUS.
 *
 * @found_by_adl
 * @see ExternalCameraAttachedToDeviceOCULUS
 */
OPENXR_HPP_INLINE XrExternalCameraAttachedToDeviceOCULUS* put(
    ExternalCameraAttachedToDeviceOCULUS& v) {
  return reinterpret_cast<XrExternalCameraAttachedToDeviceOCULUS*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a ExternalCameraAttachedToDeviceOCULUS
 * value as a const char *.
 *
 * @found_by_adl
 * @see ExternalCameraAttachedToDeviceOCULUS
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    ExternalCameraAttachedToDeviceOCULUS value) {
  switch (value) {
    case ExternalCameraAttachedToDeviceOCULUS::None:
      return "None";

    case ExternalCameraAttachedToDeviceOCULUS::Hmd:
      return "Hmd";

    case ExternalCameraAttachedToDeviceOCULUS::Ltouch:
      return "Ltouch";

    case ExternalCameraAttachedToDeviceOCULUS::Rtouch:
      return "Rtouch";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ExternalCameraAttachedToDeviceOCULUS
 * value as a std::string.
 *
 * @found_by_adl
 * @see ExternalCameraAttachedToDeviceOCULUS
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    ExternalCameraAttachedToDeviceOCULUS value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_OCULUS_external_camera

#ifdef XR_META_performance_metrics
/*!
 * @brief Enum class for XrPerformanceMetricsCounterUnitMETA
 *
 * Provided by the `XR_META_performance_metrics` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerformanceMetricsCounterUnitMETA>
 *
 * @xrentity{XrPerformanceMetricsCounterUnitMETA}
 */
enum class PerformanceMetricsCounterUnitMETA {

  Generic = XR_PERFORMANCE_METRICS_COUNTER_UNIT_GENERIC_META,

  Percentage = XR_PERFORMANCE_METRICS_COUNTER_UNIT_PERCENTAGE_META,

  Milliseconds = XR_PERFORMANCE_METRICS_COUNTER_UNIT_MILLISECONDS_META,

  Bytes = XR_PERFORMANCE_METRICS_COUNTER_UNIT_BYTES_META,

  Hertz = XR_PERFORMANCE_METRICS_COUNTER_UNIT_HERTZ_META,

};
static_assert(sizeof(PerformanceMetricsCounterUnitMETA) ==
                  sizeof(XrPerformanceMetricsCounterUnitMETA),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerformanceMetricsCounterUnitMETA value from a
 * PerformanceMetricsCounterUnitMETA.
 *
 * @found_by_adl
 * @see PerformanceMetricsCounterUnitMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPerformanceMetricsCounterUnitMETA
get(PerformanceMetricsCounterUnitMETA const& v) {
  return static_cast<XrPerformanceMetricsCounterUnitMETA>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPerformanceMetricsCounterUnitMETA address from a
 * PerformanceMetricsCounterUnitMETA.
 *
 * @found_by_adl
 * @see PerformanceMetricsCounterUnitMETA
 */
OPENXR_HPP_INLINE XrPerformanceMetricsCounterUnitMETA* put(PerformanceMetricsCounterUnitMETA& v) {
  return reinterpret_cast<XrPerformanceMetricsCounterUnitMETA*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PerformanceMetricsCounterUnitMETA value
 * as a const char *.
 *
 * @found_by_adl
 * @see PerformanceMetricsCounterUnitMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PerformanceMetricsCounterUnitMETA value) {
  switch (value) {
    case PerformanceMetricsCounterUnitMETA::Generic:
      return "Generic";

    case PerformanceMetricsCounterUnitMETA::Percentage:
      return "Percentage";

    case PerformanceMetricsCounterUnitMETA::Milliseconds:
      return "Milliseconds";

    case PerformanceMetricsCounterUnitMETA::Bytes:
      return "Bytes";

    case PerformanceMetricsCounterUnitMETA::Hertz:
      return "Hertz";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PerformanceMetricsCounterUnitMETA value
 * as a std::string.
 *
 * @found_by_adl
 * @see PerformanceMetricsCounterUnitMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    PerformanceMetricsCounterUnitMETA value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_META_performance_metrics

#ifdef XR_META_passthrough_color_lut
/*!
 * @brief Enum class for XrPassthroughColorLutChannelsMETA
 *
 * Provided by the `XR_META_passthrough_color_lut` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorLutChannelsMETA>
 *
 * @xrentity{XrPassthroughColorLutChannelsMETA}
 */
enum class PassthroughColorLutChannelsMETA {

  RGB = XR_PASSTHROUGH_COLOR_LUT_CHANNELS_RGB_META,

  Rgba = XR_PASSTHROUGH_COLOR_LUT_CHANNELS_RGBA_META,

};
static_assert(sizeof(PassthroughColorLutChannelsMETA) == sizeof(XrPassthroughColorLutChannelsMETA),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPassthroughColorLutChannelsMETA value from a
 * PassthroughColorLutChannelsMETA.
 *
 * @found_by_adl
 * @see PassthroughColorLutChannelsMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPassthroughColorLutChannelsMETA
get(PassthroughColorLutChannelsMETA const& v) {
  return static_cast<XrPassthroughColorLutChannelsMETA>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPassthroughColorLutChannelsMETA address from a
 * PassthroughColorLutChannelsMETA.
 *
 * @found_by_adl
 * @see PassthroughColorLutChannelsMETA
 */
OPENXR_HPP_INLINE XrPassthroughColorLutChannelsMETA* put(PassthroughColorLutChannelsMETA& v) {
  return reinterpret_cast<XrPassthroughColorLutChannelsMETA*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughColorLutChannelsMETA value as
 * a const char *.
 *
 * @found_by_adl
 * @see PassthroughColorLutChannelsMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PassthroughColorLutChannelsMETA value) {
  switch (value) {
    case PassthroughColorLutChannelsMETA::RGB:
      return "RGB";

    case PassthroughColorLutChannelsMETA::Rgba:
      return "Rgba";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughColorLutChannelsMETA value as
 * a std::string.
 *
 * @found_by_adl
 * @see PassthroughColorLutChannelsMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    PassthroughColorLutChannelsMETA value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_META_passthrough_color_lut

#ifdef XR_META_body_tracking_full_body
/*!
 * @brief Enum class for XrFullBodyJointMETA
 *
 * Provided by the `XR_META_body_tracking_full_body` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFullBodyJointMETA>
 *
 * @xrentity{XrFullBodyJointMETA}
 */
enum class FullBodyJointMETA {

  Root = XR_FULL_BODY_JOINT_ROOT_META,

  Hips = XR_FULL_BODY_JOINT_HIPS_META,

  SpineLower = XR_FULL_BODY_JOINT_SPINE_LOWER_META,

  SpineMiddle = XR_FULL_BODY_JOINT_SPINE_MIDDLE_META,

  SpineUpper = XR_FULL_BODY_JOINT_SPINE_UPPER_META,

  Chest = XR_FULL_BODY_JOINT_CHEST_META,

  Neck = XR_FULL_BODY_JOINT_NECK_META,

  Head = XR_FULL_BODY_JOINT_HEAD_META,

  LeftShoulder = XR_FULL_BODY_JOINT_LEFT_SHOULDER_META,

  LeftScapula = XR_FULL_BODY_JOINT_LEFT_SCAPULA_META,

  LeftArmUpper = XR_FULL_BODY_JOINT_LEFT_ARM_UPPER_META,

  LeftArmLower = XR_FULL_BODY_JOINT_LEFT_ARM_LOWER_META,

  LeftHandWristTwist = XR_FULL_BODY_JOINT_LEFT_HAND_WRIST_TWIST_META,

  RightShoulder = XR_FULL_BODY_JOINT_RIGHT_SHOULDER_META,

  RightScapula = XR_FULL_BODY_JOINT_RIGHT_SCAPULA_META,

  RightArmUpper = XR_FULL_BODY_JOINT_RIGHT_ARM_UPPER_META,

  RightArmLower = XR_FULL_BODY_JOINT_RIGHT_ARM_LOWER_META,

  RightHandWristTwist = XR_FULL_BODY_JOINT_RIGHT_HAND_WRIST_TWIST_META,

  LeftHandPalm = XR_FULL_BODY_JOINT_LEFT_HAND_PALM_META,

  LeftHandWrist = XR_FULL_BODY_JOINT_LEFT_HAND_WRIST_META,

  LeftHandThumbMetacarpal = XR_FULL_BODY_JOINT_LEFT_HAND_THUMB_METACARPAL_META,

  LeftHandThumbProximal = XR_FULL_BODY_JOINT_LEFT_HAND_THUMB_PROXIMAL_META,

  LeftHandThumbDistal = XR_FULL_BODY_JOINT_LEFT_HAND_THUMB_DISTAL_META,

  LeftHandThumbTip = XR_FULL_BODY_JOINT_LEFT_HAND_THUMB_TIP_META,

  LeftHandIndexMetacarpal = XR_FULL_BODY_JOINT_LEFT_HAND_INDEX_METACARPAL_META,

  LeftHandIndexProximal = XR_FULL_BODY_JOINT_LEFT_HAND_INDEX_PROXIMAL_META,

  LeftHandIndexIntermediate = XR_FULL_BODY_JOINT_LEFT_HAND_INDEX_INTERMEDIATE_META,

  LeftHandIndexDistal = XR_FULL_BODY_JOINT_LEFT_HAND_INDEX_DISTAL_META,

  LeftHandIndexTip = XR_FULL_BODY_JOINT_LEFT_HAND_INDEX_TIP_META,

  LeftHandMiddleMetacarpal = XR_FULL_BODY_JOINT_LEFT_HAND_MIDDLE_METACARPAL_META,

  LeftHandMiddleProximal = XR_FULL_BODY_JOINT_LEFT_HAND_MIDDLE_PROXIMAL_META,

  LeftHandMiddleIntermediate = XR_FULL_BODY_JOINT_LEFT_HAND_MIDDLE_INTERMEDIATE_META,

  LeftHandMiddleDistal = XR_FULL_BODY_JOINT_LEFT_HAND_MIDDLE_DISTAL_META,

  LeftHandMiddleTip = XR_FULL_BODY_JOINT_LEFT_HAND_MIDDLE_TIP_META,

  LeftHandRingMetacarpal = XR_FULL_BODY_JOINT_LEFT_HAND_RING_METACARPAL_META,

  LeftHandRingProximal = XR_FULL_BODY_JOINT_LEFT_HAND_RING_PROXIMAL_META,

  LeftHandRingIntermediate = XR_FULL_BODY_JOINT_LEFT_HAND_RING_INTERMEDIATE_META,

  LeftHandRingDistal = XR_FULL_BODY_JOINT_LEFT_HAND_RING_DISTAL_META,

  LeftHandRingTip = XR_FULL_BODY_JOINT_LEFT_HAND_RING_TIP_META,

  LeftHandLittleMetacarpal = XR_FULL_BODY_JOINT_LEFT_HAND_LITTLE_METACARPAL_META,

  LeftHandLittleProximal = XR_FULL_BODY_JOINT_LEFT_HAND_LITTLE_PROXIMAL_META,

  LeftHandLittleIntermediate = XR_FULL_BODY_JOINT_LEFT_HAND_LITTLE_INTERMEDIATE_META,

  LeftHandLittleDistal = XR_FULL_BODY_JOINT_LEFT_HAND_LITTLE_DISTAL_META,

  LeftHandLittleTip = XR_FULL_BODY_JOINT_LEFT_HAND_LITTLE_TIP_META,

  RightHandPalm = XR_FULL_BODY_JOINT_RIGHT_HAND_PALM_META,

  RightHandWrist = XR_FULL_BODY_JOINT_RIGHT_HAND_WRIST_META,

  RightHandThumbMetacarpal = XR_FULL_BODY_JOINT_RIGHT_HAND_THUMB_METACARPAL_META,

  RightHandThumbProximal = XR_FULL_BODY_JOINT_RIGHT_HAND_THUMB_PROXIMAL_META,

  RightHandThumbDistal = XR_FULL_BODY_JOINT_RIGHT_HAND_THUMB_DISTAL_META,

  RightHandThumbTip = XR_FULL_BODY_JOINT_RIGHT_HAND_THUMB_TIP_META,

  RightHandIndexMetacarpal = XR_FULL_BODY_JOINT_RIGHT_HAND_INDEX_METACARPAL_META,

  RightHandIndexProximal = XR_FULL_BODY_JOINT_RIGHT_HAND_INDEX_PROXIMAL_META,

  RightHandIndexIntermediate = XR_FULL_BODY_JOINT_RIGHT_HAND_INDEX_INTERMEDIATE_META,

  RightHandIndexDistal = XR_FULL_BODY_JOINT_RIGHT_HAND_INDEX_DISTAL_META,

  RightHandIndexTip = XR_FULL_BODY_JOINT_RIGHT_HAND_INDEX_TIP_META,

  RightHandMiddleMetacarpal = XR_FULL_BODY_JOINT_RIGHT_HAND_MIDDLE_METACARPAL_META,

  RightHandMiddleProximal = XR_FULL_BODY_JOINT_RIGHT_HAND_MIDDLE_PROXIMAL_META,

  RightHandMiddleIntermediate = XR_FULL_BODY_JOINT_RIGHT_HAND_MIDDLE_INTERMEDIATE_META,

  RightHandMiddleDistal = XR_FULL_BODY_JOINT_RIGHT_HAND_MIDDLE_DISTAL_META,

  RightHandMiddleTip = XR_FULL_BODY_JOINT_RIGHT_HAND_MIDDLE_TIP_META,

  RightHandRingMetacarpal = XR_FULL_BODY_JOINT_RIGHT_HAND_RING_METACARPAL_META,

  RightHandRingProximal = XR_FULL_BODY_JOINT_RIGHT_HAND_RING_PROXIMAL_META,

  RightHandRingIntermediate = XR_FULL_BODY_JOINT_RIGHT_HAND_RING_INTERMEDIATE_META,

  RightHandRingDistal = XR_FULL_BODY_JOINT_RIGHT_HAND_RING_DISTAL_META,

  RightHandRingTip = XR_FULL_BODY_JOINT_RIGHT_HAND_RING_TIP_META,

  RightHandLittleMetacarpal = XR_FULL_BODY_JOINT_RIGHT_HAND_LITTLE_METACARPAL_META,

  RightHandLittleProximal = XR_FULL_BODY_JOINT_RIGHT_HAND_LITTLE_PROXIMAL_META,

  RightHandLittleIntermediate = XR_FULL_BODY_JOINT_RIGHT_HAND_LITTLE_INTERMEDIATE_META,

  RightHandLittleDistal = XR_FULL_BODY_JOINT_RIGHT_HAND_LITTLE_DISTAL_META,

  RightHandLittleTip = XR_FULL_BODY_JOINT_RIGHT_HAND_LITTLE_TIP_META,

  LeftUpperLeg = XR_FULL_BODY_JOINT_LEFT_UPPER_LEG_META,

  LeftLowerLeg = XR_FULL_BODY_JOINT_LEFT_LOWER_LEG_META,

  LeftFootAnkleTwist = XR_FULL_BODY_JOINT_LEFT_FOOT_ANKLE_TWIST_META,

  LeftFootAnkle = XR_FULL_BODY_JOINT_LEFT_FOOT_ANKLE_META,

  LeftFootSubtalar = XR_FULL_BODY_JOINT_LEFT_FOOT_SUBTALAR_META,

  LeftFootTransverse = XR_FULL_BODY_JOINT_LEFT_FOOT_TRANSVERSE_META,

  LeftFootBall = XR_FULL_BODY_JOINT_LEFT_FOOT_BALL_META,

  RightUpperLeg = XR_FULL_BODY_JOINT_RIGHT_UPPER_LEG_META,

  RightLowerLeg = XR_FULL_BODY_JOINT_RIGHT_LOWER_LEG_META,

  RightFootAnkleTwist = XR_FULL_BODY_JOINT_RIGHT_FOOT_ANKLE_TWIST_META,

  RightFootAnkle = XR_FULL_BODY_JOINT_RIGHT_FOOT_ANKLE_META,

  RightFootSubtalar = XR_FULL_BODY_JOINT_RIGHT_FOOT_SUBTALAR_META,

  RightFootTransverse = XR_FULL_BODY_JOINT_RIGHT_FOOT_TRANSVERSE_META,

  RightFootBall = XR_FULL_BODY_JOINT_RIGHT_FOOT_BALL_META,

  Count = XR_FULL_BODY_JOINT_COUNT_META,

  None = XR_FULL_BODY_JOINT_NONE_META,

};
static_assert(sizeof(FullBodyJointMETA) == sizeof(XrFullBodyJointMETA),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFullBodyJointMETA value from a FullBodyJointMETA.
 *
 * @found_by_adl
 * @see FullBodyJointMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFullBodyJointMETA get(FullBodyJointMETA const& v) {
  return static_cast<XrFullBodyJointMETA>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFullBodyJointMETA address from a FullBodyJointMETA.
 *
 * @found_by_adl
 * @see FullBodyJointMETA
 */
OPENXR_HPP_INLINE XrFullBodyJointMETA* put(FullBodyJointMETA& v) {
  return reinterpret_cast<XrFullBodyJointMETA*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FullBodyJointMETA value as a const char
 * *.
 *
 * @found_by_adl
 * @see FullBodyJointMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FullBodyJointMETA value) {
  switch (value) {
    case FullBodyJointMETA::Root:
      return "Root";

    case FullBodyJointMETA::Hips:
      return "Hips";

    case FullBodyJointMETA::SpineLower:
      return "SpineLower";

    case FullBodyJointMETA::SpineMiddle:
      return "SpineMiddle";

    case FullBodyJointMETA::SpineUpper:
      return "SpineUpper";

    case FullBodyJointMETA::Chest:
      return "Chest";

    case FullBodyJointMETA::Neck:
      return "Neck";

    case FullBodyJointMETA::Head:
      return "Head";

    case FullBodyJointMETA::LeftShoulder:
      return "LeftShoulder";

    case FullBodyJointMETA::LeftScapula:
      return "LeftScapula";

    case FullBodyJointMETA::LeftArmUpper:
      return "LeftArmUpper";

    case FullBodyJointMETA::LeftArmLower:
      return "LeftArmLower";

    case FullBodyJointMETA::LeftHandWristTwist:
      return "LeftHandWristTwist";

    case FullBodyJointMETA::RightShoulder:
      return "RightShoulder";

    case FullBodyJointMETA::RightScapula:
      return "RightScapula";

    case FullBodyJointMETA::RightArmUpper:
      return "RightArmUpper";

    case FullBodyJointMETA::RightArmLower:
      return "RightArmLower";

    case FullBodyJointMETA::RightHandWristTwist:
      return "RightHandWristTwist";

    case FullBodyJointMETA::LeftHandPalm:
      return "LeftHandPalm";

    case FullBodyJointMETA::LeftHandWrist:
      return "LeftHandWrist";

    case FullBodyJointMETA::LeftHandThumbMetacarpal:
      return "LeftHandThumbMetacarpal";

    case FullBodyJointMETA::LeftHandThumbProximal:
      return "LeftHandThumbProximal";

    case FullBodyJointMETA::LeftHandThumbDistal:
      return "LeftHandThumbDistal";

    case FullBodyJointMETA::LeftHandThumbTip:
      return "LeftHandThumbTip";

    case FullBodyJointMETA::LeftHandIndexMetacarpal:
      return "LeftHandIndexMetacarpal";

    case FullBodyJointMETA::LeftHandIndexProximal:
      return "LeftHandIndexProximal";

    case FullBodyJointMETA::LeftHandIndexIntermediate:
      return "LeftHandIndexIntermediate";

    case FullBodyJointMETA::LeftHandIndexDistal:
      return "LeftHandIndexDistal";

    case FullBodyJointMETA::LeftHandIndexTip:
      return "LeftHandIndexTip";

    case FullBodyJointMETA::LeftHandMiddleMetacarpal:
      return "LeftHandMiddleMetacarpal";

    case FullBodyJointMETA::LeftHandMiddleProximal:
      return "LeftHandMiddleProximal";

    case FullBodyJointMETA::LeftHandMiddleIntermediate:
      return "LeftHandMiddleIntermediate";

    case FullBodyJointMETA::LeftHandMiddleDistal:
      return "LeftHandMiddleDistal";

    case FullBodyJointMETA::LeftHandMiddleTip:
      return "LeftHandMiddleTip";

    case FullBodyJointMETA::LeftHandRingMetacarpal:
      return "LeftHandRingMetacarpal";

    case FullBodyJointMETA::LeftHandRingProximal:
      return "LeftHandRingProximal";

    case FullBodyJointMETA::LeftHandRingIntermediate:
      return "LeftHandRingIntermediate";

    case FullBodyJointMETA::LeftHandRingDistal:
      return "LeftHandRingDistal";

    case FullBodyJointMETA::LeftHandRingTip:
      return "LeftHandRingTip";

    case FullBodyJointMETA::LeftHandLittleMetacarpal:
      return "LeftHandLittleMetacarpal";

    case FullBodyJointMETA::LeftHandLittleProximal:
      return "LeftHandLittleProximal";

    case FullBodyJointMETA::LeftHandLittleIntermediate:
      return "LeftHandLittleIntermediate";

    case FullBodyJointMETA::LeftHandLittleDistal:
      return "LeftHandLittleDistal";

    case FullBodyJointMETA::LeftHandLittleTip:
      return "LeftHandLittleTip";

    case FullBodyJointMETA::RightHandPalm:
      return "RightHandPalm";

    case FullBodyJointMETA::RightHandWrist:
      return "RightHandWrist";

    case FullBodyJointMETA::RightHandThumbMetacarpal:
      return "RightHandThumbMetacarpal";

    case FullBodyJointMETA::RightHandThumbProximal:
      return "RightHandThumbProximal";

    case FullBodyJointMETA::RightHandThumbDistal:
      return "RightHandThumbDistal";

    case FullBodyJointMETA::RightHandThumbTip:
      return "RightHandThumbTip";

    case FullBodyJointMETA::RightHandIndexMetacarpal:
      return "RightHandIndexMetacarpal";

    case FullBodyJointMETA::RightHandIndexProximal:
      return "RightHandIndexProximal";

    case FullBodyJointMETA::RightHandIndexIntermediate:
      return "RightHandIndexIntermediate";

    case FullBodyJointMETA::RightHandIndexDistal:
      return "RightHandIndexDistal";

    case FullBodyJointMETA::RightHandIndexTip:
      return "RightHandIndexTip";

    case FullBodyJointMETA::RightHandMiddleMetacarpal:
      return "RightHandMiddleMetacarpal";

    case FullBodyJointMETA::RightHandMiddleProximal:
      return "RightHandMiddleProximal";

    case FullBodyJointMETA::RightHandMiddleIntermediate:
      return "RightHandMiddleIntermediate";

    case FullBodyJointMETA::RightHandMiddleDistal:
      return "RightHandMiddleDistal";

    case FullBodyJointMETA::RightHandMiddleTip:
      return "RightHandMiddleTip";

    case FullBodyJointMETA::RightHandRingMetacarpal:
      return "RightHandRingMetacarpal";

    case FullBodyJointMETA::RightHandRingProximal:
      return "RightHandRingProximal";

    case FullBodyJointMETA::RightHandRingIntermediate:
      return "RightHandRingIntermediate";

    case FullBodyJointMETA::RightHandRingDistal:
      return "RightHandRingDistal";

    case FullBodyJointMETA::RightHandRingTip:
      return "RightHandRingTip";

    case FullBodyJointMETA::RightHandLittleMetacarpal:
      return "RightHandLittleMetacarpal";

    case FullBodyJointMETA::RightHandLittleProximal:
      return "RightHandLittleProximal";

    case FullBodyJointMETA::RightHandLittleIntermediate:
      return "RightHandLittleIntermediate";

    case FullBodyJointMETA::RightHandLittleDistal:
      return "RightHandLittleDistal";

    case FullBodyJointMETA::RightHandLittleTip:
      return "RightHandLittleTip";

    case FullBodyJointMETA::LeftUpperLeg:
      return "LeftUpperLeg";

    case FullBodyJointMETA::LeftLowerLeg:
      return "LeftLowerLeg";

    case FullBodyJointMETA::LeftFootAnkleTwist:
      return "LeftFootAnkleTwist";

    case FullBodyJointMETA::LeftFootAnkle:
      return "LeftFootAnkle";

    case FullBodyJointMETA::LeftFootSubtalar:
      return "LeftFootSubtalar";

    case FullBodyJointMETA::LeftFootTransverse:
      return "LeftFootTransverse";

    case FullBodyJointMETA::LeftFootBall:
      return "LeftFootBall";

    case FullBodyJointMETA::RightUpperLeg:
      return "RightUpperLeg";

    case FullBodyJointMETA::RightLowerLeg:
      return "RightLowerLeg";

    case FullBodyJointMETA::RightFootAnkleTwist:
      return "RightFootAnkleTwist";

    case FullBodyJointMETA::RightFootAnkle:
      return "RightFootAnkle";

    case FullBodyJointMETA::RightFootSubtalar:
      return "RightFootSubtalar";

    case FullBodyJointMETA::RightFootTransverse:
      return "RightFootTransverse";

    case FullBodyJointMETA::RightFootBall:
      return "RightFootBall";

    case FullBodyJointMETA::Count:
      return "Count";

    case FullBodyJointMETA::None:
      return "None";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FullBodyJointMETA value as a
 * std::string.
 *
 * @found_by_adl
 * @see FullBodyJointMETA
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FullBodyJointMETA value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_META_body_tracking_full_body

#ifdef XR_FB_face_tracking2
/*!
 * @brief Enum class for XrFaceExpression2FB
 *
 * Provided by the `XR_FB_face_tracking2` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpression2FB>
 *
 * @xrentity{XrFaceExpression2FB}
 */
enum class FaceExpression2FB {

  BrowLowererL = XR_FACE_EXPRESSION2_BROW_LOWERER_L_FB,

  BrowLowererR = XR_FACE_EXPRESSION2_BROW_LOWERER_R_FB,

  CheekPuffL = XR_FACE_EXPRESSION2_CHEEK_PUFF_L_FB,

  CheekPuffR = XR_FACE_EXPRESSION2_CHEEK_PUFF_R_FB,

  CheekRaiserL = XR_FACE_EXPRESSION2_CHEEK_RAISER_L_FB,

  CheekRaiserR = XR_FACE_EXPRESSION2_CHEEK_RAISER_R_FB,

  CheekSuckL = XR_FACE_EXPRESSION2_CHEEK_SUCK_L_FB,

  CheekSuckR = XR_FACE_EXPRESSION2_CHEEK_SUCK_R_FB,

  ChinRaiserB = XR_FACE_EXPRESSION2_CHIN_RAISER_B_FB,

  ChinRaiserT = XR_FACE_EXPRESSION2_CHIN_RAISER_T_FB,

  DimplerL = XR_FACE_EXPRESSION2_DIMPLER_L_FB,

  DimplerR = XR_FACE_EXPRESSION2_DIMPLER_R_FB,

  EyesClosedL = XR_FACE_EXPRESSION2_EYES_CLOSED_L_FB,

  EyesClosedR = XR_FACE_EXPRESSION2_EYES_CLOSED_R_FB,

  EyesLookDownL = XR_FACE_EXPRESSION2_EYES_LOOK_DOWN_L_FB,

  EyesLookDownR = XR_FACE_EXPRESSION2_EYES_LOOK_DOWN_R_FB,

  EyesLookLeftL = XR_FACE_EXPRESSION2_EYES_LOOK_LEFT_L_FB,

  EyesLookLeftR = XR_FACE_EXPRESSION2_EYES_LOOK_LEFT_R_FB,

  EyesLookRightL = XR_FACE_EXPRESSION2_EYES_LOOK_RIGHT_L_FB,

  EyesLookRightR = XR_FACE_EXPRESSION2_EYES_LOOK_RIGHT_R_FB,

  EyesLookUpL = XR_FACE_EXPRESSION2_EYES_LOOK_UP_L_FB,

  EyesLookUpR = XR_FACE_EXPRESSION2_EYES_LOOK_UP_R_FB,

  InnerBrowRaiserL = XR_FACE_EXPRESSION2_INNER_BROW_RAISER_L_FB,

  InnerBrowRaiserR = XR_FACE_EXPRESSION2_INNER_BROW_RAISER_R_FB,

  JawDrop = XR_FACE_EXPRESSION2_JAW_DROP_FB,

  JawSidewaysLeft = XR_FACE_EXPRESSION2_JAW_SIDEWAYS_LEFT_FB,

  JawSidewaysRight = XR_FACE_EXPRESSION2_JAW_SIDEWAYS_RIGHT_FB,

  JawThrust = XR_FACE_EXPRESSION2_JAW_THRUST_FB,

  LidTightenerL = XR_FACE_EXPRESSION2_LID_TIGHTENER_L_FB,

  LidTightenerR = XR_FACE_EXPRESSION2_LID_TIGHTENER_R_FB,

  LipCornerDepressorL = XR_FACE_EXPRESSION2_LIP_CORNER_DEPRESSOR_L_FB,

  LipCornerDepressorR = XR_FACE_EXPRESSION2_LIP_CORNER_DEPRESSOR_R_FB,

  LipCornerPullerL = XR_FACE_EXPRESSION2_LIP_CORNER_PULLER_L_FB,

  LipCornerPullerR = XR_FACE_EXPRESSION2_LIP_CORNER_PULLER_R_FB,

  LipFunnelerLb = XR_FACE_EXPRESSION2_LIP_FUNNELER_LB_FB,

  LipFunnelerLt = XR_FACE_EXPRESSION2_LIP_FUNNELER_LT_FB,

  LipFunnelerRb = XR_FACE_EXPRESSION2_LIP_FUNNELER_RB_FB,

  LipFunnelerRt = XR_FACE_EXPRESSION2_LIP_FUNNELER_RT_FB,

  LipPressorL = XR_FACE_EXPRESSION2_LIP_PRESSOR_L_FB,

  LipPressorR = XR_FACE_EXPRESSION2_LIP_PRESSOR_R_FB,

  LipPuckerL = XR_FACE_EXPRESSION2_LIP_PUCKER_L_FB,

  LipPuckerR = XR_FACE_EXPRESSION2_LIP_PUCKER_R_FB,

  LipStretcherL = XR_FACE_EXPRESSION2_LIP_STRETCHER_L_FB,

  LipStretcherR = XR_FACE_EXPRESSION2_LIP_STRETCHER_R_FB,

  LipSuckLb = XR_FACE_EXPRESSION2_LIP_SUCK_LB_FB,

  LipSuckLt = XR_FACE_EXPRESSION2_LIP_SUCK_LT_FB,

  LipSuckRb = XR_FACE_EXPRESSION2_LIP_SUCK_RB_FB,

  LipSuckRt = XR_FACE_EXPRESSION2_LIP_SUCK_RT_FB,

  LipTightenerL = XR_FACE_EXPRESSION2_LIP_TIGHTENER_L_FB,

  LipTightenerR = XR_FACE_EXPRESSION2_LIP_TIGHTENER_R_FB,

  LipsToward = XR_FACE_EXPRESSION2_LIPS_TOWARD_FB,

  LowerLipDepressorL = XR_FACE_EXPRESSION2_LOWER_LIP_DEPRESSOR_L_FB,

  LowerLipDepressorR = XR_FACE_EXPRESSION2_LOWER_LIP_DEPRESSOR_R_FB,

  MouthLeft = XR_FACE_EXPRESSION2_MOUTH_LEFT_FB,

  MouthRight = XR_FACE_EXPRESSION2_MOUTH_RIGHT_FB,

  NoseWrinklerL = XR_FACE_EXPRESSION2_NOSE_WRINKLER_L_FB,

  NoseWrinklerR = XR_FACE_EXPRESSION2_NOSE_WRINKLER_R_FB,

  OuterBrowRaiserL = XR_FACE_EXPRESSION2_OUTER_BROW_RAISER_L_FB,

  OuterBrowRaiserR = XR_FACE_EXPRESSION2_OUTER_BROW_RAISER_R_FB,

  UpperLidRaiserL = XR_FACE_EXPRESSION2_UPPER_LID_RAISER_L_FB,

  UpperLidRaiserR = XR_FACE_EXPRESSION2_UPPER_LID_RAISER_R_FB,

  UpperLipRaiserL = XR_FACE_EXPRESSION2_UPPER_LIP_RAISER_L_FB,

  UpperLipRaiserR = XR_FACE_EXPRESSION2_UPPER_LIP_RAISER_R_FB,

  TongueTipInterdental = XR_FACE_EXPRESSION2_TONGUE_TIP_INTERDENTAL_FB,

  TongueTipAlveolar = XR_FACE_EXPRESSION2_TONGUE_TIP_ALVEOLAR_FB,

  TongueFrontDorsalPalate = XR_FACE_EXPRESSION2_TONGUE_FRONT_DORSAL_PALATE_FB,

  TongueMidDorsalPalate = XR_FACE_EXPRESSION2_TONGUE_MID_DORSAL_PALATE_FB,

  TongueBackDorsalVelar = XR_FACE_EXPRESSION2_TONGUE_BACK_DORSAL_VELAR_FB,

  TongueOut = XR_FACE_EXPRESSION2_TONGUE_OUT_FB,

  TongueRetreat = XR_FACE_EXPRESSION2_TONGUE_RETREAT_FB,

  Count = XR_FACE_EXPRESSION2_COUNT_FB,

};
static_assert(sizeof(FaceExpression2FB) == sizeof(XrFaceExpression2FB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceExpression2FB value from a FaceExpression2FB.
 *
 * @found_by_adl
 * @see FaceExpression2FB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFaceExpression2FB get(FaceExpression2FB const& v) {
  return static_cast<XrFaceExpression2FB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceExpression2FB address from a FaceExpression2FB.
 *
 * @found_by_adl
 * @see FaceExpression2FB
 */
OPENXR_HPP_INLINE XrFaceExpression2FB* put(FaceExpression2FB& v) {
  return reinterpret_cast<XrFaceExpression2FB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FaceExpression2FB value as a const char
 * *.
 *
 * @found_by_adl
 * @see FaceExpression2FB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FaceExpression2FB value) {
  switch (value) {
    case FaceExpression2FB::BrowLowererL:
      return "BrowLowererL";

    case FaceExpression2FB::BrowLowererR:
      return "BrowLowererR";

    case FaceExpression2FB::CheekPuffL:
      return "CheekPuffL";

    case FaceExpression2FB::CheekPuffR:
      return "CheekPuffR";

    case FaceExpression2FB::CheekRaiserL:
      return "CheekRaiserL";

    case FaceExpression2FB::CheekRaiserR:
      return "CheekRaiserR";

    case FaceExpression2FB::CheekSuckL:
      return "CheekSuckL";

    case FaceExpression2FB::CheekSuckR:
      return "CheekSuckR";

    case FaceExpression2FB::ChinRaiserB:
      return "ChinRaiserB";

    case FaceExpression2FB::ChinRaiserT:
      return "ChinRaiserT";

    case FaceExpression2FB::DimplerL:
      return "DimplerL";

    case FaceExpression2FB::DimplerR:
      return "DimplerR";

    case FaceExpression2FB::EyesClosedL:
      return "EyesClosedL";

    case FaceExpression2FB::EyesClosedR:
      return "EyesClosedR";

    case FaceExpression2FB::EyesLookDownL:
      return "EyesLookDownL";

    case FaceExpression2FB::EyesLookDownR:
      return "EyesLookDownR";

    case FaceExpression2FB::EyesLookLeftL:
      return "EyesLookLeftL";

    case FaceExpression2FB::EyesLookLeftR:
      return "EyesLookLeftR";

    case FaceExpression2FB::EyesLookRightL:
      return "EyesLookRightL";

    case FaceExpression2FB::EyesLookRightR:
      return "EyesLookRightR";

    case FaceExpression2FB::EyesLookUpL:
      return "EyesLookUpL";

    case FaceExpression2FB::EyesLookUpR:
      return "EyesLookUpR";

    case FaceExpression2FB::InnerBrowRaiserL:
      return "InnerBrowRaiserL";

    case FaceExpression2FB::InnerBrowRaiserR:
      return "InnerBrowRaiserR";

    case FaceExpression2FB::JawDrop:
      return "JawDrop";

    case FaceExpression2FB::JawSidewaysLeft:
      return "JawSidewaysLeft";

    case FaceExpression2FB::JawSidewaysRight:
      return "JawSidewaysRight";

    case FaceExpression2FB::JawThrust:
      return "JawThrust";

    case FaceExpression2FB::LidTightenerL:
      return "LidTightenerL";

    case FaceExpression2FB::LidTightenerR:
      return "LidTightenerR";

    case FaceExpression2FB::LipCornerDepressorL:
      return "LipCornerDepressorL";

    case FaceExpression2FB::LipCornerDepressorR:
      return "LipCornerDepressorR";

    case FaceExpression2FB::LipCornerPullerL:
      return "LipCornerPullerL";

    case FaceExpression2FB::LipCornerPullerR:
      return "LipCornerPullerR";

    case FaceExpression2FB::LipFunnelerLb:
      return "LipFunnelerLb";

    case FaceExpression2FB::LipFunnelerLt:
      return "LipFunnelerLt";

    case FaceExpression2FB::LipFunnelerRb:
      return "LipFunnelerRb";

    case FaceExpression2FB::LipFunnelerRt:
      return "LipFunnelerRt";

    case FaceExpression2FB::LipPressorL:
      return "LipPressorL";

    case FaceExpression2FB::LipPressorR:
      return "LipPressorR";

    case FaceExpression2FB::LipPuckerL:
      return "LipPuckerL";

    case FaceExpression2FB::LipPuckerR:
      return "LipPuckerR";

    case FaceExpression2FB::LipStretcherL:
      return "LipStretcherL";

    case FaceExpression2FB::LipStretcherR:
      return "LipStretcherR";

    case FaceExpression2FB::LipSuckLb:
      return "LipSuckLb";

    case FaceExpression2FB::LipSuckLt:
      return "LipSuckLt";

    case FaceExpression2FB::LipSuckRb:
      return "LipSuckRb";

    case FaceExpression2FB::LipSuckRt:
      return "LipSuckRt";

    case FaceExpression2FB::LipTightenerL:
      return "LipTightenerL";

    case FaceExpression2FB::LipTightenerR:
      return "LipTightenerR";

    case FaceExpression2FB::LipsToward:
      return "LipsToward";

    case FaceExpression2FB::LowerLipDepressorL:
      return "LowerLipDepressorL";

    case FaceExpression2FB::LowerLipDepressorR:
      return "LowerLipDepressorR";

    case FaceExpression2FB::MouthLeft:
      return "MouthLeft";

    case FaceExpression2FB::MouthRight:
      return "MouthRight";

    case FaceExpression2FB::NoseWrinklerL:
      return "NoseWrinklerL";

    case FaceExpression2FB::NoseWrinklerR:
      return "NoseWrinklerR";

    case FaceExpression2FB::OuterBrowRaiserL:
      return "OuterBrowRaiserL";

    case FaceExpression2FB::OuterBrowRaiserR:
      return "OuterBrowRaiserR";

    case FaceExpression2FB::UpperLidRaiserL:
      return "UpperLidRaiserL";

    case FaceExpression2FB::UpperLidRaiserR:
      return "UpperLidRaiserR";

    case FaceExpression2FB::UpperLipRaiserL:
      return "UpperLipRaiserL";

    case FaceExpression2FB::UpperLipRaiserR:
      return "UpperLipRaiserR";

    case FaceExpression2FB::TongueTipInterdental:
      return "TongueTipInterdental";

    case FaceExpression2FB::TongueTipAlveolar:
      return "TongueTipAlveolar";

    case FaceExpression2FB::TongueFrontDorsalPalate:
      return "TongueFrontDorsalPalate";

    case FaceExpression2FB::TongueMidDorsalPalate:
      return "TongueMidDorsalPalate";

    case FaceExpression2FB::TongueBackDorsalVelar:
      return "TongueBackDorsalVelar";

    case FaceExpression2FB::TongueOut:
      return "TongueOut";

    case FaceExpression2FB::TongueRetreat:
      return "TongueRetreat";

    case FaceExpression2FB::Count:
      return "Count";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FaceExpression2FB value as a
 * std::string.
 *
 * @found_by_adl
 * @see FaceExpression2FB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FaceExpression2FB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_face_tracking2

#ifdef XR_FB_face_tracking2
/*!
 * @brief Enum class for XrFaceExpressionSet2FB
 *
 * Provided by the `XR_FB_face_tracking2` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionSet2FB>
 *
 * @xrentity{XrFaceExpressionSet2FB}
 */
enum class FaceExpressionSet2FB {

  Default = XR_FACE_EXPRESSION_SET2_DEFAULT_FB,

};
static_assert(sizeof(FaceExpressionSet2FB) == sizeof(XrFaceExpressionSet2FB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceExpressionSet2FB value from a
 * FaceExpressionSet2FB.
 *
 * @found_by_adl
 * @see FaceExpressionSet2FB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFaceExpressionSet2FB get(FaceExpressionSet2FB const& v) {
  return static_cast<XrFaceExpressionSet2FB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceExpressionSet2FB address from a
 * FaceExpressionSet2FB.
 *
 * @found_by_adl
 * @see FaceExpressionSet2FB
 */
OPENXR_HPP_INLINE XrFaceExpressionSet2FB* put(FaceExpressionSet2FB& v) {
  return reinterpret_cast<XrFaceExpressionSet2FB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FaceExpressionSet2FB value as a const
 * char *.
 *
 * @found_by_adl
 * @see FaceExpressionSet2FB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FaceExpressionSet2FB value) {
  switch (value) {
    case FaceExpressionSet2FB::Default:
      return "Default";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FaceExpressionSet2FB value as a
 * std::string.
 *
 * @found_by_adl
 * @see FaceExpressionSet2FB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FaceExpressionSet2FB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_face_tracking2

#ifdef XR_FB_face_tracking2
/*!
 * @brief Enum class for XrFaceTrackingDataSource2FB
 *
 * Provided by the `XR_FB_face_tracking2` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceTrackingDataSource2FB>
 *
 * @xrentity{XrFaceTrackingDataSource2FB}
 */
enum class FaceTrackingDataSource2FB {

  Visual = XR_FACE_TRACKING_DATA_SOURCE2_VISUAL_FB,

  Audio = XR_FACE_TRACKING_DATA_SOURCE2_AUDIO_FB,

};
static_assert(sizeof(FaceTrackingDataSource2FB) == sizeof(XrFaceTrackingDataSource2FB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceTrackingDataSource2FB value from a
 * FaceTrackingDataSource2FB.
 *
 * @found_by_adl
 * @see FaceTrackingDataSource2FB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFaceTrackingDataSource2FB
get(FaceTrackingDataSource2FB const& v) {
  return static_cast<XrFaceTrackingDataSource2FB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceTrackingDataSource2FB address from a
 * FaceTrackingDataSource2FB.
 *
 * @found_by_adl
 * @see FaceTrackingDataSource2FB
 */
OPENXR_HPP_INLINE XrFaceTrackingDataSource2FB* put(FaceTrackingDataSource2FB& v) {
  return reinterpret_cast<XrFaceTrackingDataSource2FB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FaceTrackingDataSource2FB value as a
 * const char *.
 *
 * @found_by_adl
 * @see FaceTrackingDataSource2FB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FaceTrackingDataSource2FB value) {
  switch (value) {
    case FaceTrackingDataSource2FB::Visual:
      return "Visual";

    case FaceTrackingDataSource2FB::Audio:
      return "Audio";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FaceTrackingDataSource2FB value as a
 * std::string.
 *
 * @found_by_adl
 * @see FaceTrackingDataSource2FB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    FaceTrackingDataSource2FB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_face_tracking2

#ifdef XR_FB_face_tracking2
/*!
 * @brief Enum class for XrFaceConfidence2FB
 *
 * Provided by the `XR_FB_face_tracking2` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceConfidence2FB>
 *
 * @xrentity{XrFaceConfidence2FB}
 */
enum class FaceConfidence2FB {

  LowerFace = XR_FACE_CONFIDENCE2_LOWER_FACE_FB,

  UpperFace = XR_FACE_CONFIDENCE2_UPPER_FACE_FB,

  Count = XR_FACE_CONFIDENCE2_COUNT_FB,

};
static_assert(sizeof(FaceConfidence2FB) == sizeof(XrFaceConfidence2FB),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceConfidence2FB value from a FaceConfidence2FB.
 *
 * @found_by_adl
 * @see FaceConfidence2FB
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFaceConfidence2FB get(FaceConfidence2FB const& v) {
  return static_cast<XrFaceConfidence2FB>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFaceConfidence2FB address from a FaceConfidence2FB.
 *
 * @found_by_adl
 * @see FaceConfidence2FB
 */
OPENXR_HPP_INLINE XrFaceConfidence2FB* put(FaceConfidence2FB& v) {
  return reinterpret_cast<XrFaceConfidence2FB*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FaceConfidence2FB value as a const char
 * *.
 *
 * @found_by_adl
 * @see FaceConfidence2FB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FaceConfidence2FB value) {
  switch (value) {
    case FaceConfidence2FB::LowerFace:
      return "LowerFace";

    case FaceConfidence2FB::UpperFace:
      return "UpperFace";

    case FaceConfidence2FB::Count:
      return "Count";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FaceConfidence2FB value as a
 * std::string.
 *
 * @found_by_adl
 * @see FaceConfidence2FB
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FaceConfidence2FB value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_FB_face_tracking2

#ifdef XR_QCOM_tracking_optimization_settings
/*!
 * @brief Enum class for XrTrackingOptimizationSettingsDomainQCOM
 *
 * Provided by the `XR_QCOM_tracking_optimization_settings` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrTrackingOptimizationSettingsDomainQCOM>
 *
 * @xrentity{XrTrackingOptimizationSettingsDomainQCOM}
 */
enum class TrackingOptimizationSettingsDomainQCOM {

  All = XR_TRACKING_OPTIMIZATION_SETTINGS_DOMAIN_ALL_QCOM,

};
static_assert(sizeof(TrackingOptimizationSettingsDomainQCOM) ==
                  sizeof(XrTrackingOptimizationSettingsDomainQCOM),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrTrackingOptimizationSettingsDomainQCOM value from a
 * TrackingOptimizationSettingsDomainQCOM.
 *
 * @found_by_adl
 * @see TrackingOptimizationSettingsDomainQCOM
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrTrackingOptimizationSettingsDomainQCOM
get(TrackingOptimizationSettingsDomainQCOM const& v) {
  return static_cast<XrTrackingOptimizationSettingsDomainQCOM>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrTrackingOptimizationSettingsDomainQCOM address from
 * a TrackingOptimizationSettingsDomainQCOM.
 *
 * @found_by_adl
 * @see TrackingOptimizationSettingsDomainQCOM
 */
OPENXR_HPP_INLINE XrTrackingOptimizationSettingsDomainQCOM* put(
    TrackingOptimizationSettingsDomainQCOM& v) {
  return reinterpret_cast<XrTrackingOptimizationSettingsDomainQCOM*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a TrackingOptimizationSettingsDomainQCOM
 * value as a const char *.
 *
 * @found_by_adl
 * @see TrackingOptimizationSettingsDomainQCOM
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    TrackingOptimizationSettingsDomainQCOM value) {
  switch (value) {
    case TrackingOptimizationSettingsDomainQCOM::All:
      return "All";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a TrackingOptimizationSettingsDomainQCOM
 * value as a std::string.
 *
 * @found_by_adl
 * @see TrackingOptimizationSettingsDomainQCOM
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    TrackingOptimizationSettingsDomainQCOM value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_QCOM_tracking_optimization_settings

#ifdef XR_QCOM_tracking_optimization_settings
/*!
 * @brief Enum class for XrTrackingOptimizationSettingsHintQCOM
 *
 * Provided by the `XR_QCOM_tracking_optimization_settings` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrTrackingOptimizationSettingsHintQCOM>
 *
 * @xrentity{XrTrackingOptimizationSettingsHintQCOM}
 */
enum class TrackingOptimizationSettingsHintQCOM {

  None = XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_NONE_QCOM,

  LongRangePriorization = XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_LONG_RANGE_PRIORIZATION_QCOM,

  CloseRangePriorization = XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_CLOSE_RANGE_PRIORIZATION_QCOM,

  LowPowerPriorization = XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_LOW_POWER_PRIORIZATION_QCOM,

  HighPowerPriorization = XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_HIGH_POWER_PRIORIZATION_QCOM,

};
static_assert(sizeof(TrackingOptimizationSettingsHintQCOM) ==
                  sizeof(XrTrackingOptimizationSettingsHintQCOM),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrTrackingOptimizationSettingsHintQCOM value from a
 * TrackingOptimizationSettingsHintQCOM.
 *
 * @found_by_adl
 * @see TrackingOptimizationSettingsHintQCOM
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrTrackingOptimizationSettingsHintQCOM
get(TrackingOptimizationSettingsHintQCOM const& v) {
  return static_cast<XrTrackingOptimizationSettingsHintQCOM>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrTrackingOptimizationSettingsHintQCOM address from a
 * TrackingOptimizationSettingsHintQCOM.
 *
 * @found_by_adl
 * @see TrackingOptimizationSettingsHintQCOM
 */
OPENXR_HPP_INLINE XrTrackingOptimizationSettingsHintQCOM* put(
    TrackingOptimizationSettingsHintQCOM& v) {
  return reinterpret_cast<XrTrackingOptimizationSettingsHintQCOM*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a TrackingOptimizationSettingsHintQCOM
 * value as a const char *.
 *
 * @found_by_adl
 * @see TrackingOptimizationSettingsHintQCOM
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    TrackingOptimizationSettingsHintQCOM value) {
  switch (value) {
    case TrackingOptimizationSettingsHintQCOM::None:
      return "None";

    case TrackingOptimizationSettingsHintQCOM::LongRangePriorization:
      return "LongRangePriorization";

    case TrackingOptimizationSettingsHintQCOM::CloseRangePriorization:
      return "CloseRangePriorization";

    case TrackingOptimizationSettingsHintQCOM::LowPowerPriorization:
      return "LowPowerPriorization";

    case TrackingOptimizationSettingsHintQCOM::HighPowerPriorization:
      return "HighPowerPriorization";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a TrackingOptimizationSettingsHintQCOM
 * value as a std::string.
 *
 * @found_by_adl
 * @see TrackingOptimizationSettingsHintQCOM
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    TrackingOptimizationSettingsHintQCOM value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_QCOM_tracking_optimization_settings

#ifdef XR_HTC_passthrough
/*!
 * @brief Enum class for XrPassthroughFormHTC
 *
 * Provided by the `XR_HTC_passthrough` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughFormHTC>
 *
 * @xrentity{XrPassthroughFormHTC}
 */
enum class PassthroughFormHTC {

  Planar = XR_PASSTHROUGH_FORM_PLANAR_HTC,

  Projected = XR_PASSTHROUGH_FORM_PROJECTED_HTC,

};
static_assert(sizeof(PassthroughFormHTC) == sizeof(XrPassthroughFormHTC),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPassthroughFormHTC value from a PassthroughFormHTC.
 *
 * @found_by_adl
 * @see PassthroughFormHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPassthroughFormHTC get(PassthroughFormHTC const& v) {
  return static_cast<XrPassthroughFormHTC>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPassthroughFormHTC address from a
 * PassthroughFormHTC.
 *
 * @found_by_adl
 * @see PassthroughFormHTC
 */
OPENXR_HPP_INLINE XrPassthroughFormHTC* put(PassthroughFormHTC& v) {
  return reinterpret_cast<XrPassthroughFormHTC*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughFormHTC value as a const char
 * *.
 *
 * @found_by_adl
 * @see PassthroughFormHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PassthroughFormHTC value) {
  switch (value) {
    case PassthroughFormHTC::Planar:
      return "Planar";

    case PassthroughFormHTC::Projected:
      return "Projected";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PassthroughFormHTC value as a
 * std::string.
 *
 * @found_by_adl
 * @see PassthroughFormHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PassthroughFormHTC value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_passthrough

#ifdef XR_HTC_foveation
/*!
 * @brief Enum class for XrFoveationModeHTC
 *
 * Provided by the `XR_HTC_foveation` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationModeHTC>
 *
 * @xrentity{XrFoveationModeHTC}
 */
enum class FoveationModeHTC {

  Disable = XR_FOVEATION_MODE_DISABLE_HTC,

  Fixed = XR_FOVEATION_MODE_FIXED_HTC,

  Dynamic = XR_FOVEATION_MODE_DYNAMIC_HTC,

  Custom = XR_FOVEATION_MODE_CUSTOM_HTC,

};
static_assert(sizeof(FoveationModeHTC) == sizeof(XrFoveationModeHTC),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationModeHTC value from a FoveationModeHTC.
 *
 * @found_by_adl
 * @see FoveationModeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFoveationModeHTC get(FoveationModeHTC const& v) {
  return static_cast<XrFoveationModeHTC>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationModeHTC address from a FoveationModeHTC.
 *
 * @found_by_adl
 * @see FoveationModeHTC
 */
OPENXR_HPP_INLINE XrFoveationModeHTC* put(FoveationModeHTC& v) {
  return reinterpret_cast<XrFoveationModeHTC*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FoveationModeHTC value as a const char
 * *.
 *
 * @found_by_adl
 * @see FoveationModeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FoveationModeHTC value) {
  switch (value) {
    case FoveationModeHTC::Disable:
      return "Disable";

    case FoveationModeHTC::Fixed:
      return "Fixed";

    case FoveationModeHTC::Dynamic:
      return "Dynamic";

    case FoveationModeHTC::Custom:
      return "Custom";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FoveationModeHTC value as a std::string.
 *
 * @found_by_adl
 * @see FoveationModeHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FoveationModeHTC value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_foveation

#ifdef XR_HTC_foveation
/*!
 * @brief Enum class for XrFoveationLevelHTC
 *
 * Provided by the `XR_HTC_foveation` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationLevelHTC>
 *
 * @xrentity{XrFoveationLevelHTC}
 */
enum class FoveationLevelHTC {

  None = XR_FOVEATION_LEVEL_NONE_HTC,

  Low = XR_FOVEATION_LEVEL_LOW_HTC,

  Medium = XR_FOVEATION_LEVEL_MEDIUM_HTC,

  High = XR_FOVEATION_LEVEL_HIGH_HTC,

};
static_assert(sizeof(FoveationLevelHTC) == sizeof(XrFoveationLevelHTC),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationLevelHTC value from a FoveationLevelHTC.
 *
 * @found_by_adl
 * @see FoveationLevelHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFoveationLevelHTC get(FoveationLevelHTC const& v) {
  return static_cast<XrFoveationLevelHTC>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFoveationLevelHTC address from a FoveationLevelHTC.
 *
 * @found_by_adl
 * @see FoveationLevelHTC
 */
OPENXR_HPP_INLINE XrFoveationLevelHTC* put(FoveationLevelHTC& v) {
  return reinterpret_cast<XrFoveationLevelHTC*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FoveationLevelHTC value as a const char
 * *.
 *
 * @found_by_adl
 * @see FoveationLevelHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FoveationLevelHTC value) {
  switch (value) {
    case FoveationLevelHTC::None:
      return "None";

    case FoveationLevelHTC::Low:
      return "Low";

    case FoveationLevelHTC::Medium:
      return "Medium";

    case FoveationLevelHTC::High:
      return "High";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FoveationLevelHTC value as a
 * std::string.
 *
 * @found_by_adl
 * @see FoveationLevelHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FoveationLevelHTC value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_foveation

#ifdef XR_HTC_body_tracking
/*!
 * @brief Enum class for XrBodyJointHTC
 *
 * Provided by the `XR_HTC_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointHTC>
 *
 * @xrentity{XrBodyJointHTC}
 */
enum class BodyJointHTC {

  Pelvis = XR_BODY_JOINT_PELVIS_HTC,

  LeftHip = XR_BODY_JOINT_LEFT_HIP_HTC,

  LeftKnee = XR_BODY_JOINT_LEFT_KNEE_HTC,

  LeftAnkle = XR_BODY_JOINT_LEFT_ANKLE_HTC,

  LeftFeet = XR_BODY_JOINT_LEFT_FEET_HTC,

  RightHip = XR_BODY_JOINT_RIGHT_HIP_HTC,

  RightKnee = XR_BODY_JOINT_RIGHT_KNEE_HTC,

  RightAnkle = XR_BODY_JOINT_RIGHT_ANKLE_HTC,

  RightFeet = XR_BODY_JOINT_RIGHT_FEET_HTC,

  Waist = XR_BODY_JOINT_WAIST_HTC,

  SpineLower = XR_BODY_JOINT_SPINE_LOWER_HTC,

  SpineMiddle = XR_BODY_JOINT_SPINE_MIDDLE_HTC,

  SpineHigh = XR_BODY_JOINT_SPINE_HIGH_HTC,

  Chest = XR_BODY_JOINT_CHEST_HTC,

  Neck = XR_BODY_JOINT_NECK_HTC,

  Head = XR_BODY_JOINT_HEAD_HTC,

  LeftClavicle = XR_BODY_JOINT_LEFT_CLAVICLE_HTC,

  LeftScapula = XR_BODY_JOINT_LEFT_SCAPULA_HTC,

  LeftARM = XR_BODY_JOINT_LEFT_ARM_HTC,

  LeftElbow = XR_BODY_JOINT_LEFT_ELBOW_HTC,

  LeftWrist = XR_BODY_JOINT_LEFT_WRIST_HTC,

  RightClavicle = XR_BODY_JOINT_RIGHT_CLAVICLE_HTC,

  RightScapula = XR_BODY_JOINT_RIGHT_SCAPULA_HTC,

  RightARM = XR_BODY_JOINT_RIGHT_ARM_HTC,

  RightElbow = XR_BODY_JOINT_RIGHT_ELBOW_HTC,

  RightWrist = XR_BODY_JOINT_RIGHT_WRIST_HTC,

};
static_assert(sizeof(BodyJointHTC) == sizeof(XrBodyJointHTC),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointHTC value from a BodyJointHTC.
 *
 * @found_by_adl
 * @see BodyJointHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrBodyJointHTC get(BodyJointHTC const& v) {
  return static_cast<XrBodyJointHTC>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointHTC address from a BodyJointHTC.
 *
 * @found_by_adl
 * @see BodyJointHTC
 */
OPENXR_HPP_INLINE XrBodyJointHTC* put(BodyJointHTC& v) {
  return reinterpret_cast<XrBodyJointHTC*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointHTC value as a const char *.
 *
 * @found_by_adl
 * @see BodyJointHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(BodyJointHTC value) {
  switch (value) {
    case BodyJointHTC::Pelvis:
      return "Pelvis";

    case BodyJointHTC::LeftHip:
      return "LeftHip";

    case BodyJointHTC::LeftKnee:
      return "LeftKnee";

    case BodyJointHTC::LeftAnkle:
      return "LeftAnkle";

    case BodyJointHTC::LeftFeet:
      return "LeftFeet";

    case BodyJointHTC::RightHip:
      return "RightHip";

    case BodyJointHTC::RightKnee:
      return "RightKnee";

    case BodyJointHTC::RightAnkle:
      return "RightAnkle";

    case BodyJointHTC::RightFeet:
      return "RightFeet";

    case BodyJointHTC::Waist:
      return "Waist";

    case BodyJointHTC::SpineLower:
      return "SpineLower";

    case BodyJointHTC::SpineMiddle:
      return "SpineMiddle";

    case BodyJointHTC::SpineHigh:
      return "SpineHigh";

    case BodyJointHTC::Chest:
      return "Chest";

    case BodyJointHTC::Neck:
      return "Neck";

    case BodyJointHTC::Head:
      return "Head";

    case BodyJointHTC::LeftClavicle:
      return "LeftClavicle";

    case BodyJointHTC::LeftScapula:
      return "LeftScapula";

    case BodyJointHTC::LeftARM:
      return "LeftARM";

    case BodyJointHTC::LeftElbow:
      return "LeftElbow";

    case BodyJointHTC::LeftWrist:
      return "LeftWrist";

    case BodyJointHTC::RightClavicle:
      return "RightClavicle";

    case BodyJointHTC::RightScapula:
      return "RightScapula";

    case BodyJointHTC::RightARM:
      return "RightARM";

    case BodyJointHTC::RightElbow:
      return "RightElbow";

    case BodyJointHTC::RightWrist:
      return "RightWrist";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointHTC value as a std::string.
 *
 * @found_by_adl
 * @see BodyJointHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(BodyJointHTC value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_body_tracking

#ifdef XR_HTC_body_tracking
/*!
 * @brief Enum class for XrBodyJointSetHTC
 *
 * Provided by the `XR_HTC_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointSetHTC>
 *
 * @xrentity{XrBodyJointSetHTC}
 */
enum class BodyJointSetHTC {

  Full = XR_BODY_JOINT_SET_FULL_HTC,

};
static_assert(sizeof(BodyJointSetHTC) == sizeof(XrBodyJointSetHTC),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointSetHTC value from a BodyJointSetHTC.
 *
 * @found_by_adl
 * @see BodyJointSetHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrBodyJointSetHTC get(BodyJointSetHTC const& v) {
  return static_cast<XrBodyJointSetHTC>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointSetHTC address from a BodyJointSetHTC.
 *
 * @found_by_adl
 * @see BodyJointSetHTC
 */
OPENXR_HPP_INLINE XrBodyJointSetHTC* put(BodyJointSetHTC& v) {
  return reinterpret_cast<XrBodyJointSetHTC*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointSetHTC value as a const char *.
 *
 * @found_by_adl
 * @see BodyJointSetHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(BodyJointSetHTC value) {
  switch (value) {
    case BodyJointSetHTC::Full:
      return "Full";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointSetHTC value as a std::string.
 *
 * @found_by_adl
 * @see BodyJointSetHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(BodyJointSetHTC value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_body_tracking

#ifdef XR_HTC_body_tracking
/*!
 * @brief Enum class for XrBodyJointConfidenceHTC
 *
 * Provided by the `XR_HTC_body_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointConfidenceHTC>
 *
 * @xrentity{XrBodyJointConfidenceHTC}
 */
enum class BodyJointConfidenceHTC {

  None = XR_BODY_JOINT_CONFIDENCE_NONE_HTC,

  Low = XR_BODY_JOINT_CONFIDENCE_LOW_HTC,

  High = XR_BODY_JOINT_CONFIDENCE_HIGH_HTC,

};
static_assert(sizeof(BodyJointConfidenceHTC) == sizeof(XrBodyJointConfidenceHTC),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointConfidenceHTC value from a
 * BodyJointConfidenceHTC.
 *
 * @found_by_adl
 * @see BodyJointConfidenceHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrBodyJointConfidenceHTC
get(BodyJointConfidenceHTC const& v) {
  return static_cast<XrBodyJointConfidenceHTC>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointConfidenceHTC address from a
 * BodyJointConfidenceHTC.
 *
 * @found_by_adl
 * @see BodyJointConfidenceHTC
 */
OPENXR_HPP_INLINE XrBodyJointConfidenceHTC* put(BodyJointConfidenceHTC& v) {
  return reinterpret_cast<XrBodyJointConfidenceHTC*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointConfidenceHTC value as a const
 * char *.
 *
 * @found_by_adl
 * @see BodyJointConfidenceHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    BodyJointConfidenceHTC value) {
  switch (value) {
    case BodyJointConfidenceHTC::None:
      return "None";

    case BodyJointConfidenceHTC::Low:
      return "Low";

    case BodyJointConfidenceHTC::High:
      return "High";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointConfidenceHTC value as a
 * std::string.
 *
 * @found_by_adl
 * @see BodyJointConfidenceHTC
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(BodyJointConfidenceHTC value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_HTC_body_tracking

#ifdef XR_MNDX_force_feedback_curl
/*!
 * @brief Enum class for XrForceFeedbackCurlLocationMNDX
 *
 * Provided by the `XR_MNDX_force_feedback_curl` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrForceFeedbackCurlLocationMNDX>
 *
 * @xrentity{XrForceFeedbackCurlLocationMNDX}
 */
enum class ForceFeedbackCurlLocationMNDX {

  ThumbCurl = XR_FORCE_FEEDBACK_CURL_LOCATION_THUMB_CURL_MNDX,

  IndexCurl = XR_FORCE_FEEDBACK_CURL_LOCATION_INDEX_CURL_MNDX,

  MiddleCurl = XR_FORCE_FEEDBACK_CURL_LOCATION_MIDDLE_CURL_MNDX,

  RingCurl = XR_FORCE_FEEDBACK_CURL_LOCATION_RING_CURL_MNDX,

  LittleCurl = XR_FORCE_FEEDBACK_CURL_LOCATION_LITTLE_CURL_MNDX,

};
static_assert(sizeof(ForceFeedbackCurlLocationMNDX) == sizeof(XrForceFeedbackCurlLocationMNDX),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrForceFeedbackCurlLocationMNDX value from a
 * ForceFeedbackCurlLocationMNDX.
 *
 * @found_by_adl
 * @see ForceFeedbackCurlLocationMNDX
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrForceFeedbackCurlLocationMNDX
get(ForceFeedbackCurlLocationMNDX const& v) {
  return static_cast<XrForceFeedbackCurlLocationMNDX>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrForceFeedbackCurlLocationMNDX address from a
 * ForceFeedbackCurlLocationMNDX.
 *
 * @found_by_adl
 * @see ForceFeedbackCurlLocationMNDX
 */
OPENXR_HPP_INLINE XrForceFeedbackCurlLocationMNDX* put(ForceFeedbackCurlLocationMNDX& v) {
  return reinterpret_cast<XrForceFeedbackCurlLocationMNDX*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a ForceFeedbackCurlLocationMNDX value as a
 * const char *.
 *
 * @found_by_adl
 * @see ForceFeedbackCurlLocationMNDX
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    ForceFeedbackCurlLocationMNDX value) {
  switch (value) {
    case ForceFeedbackCurlLocationMNDX::ThumbCurl:
      return "ThumbCurl";

    case ForceFeedbackCurlLocationMNDX::IndexCurl:
      return "IndexCurl";

    case ForceFeedbackCurlLocationMNDX::MiddleCurl:
      return "MiddleCurl";

    case ForceFeedbackCurlLocationMNDX::RingCurl:
      return "RingCurl";

    case ForceFeedbackCurlLocationMNDX::LittleCurl:
      return "LittleCurl";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a ForceFeedbackCurlLocationMNDX value as a
 * std::string.
 *
 * @found_by_adl
 * @see ForceFeedbackCurlLocationMNDX
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    ForceFeedbackCurlLocationMNDX value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_MNDX_force_feedback_curl

#ifdef XR_BD_body_tracking
/*!
 * @brief Enum class for XrBodyJointBD
 *
 * Provided by the `XR_BD_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointBD>
 *
 * @xrentity{XrBodyJointBD}
 */
enum class BodyJointBD {

  Pelvis = XR_BODY_JOINT_PELVIS_BD,

  LeftHip = XR_BODY_JOINT_LEFT_HIP_BD,

  RightHip = XR_BODY_JOINT_RIGHT_HIP_BD,

  Spine1 = XR_BODY_JOINT_SPINE1_BD,

  LeftKnee = XR_BODY_JOINT_LEFT_KNEE_BD,

  RightKnee = XR_BODY_JOINT_RIGHT_KNEE_BD,

  Spine2 = XR_BODY_JOINT_SPINE2_BD,

  LeftAnkle = XR_BODY_JOINT_LEFT_ANKLE_BD,

  RightAnkle = XR_BODY_JOINT_RIGHT_ANKLE_BD,

  Spine3 = XR_BODY_JOINT_SPINE3_BD,

  LeftFoot = XR_BODY_JOINT_LEFT_FOOT_BD,

  RightFoot = XR_BODY_JOINT_RIGHT_FOOT_BD,

  Neck = XR_BODY_JOINT_NECK_BD,

  LeftCollar = XR_BODY_JOINT_LEFT_COLLAR_BD,

  RightCollar = XR_BODY_JOINT_RIGHT_COLLAR_BD,

  Head = XR_BODY_JOINT_HEAD_BD,

  LeftShoulder = XR_BODY_JOINT_LEFT_SHOULDER_BD,

  RightShoulder = XR_BODY_JOINT_RIGHT_SHOULDER_BD,

  LeftElbow = XR_BODY_JOINT_LEFT_ELBOW_BD,

  RightElbow = XR_BODY_JOINT_RIGHT_ELBOW_BD,

  LeftWrist = XR_BODY_JOINT_LEFT_WRIST_BD,

  RightWrist = XR_BODY_JOINT_RIGHT_WRIST_BD,

  LeftHand = XR_BODY_JOINT_LEFT_HAND_BD,

  RightHand = XR_BODY_JOINT_RIGHT_HAND_BD,

};
static_assert(sizeof(BodyJointBD) == sizeof(XrBodyJointBD),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointBD value from a BodyJointBD.
 *
 * @found_by_adl
 * @see BodyJointBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrBodyJointBD get(BodyJointBD const& v) {
  return static_cast<XrBodyJointBD>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointBD address from a BodyJointBD.
 *
 * @found_by_adl
 * @see BodyJointBD
 */
OPENXR_HPP_INLINE XrBodyJointBD* put(BodyJointBD& v) {
  return reinterpret_cast<XrBodyJointBD*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointBD value as a const char *.
 *
 * @found_by_adl
 * @see BodyJointBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(BodyJointBD value) {
  switch (value) {
    case BodyJointBD::Pelvis:
      return "Pelvis";

    case BodyJointBD::LeftHip:
      return "LeftHip";

    case BodyJointBD::RightHip:
      return "RightHip";

    case BodyJointBD::Spine1:
      return "Spine1";

    case BodyJointBD::LeftKnee:
      return "LeftKnee";

    case BodyJointBD::RightKnee:
      return "RightKnee";

    case BodyJointBD::Spine2:
      return "Spine2";

    case BodyJointBD::LeftAnkle:
      return "LeftAnkle";

    case BodyJointBD::RightAnkle:
      return "RightAnkle";

    case BodyJointBD::Spine3:
      return "Spine3";

    case BodyJointBD::LeftFoot:
      return "LeftFoot";

    case BodyJointBD::RightFoot:
      return "RightFoot";

    case BodyJointBD::Neck:
      return "Neck";

    case BodyJointBD::LeftCollar:
      return "LeftCollar";

    case BodyJointBD::RightCollar:
      return "RightCollar";

    case BodyJointBD::Head:
      return "Head";

    case BodyJointBD::LeftShoulder:
      return "LeftShoulder";

    case BodyJointBD::RightShoulder:
      return "RightShoulder";

    case BodyJointBD::LeftElbow:
      return "LeftElbow";

    case BodyJointBD::RightElbow:
      return "RightElbow";

    case BodyJointBD::LeftWrist:
      return "LeftWrist";

    case BodyJointBD::RightWrist:
      return "RightWrist";

    case BodyJointBD::LeftHand:
      return "LeftHand";

    case BodyJointBD::RightHand:
      return "RightHand";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointBD value as a std::string.
 *
 * @found_by_adl
 * @see BodyJointBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(BodyJointBD value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_BD_body_tracking

#ifdef XR_BD_body_tracking
/*!
 * @brief Enum class for XrBodyJointSetBD
 *
 * Provided by the `XR_BD_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointSetBD>
 *
 * @xrentity{XrBodyJointSetBD}
 */
enum class BodyJointSetBD {

  BodyWithoutARM = XR_BODY_JOINT_SET_BODY_WITHOUT_ARM_BD,

  FullBodyJoints = XR_BODY_JOINT_SET_FULL_BODY_JOINTS_BD,

};
static_assert(sizeof(BodyJointSetBD) == sizeof(XrBodyJointSetBD),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointSetBD value from a BodyJointSetBD.
 *
 * @found_by_adl
 * @see BodyJointSetBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrBodyJointSetBD get(BodyJointSetBD const& v) {
  return static_cast<XrBodyJointSetBD>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrBodyJointSetBD address from a BodyJointSetBD.
 *
 * @found_by_adl
 * @see BodyJointSetBD
 */
OPENXR_HPP_INLINE XrBodyJointSetBD* put(BodyJointSetBD& v) {
  return reinterpret_cast<XrBodyJointSetBD*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointSetBD value as a const char *.
 *
 * @found_by_adl
 * @see BodyJointSetBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(BodyJointSetBD value) {
  switch (value) {
    case BodyJointSetBD::BodyWithoutARM:
      return "BodyWithoutARM";

    case BodyJointSetBD::FullBodyJoints:
      return "FullBodyJoints";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a BodyJointSetBD value as a std::string.
 *
 * @found_by_adl
 * @see BodyJointSetBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(BodyJointSetBD value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_BD_body_tracking

#ifdef XR_BD_spatial_sensing
/*!
 * @brief Enum class for XrSpatialEntityComponentTypeBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityComponentTypeBD>
 *
 * @xrentity{XrSpatialEntityComponentTypeBD}
 */
enum class SpatialEntityComponentTypeBD {

  Location = XR_SPATIAL_ENTITY_COMPONENT_TYPE_LOCATION_BD,

  Semantic = XR_SPATIAL_ENTITY_COMPONENT_TYPE_SEMANTIC_BD,

  BoundingBox2D = XR_SPATIAL_ENTITY_COMPONENT_TYPE_BOUNDING_BOX_2D_BD,

  Polygon = XR_SPATIAL_ENTITY_COMPONENT_TYPE_POLYGON_BD,

  BoundingBox3D = XR_SPATIAL_ENTITY_COMPONENT_TYPE_BOUNDING_BOX_3D_BD,

  TriangleMesh = XR_SPATIAL_ENTITY_COMPONENT_TYPE_TRIANGLE_MESH_BD,

#ifdef XR_BD_spatial_plane
  PlaneOrientation = XR_SPATIAL_ENTITY_COMPONENT_TYPE_PLANE_ORIENTATION_BD,
#endif  // XR_BD_spatial_plane
};
static_assert(sizeof(SpatialEntityComponentTypeBD) == sizeof(XrSpatialEntityComponentTypeBD),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialEntityComponentTypeBD value from a
 * SpatialEntityComponentTypeBD.
 *
 * @found_by_adl
 * @see SpatialEntityComponentTypeBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialEntityComponentTypeBD
get(SpatialEntityComponentTypeBD const& v) {
  return static_cast<XrSpatialEntityComponentTypeBD>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialEntityComponentTypeBD address from a
 * SpatialEntityComponentTypeBD.
 *
 * @found_by_adl
 * @see SpatialEntityComponentTypeBD
 */
OPENXR_HPP_INLINE XrSpatialEntityComponentTypeBD* put(SpatialEntityComponentTypeBD& v) {
  return reinterpret_cast<XrSpatialEntityComponentTypeBD*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialEntityComponentTypeBD value as a
 * const char *.
 *
 * @found_by_adl
 * @see SpatialEntityComponentTypeBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialEntityComponentTypeBD value) {
  switch (value) {
    case SpatialEntityComponentTypeBD::Location:
      return "Location";

    case SpatialEntityComponentTypeBD::Semantic:
      return "Semantic";

    case SpatialEntityComponentTypeBD::BoundingBox2D:
      return "BoundingBox2D";

    case SpatialEntityComponentTypeBD::Polygon:
      return "Polygon";

    case SpatialEntityComponentTypeBD::BoundingBox3D:
      return "BoundingBox3D";

    case SpatialEntityComponentTypeBD::TriangleMesh:
      return "TriangleMesh";

#ifdef XR_BD_spatial_plane
    case SpatialEntityComponentTypeBD::PlaneOrientation:
      return "PlaneOrientation";
#endif  // XR_BD_spatial_plane
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialEntityComponentTypeBD value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialEntityComponentTypeBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SpatialEntityComponentTypeBD value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * @brief Enum class for XrSemanticLabelBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSemanticLabelBD>
 *
 * @xrentity{XrSemanticLabelBD}
 */
enum class SemanticLabelBD {

  Unknown = XR_SEMANTIC_LABEL_UNKNOWN_BD,

  Floor = XR_SEMANTIC_LABEL_FLOOR_BD,

  Ceiling = XR_SEMANTIC_LABEL_CEILING_BD,

  Wall = XR_SEMANTIC_LABEL_WALL_BD,

  Door = XR_SEMANTIC_LABEL_DOOR_BD,

  Window = XR_SEMANTIC_LABEL_WINDOW_BD,

  Opening = XR_SEMANTIC_LABEL_OPENING_BD,

  Table = XR_SEMANTIC_LABEL_TABLE_BD,

  Sofa = XR_SEMANTIC_LABEL_SOFA_BD,

  Chair = XR_SEMANTIC_LABEL_CHAIR_BD,

  Human = XR_SEMANTIC_LABEL_HUMAN_BD,

  Beam = XR_SEMANTIC_LABEL_BEAM_BD,

  Column = XR_SEMANTIC_LABEL_COLUMN_BD,

  Curtain = XR_SEMANTIC_LABEL_CURTAIN_BD,

  Cabinet = XR_SEMANTIC_LABEL_CABINET_BD,

  Bed = XR_SEMANTIC_LABEL_BED_BD,

  Plant = XR_SEMANTIC_LABEL_PLANT_BD,

  Screen = XR_SEMANTIC_LABEL_SCREEN_BD,

  VirtualWall = XR_SEMANTIC_LABEL_VIRTUAL_WALL_BD,

  Refrigerator = XR_SEMANTIC_LABEL_REFRIGERATOR_BD,

  WashingMachine = XR_SEMANTIC_LABEL_WASHING_MACHINE_BD,

  AirConditioner = XR_SEMANTIC_LABEL_AIR_CONDITIONER_BD,

  Lamp = XR_SEMANTIC_LABEL_LAMP_BD,

  WallArt = XR_SEMANTIC_LABEL_WALL_ART_BD,

  Stairway = XR_SEMANTIC_LABEL_STAIRWAY_BD,

};
static_assert(sizeof(SemanticLabelBD) == sizeof(XrSemanticLabelBD),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSemanticLabelBD value from a SemanticLabelBD.
 *
 * @found_by_adl
 * @see SemanticLabelBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSemanticLabelBD get(SemanticLabelBD const& v) {
  return static_cast<XrSemanticLabelBD>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSemanticLabelBD address from a SemanticLabelBD.
 *
 * @found_by_adl
 * @see SemanticLabelBD
 */
OPENXR_HPP_INLINE XrSemanticLabelBD* put(SemanticLabelBD& v) {
  return reinterpret_cast<XrSemanticLabelBD*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SemanticLabelBD value as a const char *.
 *
 * @found_by_adl
 * @see SemanticLabelBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(SemanticLabelBD value) {
  switch (value) {
    case SemanticLabelBD::Unknown:
      return "Unknown";

    case SemanticLabelBD::Floor:
      return "Floor";

    case SemanticLabelBD::Ceiling:
      return "Ceiling";

    case SemanticLabelBD::Wall:
      return "Wall";

    case SemanticLabelBD::Door:
      return "Door";

    case SemanticLabelBD::Window:
      return "Window";

    case SemanticLabelBD::Opening:
      return "Opening";

    case SemanticLabelBD::Table:
      return "Table";

    case SemanticLabelBD::Sofa:
      return "Sofa";

    case SemanticLabelBD::Chair:
      return "Chair";

    case SemanticLabelBD::Human:
      return "Human";

    case SemanticLabelBD::Beam:
      return "Beam";

    case SemanticLabelBD::Column:
      return "Column";

    case SemanticLabelBD::Curtain:
      return "Curtain";

    case SemanticLabelBD::Cabinet:
      return "Cabinet";

    case SemanticLabelBD::Bed:
      return "Bed";

    case SemanticLabelBD::Plant:
      return "Plant";

    case SemanticLabelBD::Screen:
      return "Screen";

    case SemanticLabelBD::VirtualWall:
      return "VirtualWall";

    case SemanticLabelBD::Refrigerator:
      return "Refrigerator";

    case SemanticLabelBD::WashingMachine:
      return "WashingMachine";

    case SemanticLabelBD::AirConditioner:
      return "AirConditioner";

    case SemanticLabelBD::Lamp:
      return "Lamp";

    case SemanticLabelBD::WallArt:
      return "WallArt";

    case SemanticLabelBD::Stairway:
      return "Stairway";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SemanticLabelBD value as a std::string.
 *
 * @found_by_adl
 * @see SemanticLabelBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SemanticLabelBD value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * @brief Enum class for XrSenseDataProviderTypeBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSenseDataProviderTypeBD>
 *
 * @xrentity{XrSenseDataProviderTypeBD}
 */
enum class SenseDataProviderTypeBD {
#ifdef XR_BD_spatial_anchor
  Anchor = XR_SENSE_DATA_PROVIDER_TYPE_ANCHOR_BD,
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_scene
  Scene = XR_SENSE_DATA_PROVIDER_TYPE_SCENE_BD,
#endif  // XR_BD_spatial_scene
#ifdef XR_BD_spatial_mesh
  Mesh = XR_SENSE_DATA_PROVIDER_TYPE_MESH_BD,
#endif  // XR_BD_spatial_mesh
#ifdef XR_BD_spatial_plane
  Plane = XR_SENSE_DATA_PROVIDER_TYPE_PLANE_BD,
#endif  // XR_BD_spatial_plane
};
static_assert(sizeof(SenseDataProviderTypeBD) == sizeof(XrSenseDataProviderTypeBD),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSenseDataProviderTypeBD value from a
 * SenseDataProviderTypeBD.
 *
 * @found_by_adl
 * @see SenseDataProviderTypeBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSenseDataProviderTypeBD
get(SenseDataProviderTypeBD const& v) {
  return static_cast<XrSenseDataProviderTypeBD>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSenseDataProviderTypeBD address from a
 * SenseDataProviderTypeBD.
 *
 * @found_by_adl
 * @see SenseDataProviderTypeBD
 */
OPENXR_HPP_INLINE XrSenseDataProviderTypeBD* put(SenseDataProviderTypeBD& v) {
  return reinterpret_cast<XrSenseDataProviderTypeBD*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SenseDataProviderTypeBD value as a const
 * char *.
 *
 * @found_by_adl
 * @see SenseDataProviderTypeBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SenseDataProviderTypeBD value) {
  switch (value) {
#ifdef XR_BD_spatial_anchor
    case SenseDataProviderTypeBD::Anchor:
      return "Anchor";
#endif  // XR_BD_spatial_anchor
#ifdef XR_BD_spatial_scene
    case SenseDataProviderTypeBD::Scene:
      return "Scene";
#endif  // XR_BD_spatial_scene
#ifdef XR_BD_spatial_mesh
    case SenseDataProviderTypeBD::Mesh:
      return "Mesh";
#endif  // XR_BD_spatial_mesh
#ifdef XR_BD_spatial_plane
    case SenseDataProviderTypeBD::Plane:
      return "Plane";
#endif  // XR_BD_spatial_plane
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SenseDataProviderTypeBD value as a
 * std::string.
 *
 * @found_by_adl
 * @see SenseDataProviderTypeBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SenseDataProviderTypeBD value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * @brief Enum class for XrSenseDataProviderStateBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSenseDataProviderStateBD>
 *
 * @xrentity{XrSenseDataProviderStateBD}
 */
enum class SenseDataProviderStateBD {

  Initialized = XR_SENSE_DATA_PROVIDER_STATE_INITIALIZED_BD,

  Running = XR_SENSE_DATA_PROVIDER_STATE_RUNNING_BD,

  Stopped = XR_SENSE_DATA_PROVIDER_STATE_STOPPED_BD,

};
static_assert(sizeof(SenseDataProviderStateBD) == sizeof(XrSenseDataProviderStateBD),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSenseDataProviderStateBD value from a
 * SenseDataProviderStateBD.
 *
 * @found_by_adl
 * @see SenseDataProviderStateBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSenseDataProviderStateBD
get(SenseDataProviderStateBD const& v) {
  return static_cast<XrSenseDataProviderStateBD>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSenseDataProviderStateBD address from a
 * SenseDataProviderStateBD.
 *
 * @found_by_adl
 * @see SenseDataProviderStateBD
 */
OPENXR_HPP_INLINE XrSenseDataProviderStateBD* put(SenseDataProviderStateBD& v) {
  return reinterpret_cast<XrSenseDataProviderStateBD*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SenseDataProviderStateBD value as a
 * const char *.
 *
 * @found_by_adl
 * @see SenseDataProviderStateBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SenseDataProviderStateBD value) {
  switch (value) {
    case SenseDataProviderStateBD::Initialized:
      return "Initialized";

    case SenseDataProviderStateBD::Running:
      return "Running";

    case SenseDataProviderStateBD::Stopped:
      return "Stopped";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SenseDataProviderStateBD value as a
 * std::string.
 *
 * @found_by_adl
 * @see SenseDataProviderStateBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SenseDataProviderStateBD value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_anchor
/*!
 * @brief Enum class for XrPersistenceLocationBD
 *
 * Provided by the `XR_BD_spatial_anchor` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPersistenceLocationBD>
 *
 * @xrentity{XrPersistenceLocationBD}
 */
enum class PersistenceLocationBD {

  Local = XR_PERSISTENCE_LOCATION_LOCAL_BD,

};
static_assert(sizeof(PersistenceLocationBD) == sizeof(XrPersistenceLocationBD),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPersistenceLocationBD value from a
 * PersistenceLocationBD.
 *
 * @found_by_adl
 * @see PersistenceLocationBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPersistenceLocationBD get(PersistenceLocationBD const& v) {
  return static_cast<XrPersistenceLocationBD>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPersistenceLocationBD address from a
 * PersistenceLocationBD.
 *
 * @found_by_adl
 * @see PersistenceLocationBD
 */
OPENXR_HPP_INLINE XrPersistenceLocationBD* put(PersistenceLocationBD& v) {
  return reinterpret_cast<XrPersistenceLocationBD*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PersistenceLocationBD value as a const
 * char *.
 *
 * @found_by_adl
 * @see PersistenceLocationBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PersistenceLocationBD value) {
  switch (value) {
    case PersistenceLocationBD::Local:
      return "Local";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PersistenceLocationBD value as a
 * std::string.
 *
 * @found_by_adl
 * @see PersistenceLocationBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PersistenceLocationBD value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_BD_spatial_anchor

#ifdef XR_BD_spatial_mesh
/*!
 * @brief Enum class for XrSpatialMeshLodBD
 *
 * Provided by the `XR_BD_spatial_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialMeshLodBD>
 *
 * @xrentity{XrSpatialMeshLodBD}
 */
enum class SpatialMeshLodBD {

  Coarse = XR_SPATIAL_MESH_LOD_COARSE_BD,

  Medium = XR_SPATIAL_MESH_LOD_MEDIUM_BD,

  Fine = XR_SPATIAL_MESH_LOD_FINE_BD,

};
static_assert(sizeof(SpatialMeshLodBD) == sizeof(XrSpatialMeshLodBD),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialMeshLodBD value from a SpatialMeshLodBD.
 *
 * @found_by_adl
 * @see SpatialMeshLodBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialMeshLodBD get(SpatialMeshLodBD const& v) {
  return static_cast<XrSpatialMeshLodBD>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialMeshLodBD address from a SpatialMeshLodBD.
 *
 * @found_by_adl
 * @see SpatialMeshLodBD
 */
OPENXR_HPP_INLINE XrSpatialMeshLodBD* put(SpatialMeshLodBD& v) {
  return reinterpret_cast<XrSpatialMeshLodBD*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialMeshLodBD value as a const char
 * *.
 *
 * @found_by_adl
 * @see SpatialMeshLodBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialMeshLodBD value) {
  switch (value) {
    case SpatialMeshLodBD::Coarse:
      return "Coarse";

    case SpatialMeshLodBD::Medium:
      return "Medium";

    case SpatialMeshLodBD::Fine:
      return "Fine";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialMeshLodBD value as a std::string.
 *
 * @found_by_adl
 * @see SpatialMeshLodBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SpatialMeshLodBD value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_BD_spatial_mesh

#ifdef XR_BD_spatial_plane
/*!
 * @brief Enum class for XrPlaneOrientationBD
 *
 * Provided by the `XR_BD_spatial_plane` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneOrientationBD>
 *
 * @xrentity{XrPlaneOrientationBD}
 */
enum class PlaneOrientationBD {

  HorizontalUpward = XR_PLANE_ORIENTATION_HORIZONTAL_UPWARD_BD,

  HorizontalDownward = XR_PLANE_ORIENTATION_HORIZONTAL_DOWNWARD_BD,

  Vertical = XR_PLANE_ORIENTATION_VERTICAL_BD,

  Arbitrary = XR_PLANE_ORIENTATION_ARBITRARY_BD,

};
static_assert(sizeof(PlaneOrientationBD) == sizeof(XrPlaneOrientationBD),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPlaneOrientationBD value from a PlaneOrientationBD.
 *
 * @found_by_adl
 * @see PlaneOrientationBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPlaneOrientationBD get(PlaneOrientationBD const& v) {
  return static_cast<XrPlaneOrientationBD>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPlaneOrientationBD address from a
 * PlaneOrientationBD.
 *
 * @found_by_adl
 * @see PlaneOrientationBD
 */
OPENXR_HPP_INLINE XrPlaneOrientationBD* put(PlaneOrientationBD& v) {
  return reinterpret_cast<XrPlaneOrientationBD*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PlaneOrientationBD value as a const char
 * *.
 *
 * @found_by_adl
 * @see PlaneOrientationBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PlaneOrientationBD value) {
  switch (value) {
    case PlaneOrientationBD::HorizontalUpward:
      return "HorizontalUpward";

    case PlaneOrientationBD::HorizontalDownward:
      return "HorizontalDownward";

    case PlaneOrientationBD::Vertical:
      return "Vertical";

    case PlaneOrientationBD::Arbitrary:
      return "Arbitrary";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PlaneOrientationBD value as a
 * std::string.
 *
 * @found_by_adl
 * @see PlaneOrientationBD
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PlaneOrientationBD value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_BD_spatial_plane

#ifdef XR_EXT_hand_tracking_data_source
/*!
 * @brief Enum class for XrHandTrackingDataSourceEXT
 *
 * Provided by the `XR_EXT_hand_tracking_data_source` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingDataSourceEXT>
 *
 * @xrentity{XrHandTrackingDataSourceEXT}
 */
enum class HandTrackingDataSourceEXT {

  Unobstructed = XR_HAND_TRACKING_DATA_SOURCE_UNOBSTRUCTED_EXT,

  Controller = XR_HAND_TRACKING_DATA_SOURCE_CONTROLLER_EXT,

};
static_assert(sizeof(HandTrackingDataSourceEXT) == sizeof(XrHandTrackingDataSourceEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandTrackingDataSourceEXT value from a
 * HandTrackingDataSourceEXT.
 *
 * @found_by_adl
 * @see HandTrackingDataSourceEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHandTrackingDataSourceEXT
get(HandTrackingDataSourceEXT const& v) {
  return static_cast<XrHandTrackingDataSourceEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHandTrackingDataSourceEXT address from a
 * HandTrackingDataSourceEXT.
 *
 * @found_by_adl
 * @see HandTrackingDataSourceEXT
 */
OPENXR_HPP_INLINE XrHandTrackingDataSourceEXT* put(HandTrackingDataSourceEXT& v) {
  return reinterpret_cast<XrHandTrackingDataSourceEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a HandTrackingDataSourceEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see HandTrackingDataSourceEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    HandTrackingDataSourceEXT value) {
  switch (value) {
    case HandTrackingDataSourceEXT::Unobstructed:
      return "Unobstructed";

    case HandTrackingDataSourceEXT::Controller:
      return "Controller";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HandTrackingDataSourceEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see HandTrackingDataSourceEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    HandTrackingDataSourceEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_hand_tracking_data_source

#ifdef XR_EXT_plane_detection
/*!
 * @brief Enum class for XrPlaneDetectorOrientationEXT
 *
 * Provided by the `XR_EXT_plane_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorOrientationEXT>
 *
 * @xrentity{XrPlaneDetectorOrientationEXT}
 */
enum class PlaneDetectorOrientationEXT {

  HorizontalUpward = XR_PLANE_DETECTOR_ORIENTATION_HORIZONTAL_UPWARD_EXT,

  HorizontalDownward = XR_PLANE_DETECTOR_ORIENTATION_HORIZONTAL_DOWNWARD_EXT,

  Vertical = XR_PLANE_DETECTOR_ORIENTATION_VERTICAL_EXT,

  Arbitrary = XR_PLANE_DETECTOR_ORIENTATION_ARBITRARY_EXT,

};
static_assert(sizeof(PlaneDetectorOrientationEXT) == sizeof(XrPlaneDetectorOrientationEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPlaneDetectorOrientationEXT value from a
 * PlaneDetectorOrientationEXT.
 *
 * @found_by_adl
 * @see PlaneDetectorOrientationEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPlaneDetectorOrientationEXT
get(PlaneDetectorOrientationEXT const& v) {
  return static_cast<XrPlaneDetectorOrientationEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPlaneDetectorOrientationEXT address from a
 * PlaneDetectorOrientationEXT.
 *
 * @found_by_adl
 * @see PlaneDetectorOrientationEXT
 */
OPENXR_HPP_INLINE XrPlaneDetectorOrientationEXT* put(PlaneDetectorOrientationEXT& v) {
  return reinterpret_cast<XrPlaneDetectorOrientationEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PlaneDetectorOrientationEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see PlaneDetectorOrientationEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PlaneDetectorOrientationEXT value) {
  switch (value) {
    case PlaneDetectorOrientationEXT::HorizontalUpward:
      return "HorizontalUpward";

    case PlaneDetectorOrientationEXT::HorizontalDownward:
      return "HorizontalDownward";

    case PlaneDetectorOrientationEXT::Vertical:
      return "Vertical";

    case PlaneDetectorOrientationEXT::Arbitrary:
      return "Arbitrary";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PlaneDetectorOrientationEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see PlaneDetectorOrientationEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    PlaneDetectorOrientationEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_plane_detection

#ifdef XR_EXT_plane_detection
/*!
 * @brief Enum class for XrPlaneDetectorSemanticTypeEXT
 *
 * Provided by the `XR_EXT_plane_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorSemanticTypeEXT>
 *
 * @xrentity{XrPlaneDetectorSemanticTypeEXT}
 */
enum class PlaneDetectorSemanticTypeEXT {

  Undefined = XR_PLANE_DETECTOR_SEMANTIC_TYPE_UNDEFINED_EXT,

  Ceiling = XR_PLANE_DETECTOR_SEMANTIC_TYPE_CEILING_EXT,

  Floor = XR_PLANE_DETECTOR_SEMANTIC_TYPE_FLOOR_EXT,

  Wall = XR_PLANE_DETECTOR_SEMANTIC_TYPE_WALL_EXT,

  Platform = XR_PLANE_DETECTOR_SEMANTIC_TYPE_PLATFORM_EXT,

};
static_assert(sizeof(PlaneDetectorSemanticTypeEXT) == sizeof(XrPlaneDetectorSemanticTypeEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPlaneDetectorSemanticTypeEXT value from a
 * PlaneDetectorSemanticTypeEXT.
 *
 * @found_by_adl
 * @see PlaneDetectorSemanticTypeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPlaneDetectorSemanticTypeEXT
get(PlaneDetectorSemanticTypeEXT const& v) {
  return static_cast<XrPlaneDetectorSemanticTypeEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPlaneDetectorSemanticTypeEXT address from a
 * PlaneDetectorSemanticTypeEXT.
 *
 * @found_by_adl
 * @see PlaneDetectorSemanticTypeEXT
 */
OPENXR_HPP_INLINE XrPlaneDetectorSemanticTypeEXT* put(PlaneDetectorSemanticTypeEXT& v) {
  return reinterpret_cast<XrPlaneDetectorSemanticTypeEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PlaneDetectorSemanticTypeEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see PlaneDetectorSemanticTypeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PlaneDetectorSemanticTypeEXT value) {
  switch (value) {
    case PlaneDetectorSemanticTypeEXT::Undefined:
      return "Undefined";

    case PlaneDetectorSemanticTypeEXT::Ceiling:
      return "Ceiling";

    case PlaneDetectorSemanticTypeEXT::Floor:
      return "Floor";

    case PlaneDetectorSemanticTypeEXT::Wall:
      return "Wall";

    case PlaneDetectorSemanticTypeEXT::Platform:
      return "Platform";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PlaneDetectorSemanticTypeEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see PlaneDetectorSemanticTypeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    PlaneDetectorSemanticTypeEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_plane_detection

#ifdef XR_EXT_plane_detection
/*!
 * @brief Enum class for XrPlaneDetectionStateEXT
 *
 * Provided by the `XR_EXT_plane_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectionStateEXT>
 *
 * @xrentity{XrPlaneDetectionStateEXT}
 */
enum class PlaneDetectionStateEXT {

  None = XR_PLANE_DETECTION_STATE_NONE_EXT,

  Pending = XR_PLANE_DETECTION_STATE_PENDING_EXT,

  Done = XR_PLANE_DETECTION_STATE_DONE_EXT,

  Error = XR_PLANE_DETECTION_STATE_ERROR_EXT,

  Fatal = XR_PLANE_DETECTION_STATE_FATAL_EXT,

};
static_assert(sizeof(PlaneDetectionStateEXT) == sizeof(XrPlaneDetectionStateEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPlaneDetectionStateEXT value from a
 * PlaneDetectionStateEXT.
 *
 * @found_by_adl
 * @see PlaneDetectionStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrPlaneDetectionStateEXT
get(PlaneDetectionStateEXT const& v) {
  return static_cast<XrPlaneDetectionStateEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrPlaneDetectionStateEXT address from a
 * PlaneDetectionStateEXT.
 *
 * @found_by_adl
 * @see PlaneDetectionStateEXT
 */
OPENXR_HPP_INLINE XrPlaneDetectionStateEXT* put(PlaneDetectionStateEXT& v) {
  return reinterpret_cast<XrPlaneDetectionStateEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a PlaneDetectionStateEXT value as a const
 * char *.
 *
 * @found_by_adl
 * @see PlaneDetectionStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    PlaneDetectionStateEXT value) {
  switch (value) {
    case PlaneDetectionStateEXT::None:
      return "None";

    case PlaneDetectionStateEXT::Pending:
      return "Pending";

    case PlaneDetectionStateEXT::Done:
      return "Done";

    case PlaneDetectionStateEXT::Error:
      return "Error";

    case PlaneDetectionStateEXT::Fatal:
      return "Fatal";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a PlaneDetectionStateEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see PlaneDetectionStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(PlaneDetectionStateEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_plane_detection

#ifdef XR_EXT_future
/*!
 * @brief Enum class for XrFutureStateEXT
 *
 * Provided by the `XR_EXT_future` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFutureStateEXT>
 *
 * @xrentity{XrFutureStateEXT}
 */
enum class FutureStateEXT {

  Pending = XR_FUTURE_STATE_PENDING_EXT,

  Ready = XR_FUTURE_STATE_READY_EXT,

};
static_assert(sizeof(FutureStateEXT) == sizeof(XrFutureStateEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFutureStateEXT value from a FutureStateEXT.
 *
 * @found_by_adl
 * @see FutureStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFutureStateEXT get(FutureStateEXT const& v) {
  return static_cast<XrFutureStateEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFutureStateEXT address from a FutureStateEXT.
 *
 * @found_by_adl
 * @see FutureStateEXT
 */
OPENXR_HPP_INLINE XrFutureStateEXT* put(FutureStateEXT& v) {
  return reinterpret_cast<XrFutureStateEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FutureStateEXT value as a const char *.
 *
 * @found_by_adl
 * @see FutureStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(FutureStateEXT value) {
  switch (value) {
    case FutureStateEXT::Pending:
      return "Pending";

    case FutureStateEXT::Ready:
      return "Ready";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FutureStateEXT value as a std::string.
 *
 * @found_by_adl
 * @see FutureStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FutureStateEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_future

#ifdef XR_ML_user_calibration
/*!
 * @brief Enum class for XrHeadsetFitStatusML
 *
 * Provided by the `XR_ML_user_calibration` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHeadsetFitStatusML>
 *
 * @xrentity{XrHeadsetFitStatusML}
 */
enum class HeadsetFitStatusML {

  Unknown = XR_HEADSET_FIT_STATUS_UNKNOWN_ML,

  NotWorn = XR_HEADSET_FIT_STATUS_NOT_WORN_ML,

  GoodFit = XR_HEADSET_FIT_STATUS_GOOD_FIT_ML,

  BadFit = XR_HEADSET_FIT_STATUS_BAD_FIT_ML,

};
static_assert(sizeof(HeadsetFitStatusML) == sizeof(XrHeadsetFitStatusML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHeadsetFitStatusML value from a HeadsetFitStatusML.
 *
 * @found_by_adl
 * @see HeadsetFitStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrHeadsetFitStatusML get(HeadsetFitStatusML const& v) {
  return static_cast<XrHeadsetFitStatusML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrHeadsetFitStatusML address from a
 * HeadsetFitStatusML.
 *
 * @found_by_adl
 * @see HeadsetFitStatusML
 */
OPENXR_HPP_INLINE XrHeadsetFitStatusML* put(HeadsetFitStatusML& v) {
  return reinterpret_cast<XrHeadsetFitStatusML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a HeadsetFitStatusML value as a const char
 * *.
 *
 * @found_by_adl
 * @see HeadsetFitStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    HeadsetFitStatusML value) {
  switch (value) {
    case HeadsetFitStatusML::Unknown:
      return "Unknown";

    case HeadsetFitStatusML::NotWorn:
      return "NotWorn";

    case HeadsetFitStatusML::GoodFit:
      return "GoodFit";

    case HeadsetFitStatusML::BadFit:
      return "BadFit";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a HeadsetFitStatusML value as a
 * std::string.
 *
 * @found_by_adl
 * @see HeadsetFitStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(HeadsetFitStatusML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_user_calibration

#ifdef XR_ML_user_calibration
/*!
 * @brief Enum class for XrEyeCalibrationStatusML
 *
 * Provided by the `XR_ML_user_calibration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeCalibrationStatusML>
 *
 * @xrentity{XrEyeCalibrationStatusML}
 */
enum class EyeCalibrationStatusML {

  Unknown = XR_EYE_CALIBRATION_STATUS_UNKNOWN_ML,

  None = XR_EYE_CALIBRATION_STATUS_NONE_ML,

  Coarse = XR_EYE_CALIBRATION_STATUS_COARSE_ML,

  Fine = XR_EYE_CALIBRATION_STATUS_FINE_ML,

};
static_assert(sizeof(EyeCalibrationStatusML) == sizeof(XrEyeCalibrationStatusML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyeCalibrationStatusML value from a
 * EyeCalibrationStatusML.
 *
 * @found_by_adl
 * @see EyeCalibrationStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrEyeCalibrationStatusML
get(EyeCalibrationStatusML const& v) {
  return static_cast<XrEyeCalibrationStatusML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrEyeCalibrationStatusML address from a
 * EyeCalibrationStatusML.
 *
 * @found_by_adl
 * @see EyeCalibrationStatusML
 */
OPENXR_HPP_INLINE XrEyeCalibrationStatusML* put(EyeCalibrationStatusML& v) {
  return reinterpret_cast<XrEyeCalibrationStatusML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a EyeCalibrationStatusML value as a const
 * char *.
 *
 * @found_by_adl
 * @see EyeCalibrationStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    EyeCalibrationStatusML value) {
  switch (value) {
    case EyeCalibrationStatusML::Unknown:
      return "Unknown";

    case EyeCalibrationStatusML::None:
      return "None";

    case EyeCalibrationStatusML::Coarse:
      return "Coarse";

    case EyeCalibrationStatusML::Fine:
      return "Fine";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a EyeCalibrationStatusML value as a
 * std::string.
 *
 * @found_by_adl
 * @see EyeCalibrationStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(EyeCalibrationStatusML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_user_calibration

#ifdef dsaXR_ML_world_mesh_detection
/*!
 * @brief Enum class for XrWorldMeshDetectorLodML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshDetectorLodML>
 *
 * @xrentity{XrWorldMeshDetectorLodML}
 */
enum class WorldMeshDetectorLodML {

  Minimum = XR_WORLD_MESH_DETECTOR_LOD_MINIMUM_ML,

  Medium = XR_WORLD_MESH_DETECTOR_LOD_MEDIUM_ML,

  Maximum = XR_WORLD_MESH_DETECTOR_LOD_MAXIMUM_ML,

};
static_assert(sizeof(WorldMeshDetectorLodML) == sizeof(XrWorldMeshDetectorLodML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrWorldMeshDetectorLodML value from a
 * WorldMeshDetectorLodML.
 *
 * @found_by_adl
 * @see WorldMeshDetectorLodML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrWorldMeshDetectorLodML
get(WorldMeshDetectorLodML const& v) {
  return static_cast<XrWorldMeshDetectorLodML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrWorldMeshDetectorLodML address from a
 * WorldMeshDetectorLodML.
 *
 * @found_by_adl
 * @see WorldMeshDetectorLodML
 */
OPENXR_HPP_INLINE XrWorldMeshDetectorLodML* put(WorldMeshDetectorLodML& v) {
  return reinterpret_cast<XrWorldMeshDetectorLodML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a WorldMeshDetectorLodML value as a const
 * char *.
 *
 * @found_by_adl
 * @see WorldMeshDetectorLodML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    WorldMeshDetectorLodML value) {
  switch (value) {
    case WorldMeshDetectorLodML::Minimum:
      return "Minimum";

    case WorldMeshDetectorLodML::Medium:
      return "Medium";

    case WorldMeshDetectorLodML::Maximum:
      return "Maximum";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a WorldMeshDetectorLodML value as a
 * std::string.
 *
 * @found_by_adl
 * @see WorldMeshDetectorLodML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(WorldMeshDetectorLodML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_world_mesh_detection

#ifdef dsaXR_ML_world_mesh_detection
/*!
 * @brief Enum class for XrWorldMeshBlockStatusML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshBlockStatusML>
 *
 * @xrentity{XrWorldMeshBlockStatusML}
 */
enum class WorldMeshBlockStatusML {

  New = XR_WORLD_MESH_BLOCK_STATUS_NEW_ML,

  Updated = XR_WORLD_MESH_BLOCK_STATUS_UPDATED_ML,

  Deleted = XR_WORLD_MESH_BLOCK_STATUS_DELETED_ML,

  Unchanged = XR_WORLD_MESH_BLOCK_STATUS_UNCHANGED_ML,

};
static_assert(sizeof(WorldMeshBlockStatusML) == sizeof(XrWorldMeshBlockStatusML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrWorldMeshBlockStatusML value from a
 * WorldMeshBlockStatusML.
 *
 * @found_by_adl
 * @see WorldMeshBlockStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrWorldMeshBlockStatusML
get(WorldMeshBlockStatusML const& v) {
  return static_cast<XrWorldMeshBlockStatusML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrWorldMeshBlockStatusML address from a
 * WorldMeshBlockStatusML.
 *
 * @found_by_adl
 * @see WorldMeshBlockStatusML
 */
OPENXR_HPP_INLINE XrWorldMeshBlockStatusML* put(WorldMeshBlockStatusML& v) {
  return reinterpret_cast<XrWorldMeshBlockStatusML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a WorldMeshBlockStatusML value as a const
 * char *.
 *
 * @found_by_adl
 * @see WorldMeshBlockStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    WorldMeshBlockStatusML value) {
  switch (value) {
    case WorldMeshBlockStatusML::New:
      return "New";

    case WorldMeshBlockStatusML::Updated:
      return "Updated";

    case WorldMeshBlockStatusML::Deleted:
      return "Deleted";

    case WorldMeshBlockStatusML::Unchanged:
      return "Unchanged";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a WorldMeshBlockStatusML value as a
 * std::string.
 *
 * @found_by_adl
 * @see WorldMeshBlockStatusML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(WorldMeshBlockStatusML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_world_mesh_detection

#ifdef dsaXR_ML_world_mesh_detection
/*!
 * @brief Enum class for XrWorldMeshBlockResultML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshBlockResultML>
 *
 * @xrentity{XrWorldMeshBlockResultML}
 */
enum class WorldMeshBlockResultML {

  Success = XR_WORLD_MESH_BLOCK_RESULT_SUCCESS_ML,

  Failed = XR_WORLD_MESH_BLOCK_RESULT_FAILED_ML,

  Pending = XR_WORLD_MESH_BLOCK_RESULT_PENDING_ML,

  PartialUpdate = XR_WORLD_MESH_BLOCK_RESULT_PARTIAL_UPDATE_ML,

};
static_assert(sizeof(WorldMeshBlockResultML) == sizeof(XrWorldMeshBlockResultML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrWorldMeshBlockResultML value from a
 * WorldMeshBlockResultML.
 *
 * @found_by_adl
 * @see WorldMeshBlockResultML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrWorldMeshBlockResultML
get(WorldMeshBlockResultML const& v) {
  return static_cast<XrWorldMeshBlockResultML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrWorldMeshBlockResultML address from a
 * WorldMeshBlockResultML.
 *
 * @found_by_adl
 * @see WorldMeshBlockResultML
 */
OPENXR_HPP_INLINE XrWorldMeshBlockResultML* put(WorldMeshBlockResultML& v) {
  return reinterpret_cast<XrWorldMeshBlockResultML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a WorldMeshBlockResultML value as a const
 * char *.
 *
 * @found_by_adl
 * @see WorldMeshBlockResultML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    WorldMeshBlockResultML value) {
  switch (value) {
    case WorldMeshBlockResultML::Success:
      return "Success";

    case WorldMeshBlockResultML::Failed:
      return "Failed";

    case WorldMeshBlockResultML::Pending:
      return "Pending";

    case WorldMeshBlockResultML::PartialUpdate:
      return "PartialUpdate";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a WorldMeshBlockResultML value as a
 * std::string.
 *
 * @found_by_adl
 * @see WorldMeshBlockResultML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(WorldMeshBlockResultML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_facial_expression
/*!
 * @brief Enum class for XrFacialBlendShapeML
 *
 * Provided by the `XR_ML_facial_expression` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialBlendShapeML>
 *
 * @xrentity{XrFacialBlendShapeML}
 */
enum class FacialBlendShapeML {

  BrowLowererL = XR_FACIAL_BLEND_SHAPE_BROW_LOWERER_L_ML,

  BrowLowererR = XR_FACIAL_BLEND_SHAPE_BROW_LOWERER_R_ML,

  CheekRaiserL = XR_FACIAL_BLEND_SHAPE_CHEEK_RAISER_L_ML,

  CheekRaiserR = XR_FACIAL_BLEND_SHAPE_CHEEK_RAISER_R_ML,

  ChinRaiser = XR_FACIAL_BLEND_SHAPE_CHIN_RAISER_ML,

  DimplerL = XR_FACIAL_BLEND_SHAPE_DIMPLER_L_ML,

  DimplerR = XR_FACIAL_BLEND_SHAPE_DIMPLER_R_ML,

  EyesClosedL = XR_FACIAL_BLEND_SHAPE_EYES_CLOSED_L_ML,

  EyesClosedR = XR_FACIAL_BLEND_SHAPE_EYES_CLOSED_R_ML,

  InnerBrowRaiserL = XR_FACIAL_BLEND_SHAPE_INNER_BROW_RAISER_L_ML,

  InnerBrowRaiserR = XR_FACIAL_BLEND_SHAPE_INNER_BROW_RAISER_R_ML,

  JawDrop = XR_FACIAL_BLEND_SHAPE_JAW_DROP_ML,

  LidTightenerL = XR_FACIAL_BLEND_SHAPE_LID_TIGHTENER_L_ML,

  LidTightenerR = XR_FACIAL_BLEND_SHAPE_LID_TIGHTENER_R_ML,

  LipCornerDepressorL = XR_FACIAL_BLEND_SHAPE_LIP_CORNER_DEPRESSOR_L_ML,

  LipCornerDepressorR = XR_FACIAL_BLEND_SHAPE_LIP_CORNER_DEPRESSOR_R_ML,

  LipCornerPullerL = XR_FACIAL_BLEND_SHAPE_LIP_CORNER_PULLER_L_ML,

  LipCornerPullerR = XR_FACIAL_BLEND_SHAPE_LIP_CORNER_PULLER_R_ML,

  LipFunnelerLb = XR_FACIAL_BLEND_SHAPE_LIP_FUNNELER_LB_ML,

  LipFunnelerLt = XR_FACIAL_BLEND_SHAPE_LIP_FUNNELER_LT_ML,

  LipFunnelerRb = XR_FACIAL_BLEND_SHAPE_LIP_FUNNELER_RB_ML,

  LipFunnelerRt = XR_FACIAL_BLEND_SHAPE_LIP_FUNNELER_RT_ML,

  LipPressorL = XR_FACIAL_BLEND_SHAPE_LIP_PRESSOR_L_ML,

  LipPressorR = XR_FACIAL_BLEND_SHAPE_LIP_PRESSOR_R_ML,

  LipPuckerL = XR_FACIAL_BLEND_SHAPE_LIP_PUCKER_L_ML,

  LipPuckerR = XR_FACIAL_BLEND_SHAPE_LIP_PUCKER_R_ML,

  LipStretcherL = XR_FACIAL_BLEND_SHAPE_LIP_STRETCHER_L_ML,

  LipStretcherR = XR_FACIAL_BLEND_SHAPE_LIP_STRETCHER_R_ML,

  LipSuckLb = XR_FACIAL_BLEND_SHAPE_LIP_SUCK_LB_ML,

  LipSuckLt = XR_FACIAL_BLEND_SHAPE_LIP_SUCK_LT_ML,

  LipSuckRb = XR_FACIAL_BLEND_SHAPE_LIP_SUCK_RB_ML,

  LipSuckRt = XR_FACIAL_BLEND_SHAPE_LIP_SUCK_RT_ML,

  LipTightenerL = XR_FACIAL_BLEND_SHAPE_LIP_TIGHTENER_L_ML,

  LipTightenerR = XR_FACIAL_BLEND_SHAPE_LIP_TIGHTENER_R_ML,

  LipsToward = XR_FACIAL_BLEND_SHAPE_LIPS_TOWARD_ML,

  LowerLipDepressorL = XR_FACIAL_BLEND_SHAPE_LOWER_LIP_DEPRESSOR_L_ML,

  LowerLipDepressorR = XR_FACIAL_BLEND_SHAPE_LOWER_LIP_DEPRESSOR_R_ML,

  NoseWrinklerL = XR_FACIAL_BLEND_SHAPE_NOSE_WRINKLER_L_ML,

  NoseWrinklerR = XR_FACIAL_BLEND_SHAPE_NOSE_WRINKLER_R_ML,

  OuterBrowRaiserL = XR_FACIAL_BLEND_SHAPE_OUTER_BROW_RAISER_L_ML,

  OuterBrowRaiserR = XR_FACIAL_BLEND_SHAPE_OUTER_BROW_RAISER_R_ML,

  UpperLidRaiserL = XR_FACIAL_BLEND_SHAPE_UPPER_LID_RAISER_L_ML,

  UpperLidRaiserR = XR_FACIAL_BLEND_SHAPE_UPPER_LID_RAISER_R_ML,

  UpperLipRaiserL = XR_FACIAL_BLEND_SHAPE_UPPER_LIP_RAISER_L_ML,

  UpperLipRaiserR = XR_FACIAL_BLEND_SHAPE_UPPER_LIP_RAISER_R_ML,

  TongueOut = XR_FACIAL_BLEND_SHAPE_TONGUE_OUT_ML,

};
static_assert(sizeof(FacialBlendShapeML) == sizeof(XrFacialBlendShapeML),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFacialBlendShapeML value from a FacialBlendShapeML.
 *
 * @found_by_adl
 * @see FacialBlendShapeML
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrFacialBlendShapeML get(FacialBlendShapeML const& v) {
  return static_cast<XrFacialBlendShapeML>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrFacialBlendShapeML address from a
 * FacialBlendShapeML.
 *
 * @found_by_adl
 * @see FacialBlendShapeML
 */
OPENXR_HPP_INLINE XrFacialBlendShapeML* put(FacialBlendShapeML& v) {
  return reinterpret_cast<XrFacialBlendShapeML*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a FacialBlendShapeML value as a const char
 * *.
 *
 * @found_by_adl
 * @see FacialBlendShapeML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    FacialBlendShapeML value) {
  switch (value) {
    case FacialBlendShapeML::BrowLowererL:
      return "BrowLowererL";

    case FacialBlendShapeML::BrowLowererR:
      return "BrowLowererR";

    case FacialBlendShapeML::CheekRaiserL:
      return "CheekRaiserL";

    case FacialBlendShapeML::CheekRaiserR:
      return "CheekRaiserR";

    case FacialBlendShapeML::ChinRaiser:
      return "ChinRaiser";

    case FacialBlendShapeML::DimplerL:
      return "DimplerL";

    case FacialBlendShapeML::DimplerR:
      return "DimplerR";

    case FacialBlendShapeML::EyesClosedL:
      return "EyesClosedL";

    case FacialBlendShapeML::EyesClosedR:
      return "EyesClosedR";

    case FacialBlendShapeML::InnerBrowRaiserL:
      return "InnerBrowRaiserL";

    case FacialBlendShapeML::InnerBrowRaiserR:
      return "InnerBrowRaiserR";

    case FacialBlendShapeML::JawDrop:
      return "JawDrop";

    case FacialBlendShapeML::LidTightenerL:
      return "LidTightenerL";

    case FacialBlendShapeML::LidTightenerR:
      return "LidTightenerR";

    case FacialBlendShapeML::LipCornerDepressorL:
      return "LipCornerDepressorL";

    case FacialBlendShapeML::LipCornerDepressorR:
      return "LipCornerDepressorR";

    case FacialBlendShapeML::LipCornerPullerL:
      return "LipCornerPullerL";

    case FacialBlendShapeML::LipCornerPullerR:
      return "LipCornerPullerR";

    case FacialBlendShapeML::LipFunnelerLb:
      return "LipFunnelerLb";

    case FacialBlendShapeML::LipFunnelerLt:
      return "LipFunnelerLt";

    case FacialBlendShapeML::LipFunnelerRb:
      return "LipFunnelerRb";

    case FacialBlendShapeML::LipFunnelerRt:
      return "LipFunnelerRt";

    case FacialBlendShapeML::LipPressorL:
      return "LipPressorL";

    case FacialBlendShapeML::LipPressorR:
      return "LipPressorR";

    case FacialBlendShapeML::LipPuckerL:
      return "LipPuckerL";

    case FacialBlendShapeML::LipPuckerR:
      return "LipPuckerR";

    case FacialBlendShapeML::LipStretcherL:
      return "LipStretcherL";

    case FacialBlendShapeML::LipStretcherR:
      return "LipStretcherR";

    case FacialBlendShapeML::LipSuckLb:
      return "LipSuckLb";

    case FacialBlendShapeML::LipSuckLt:
      return "LipSuckLt";

    case FacialBlendShapeML::LipSuckRb:
      return "LipSuckRb";

    case FacialBlendShapeML::LipSuckRt:
      return "LipSuckRt";

    case FacialBlendShapeML::LipTightenerL:
      return "LipTightenerL";

    case FacialBlendShapeML::LipTightenerR:
      return "LipTightenerR";

    case FacialBlendShapeML::LipsToward:
      return "LipsToward";

    case FacialBlendShapeML::LowerLipDepressorL:
      return "LowerLipDepressorL";

    case FacialBlendShapeML::LowerLipDepressorR:
      return "LowerLipDepressorR";

    case FacialBlendShapeML::NoseWrinklerL:
      return "NoseWrinklerL";

    case FacialBlendShapeML::NoseWrinklerR:
      return "NoseWrinklerR";

    case FacialBlendShapeML::OuterBrowRaiserL:
      return "OuterBrowRaiserL";

    case FacialBlendShapeML::OuterBrowRaiserR:
      return "OuterBrowRaiserR";

    case FacialBlendShapeML::UpperLidRaiserL:
      return "UpperLidRaiserL";

    case FacialBlendShapeML::UpperLidRaiserR:
      return "UpperLidRaiserR";

    case FacialBlendShapeML::UpperLipRaiserL:
      return "UpperLipRaiserL";

    case FacialBlendShapeML::UpperLipRaiserR:
      return "UpperLipRaiserR";

    case FacialBlendShapeML::TongueOut:
      return "TongueOut";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a FacialBlendShapeML value as a
 * std::string.
 *
 * @found_by_adl
 * @see FacialBlendShapeML
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(FacialBlendShapeML value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_ML_facial_expression

#ifdef XR_EXT_spatial_entity
/*!
 * @brief Enum class for XrSpatialCapabilityEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialCapabilityEXT>
 *
 * @xrentity{XrSpatialCapabilityEXT}
 */
enum class SpatialCapabilityEXT {
#ifdef XR_EXT_spatial_plane_tracking
  PlaneTracking = XR_SPATIAL_CAPABILITY_PLANE_TRACKING_EXT,
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_marker_tracking
  MarkerTrackingQrCode = XR_SPATIAL_CAPABILITY_MARKER_TRACKING_QR_CODE_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
  MarkerTrackingMicroQrCode = XR_SPATIAL_CAPABILITY_MARKER_TRACKING_MICRO_QR_CODE_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
  MarkerTrackingArucoMarker = XR_SPATIAL_CAPABILITY_MARKER_TRACKING_ARUCO_MARKER_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
  MarkerTrackingAprilTag = XR_SPATIAL_CAPABILITY_MARKER_TRACKING_APRIL_TAG_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_anchor
  Anchor = XR_SPATIAL_CAPABILITY_ANCHOR_EXT,
#endif  // XR_EXT_spatial_anchor
};
static_assert(sizeof(SpatialCapabilityEXT) == sizeof(XrSpatialCapabilityEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialCapabilityEXT value from a
 * SpatialCapabilityEXT.
 *
 * @found_by_adl
 * @see SpatialCapabilityEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialCapabilityEXT get(SpatialCapabilityEXT const& v) {
  return static_cast<XrSpatialCapabilityEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialCapabilityEXT address from a
 * SpatialCapabilityEXT.
 *
 * @found_by_adl
 * @see SpatialCapabilityEXT
 */
OPENXR_HPP_INLINE XrSpatialCapabilityEXT* put(SpatialCapabilityEXT& v) {
  return reinterpret_cast<XrSpatialCapabilityEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialCapabilityEXT value as a const
 * char *.
 *
 * @found_by_adl
 * @see SpatialCapabilityEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialCapabilityEXT value) {
  switch (value) {
#ifdef XR_EXT_spatial_plane_tracking
    case SpatialCapabilityEXT::PlaneTracking:
      return "PlaneTracking";
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case SpatialCapabilityEXT::MarkerTrackingQrCode:
      return "MarkerTrackingQrCode";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case SpatialCapabilityEXT::MarkerTrackingMicroQrCode:
      return "MarkerTrackingMicroQrCode";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case SpatialCapabilityEXT::MarkerTrackingArucoMarker:
      return "MarkerTrackingArucoMarker";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case SpatialCapabilityEXT::MarkerTrackingAprilTag:
      return "MarkerTrackingAprilTag";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_anchor
    case SpatialCapabilityEXT::Anchor:
      return "Anchor";
#endif  // XR_EXT_spatial_anchor
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialCapabilityEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialCapabilityEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SpatialCapabilityEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * @brief Enum class for XrSpatialCapabilityFeatureEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialCapabilityFeatureEXT>
 *
 * @xrentity{XrSpatialCapabilityFeatureEXT}
 */
enum class SpatialCapabilityFeatureEXT {
#ifdef XR_EXT_spatial_marker_tracking
  MarkerTrackingFixedSizeMarkers =
      XR_SPATIAL_CAPABILITY_FEATURE_MARKER_TRACKING_FIXED_SIZE_MARKERS_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
  MarkerTrackingStaticMarkers = XR_SPATIAL_CAPABILITY_FEATURE_MARKER_TRACKING_STATIC_MARKERS_EXT,
#endif  // XR_EXT_spatial_marker_tracking
};
static_assert(sizeof(SpatialCapabilityFeatureEXT) == sizeof(XrSpatialCapabilityFeatureEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialCapabilityFeatureEXT value from a
 * SpatialCapabilityFeatureEXT.
 *
 * @found_by_adl
 * @see SpatialCapabilityFeatureEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialCapabilityFeatureEXT
get(SpatialCapabilityFeatureEXT const& v) {
  return static_cast<XrSpatialCapabilityFeatureEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialCapabilityFeatureEXT address from a
 * SpatialCapabilityFeatureEXT.
 *
 * @found_by_adl
 * @see SpatialCapabilityFeatureEXT
 */
OPENXR_HPP_INLINE XrSpatialCapabilityFeatureEXT* put(SpatialCapabilityFeatureEXT& v) {
  return reinterpret_cast<XrSpatialCapabilityFeatureEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialCapabilityFeatureEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see SpatialCapabilityFeatureEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialCapabilityFeatureEXT value) {
  switch (value) {
#ifdef XR_EXT_spatial_marker_tracking
    case SpatialCapabilityFeatureEXT::MarkerTrackingFixedSizeMarkers:
      return "MarkerTrackingFixedSizeMarkers";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case SpatialCapabilityFeatureEXT::MarkerTrackingStaticMarkers:
      return "MarkerTrackingStaticMarkers";
#endif  // XR_EXT_spatial_marker_tracking
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialCapabilityFeatureEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialCapabilityFeatureEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SpatialCapabilityFeatureEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * @brief Enum class for XrSpatialComponentTypeEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentTypeEXT>
 *
 * @xrentity{XrSpatialComponentTypeEXT}
 */
enum class SpatialComponentTypeEXT {

  Bounded2D = XR_SPATIAL_COMPONENT_TYPE_BOUNDED_2D_EXT,

  Bounded3D = XR_SPATIAL_COMPONENT_TYPE_BOUNDED_3D_EXT,

  Parent = XR_SPATIAL_COMPONENT_TYPE_PARENT_EXT,

  Mesh3D = XR_SPATIAL_COMPONENT_TYPE_MESH_3D_EXT,

#ifdef XR_EXT_spatial_plane_tracking
  PlaneAlignment = XR_SPATIAL_COMPONENT_TYPE_PLANE_ALIGNMENT_EXT,
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
  Mesh2D = XR_SPATIAL_COMPONENT_TYPE_MESH_2D_EXT,
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
  Polygon2D = XR_SPATIAL_COMPONENT_TYPE_POLYGON_2D_EXT,
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
  PlaneSemanticLabel = XR_SPATIAL_COMPONENT_TYPE_PLANE_SEMANTIC_LABEL_EXT,
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_marker_tracking
  Marker = XR_SPATIAL_COMPONENT_TYPE_MARKER_EXT,
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_anchor
  Anchor = XR_SPATIAL_COMPONENT_TYPE_ANCHOR_EXT,
#endif  // XR_EXT_spatial_anchor
#ifdef dsaXR_EXT_spatial_persistence
  Persistence = XR_SPATIAL_COMPONENT_TYPE_PERSISTENCE_EXT,
#endif  // XR_EXT_spatial_persistence
};
static_assert(sizeof(SpatialComponentTypeEXT) == sizeof(XrSpatialComponentTypeEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialComponentTypeEXT value from a
 * SpatialComponentTypeEXT.
 *
 * @found_by_adl
 * @see SpatialComponentTypeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialComponentTypeEXT
get(SpatialComponentTypeEXT const& v) {
  return static_cast<XrSpatialComponentTypeEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialComponentTypeEXT address from a
 * SpatialComponentTypeEXT.
 *
 * @found_by_adl
 * @see SpatialComponentTypeEXT
 */
OPENXR_HPP_INLINE XrSpatialComponentTypeEXT* put(SpatialComponentTypeEXT& v) {
  return reinterpret_cast<XrSpatialComponentTypeEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialComponentTypeEXT value as a const
 * char *.
 *
 * @found_by_adl
 * @see SpatialComponentTypeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialComponentTypeEXT value) {
  switch (value) {
    case SpatialComponentTypeEXT::Bounded2D:
      return "Bounded2D";

    case SpatialComponentTypeEXT::Bounded3D:
      return "Bounded3D";

    case SpatialComponentTypeEXT::Parent:
      return "Parent";

    case SpatialComponentTypeEXT::Mesh3D:
      return "Mesh3D";

#ifdef XR_EXT_spatial_plane_tracking
    case SpatialComponentTypeEXT::PlaneAlignment:
      return "PlaneAlignment";
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
    case SpatialComponentTypeEXT::Mesh2D:
      return "Mesh2D";
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
    case SpatialComponentTypeEXT::Polygon2D:
      return "Polygon2D";
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_plane_tracking
    case SpatialComponentTypeEXT::PlaneSemanticLabel:
      return "PlaneSemanticLabel";
#endif  // XR_EXT_spatial_plane_tracking
#ifdef XR_EXT_spatial_marker_tracking
    case SpatialComponentTypeEXT::Marker:
      return "Marker";
#endif  // XR_EXT_spatial_marker_tracking
#ifdef XR_EXT_spatial_anchor
    case SpatialComponentTypeEXT::Anchor:
      return "Anchor";
#endif  // XR_EXT_spatial_anchor
#ifdef dsaXR_EXT_spatial_persistence
    case SpatialComponentTypeEXT::Persistence:
      return "Persistence";
#endif  // XR_EXT_spatial_persistence
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialComponentTypeEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialComponentTypeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SpatialComponentTypeEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * @brief Enum class for XrSpatialEntityTrackingStateEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityTrackingStateEXT>
 *
 * @xrentity{XrSpatialEntityTrackingStateEXT}
 */
enum class SpatialEntityTrackingStateEXT {

  Stopped = XR_SPATIAL_ENTITY_TRACKING_STATE_STOPPED_EXT,

  Paused = XR_SPATIAL_ENTITY_TRACKING_STATE_PAUSED_EXT,

  Tracking = XR_SPATIAL_ENTITY_TRACKING_STATE_TRACKING_EXT,

};
static_assert(sizeof(SpatialEntityTrackingStateEXT) == sizeof(XrSpatialEntityTrackingStateEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialEntityTrackingStateEXT value from a
 * SpatialEntityTrackingStateEXT.
 *
 * @found_by_adl
 * @see SpatialEntityTrackingStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialEntityTrackingStateEXT
get(SpatialEntityTrackingStateEXT const& v) {
  return static_cast<XrSpatialEntityTrackingStateEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialEntityTrackingStateEXT address from a
 * SpatialEntityTrackingStateEXT.
 *
 * @found_by_adl
 * @see SpatialEntityTrackingStateEXT
 */
OPENXR_HPP_INLINE XrSpatialEntityTrackingStateEXT* put(SpatialEntityTrackingStateEXT& v) {
  return reinterpret_cast<XrSpatialEntityTrackingStateEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialEntityTrackingStateEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see SpatialEntityTrackingStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialEntityTrackingStateEXT value) {
  switch (value) {
    case SpatialEntityTrackingStateEXT::Stopped:
      return "Stopped";

    case SpatialEntityTrackingStateEXT::Paused:
      return "Paused";

    case SpatialEntityTrackingStateEXT::Tracking:
      return "Tracking";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialEntityTrackingStateEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialEntityTrackingStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SpatialEntityTrackingStateEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * @brief Enum class for XrSpatialBufferTypeEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialBufferTypeEXT>
 *
 * @xrentity{XrSpatialBufferTypeEXT}
 */
enum class SpatialBufferTypeEXT {

  Unknown = XR_SPATIAL_BUFFER_TYPE_UNKNOWN_EXT,

  String = XR_SPATIAL_BUFFER_TYPE_STRING_EXT,

  Uint8 = XR_SPATIAL_BUFFER_TYPE_UINT8_EXT,

  Uint16 = XR_SPATIAL_BUFFER_TYPE_UINT16_EXT,

  Uint32 = XR_SPATIAL_BUFFER_TYPE_UINT32_EXT,

  Float = XR_SPATIAL_BUFFER_TYPE_FLOAT_EXT,

  Vector2F = XR_SPATIAL_BUFFER_TYPE_VECTOR2F_EXT,

  Vector3F = XR_SPATIAL_BUFFER_TYPE_VECTOR3F_EXT,

};
static_assert(sizeof(SpatialBufferTypeEXT) == sizeof(XrSpatialBufferTypeEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialBufferTypeEXT value from a
 * SpatialBufferTypeEXT.
 *
 * @found_by_adl
 * @see SpatialBufferTypeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialBufferTypeEXT get(SpatialBufferTypeEXT const& v) {
  return static_cast<XrSpatialBufferTypeEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialBufferTypeEXT address from a
 * SpatialBufferTypeEXT.
 *
 * @found_by_adl
 * @see SpatialBufferTypeEXT
 */
OPENXR_HPP_INLINE XrSpatialBufferTypeEXT* put(SpatialBufferTypeEXT& v) {
  return reinterpret_cast<XrSpatialBufferTypeEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialBufferTypeEXT value as a const
 * char *.
 *
 * @found_by_adl
 * @see SpatialBufferTypeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialBufferTypeEXT value) {
  switch (value) {
    case SpatialBufferTypeEXT::Unknown:
      return "Unknown";

    case SpatialBufferTypeEXT::String:
      return "String";

    case SpatialBufferTypeEXT::Uint8:
      return "Uint8";

    case SpatialBufferTypeEXT::Uint16:
      return "Uint16";

    case SpatialBufferTypeEXT::Uint32:
      return "Uint32";

    case SpatialBufferTypeEXT::Float:
      return "Float";

    case SpatialBufferTypeEXT::Vector2F:
      return "Vector2F";

    case SpatialBufferTypeEXT::Vector3F:
      return "Vector3F";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialBufferTypeEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialBufferTypeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(SpatialBufferTypeEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_plane_tracking
/*!
 * @brief Enum class for XrSpatialPlaneAlignmentEXT
 *
 * Provided by the `XR_EXT_spatial_plane_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialPlaneAlignmentEXT>
 *
 * @xrentity{XrSpatialPlaneAlignmentEXT}
 */
enum class SpatialPlaneAlignmentEXT {

  HorizontalUpward = XR_SPATIAL_PLANE_ALIGNMENT_HORIZONTAL_UPWARD_EXT,

  HorizontalDownward = XR_SPATIAL_PLANE_ALIGNMENT_HORIZONTAL_DOWNWARD_EXT,

  Vertical = XR_SPATIAL_PLANE_ALIGNMENT_VERTICAL_EXT,

  Arbitrary = XR_SPATIAL_PLANE_ALIGNMENT_ARBITRARY_EXT,

};
static_assert(sizeof(SpatialPlaneAlignmentEXT) == sizeof(XrSpatialPlaneAlignmentEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialPlaneAlignmentEXT value from a
 * SpatialPlaneAlignmentEXT.
 *
 * @found_by_adl
 * @see SpatialPlaneAlignmentEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialPlaneAlignmentEXT
get(SpatialPlaneAlignmentEXT const& v) {
  return static_cast<XrSpatialPlaneAlignmentEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialPlaneAlignmentEXT address from a
 * SpatialPlaneAlignmentEXT.
 *
 * @found_by_adl
 * @see SpatialPlaneAlignmentEXT
 */
OPENXR_HPP_INLINE XrSpatialPlaneAlignmentEXT* put(SpatialPlaneAlignmentEXT& v) {
  return reinterpret_cast<XrSpatialPlaneAlignmentEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialPlaneAlignmentEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see SpatialPlaneAlignmentEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialPlaneAlignmentEXT value) {
  switch (value) {
    case SpatialPlaneAlignmentEXT::HorizontalUpward:
      return "HorizontalUpward";

    case SpatialPlaneAlignmentEXT::HorizontalDownward:
      return "HorizontalDownward";

    case SpatialPlaneAlignmentEXT::Vertical:
      return "Vertical";

    case SpatialPlaneAlignmentEXT::Arbitrary:
      return "Arbitrary";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialPlaneAlignmentEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialPlaneAlignmentEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SpatialPlaneAlignmentEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_spatial_plane_tracking

#ifdef XR_EXT_spatial_plane_tracking
/*!
 * @brief Enum class for XrSpatialPlaneSemanticLabelEXT
 *
 * Provided by the `XR_EXT_spatial_plane_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialPlaneSemanticLabelEXT>
 *
 * @xrentity{XrSpatialPlaneSemanticLabelEXT}
 */
enum class SpatialPlaneSemanticLabelEXT {

  Uncategorized = XR_SPATIAL_PLANE_SEMANTIC_LABEL_UNCATEGORIZED_EXT,

  Floor = XR_SPATIAL_PLANE_SEMANTIC_LABEL_FLOOR_EXT,

  Wall = XR_SPATIAL_PLANE_SEMANTIC_LABEL_WALL_EXT,

  Ceiling = XR_SPATIAL_PLANE_SEMANTIC_LABEL_CEILING_EXT,

  Table = XR_SPATIAL_PLANE_SEMANTIC_LABEL_TABLE_EXT,

};
static_assert(sizeof(SpatialPlaneSemanticLabelEXT) == sizeof(XrSpatialPlaneSemanticLabelEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialPlaneSemanticLabelEXT value from a
 * SpatialPlaneSemanticLabelEXT.
 *
 * @found_by_adl
 * @see SpatialPlaneSemanticLabelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialPlaneSemanticLabelEXT
get(SpatialPlaneSemanticLabelEXT const& v) {
  return static_cast<XrSpatialPlaneSemanticLabelEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialPlaneSemanticLabelEXT address from a
 * SpatialPlaneSemanticLabelEXT.
 *
 * @found_by_adl
 * @see SpatialPlaneSemanticLabelEXT
 */
OPENXR_HPP_INLINE XrSpatialPlaneSemanticLabelEXT* put(SpatialPlaneSemanticLabelEXT& v) {
  return reinterpret_cast<XrSpatialPlaneSemanticLabelEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialPlaneSemanticLabelEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see SpatialPlaneSemanticLabelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialPlaneSemanticLabelEXT value) {
  switch (value) {
    case SpatialPlaneSemanticLabelEXT::Uncategorized:
      return "Uncategorized";

    case SpatialPlaneSemanticLabelEXT::Floor:
      return "Floor";

    case SpatialPlaneSemanticLabelEXT::Wall:
      return "Wall";

    case SpatialPlaneSemanticLabelEXT::Ceiling:
      return "Ceiling";

    case SpatialPlaneSemanticLabelEXT::Table:
      return "Table";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialPlaneSemanticLabelEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialPlaneSemanticLabelEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SpatialPlaneSemanticLabelEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_spatial_plane_tracking

#ifdef XR_EXT_spatial_marker_tracking
/*!
 * @brief Enum class for XrSpatialMarkerArucoDictEXT
 *
 * Provided by the `XR_EXT_spatial_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialMarkerArucoDictEXT>
 *
 * @xrentity{XrSpatialMarkerArucoDictEXT}
 */
enum class SpatialMarkerArucoDictEXT {

  _4X450 = XR_SPATIAL_MARKER_ARUCO_DICT_4X4_50_EXT,

  _4X4100 = XR_SPATIAL_MARKER_ARUCO_DICT_4X4_100_EXT,

  _4X4250 = XR_SPATIAL_MARKER_ARUCO_DICT_4X4_250_EXT,

  _4X41000 = XR_SPATIAL_MARKER_ARUCO_DICT_4X4_1000_EXT,

  _5X550 = XR_SPATIAL_MARKER_ARUCO_DICT_5X5_50_EXT,

  _5X5100 = XR_SPATIAL_MARKER_ARUCO_DICT_5X5_100_EXT,

  _5X5250 = XR_SPATIAL_MARKER_ARUCO_DICT_5X5_250_EXT,

  _5X51000 = XR_SPATIAL_MARKER_ARUCO_DICT_5X5_1000_EXT,

  _6X650 = XR_SPATIAL_MARKER_ARUCO_DICT_6X6_50_EXT,

  _6X6100 = XR_SPATIAL_MARKER_ARUCO_DICT_6X6_100_EXT,

  _6X6250 = XR_SPATIAL_MARKER_ARUCO_DICT_6X6_250_EXT,

  _6X61000 = XR_SPATIAL_MARKER_ARUCO_DICT_6X6_1000_EXT,

  _7X750 = XR_SPATIAL_MARKER_ARUCO_DICT_7X7_50_EXT,

  _7X7100 = XR_SPATIAL_MARKER_ARUCO_DICT_7X7_100_EXT,

  _7X7250 = XR_SPATIAL_MARKER_ARUCO_DICT_7X7_250_EXT,

  _7X71000 = XR_SPATIAL_MARKER_ARUCO_DICT_7X7_1000_EXT,

};
static_assert(sizeof(SpatialMarkerArucoDictEXT) == sizeof(XrSpatialMarkerArucoDictEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialMarkerArucoDictEXT value from a
 * SpatialMarkerArucoDictEXT.
 *
 * @found_by_adl
 * @see SpatialMarkerArucoDictEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialMarkerArucoDictEXT
get(SpatialMarkerArucoDictEXT const& v) {
  return static_cast<XrSpatialMarkerArucoDictEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialMarkerArucoDictEXT address from a
 * SpatialMarkerArucoDictEXT.
 *
 * @found_by_adl
 * @see SpatialMarkerArucoDictEXT
 */
OPENXR_HPP_INLINE XrSpatialMarkerArucoDictEXT* put(SpatialMarkerArucoDictEXT& v) {
  return reinterpret_cast<XrSpatialMarkerArucoDictEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialMarkerArucoDictEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see SpatialMarkerArucoDictEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialMarkerArucoDictEXT value) {
  switch (value) {
    case SpatialMarkerArucoDictEXT::_4X450:
      return "_4X450";

    case SpatialMarkerArucoDictEXT::_4X4100:
      return "_4X4100";

    case SpatialMarkerArucoDictEXT::_4X4250:
      return "_4X4250";

    case SpatialMarkerArucoDictEXT::_4X41000:
      return "_4X41000";

    case SpatialMarkerArucoDictEXT::_5X550:
      return "_5X550";

    case SpatialMarkerArucoDictEXT::_5X5100:
      return "_5X5100";

    case SpatialMarkerArucoDictEXT::_5X5250:
      return "_5X5250";

    case SpatialMarkerArucoDictEXT::_5X51000:
      return "_5X51000";

    case SpatialMarkerArucoDictEXT::_6X650:
      return "_6X650";

    case SpatialMarkerArucoDictEXT::_6X6100:
      return "_6X6100";

    case SpatialMarkerArucoDictEXT::_6X6250:
      return "_6X6250";

    case SpatialMarkerArucoDictEXT::_6X61000:
      return "_6X61000";

    case SpatialMarkerArucoDictEXT::_7X750:
      return "_7X750";

    case SpatialMarkerArucoDictEXT::_7X7100:
      return "_7X7100";

    case SpatialMarkerArucoDictEXT::_7X7250:
      return "_7X7250";

    case SpatialMarkerArucoDictEXT::_7X71000:
      return "_7X71000";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialMarkerArucoDictEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialMarkerArucoDictEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SpatialMarkerArucoDictEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_spatial_marker_tracking

#ifdef XR_EXT_spatial_marker_tracking
/*!
 * @brief Enum class for XrSpatialMarkerAprilTagDictEXT
 *
 * Provided by the `XR_EXT_spatial_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialMarkerAprilTagDictEXT>
 *
 * @xrentity{XrSpatialMarkerAprilTagDictEXT}
 */
enum class SpatialMarkerAprilTagDictEXT {

  _16H5 = XR_SPATIAL_MARKER_APRIL_TAG_DICT_16H5_EXT,

  _25H9 = XR_SPATIAL_MARKER_APRIL_TAG_DICT_25H9_EXT,

  _36H10 = XR_SPATIAL_MARKER_APRIL_TAG_DICT_36H10_EXT,

  _36H11 = XR_SPATIAL_MARKER_APRIL_TAG_DICT_36H11_EXT,

};
static_assert(sizeof(SpatialMarkerAprilTagDictEXT) == sizeof(XrSpatialMarkerAprilTagDictEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialMarkerAprilTagDictEXT value from a
 * SpatialMarkerAprilTagDictEXT.
 *
 * @found_by_adl
 * @see SpatialMarkerAprilTagDictEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialMarkerAprilTagDictEXT
get(SpatialMarkerAprilTagDictEXT const& v) {
  return static_cast<XrSpatialMarkerAprilTagDictEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialMarkerAprilTagDictEXT address from a
 * SpatialMarkerAprilTagDictEXT.
 *
 * @found_by_adl
 * @see SpatialMarkerAprilTagDictEXT
 */
OPENXR_HPP_INLINE XrSpatialMarkerAprilTagDictEXT* put(SpatialMarkerAprilTagDictEXT& v) {
  return reinterpret_cast<XrSpatialMarkerAprilTagDictEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialMarkerAprilTagDictEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see SpatialMarkerAprilTagDictEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialMarkerAprilTagDictEXT value) {
  switch (value) {
    case SpatialMarkerAprilTagDictEXT::_16H5:
      return "_16H5";

    case SpatialMarkerAprilTagDictEXT::_25H9:
      return "_25H9";

    case SpatialMarkerAprilTagDictEXT::_36H10:
      return "_36H10";

    case SpatialMarkerAprilTagDictEXT::_36H11:
      return "_36H11";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialMarkerAprilTagDictEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialMarkerAprilTagDictEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SpatialMarkerAprilTagDictEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_spatial_marker_tracking

#ifdef dsaXR_EXT_spatial_persistence
/*!
 * @brief Enum class for XrSpatialPersistenceScopeEXT
 *
 * Provided by the `XR_EXT_spatial_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialPersistenceScopeEXT>
 *
 * @xrentity{XrSpatialPersistenceScopeEXT}
 */
enum class SpatialPersistenceScopeEXT {

  SystemManaged = XR_SPATIAL_PERSISTENCE_SCOPE_SYSTEM_MANAGED_EXT,

#ifdef dsaXR_EXT_spatial_persistence_operations
  LocalAnchors = XR_SPATIAL_PERSISTENCE_SCOPE_LOCAL_ANCHORS_EXT,
#endif  // XR_EXT_spatial_persistence_operations
};
static_assert(sizeof(SpatialPersistenceScopeEXT) == sizeof(XrSpatialPersistenceScopeEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialPersistenceScopeEXT value from a
 * SpatialPersistenceScopeEXT.
 *
 * @found_by_adl
 * @see SpatialPersistenceScopeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialPersistenceScopeEXT
get(SpatialPersistenceScopeEXT const& v) {
  return static_cast<XrSpatialPersistenceScopeEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialPersistenceScopeEXT address from a
 * SpatialPersistenceScopeEXT.
 *
 * @found_by_adl
 * @see SpatialPersistenceScopeEXT
 */
OPENXR_HPP_INLINE XrSpatialPersistenceScopeEXT* put(SpatialPersistenceScopeEXT& v) {
  return reinterpret_cast<XrSpatialPersistenceScopeEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialPersistenceScopeEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see SpatialPersistenceScopeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialPersistenceScopeEXT value) {
  switch (value) {
    case SpatialPersistenceScopeEXT::SystemManaged:
      return "SystemManaged";

#ifdef dsaXR_EXT_spatial_persistence_operations
    case SpatialPersistenceScopeEXT::LocalAnchors:
      return "LocalAnchors";
#endif  // XR_EXT_spatial_persistence_operations
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialPersistenceScopeEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialPersistenceScopeEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SpatialPersistenceScopeEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_spatial_persistence

#ifdef dsaXR_EXT_spatial_persistence
/*!
 * @brief Enum class for XrSpatialPersistenceContextResultEXT
 *
 * Provided by the `XR_EXT_spatial_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialPersistenceContextResultEXT>
 *
 * @xrentity{XrSpatialPersistenceContextResultEXT}
 */
enum class SpatialPersistenceContextResultEXT {

  Success = XR_SPATIAL_PERSISTENCE_CONTEXT_RESULT_SUCCESS_EXT,

#ifdef dsaXR_EXT_spatial_persistence_operations
  EntityNotTracking = XR_SPATIAL_PERSISTENCE_CONTEXT_RESULT_ENTITY_NOT_TRACKING_EXT,
#endif  // XR_EXT_spatial_persistence_operations
#ifdef dsaXR_EXT_spatial_persistence_operations
  PersistUuidNotFound = XR_SPATIAL_PERSISTENCE_CONTEXT_RESULT_PERSIST_UUID_NOT_FOUND_EXT,
#endif  // XR_EXT_spatial_persistence_operations
};
static_assert(sizeof(SpatialPersistenceContextResultEXT) ==
                  sizeof(XrSpatialPersistenceContextResultEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialPersistenceContextResultEXT value from a
 * SpatialPersistenceContextResultEXT.
 *
 * @found_by_adl
 * @see SpatialPersistenceContextResultEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialPersistenceContextResultEXT
get(SpatialPersistenceContextResultEXT const& v) {
  return static_cast<XrSpatialPersistenceContextResultEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialPersistenceContextResultEXT address from a
 * SpatialPersistenceContextResultEXT.
 *
 * @found_by_adl
 * @see SpatialPersistenceContextResultEXT
 */
OPENXR_HPP_INLINE XrSpatialPersistenceContextResultEXT* put(SpatialPersistenceContextResultEXT& v) {
  return reinterpret_cast<XrSpatialPersistenceContextResultEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialPersistenceContextResultEXT value
 * as a const char *.
 *
 * @found_by_adl
 * @see SpatialPersistenceContextResultEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialPersistenceContextResultEXT value) {
  switch (value) {
    case SpatialPersistenceContextResultEXT::Success:
      return "Success";

#ifdef dsaXR_EXT_spatial_persistence_operations
    case SpatialPersistenceContextResultEXT::EntityNotTracking:
      return "EntityNotTracking";
#endif  // XR_EXT_spatial_persistence_operations
#ifdef dsaXR_EXT_spatial_persistence_operations
    case SpatialPersistenceContextResultEXT::PersistUuidNotFound:
      return "PersistUuidNotFound";
#endif  // XR_EXT_spatial_persistence_operations
    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialPersistenceContextResultEXT value
 * as a std::string.
 *
 * @found_by_adl
 * @see SpatialPersistenceContextResultEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SpatialPersistenceContextResultEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_spatial_persistence

#ifdef dsaXR_EXT_spatial_persistence
/*!
 * @brief Enum class for XrSpatialPersistenceStateEXT
 *
 * Provided by the `XR_EXT_spatial_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialPersistenceStateEXT>
 *
 * @xrentity{XrSpatialPersistenceStateEXT}
 */
enum class SpatialPersistenceStateEXT {

  Loaded = XR_SPATIAL_PERSISTENCE_STATE_LOADED_EXT,

  NotFound = XR_SPATIAL_PERSISTENCE_STATE_NOT_FOUND_EXT,

};
static_assert(sizeof(SpatialPersistenceStateEXT) == sizeof(XrSpatialPersistenceStateEXT),
              "Original type and wrapper have different size!");

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialPersistenceStateEXT value from a
 * SpatialPersistenceStateEXT.
 *
 * @found_by_adl
 * @see SpatialPersistenceStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_CONSTEXPR XrSpatialPersistenceStateEXT
get(SpatialPersistenceStateEXT const& v) {
  return static_cast<XrSpatialPersistenceStateEXT>(v);
}

//! @addtogroup utility_accessors
//! @{
/*!
 * @brief Free function for retrieving the raw XrSpatialPersistenceStateEXT address from a
 * SpatialPersistenceStateEXT.
 *
 * @found_by_adl
 * @see SpatialPersistenceStateEXT
 */
OPENXR_HPP_INLINE XrSpatialPersistenceStateEXT* put(SpatialPersistenceStateEXT& v) {
  return reinterpret_cast<XrSpatialPersistenceStateEXT*>(&v);
}

/*!
 * @brief Free function for retrieving the string name of a SpatialPersistenceStateEXT value as a
 * const char *.
 *
 * @found_by_adl
 * @see SpatialPersistenceStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR const char* to_string_literal(
    SpatialPersistenceStateEXT value) {
  switch (value) {
    case SpatialPersistenceStateEXT::Loaded:
      return "Loaded";

    case SpatialPersistenceStateEXT::NotFound:
      return "NotFound";

    default:
      return "invalid";
  }
}

/*!
 * @brief Free function for retrieving the string name of a SpatialPersistenceStateEXT value as a
 * std::string.
 *
 * @found_by_adl
 * @see SpatialPersistenceStateEXT
 */
OPENXR_HPP_INLINE OPENXR_HPP_SWITCH_CONSTEXPR std::string to_string(
    SpatialPersistenceStateEXT value) {
  return {to_string_literal(value)};
}
//! @}

#endif  // XR_EXT_spatial_persistence
//! @}

}  // namespace OPENXR_HPP_NAMESPACE

#endif  // ifndef OPENXR_ENUMS_HPP_
