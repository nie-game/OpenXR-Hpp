// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************

/*
** Copyright (c) 2017-2023 The Khronos Group Inc.
** Copyright (c) 2019-2023 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_STRUCTS_HPP_
#define OPENXR_STRUCTS_HPP_
/**
 * @file
 * @brief C++ projections of OpenXR structure types.
 * @ingroup structs
 */

/*!
 * @defgroup structs Structures
 * @brief C++ projections of OpenXR structure types, with easier init but identical layout.
 * @ingroup wrappers
 *
 * These are all implicitly convertible to a reference-to-const to their corresponding raw C types,
 * so you can treat them as you otherwise might.
 */
/*!
 * @defgroup typedstructs Typed/chainable structures
 * @brief C++ projections of those OpenXR structure types with a `type` and `next` field.
 * @ingroup structs
 */
/*!
 * @defgroup abstracttypedstructs Abstract typed structures
 * @brief C++ projections of those OpenXR structure types with a `type` and `next` field,
 * but no specific type enum value of their own: these are the "base structs" in OpenXR.
 * @ingroup typedstructs
 */

// for strncpy_s
#ifndef __STDC_WANT_LIB_EXT1__
#define __STDC_WANT_LIB_EXT1__ 1
#endif
#include <string.h>

#include "openxr_enums.hpp"
#include "openxr_flags.hpp"
#include "openxr_version.hpp"
#include "openxr_time.hpp"
#include "openxr_atoms.hpp"
#include "openxr_bool.hpp"
#include "openxr_handles.hpp"

#include <openxr/openxr.h>

#ifdef OPENXR_HPP_DOXYGEN
#include <openxr/openxr_platform.h>
#endif

namespace OPENXR_HPP_NAMESPACE {

namespace impl {

  class XR_MAY_ALIAS InputStructBase {
  protected:
    InputStructBase(StructureType type_, const void* next_ = nullptr) : type(type_), next(next_) {}

  public:
    StructureType type;
    const void* next;
  };
  static_assert(sizeof(::XrBaseInStructure) == sizeof(InputStructBase),
                "Original type and wrapper have different size!");

  class XR_MAY_ALIAS OutputStructBase {
  protected:
    OutputStructBase(StructureType type_, void* next_ = nullptr) : type(type_), next(next_) {}

  public:
    StructureType type;
    void* next;
  };
  static_assert(sizeof(::XrBaseOutStructure) == sizeof(OutputStructBase),
                "Original type and wrapper have different size!");
}  // namespace impl

/*!
 * @brief Wrapper for XrEventDataBuffer
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataBuffer>
 *
 * @xrentity{XrEventDataBuffer}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataBuffer : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  EventDataBuffer(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_), varying{} {}

public:
  //! Default constructor - use this one.
  EventDataBuffer() : Parent(StructureType::EventDataBuffer), varying{} { (void)varying; }
  //! @brief "Put" function for assigning as null then getting the address of the raw pointer to
  //! pass as function output parameter.
  XrEventDataBuffer* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = {};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataBuffer*>(this);
  }

  //! Gets a pointer to the underlying raw XrEventDataBuffer type.
  XrEventDataBuffer* get() noexcept { return reinterpret_cast<XrEventDataBuffer*>(this); }

  //! Gets a pointer to the underlying raw XrEventDataBuffer type.
  XrEventDataBuffer const* get() const noexcept {
    return reinterpret_cast<XrEventDataBuffer const*>(this);
  }

private:
  uint8_t varying[4000];
};
static_assert(sizeof(::XrEventDataBuffer) == sizeof(EventDataBuffer),
              "Original type and wrapper have different size!");

/*!
 * @brief Free "put" function for clearing and getting the address of the raw XrEventDataBuffer in
 * an EventDataBuffer.
 * @relates EventDataBuffer
 * @ingroup utility_accessors
 */
OPENXR_HPP_INLINE XrEventDataBuffer* put(EventDataBuffer& v, bool clear = true) noexcept {
  return v.put(clear);
}

/*!
 * C++ projection of XrApiLayerProperties
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrApiLayerProperties>
 * @xrentity{XrApiLayerProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ApiLayerProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ApiLayerProperties(void* next_ = nullptr)

      : Parent(StructureType::APILayerProperties, next_) {}

  //! Default copy constructor
  ApiLayerProperties(const ApiLayerProperties& rhs) = default;
  //! Default copy assignment
  ApiLayerProperties& operator=(const ApiLayerProperties& rhs) = default;
  //! Copy construct from raw
  ApiLayerProperties(const XrApiLayerProperties& rhs) : ApiLayerProperties() { *put() = rhs; }
  //! Copy assign from raw
  ApiLayerProperties& operator=(const XrApiLayerProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrApiLayerProperties&() const {
    return *reinterpret_cast<const XrApiLayerProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrApiLayerProperties&() { return *reinterpret_cast<XrApiLayerProperties*>(this); }

  //! Accessor for this as the address of a raw XrApiLayerProperties
  XrApiLayerProperties const* get() const noexcept {
    return reinterpret_cast<XrApiLayerProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrApiLayerProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrApiLayerProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ApiLayerProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrApiLayerProperties*>(this);
  }
  char layerName[XR_MAX_API_LAYER_NAME_SIZE];
  Version specVersion;
  uint32_t layerVersion;
  char description[XR_MAX_API_LAYER_DESCRIPTION_SIZE];
};
static_assert(sizeof(XrApiLayerProperties) == sizeof(ApiLayerProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrApiLayerProperties pointer to const from a
 * ApiLayerProperties reference to const.
 * @relates ApiLayerProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApiLayerProperties const* get(ApiLayerProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ApiLayerProperties as the
 * address of a raw XrApiLayerProperties
 * @relates ApiLayerProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApiLayerProperties* put(ApiLayerProperties& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrExtensionProperties
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtensionProperties>
 * @xrentity{XrExtensionProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ExtensionProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ExtensionProperties(void* next_ = nullptr)

      : Parent(StructureType::ExtensionProperties, next_) {}

  //! Default copy constructor
  ExtensionProperties(const ExtensionProperties& rhs) = default;
  //! Default copy assignment
  ExtensionProperties& operator=(const ExtensionProperties& rhs) = default;
  //! Copy construct from raw
  ExtensionProperties(const XrExtensionProperties& rhs) : ExtensionProperties() { *put() = rhs; }
  //! Copy assign from raw
  ExtensionProperties& operator=(const XrExtensionProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExtensionProperties&() const {
    return *reinterpret_cast<const XrExtensionProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExtensionProperties&() { return *reinterpret_cast<XrExtensionProperties*>(this); }

  //! Accessor for this as the address of a raw XrExtensionProperties
  XrExtensionProperties const* get() const noexcept {
    return reinterpret_cast<XrExtensionProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrExtensionProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrExtensionProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ExtensionProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrExtensionProperties*>(this);
  }
  char extensionName[XR_MAX_EXTENSION_NAME_SIZE];
  uint32_t extensionVersion;
};
static_assert(sizeof(XrExtensionProperties) == sizeof(ExtensionProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExtensionProperties pointer to const from a
 * ExtensionProperties reference to const.
 * @relates ExtensionProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtensionProperties const* get(ExtensionProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ExtensionProperties as the
 * address of a raw XrExtensionProperties
 * @relates ExtensionProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtensionProperties* put(ExtensionProperties& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrApplicationInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrApplicationInfo>
 * @xrentity{XrApplicationInfo}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ApplicationInfo {
public:
  //! Constructor initializing all members.
  ApplicationInfo(const char* applicationName_, uint32_t applicationVersion_,
                  const char* engineName_, uint32_t engineVersion_, const Version& apiVersion_)
      : applicationVersion{applicationVersion_},
        engineVersion{engineVersion_},
        apiVersion{apiVersion_} {
    if (nullptr != applicationName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(applicationName, XR_MAX_APPLICATION_NAME_SIZE, applicationName_,
                XR_MAX_APPLICATION_NAME_SIZE);
#else
      strncpy(applicationName, applicationName_, XR_MAX_APPLICATION_NAME_SIZE - 1);
      applicationName[XR_MAX_APPLICATION_NAME_SIZE - 1] = '\0';
#endif
    }

    if (nullptr != engineName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(engineName, XR_MAX_ENGINE_NAME_SIZE, engineName_, XR_MAX_ENGINE_NAME_SIZE);
#else
      strncpy(engineName, engineName_, XR_MAX_ENGINE_NAME_SIZE - 1);
      engineName[XR_MAX_ENGINE_NAME_SIZE - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  ApplicationInfo()

      : applicationVersion{0}, engineVersion{0}, apiVersion{} {}

  //! Default copy constructor
  ApplicationInfo(const ApplicationInfo& rhs) = default;
  //! Default copy assignment
  ApplicationInfo& operator=(const ApplicationInfo& rhs) = default;
  //! Copy construct from raw
  ApplicationInfo(const XrApplicationInfo& rhs) : ApplicationInfo() { *put() = rhs; }
  //! Copy assign from raw
  ApplicationInfo& operator=(const XrApplicationInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrApplicationInfo&() const {
    return *reinterpret_cast<const XrApplicationInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrApplicationInfo&() { return *reinterpret_cast<XrApplicationInfo*>(this); }

  //! Accessor for this as the address of a raw XrApplicationInfo
  XrApplicationInfo const* get() const noexcept {
    return reinterpret_cast<XrApplicationInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrApplicationInfo.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrApplicationInfo* put(bool clear = true) noexcept {
    if (clear) {
      *this = ApplicationInfo{};
    }
    return reinterpret_cast<XrApplicationInfo*>(this);
  }
  char applicationName[XR_MAX_APPLICATION_NAME_SIZE];
  uint32_t applicationVersion;
  char engineName[XR_MAX_ENGINE_NAME_SIZE];
  uint32_t engineVersion;
  Version apiVersion;
};
static_assert(sizeof(XrApplicationInfo) == sizeof(ApplicationInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrApplicationInfo pointer to const from a ApplicationInfo
 * reference to const.
 * @relates ApplicationInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApplicationInfo const* get(ApplicationInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ApplicationInfo as the
 * address of a raw XrApplicationInfo
 * @relates ApplicationInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApplicationInfo* put(ApplicationInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInstanceCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstanceCreateInfo>
 * @xrentity{XrInstanceCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InstanceCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InstanceCreateInfo(const InstanceCreateFlags& createFlags_,
                     const ApplicationInfo& applicationInfo_, uint32_t enabledApiLayerCount_,
                     const char* const* enabledApiLayerNames_, uint32_t enabledExtensionCount_,
                     const char* const* enabledExtensionNames_, const void* next_ = nullptr)
      : Parent(StructureType::InstanceCreateInfo, next_),
        createFlags{createFlags_},
        applicationInfo{applicationInfo_},
        enabledApiLayerCount{enabledApiLayerCount_},
        enabledApiLayerNames{enabledApiLayerNames_},
        enabledExtensionCount{enabledExtensionCount_},
        enabledExtensionNames{enabledExtensionNames_} {}

  //! Default/empty constructor
  InstanceCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::InstanceCreateInfo, next_),
        createFlags{},
        applicationInfo{},
        enabledApiLayerCount{0},
        enabledApiLayerNames{nullptr},
        enabledExtensionCount{0},
        enabledExtensionNames{nullptr} {}

  //! Default copy constructor
  InstanceCreateInfo(const InstanceCreateInfo& rhs) = default;
  //! Default copy assignment
  InstanceCreateInfo& operator=(const InstanceCreateInfo& rhs) = default;
  //! Copy construct from raw
  InstanceCreateInfo(const XrInstanceCreateInfo& rhs) : InstanceCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  InstanceCreateInfo& operator=(const XrInstanceCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInstanceCreateInfo&() const {
    return *reinterpret_cast<const XrInstanceCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInstanceCreateInfo&() { return *reinterpret_cast<XrInstanceCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrInstanceCreateInfo
  XrInstanceCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrInstanceCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrInstanceCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInstanceCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InstanceCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrInstanceCreateInfo*>(this);
  }
  InstanceCreateFlags createFlags;
  ApplicationInfo applicationInfo;
  uint32_t enabledApiLayerCount;
  const char* const* enabledApiLayerNames;
  uint32_t enabledExtensionCount;
  const char* const* enabledExtensionNames;
};
static_assert(sizeof(XrInstanceCreateInfo) == sizeof(InstanceCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInstanceCreateInfo pointer to const from a
 * InstanceCreateInfo reference to const.
 * @relates InstanceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceCreateInfo const* get(InstanceCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing InstanceCreateInfo as the
 * address of a raw XrInstanceCreateInfo
 * @relates InstanceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceCreateInfo* put(InstanceCreateInfo& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInstanceProperties
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstanceProperties>
 * @xrentity{XrInstanceProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InstanceProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  InstanceProperties(void* next_ = nullptr)

      : Parent(StructureType::InstanceProperties, next_) {}

  //! Default copy constructor
  InstanceProperties(const InstanceProperties& rhs) = default;
  //! Default copy assignment
  InstanceProperties& operator=(const InstanceProperties& rhs) = default;
  //! Copy construct from raw
  InstanceProperties(const XrInstanceProperties& rhs) : InstanceProperties() { *put() = rhs; }
  //! Copy assign from raw
  InstanceProperties& operator=(const XrInstanceProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInstanceProperties&() const {
    return *reinterpret_cast<const XrInstanceProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInstanceProperties&() { return *reinterpret_cast<XrInstanceProperties*>(this); }

  //! Accessor for this as the address of a raw XrInstanceProperties
  XrInstanceProperties const* get() const noexcept {
    return reinterpret_cast<XrInstanceProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrInstanceProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInstanceProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InstanceProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrInstanceProperties*>(this);
  }
  Version runtimeVersion;
  char runtimeName[XR_MAX_RUNTIME_NAME_SIZE];
};
static_assert(sizeof(XrInstanceProperties) == sizeof(InstanceProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInstanceProperties pointer to const from a
 * InstanceProperties reference to const.
 * @relates InstanceProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceProperties const* get(InstanceProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing InstanceProperties as the
 * address of a raw XrInstanceProperties
 * @relates InstanceProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceProperties* put(InstanceProperties& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSystemGetInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemGetInfo>
 * @xrentity{XrSystemGetInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemGetInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SystemGetInfo(const FormFactor& formFactor_, const void* next_ = nullptr)
      : Parent(StructureType::SystemGetInfo, next_), formFactor{formFactor_} {}

  //! Default/empty constructor
  SystemGetInfo(const void* next_ = nullptr)

      : Parent(StructureType::SystemGetInfo, next_), formFactor{} {}

  //! Default copy constructor
  SystemGetInfo(const SystemGetInfo& rhs) = default;
  //! Default copy assignment
  SystemGetInfo& operator=(const SystemGetInfo& rhs) = default;
  //! Copy construct from raw
  SystemGetInfo(const XrSystemGetInfo& rhs) : SystemGetInfo() { *put() = rhs; }
  //! Copy assign from raw
  SystemGetInfo& operator=(const XrSystemGetInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemGetInfo&() const {
    return *reinterpret_cast<const XrSystemGetInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemGetInfo&() { return *reinterpret_cast<XrSystemGetInfo*>(this); }

  //! Accessor for this as the address of a raw XrSystemGetInfo
  XrSystemGetInfo const* get() const noexcept {
    return reinterpret_cast<XrSystemGetInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSystemGetInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemGetInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemGetInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemGetInfo*>(this);
  }
  FormFactor formFactor;
};
static_assert(sizeof(XrSystemGetInfo) == sizeof(SystemGetInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemGetInfo pointer to const from a SystemGetInfo
 * reference to const.
 * @relates SystemGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemGetInfo const* get(SystemGetInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemGetInfo as the address
 * of a raw XrSystemGetInfo
 * @relates SystemGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemGetInfo* put(SystemGetInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSystemGraphicsProperties
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemGraphicsProperties>
 * @xrentity{XrSystemGraphicsProperties}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SystemGraphicsProperties {
public:
  //! Constructor initializing all members.
  SystemGraphicsProperties(uint32_t maxSwapchainImageHeight_, uint32_t maxSwapchainImageWidth_,
                           uint32_t maxLayerCount_)
      : maxSwapchainImageHeight{maxSwapchainImageHeight_},
        maxSwapchainImageWidth{maxSwapchainImageWidth_},
        maxLayerCount{maxLayerCount_} {}

  //! Default/empty constructor
  SystemGraphicsProperties()

      : maxSwapchainImageHeight{0}, maxSwapchainImageWidth{0}, maxLayerCount{0} {}

  //! Default copy constructor
  SystemGraphicsProperties(const SystemGraphicsProperties& rhs) = default;
  //! Default copy assignment
  SystemGraphicsProperties& operator=(const SystemGraphicsProperties& rhs) = default;
  //! Copy construct from raw
  SystemGraphicsProperties(const XrSystemGraphicsProperties& rhs) : SystemGraphicsProperties() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemGraphicsProperties& operator=(const XrSystemGraphicsProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemGraphicsProperties&() const {
    return *reinterpret_cast<const XrSystemGraphicsProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemGraphicsProperties&() {
    return *reinterpret_cast<XrSystemGraphicsProperties*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemGraphicsProperties
  XrSystemGraphicsProperties const* get() const noexcept {
    return reinterpret_cast<XrSystemGraphicsProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemGraphicsProperties.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSystemGraphicsProperties* put(bool clear = true) noexcept {
    if (clear) {
      *this = SystemGraphicsProperties{};
    }
    return reinterpret_cast<XrSystemGraphicsProperties*>(this);
  }
  uint32_t maxSwapchainImageHeight;
  uint32_t maxSwapchainImageWidth;
  uint32_t maxLayerCount;
};
static_assert(sizeof(XrSystemGraphicsProperties) == sizeof(SystemGraphicsProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemGraphicsProperties pointer to const from a
 * SystemGraphicsProperties reference to const.
 * @relates SystemGraphicsProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemGraphicsProperties const* get(SystemGraphicsProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemGraphicsProperties as
 * the address of a raw XrSystemGraphicsProperties
 * @relates SystemGraphicsProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemGraphicsProperties* put(SystemGraphicsProperties& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSystemTrackingProperties
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemTrackingProperties>
 * @xrentity{XrSystemTrackingProperties}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SystemTrackingProperties {
public:
  //! Constructor initializing all members.
  SystemTrackingProperties(const Bool32& orientationTracking_, const Bool32& positionTracking_)
      : orientationTracking{orientationTracking_}, positionTracking{positionTracking_} {}

  //! Default/empty constructor
  SystemTrackingProperties()

      : orientationTracking{false}, positionTracking{false} {}

  //! Default copy constructor
  SystemTrackingProperties(const SystemTrackingProperties& rhs) = default;
  //! Default copy assignment
  SystemTrackingProperties& operator=(const SystemTrackingProperties& rhs) = default;
  //! Copy construct from raw
  SystemTrackingProperties(const XrSystemTrackingProperties& rhs) : SystemTrackingProperties() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemTrackingProperties& operator=(const XrSystemTrackingProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemTrackingProperties&() const {
    return *reinterpret_cast<const XrSystemTrackingProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemTrackingProperties&() {
    return *reinterpret_cast<XrSystemTrackingProperties*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemTrackingProperties
  XrSystemTrackingProperties const* get() const noexcept {
    return reinterpret_cast<XrSystemTrackingProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemTrackingProperties.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSystemTrackingProperties* put(bool clear = true) noexcept {
    if (clear) {
      *this = SystemTrackingProperties{};
    }
    return reinterpret_cast<XrSystemTrackingProperties*>(this);
  }
  Bool32 orientationTracking;
  Bool32 positionTracking;
};
static_assert(sizeof(XrSystemTrackingProperties) == sizeof(SystemTrackingProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemTrackingProperties pointer to const from a
 * SystemTrackingProperties reference to const.
 * @relates SystemTrackingProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemTrackingProperties const* get(SystemTrackingProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemTrackingProperties as
 * the address of a raw XrSystemTrackingProperties
 * @relates SystemTrackingProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemTrackingProperties* put(SystemTrackingProperties& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSystemProperties
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemProperties>
 * @xrentity{XrSystemProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemProperties(void* next_ = nullptr)

      : Parent(StructureType::SystemProperties, next_) {}

  //! Default copy constructor
  SystemProperties(const SystemProperties& rhs) = default;
  //! Default copy assignment
  SystemProperties& operator=(const SystemProperties& rhs) = default;
  //! Copy construct from raw
  SystemProperties(const XrSystemProperties& rhs) : SystemProperties() { *put() = rhs; }
  //! Copy assign from raw
  SystemProperties& operator=(const XrSystemProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemProperties&() const {
    return *reinterpret_cast<const XrSystemProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemProperties&() { return *reinterpret_cast<XrSystemProperties*>(this); }

  //! Accessor for this as the address of a raw XrSystemProperties
  XrSystemProperties const* get() const noexcept {
    return reinterpret_cast<XrSystemProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSystemProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemProperties*>(this);
  }
  SystemId systemId;
  uint32_t vendorId;
  char systemName[XR_MAX_SYSTEM_NAME_SIZE];
  SystemGraphicsProperties graphicsProperties;
  SystemTrackingProperties trackingProperties;
};
static_assert(sizeof(XrSystemProperties) == sizeof(SystemProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemProperties pointer to const from a
 * SystemProperties reference to const.
 * @relates SystemProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemProperties const* get(SystemProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemProperties as the
 * address of a raw XrSystemProperties
 * @relates SystemProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemProperties* put(SystemProperties& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSessionCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionCreateInfo>
 * @xrentity{XrSessionCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SessionCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SessionCreateInfo(const SessionCreateFlags& createFlags_, const SystemId& systemId_,
                    const void* next_ = nullptr)
      : Parent(StructureType::SessionCreateInfo, next_),
        createFlags{createFlags_},
        systemId{systemId_} {}

  //! Default/empty constructor
  SessionCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::SessionCreateInfo, next_), createFlags{}, systemId{} {}

  //! Default copy constructor
  SessionCreateInfo(const SessionCreateInfo& rhs) = default;
  //! Default copy assignment
  SessionCreateInfo& operator=(const SessionCreateInfo& rhs) = default;
  //! Copy construct from raw
  SessionCreateInfo(const XrSessionCreateInfo& rhs) : SessionCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  SessionCreateInfo& operator=(const XrSessionCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSessionCreateInfo&() const {
    return *reinterpret_cast<const XrSessionCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSessionCreateInfo&() { return *reinterpret_cast<XrSessionCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrSessionCreateInfo
  XrSessionCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrSessionCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSessionCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSessionCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SessionCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSessionCreateInfo*>(this);
  }
  SessionCreateFlags createFlags;
  SystemId systemId;
};
static_assert(sizeof(XrSessionCreateInfo) == sizeof(SessionCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSessionCreateInfo pointer to const from a
 * SessionCreateInfo reference to const.
 * @relates SessionCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionCreateInfo const* get(SessionCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionCreateInfo as the
 * address of a raw XrSessionCreateInfo
 * @relates SessionCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionCreateInfo* put(SessionCreateInfo& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrVector3f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector3f>
 * @xrentity{XrVector3f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Vector3f {
public:
  //! Constructor initializing all members.
  Vector3f(float x_, float y_, float z_) : x{x_}, y{y_}, z{z_} {}

  //! Default/empty constructor
  Vector3f()

      : x{0.0f}, y{0.0f}, z{0.0f} {}

  //! Default copy constructor
  Vector3f(const Vector3f& rhs) = default;
  //! Default copy assignment
  Vector3f& operator=(const Vector3f& rhs) = default;
  //! Copy construct from raw
  Vector3f(const XrVector3f& rhs) : Vector3f() { *put() = rhs; }
  //! Copy assign from raw
  Vector3f& operator=(const XrVector3f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVector3f&() const { return *reinterpret_cast<const XrVector3f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVector3f&() { return *reinterpret_cast<XrVector3f*>(this); }

  //! Accessor for this as the address of a raw XrVector3f
  XrVector3f const* get() const noexcept { return reinterpret_cast<XrVector3f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVector3f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrVector3f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Vector3f{};
    }
    return reinterpret_cast<XrVector3f*>(this);
  }
  float x;
  float y;
  float z;
};
static_assert(sizeof(XrVector3f) == sizeof(Vector3f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVector3f pointer to const from a Vector3f reference to
 * const.
 * @relates Vector3f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector3f const* get(Vector3f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector3f as the address of a
 * raw XrVector3f
 * @relates Vector3f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector3f* put(Vector3f& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSpaceVelocity
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceVelocity>
 * @xrentity{XrSpaceVelocity}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceVelocity : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceVelocity(void* next_ = nullptr)

      : Parent(StructureType::SpaceVelocity, next_) {}

  //! Default copy constructor
  SpaceVelocity(const SpaceVelocity& rhs) = default;
  //! Default copy assignment
  SpaceVelocity& operator=(const SpaceVelocity& rhs) = default;
  //! Copy construct from raw
  SpaceVelocity(const XrSpaceVelocity& rhs) : SpaceVelocity() { *put() = rhs; }
  //! Copy assign from raw
  SpaceVelocity& operator=(const XrSpaceVelocity& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceVelocity&() const {
    return *reinterpret_cast<const XrSpaceVelocity*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceVelocity&() { return *reinterpret_cast<XrSpaceVelocity*>(this); }

  //! Accessor for this as the address of a raw XrSpaceVelocity
  XrSpaceVelocity const* get() const noexcept {
    return reinterpret_cast<XrSpaceVelocity const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceVelocity.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceVelocity* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceVelocity{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceVelocity*>(this);
  }
  SpaceVelocityFlags velocityFlags;
  Vector3f linearVelocity;
  Vector3f angularVelocity;
};
static_assert(sizeof(XrSpaceVelocity) == sizeof(SpaceVelocity),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceVelocity pointer to const from a SpaceVelocity
 * reference to const.
 * @relates SpaceVelocity
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceVelocity const* get(SpaceVelocity const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceVelocity as the address
 * of a raw XrSpaceVelocity
 * @relates SpaceVelocity
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceVelocity* put(SpaceVelocity& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrQuaternionf
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrQuaternionf>
 * @xrentity{XrQuaternionf}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Quaternionf {
public:
  //! Constructor initializing all members.
  Quaternionf(float x_, float y_, float z_, float w_) : x{x_}, y{y_}, z{z_}, w{w_} {}

  //! Default/empty constructor
  Quaternionf()

      : x{0.0f}, y{0.0f}, z{0.0f}, w{1.0f} {}

  //! Default copy constructor
  Quaternionf(const Quaternionf& rhs) = default;
  //! Default copy assignment
  Quaternionf& operator=(const Quaternionf& rhs) = default;
  //! Copy construct from raw
  Quaternionf(const XrQuaternionf& rhs) : Quaternionf() { *put() = rhs; }
  //! Copy assign from raw
  Quaternionf& operator=(const XrQuaternionf& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrQuaternionf&() const { return *reinterpret_cast<const XrQuaternionf*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrQuaternionf&() { return *reinterpret_cast<XrQuaternionf*>(this); }

  //! Accessor for this as the address of a raw XrQuaternionf
  XrQuaternionf const* get() const noexcept { return reinterpret_cast<XrQuaternionf const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrQuaternionf.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrQuaternionf* put(bool clear = true) noexcept {
    if (clear) {
      *this = Quaternionf{};
    }
    return reinterpret_cast<XrQuaternionf*>(this);
  }
  float x;
  float y;
  float z;
  float w;
};
static_assert(sizeof(XrQuaternionf) == sizeof(Quaternionf),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrQuaternionf pointer to const from a Quaternionf
 * reference to const.
 * @relates Quaternionf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrQuaternionf const* get(Quaternionf const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Quaternionf as the address of
 * a raw XrQuaternionf
 * @relates Quaternionf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrQuaternionf* put(Quaternionf& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrPosef
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPosef>
 * @xrentity{XrPosef}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Posef {
public:
  //! Constructor initializing all members.
  Posef(const Quaternionf& orientation_, const Vector3f& position_)
      : orientation{orientation_}, position{position_} {}

  //! Default/empty constructor
  Posef()

      : orientation{}, position{} {}

  //! Default copy constructor
  Posef(const Posef& rhs) = default;
  //! Default copy assignment
  Posef& operator=(const Posef& rhs) = default;
  //! Copy construct from raw
  Posef(const XrPosef& rhs) : Posef() { *put() = rhs; }
  //! Copy assign from raw
  Posef& operator=(const XrPosef& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPosef&() const { return *reinterpret_cast<const XrPosef*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPosef&() { return *reinterpret_cast<XrPosef*>(this); }

  //! Accessor for this as the address of a raw XrPosef
  XrPosef const* get() const noexcept { return reinterpret_cast<XrPosef const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrPosef.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrPosef* put(bool clear = true) noexcept {
    if (clear) {
      *this = Posef{};
    }
    return reinterpret_cast<XrPosef*>(this);
  }
  Quaternionf orientation;
  Vector3f position;
};
static_assert(sizeof(XrPosef) == sizeof(Posef), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPosef pointer to const from a Posef reference to const.
 * @relates Posef
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPosef const* get(Posef const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Posef as the address of a raw
 * XrPosef
 * @relates Posef
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPosef* put(Posef& s, bool clear = true) noexcept { return s.put(clear); }

/*!
 * C++ projection of XrReferenceSpaceCreateInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrReferenceSpaceCreateInfo>
 * @xrentity{XrReferenceSpaceCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ReferenceSpaceCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ReferenceSpaceCreateInfo(const ReferenceSpaceType& referenceSpaceType_,
                           const Posef& poseInReferenceSpace_, const void* next_ = nullptr)
      : Parent(StructureType::ReferenceSpaceCreateInfo, next_),
        referenceSpaceType{referenceSpaceType_},
        poseInReferenceSpace{poseInReferenceSpace_} {}

  //! Default/empty constructor
  ReferenceSpaceCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::ReferenceSpaceCreateInfo, next_),
        referenceSpaceType{},
        poseInReferenceSpace{} {}

  //! Default copy constructor
  ReferenceSpaceCreateInfo(const ReferenceSpaceCreateInfo& rhs) = default;
  //! Default copy assignment
  ReferenceSpaceCreateInfo& operator=(const ReferenceSpaceCreateInfo& rhs) = default;
  //! Copy construct from raw
  ReferenceSpaceCreateInfo(const XrReferenceSpaceCreateInfo& rhs) : ReferenceSpaceCreateInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ReferenceSpaceCreateInfo& operator=(const XrReferenceSpaceCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrReferenceSpaceCreateInfo&() const {
    return *reinterpret_cast<const XrReferenceSpaceCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrReferenceSpaceCreateInfo&() {
    return *reinterpret_cast<XrReferenceSpaceCreateInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrReferenceSpaceCreateInfo
  XrReferenceSpaceCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrReferenceSpaceCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrReferenceSpaceCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrReferenceSpaceCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ReferenceSpaceCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrReferenceSpaceCreateInfo*>(this);
  }
  ReferenceSpaceType referenceSpaceType;
  Posef poseInReferenceSpace;
};
static_assert(sizeof(XrReferenceSpaceCreateInfo) == sizeof(ReferenceSpaceCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrReferenceSpaceCreateInfo pointer to const from a
 * ReferenceSpaceCreateInfo reference to const.
 * @relates ReferenceSpaceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrReferenceSpaceCreateInfo const* get(ReferenceSpaceCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ReferenceSpaceCreateInfo as
 * the address of a raw XrReferenceSpaceCreateInfo
 * @relates ReferenceSpaceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrReferenceSpaceCreateInfo* put(ReferenceSpaceCreateInfo& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrExtent2Df
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtent2Df>
 * @xrentity{XrExtent2Df}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Extent2Df {
public:
  //! Constructor initializing all members.
  Extent2Df(float width_, float height_) : width{width_}, height{height_} {}

  //! Default/empty constructor
  Extent2Df()

      : width{0.0f}, height{0.0f} {}

  //! Default copy constructor
  Extent2Df(const Extent2Df& rhs) = default;
  //! Default copy assignment
  Extent2Df& operator=(const Extent2Df& rhs) = default;
  //! Copy construct from raw
  Extent2Df(const XrExtent2Df& rhs) : Extent2Df() { *put() = rhs; }
  //! Copy assign from raw
  Extent2Df& operator=(const XrExtent2Df& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExtent2Df&() const { return *reinterpret_cast<const XrExtent2Df*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExtent2Df&() { return *reinterpret_cast<XrExtent2Df*>(this); }

  //! Accessor for this as the address of a raw XrExtent2Df
  XrExtent2Df const* get() const noexcept { return reinterpret_cast<XrExtent2Df const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrExtent2Df.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrExtent2Df* put(bool clear = true) noexcept {
    if (clear) {
      *this = Extent2Df{};
    }
    return reinterpret_cast<XrExtent2Df*>(this);
  }
  float width;
  float height;
};
static_assert(sizeof(XrExtent2Df) == sizeof(Extent2Df),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExtent2Df pointer to const from a Extent2Df reference to
 * const.
 * @relates Extent2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent2Df const* get(Extent2Df const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Extent2Df as the address of a
 * raw XrExtent2Df
 * @relates Extent2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent2Df* put(Extent2Df& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionSpaceCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSpaceCreateInfo>
 * @xrentity{XrActionSpaceCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionSpaceCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionSpaceCreateInfo(const Action& action_, const Path& subactionPath_,
                        const Posef& poseInActionSpace_, const void* next_ = nullptr)
      : Parent(StructureType::ActionSpaceCreateInfo, next_),
        action{action_},
        subactionPath{subactionPath_},
        poseInActionSpace{poseInActionSpace_} {}

  //! Default/empty constructor
  ActionSpaceCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::ActionSpaceCreateInfo, next_),
        action{},
        subactionPath{},
        poseInActionSpace{} {}

  //! Default copy constructor
  ActionSpaceCreateInfo(const ActionSpaceCreateInfo& rhs) = default;
  //! Default copy assignment
  ActionSpaceCreateInfo& operator=(const ActionSpaceCreateInfo& rhs) = default;
  //! Copy construct from raw
  ActionSpaceCreateInfo(const XrActionSpaceCreateInfo& rhs) : ActionSpaceCreateInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ActionSpaceCreateInfo& operator=(const XrActionSpaceCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionSpaceCreateInfo&() const {
    return *reinterpret_cast<const XrActionSpaceCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionSpaceCreateInfo&() { return *reinterpret_cast<XrActionSpaceCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionSpaceCreateInfo
  XrActionSpaceCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrActionSpaceCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionSpaceCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionSpaceCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionSpaceCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionSpaceCreateInfo*>(this);
  }
  Action action;
  Path subactionPath;
  Posef poseInActionSpace;
};
static_assert(sizeof(XrActionSpaceCreateInfo) == sizeof(ActionSpaceCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionSpaceCreateInfo pointer to const from a
 * ActionSpaceCreateInfo reference to const.
 * @relates ActionSpaceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSpaceCreateInfo const* get(ActionSpaceCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionSpaceCreateInfo as the
 * address of a raw XrActionSpaceCreateInfo
 * @relates ActionSpaceCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSpaceCreateInfo* put(ActionSpaceCreateInfo& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSpaceLocation
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceLocation>
 * @xrentity{XrSpaceLocation}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceLocation : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceLocation(void* next_ = nullptr)

      : Parent(StructureType::SpaceLocation, next_) {}

  //! Default copy constructor
  SpaceLocation(const SpaceLocation& rhs) = default;
  //! Default copy assignment
  SpaceLocation& operator=(const SpaceLocation& rhs) = default;
  //! Copy construct from raw
  SpaceLocation(const XrSpaceLocation& rhs) : SpaceLocation() { *put() = rhs; }
  //! Copy assign from raw
  SpaceLocation& operator=(const XrSpaceLocation& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceLocation&() const {
    return *reinterpret_cast<const XrSpaceLocation*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceLocation&() { return *reinterpret_cast<XrSpaceLocation*>(this); }

  //! Accessor for this as the address of a raw XrSpaceLocation
  XrSpaceLocation const* get() const noexcept {
    return reinterpret_cast<XrSpaceLocation const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceLocation.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceLocation* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceLocation{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceLocation*>(this);
  }
  SpaceLocationFlags locationFlags;
  Posef pose;
};
static_assert(sizeof(XrSpaceLocation) == sizeof(SpaceLocation),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceLocation pointer to const from a SpaceLocation
 * reference to const.
 * @relates SpaceLocation
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceLocation const* get(SpaceLocation const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceLocation as the address
 * of a raw XrSpaceLocation
 * @relates SpaceLocation
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceLocation* put(SpaceLocation& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrViewConfigurationProperties
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationProperties>
 * @xrentity{XrViewConfigurationProperties}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewConfigurationProperties : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViewConfigurationProperties(void* next_ = nullptr)

      : Parent(StructureType::ViewConfigurationProperties, next_) {}

  //! Default copy constructor
  ViewConfigurationProperties(const ViewConfigurationProperties& rhs) = default;
  //! Default copy assignment
  ViewConfigurationProperties& operator=(const ViewConfigurationProperties& rhs) = default;
  //! Copy construct from raw
  ViewConfigurationProperties(const XrViewConfigurationProperties& rhs)
      : ViewConfigurationProperties() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewConfigurationProperties& operator=(const XrViewConfigurationProperties& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewConfigurationProperties&() const {
    return *reinterpret_cast<const XrViewConfigurationProperties*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewConfigurationProperties&() {
    return *reinterpret_cast<XrViewConfigurationProperties*>(this);
  }

  //! Accessor for this as the address of a raw XrViewConfigurationProperties
  XrViewConfigurationProperties const* get() const noexcept {
    return reinterpret_cast<XrViewConfigurationProperties const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrViewConfigurationProperties.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewConfigurationProperties* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewConfigurationProperties{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewConfigurationProperties*>(this);
  }
  ViewConfigurationType viewConfigurationType;
  Bool32 fovMutable;
};
static_assert(sizeof(XrViewConfigurationProperties) == sizeof(ViewConfigurationProperties),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewConfigurationProperties pointer to const from a
 * ViewConfigurationProperties reference to const.
 * @relates ViewConfigurationProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationProperties const* get(
    ViewConfigurationProperties const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationProperties
 * as the address of a raw XrViewConfigurationProperties
 * @relates ViewConfigurationProperties
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationProperties* put(ViewConfigurationProperties& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrViewConfigurationView
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationView>
 * @xrentity{XrViewConfigurationView}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewConfigurationView : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViewConfigurationView(void* next_ = nullptr)

      : Parent(StructureType::ViewConfigurationView, next_) {}

  //! Default copy constructor
  ViewConfigurationView(const ViewConfigurationView& rhs) = default;
  //! Default copy assignment
  ViewConfigurationView& operator=(const ViewConfigurationView& rhs) = default;
  //! Copy construct from raw
  ViewConfigurationView(const XrViewConfigurationView& rhs) : ViewConfigurationView() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewConfigurationView& operator=(const XrViewConfigurationView& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewConfigurationView&() const {
    return *reinterpret_cast<const XrViewConfigurationView*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewConfigurationView&() { return *reinterpret_cast<XrViewConfigurationView*>(this); }

  //! Accessor for this as the address of a raw XrViewConfigurationView
  XrViewConfigurationView const* get() const noexcept {
    return reinterpret_cast<XrViewConfigurationView const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrViewConfigurationView.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewConfigurationView* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewConfigurationView{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewConfigurationView*>(this);
  }
  uint32_t recommendedImageRectWidth;
  uint32_t maxImageRectWidth;
  uint32_t recommendedImageRectHeight;
  uint32_t maxImageRectHeight;
  uint32_t recommendedSwapchainSampleCount;
  uint32_t maxSwapchainSampleCount;
};
static_assert(sizeof(XrViewConfigurationView) == sizeof(ViewConfigurationView),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewConfigurationView pointer to const from a
 * ViewConfigurationView reference to const.
 * @relates ViewConfigurationView
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationView const* get(ViewConfigurationView const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationView as the
 * address of a raw XrViewConfigurationView
 * @relates ViewConfigurationView
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationView* put(ViewConfigurationView& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainCreateInfo>
 * @xrentity{XrSwapchainCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SwapchainCreateInfo(const SwapchainCreateFlags& createFlags_,
                      const SwapchainUsageFlags& usageFlags_, int64_t format_,
                      uint32_t sampleCount_, uint32_t width_, uint32_t height_, uint32_t faceCount_,
                      uint32_t arraySize_, uint32_t mipCount_, const void* next_ = nullptr)
      : Parent(StructureType::SwapchainCreateInfo, next_),
        createFlags{createFlags_},
        usageFlags{usageFlags_},
        format{format_},
        sampleCount{sampleCount_},
        width{width_},
        height{height_},
        faceCount{faceCount_},
        arraySize{arraySize_},
        mipCount{mipCount_} {}

  //! Default/empty constructor
  SwapchainCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::SwapchainCreateInfo, next_),
        createFlags{},
        usageFlags{},
        format{0},
        sampleCount{0},
        width{0},
        height{0},
        faceCount{0},
        arraySize{0},
        mipCount{0} {}

  //! Default copy constructor
  SwapchainCreateInfo(const SwapchainCreateInfo& rhs) = default;
  //! Default copy assignment
  SwapchainCreateInfo& operator=(const SwapchainCreateInfo& rhs) = default;
  //! Copy construct from raw
  SwapchainCreateInfo(const XrSwapchainCreateInfo& rhs) : SwapchainCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  SwapchainCreateInfo& operator=(const XrSwapchainCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainCreateInfo&() const {
    return *reinterpret_cast<const XrSwapchainCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainCreateInfo&() { return *reinterpret_cast<XrSwapchainCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrSwapchainCreateInfo
  XrSwapchainCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrSwapchainCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainCreateInfo*>(this);
  }
  SwapchainCreateFlags createFlags;
  SwapchainUsageFlags usageFlags;
  int64_t format;
  uint32_t sampleCount;
  uint32_t width;
  uint32_t height;
  uint32_t faceCount;
  uint32_t arraySize;
  uint32_t mipCount;
};
static_assert(sizeof(XrSwapchainCreateInfo) == sizeof(SwapchainCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainCreateInfo pointer to const from a
 * SwapchainCreateInfo reference to const.
 * @relates SwapchainCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainCreateInfo const* get(SwapchainCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainCreateInfo as the
 * address of a raw XrSwapchainCreateInfo
 * @relates SwapchainCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainCreateInfo* put(SwapchainCreateInfo& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainImageBaseHeader
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageBaseHeader>
 * @xrentity{XrSwapchainImageBaseHeader}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS SwapchainImageBaseHeader : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  SwapchainImageBaseHeader(StructureType type_, void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageBaseHeader&() const {
    return *reinterpret_cast<const XrSwapchainImageBaseHeader*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageBaseHeader&() {
    return *reinterpret_cast<XrSwapchainImageBaseHeader*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageBaseHeader
  XrSwapchainImageBaseHeader const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw XrSwapchainImageBaseHeader.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrSwapchainImageBaseHeader* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader*>(this);
  }
};
static_assert(sizeof(XrSwapchainImageBaseHeader) == sizeof(SwapchainImageBaseHeader),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageBaseHeader pointer to const from a
 * SwapchainImageBaseHeader reference to const.
 * @relates SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get(SwapchainImageBaseHeader const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageBaseHeader as
 * the address of a raw XrSwapchainImageBaseHeader
 * @relates SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader* put(SwapchainImageBaseHeader& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainImageAcquireInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageAcquireInfo>
 * @xrentity{XrSwapchainImageAcquireInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageAcquireInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SwapchainImageAcquireInfo(const void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageAcquireInfo, next_) {}

  //! Default copy constructor
  SwapchainImageAcquireInfo(const SwapchainImageAcquireInfo& rhs) = default;
  //! Default copy assignment
  SwapchainImageAcquireInfo& operator=(const SwapchainImageAcquireInfo& rhs) = default;
  //! Copy construct from raw
  SwapchainImageAcquireInfo(const XrSwapchainImageAcquireInfo& rhs) : SwapchainImageAcquireInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageAcquireInfo& operator=(const XrSwapchainImageAcquireInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageAcquireInfo&() const {
    return *reinterpret_cast<const XrSwapchainImageAcquireInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageAcquireInfo&() {
    return *reinterpret_cast<XrSwapchainImageAcquireInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageAcquireInfo
  XrSwapchainImageAcquireInfo const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageAcquireInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageAcquireInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageAcquireInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageAcquireInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageAcquireInfo*>(this);
  }
};
static_assert(sizeof(XrSwapchainImageAcquireInfo) == sizeof(SwapchainImageAcquireInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageAcquireInfo pointer to const from a
 * SwapchainImageAcquireInfo reference to const.
 * @relates SwapchainImageAcquireInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageAcquireInfo const* get(
    SwapchainImageAcquireInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageAcquireInfo as
 * the address of a raw XrSwapchainImageAcquireInfo
 * @relates SwapchainImageAcquireInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageAcquireInfo* put(SwapchainImageAcquireInfo& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainImageWaitInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageWaitInfo>
 * @xrentity{XrSwapchainImageWaitInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageWaitInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SwapchainImageWaitInfo(const Duration& timeout_, const void* next_ = nullptr)
      : Parent(StructureType::SwapchainImageWaitInfo, next_), timeout{timeout_} {}

  //! Default/empty constructor
  SwapchainImageWaitInfo(const void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageWaitInfo, next_), timeout{} {}

  //! Default copy constructor
  SwapchainImageWaitInfo(const SwapchainImageWaitInfo& rhs) = default;
  //! Default copy assignment
  SwapchainImageWaitInfo& operator=(const SwapchainImageWaitInfo& rhs) = default;
  //! Copy construct from raw
  SwapchainImageWaitInfo(const XrSwapchainImageWaitInfo& rhs) : SwapchainImageWaitInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageWaitInfo& operator=(const XrSwapchainImageWaitInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageWaitInfo&() const {
    return *reinterpret_cast<const XrSwapchainImageWaitInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageWaitInfo&() {
    return *reinterpret_cast<XrSwapchainImageWaitInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageWaitInfo
  XrSwapchainImageWaitInfo const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageWaitInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageWaitInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageWaitInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageWaitInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageWaitInfo*>(this);
  }
  Duration timeout;
};
static_assert(sizeof(XrSwapchainImageWaitInfo) == sizeof(SwapchainImageWaitInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageWaitInfo pointer to const from a
 * SwapchainImageWaitInfo reference to const.
 * @relates SwapchainImageWaitInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageWaitInfo const* get(SwapchainImageWaitInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageWaitInfo as the
 * address of a raw XrSwapchainImageWaitInfo
 * @relates SwapchainImageWaitInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageWaitInfo* put(SwapchainImageWaitInfo& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainImageReleaseInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageReleaseInfo>
 * @xrentity{XrSwapchainImageReleaseInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageReleaseInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SwapchainImageReleaseInfo(const void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageReleaseInfo, next_) {}

  //! Default copy constructor
  SwapchainImageReleaseInfo(const SwapchainImageReleaseInfo& rhs) = default;
  //! Default copy assignment
  SwapchainImageReleaseInfo& operator=(const SwapchainImageReleaseInfo& rhs) = default;
  //! Copy construct from raw
  SwapchainImageReleaseInfo(const XrSwapchainImageReleaseInfo& rhs) : SwapchainImageReleaseInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageReleaseInfo& operator=(const XrSwapchainImageReleaseInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageReleaseInfo&() const {
    return *reinterpret_cast<const XrSwapchainImageReleaseInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageReleaseInfo&() {
    return *reinterpret_cast<XrSwapchainImageReleaseInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageReleaseInfo
  XrSwapchainImageReleaseInfo const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageReleaseInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageReleaseInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageReleaseInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageReleaseInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageReleaseInfo*>(this);
  }
};
static_assert(sizeof(XrSwapchainImageReleaseInfo) == sizeof(SwapchainImageReleaseInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageReleaseInfo pointer to const from a
 * SwapchainImageReleaseInfo reference to const.
 * @relates SwapchainImageReleaseInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageReleaseInfo const* get(
    SwapchainImageReleaseInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageReleaseInfo as
 * the address of a raw XrSwapchainImageReleaseInfo
 * @relates SwapchainImageReleaseInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageReleaseInfo* put(SwapchainImageReleaseInfo& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSessionBeginInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionBeginInfo>
 * @xrentity{XrSessionBeginInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SessionBeginInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SessionBeginInfo(const ViewConfigurationType& primaryViewConfigurationType_,
                   const void* next_ = nullptr)
      : Parent(StructureType::SessionBeginInfo, next_),
        primaryViewConfigurationType{primaryViewConfigurationType_} {}

  //! Default/empty constructor
  SessionBeginInfo(const void* next_ = nullptr)

      : Parent(StructureType::SessionBeginInfo, next_), primaryViewConfigurationType{} {}

  //! Default copy constructor
  SessionBeginInfo(const SessionBeginInfo& rhs) = default;
  //! Default copy assignment
  SessionBeginInfo& operator=(const SessionBeginInfo& rhs) = default;
  //! Copy construct from raw
  SessionBeginInfo(const XrSessionBeginInfo& rhs) : SessionBeginInfo() { *put() = rhs; }
  //! Copy assign from raw
  SessionBeginInfo& operator=(const XrSessionBeginInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSessionBeginInfo&() const {
    return *reinterpret_cast<const XrSessionBeginInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSessionBeginInfo&() { return *reinterpret_cast<XrSessionBeginInfo*>(this); }

  //! Accessor for this as the address of a raw XrSessionBeginInfo
  XrSessionBeginInfo const* get() const noexcept {
    return reinterpret_cast<XrSessionBeginInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSessionBeginInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSessionBeginInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SessionBeginInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSessionBeginInfo*>(this);
  }
  ViewConfigurationType primaryViewConfigurationType;
};
static_assert(sizeof(XrSessionBeginInfo) == sizeof(SessionBeginInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSessionBeginInfo pointer to const from a
 * SessionBeginInfo reference to const.
 * @relates SessionBeginInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionBeginInfo const* get(SessionBeginInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionBeginInfo as the
 * address of a raw XrSessionBeginInfo
 * @relates SessionBeginInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionBeginInfo* put(SessionBeginInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFrameWaitInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameWaitInfo>
 * @xrentity{XrFrameWaitInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameWaitInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  FrameWaitInfo(const void* next_ = nullptr)

      : Parent(StructureType::FrameWaitInfo, next_) {}

  //! Default copy constructor
  FrameWaitInfo(const FrameWaitInfo& rhs) = default;
  //! Default copy assignment
  FrameWaitInfo& operator=(const FrameWaitInfo& rhs) = default;
  //! Copy construct from raw
  FrameWaitInfo(const XrFrameWaitInfo& rhs) : FrameWaitInfo() { *put() = rhs; }
  //! Copy assign from raw
  FrameWaitInfo& operator=(const XrFrameWaitInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameWaitInfo&() const {
    return *reinterpret_cast<const XrFrameWaitInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameWaitInfo&() { return *reinterpret_cast<XrFrameWaitInfo*>(this); }

  //! Accessor for this as the address of a raw XrFrameWaitInfo
  XrFrameWaitInfo const* get() const noexcept {
    return reinterpret_cast<XrFrameWaitInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameWaitInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameWaitInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameWaitInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameWaitInfo*>(this);
  }
};
static_assert(sizeof(XrFrameWaitInfo) == sizeof(FrameWaitInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameWaitInfo pointer to const from a FrameWaitInfo
 * reference to const.
 * @relates FrameWaitInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameWaitInfo const* get(FrameWaitInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameWaitInfo as the address
 * of a raw XrFrameWaitInfo
 * @relates FrameWaitInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameWaitInfo* put(FrameWaitInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFrameState
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameState>
 * @xrentity{XrFrameState}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameState : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FrameState(void* next_ = nullptr)

      : Parent(StructureType::FrameState, next_) {}

  //! Default copy constructor
  FrameState(const FrameState& rhs) = default;
  //! Default copy assignment
  FrameState& operator=(const FrameState& rhs) = default;
  //! Copy construct from raw
  FrameState(const XrFrameState& rhs) : FrameState() { *put() = rhs; }
  //! Copy assign from raw
  FrameState& operator=(const XrFrameState& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameState&() const { return *reinterpret_cast<const XrFrameState*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameState&() { return *reinterpret_cast<XrFrameState*>(this); }

  //! Accessor for this as the address of a raw XrFrameState
  XrFrameState const* get() const noexcept { return reinterpret_cast<XrFrameState const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameState.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameState* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameState{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameState*>(this);
  }
  Time predictedDisplayTime;
  Duration predictedDisplayPeriod;
  Bool32 shouldRender;
};
static_assert(sizeof(XrFrameState) == sizeof(FrameState),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameState pointer to const from a FrameState reference
 * to const.
 * @relates FrameState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameState const* get(FrameState const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameState as the address of
 * a raw XrFrameState
 * @relates FrameState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameState* put(FrameState& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFrameBeginInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameBeginInfo>
 * @xrentity{XrFrameBeginInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameBeginInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  FrameBeginInfo(const void* next_ = nullptr)

      : Parent(StructureType::FrameBeginInfo, next_) {}

  //! Default copy constructor
  FrameBeginInfo(const FrameBeginInfo& rhs) = default;
  //! Default copy assignment
  FrameBeginInfo& operator=(const FrameBeginInfo& rhs) = default;
  //! Copy construct from raw
  FrameBeginInfo(const XrFrameBeginInfo& rhs) : FrameBeginInfo() { *put() = rhs; }
  //! Copy assign from raw
  FrameBeginInfo& operator=(const XrFrameBeginInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameBeginInfo&() const {
    return *reinterpret_cast<const XrFrameBeginInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameBeginInfo&() { return *reinterpret_cast<XrFrameBeginInfo*>(this); }

  //! Accessor for this as the address of a raw XrFrameBeginInfo
  XrFrameBeginInfo const* get() const noexcept {
    return reinterpret_cast<XrFrameBeginInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameBeginInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameBeginInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameBeginInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameBeginInfo*>(this);
  }
};
static_assert(sizeof(XrFrameBeginInfo) == sizeof(FrameBeginInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameBeginInfo pointer to const from a FrameBeginInfo
 * reference to const.
 * @relates FrameBeginInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameBeginInfo const* get(FrameBeginInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameBeginInfo as the address
 * of a raw XrFrameBeginInfo
 * @relates FrameBeginInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameBeginInfo* put(FrameBeginInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrCompositionLayerBaseHeader
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerBaseHeader>
 * @xrentity{XrCompositionLayerBaseHeader}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS CompositionLayerBaseHeader : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  CompositionLayerBaseHeader(StructureType type_, const CompositionLayerFlags& layerFlags_,
                             const Space& space_, const void* next_ = nullptr)
      : Parent(type_, next_), layerFlags{layerFlags_}, space{space_} {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerBaseHeader&() const {
    return *reinterpret_cast<const XrCompositionLayerBaseHeader*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerBaseHeader&() {
    return *reinterpret_cast<XrCompositionLayerBaseHeader*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerBaseHeader
  XrCompositionLayerBaseHeader const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw XrCompositionLayerBaseHeader.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrCompositionLayerBaseHeader* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader*>(this);
  }
  CompositionLayerFlags layerFlags;
  Space space;
};
static_assert(sizeof(XrCompositionLayerBaseHeader) == sizeof(CompositionLayerBaseHeader),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerBaseHeader pointer to const from a
 * CompositionLayerBaseHeader reference to const.
 * @relates CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get(
    CompositionLayerBaseHeader const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerBaseHeader as
 * the address of a raw XrCompositionLayerBaseHeader
 * @relates CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader* put(CompositionLayerBaseHeader& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFrameEndInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameEndInfo>
 * @xrentity{XrFrameEndInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameEndInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FrameEndInfo(const Time& displayTime_, const EnvironmentBlendMode& environmentBlendMode_,
               uint32_t layerCount_, const CompositionLayerBaseHeader* const* layers_,
               const void* next_ = nullptr)
      : Parent(StructureType::FrameEndInfo, next_),
        displayTime{displayTime_},
        environmentBlendMode{environmentBlendMode_},
        layerCount{layerCount_},
        layers{layers_} {}

  //! Default/empty constructor
  FrameEndInfo(const void* next_ = nullptr)

      : Parent(StructureType::FrameEndInfo, next_),
        displayTime{},
        environmentBlendMode{},
        layerCount{0},
        layers{nullptr} {}

  //! Default copy constructor
  FrameEndInfo(const FrameEndInfo& rhs) = default;
  //! Default copy assignment
  FrameEndInfo& operator=(const FrameEndInfo& rhs) = default;
  //! Copy construct from raw
  FrameEndInfo(const XrFrameEndInfo& rhs) : FrameEndInfo() { *put() = rhs; }
  //! Copy assign from raw
  FrameEndInfo& operator=(const XrFrameEndInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameEndInfo&() const { return *reinterpret_cast<const XrFrameEndInfo*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameEndInfo&() { return *reinterpret_cast<XrFrameEndInfo*>(this); }

  //! Accessor for this as the address of a raw XrFrameEndInfo
  XrFrameEndInfo const* get() const noexcept {
    return reinterpret_cast<XrFrameEndInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameEndInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameEndInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameEndInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameEndInfo*>(this);
  }
  Time displayTime;
  EnvironmentBlendMode environmentBlendMode;
  uint32_t layerCount;
  const CompositionLayerBaseHeader* const* layers;
};
static_assert(sizeof(XrFrameEndInfo) == sizeof(FrameEndInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameEndInfo pointer to const from a FrameEndInfo
 * reference to const.
 * @relates FrameEndInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameEndInfo const* get(FrameEndInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameEndInfo as the address
 * of a raw XrFrameEndInfo
 * @relates FrameEndInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameEndInfo* put(FrameEndInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrViewLocateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewLocateInfo>
 * @xrentity{XrViewLocateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewLocateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ViewLocateInfo(const ViewConfigurationType& viewConfigurationType_, const Time& displayTime_,
                 const Space& space_, const void* next_ = nullptr)
      : Parent(StructureType::ViewLocateInfo, next_),
        viewConfigurationType{viewConfigurationType_},
        displayTime{displayTime_},
        space{space_} {}

  //! Default/empty constructor
  ViewLocateInfo(const void* next_ = nullptr)

      : Parent(StructureType::ViewLocateInfo, next_),
        viewConfigurationType{},
        displayTime{},
        space{} {}

  //! Default copy constructor
  ViewLocateInfo(const ViewLocateInfo& rhs) = default;
  //! Default copy assignment
  ViewLocateInfo& operator=(const ViewLocateInfo& rhs) = default;
  //! Copy construct from raw
  ViewLocateInfo(const XrViewLocateInfo& rhs) : ViewLocateInfo() { *put() = rhs; }
  //! Copy assign from raw
  ViewLocateInfo& operator=(const XrViewLocateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewLocateInfo&() const {
    return *reinterpret_cast<const XrViewLocateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewLocateInfo&() { return *reinterpret_cast<XrViewLocateInfo*>(this); }

  //! Accessor for this as the address of a raw XrViewLocateInfo
  XrViewLocateInfo const* get() const noexcept {
    return reinterpret_cast<XrViewLocateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrViewLocateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewLocateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewLocateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewLocateInfo*>(this);
  }
  ViewConfigurationType viewConfigurationType;
  Time displayTime;
  Space space;
};
static_assert(sizeof(XrViewLocateInfo) == sizeof(ViewLocateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewLocateInfo pointer to const from a ViewLocateInfo
 * reference to const.
 * @relates ViewLocateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewLocateInfo const* get(ViewLocateInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewLocateInfo as the address
 * of a raw XrViewLocateInfo
 * @relates ViewLocateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewLocateInfo* put(ViewLocateInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrViewState
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewState>
 * @xrentity{XrViewState}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewState : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViewState(void* next_ = nullptr)

      : Parent(StructureType::ViewState, next_) {}

  //! Default copy constructor
  ViewState(const ViewState& rhs) = default;
  //! Default copy assignment
  ViewState& operator=(const ViewState& rhs) = default;
  //! Copy construct from raw
  ViewState(const XrViewState& rhs) : ViewState() { *put() = rhs; }
  //! Copy assign from raw
  ViewState& operator=(const XrViewState& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewState&() const { return *reinterpret_cast<const XrViewState*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewState&() { return *reinterpret_cast<XrViewState*>(this); }

  //! Accessor for this as the address of a raw XrViewState
  XrViewState const* get() const noexcept { return reinterpret_cast<XrViewState const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrViewState.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewState* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewState{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewState*>(this);
  }
  ViewStateFlags viewStateFlags;
};
static_assert(sizeof(XrViewState) == sizeof(ViewState),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewState pointer to const from a ViewState reference to
 * const.
 * @relates ViewState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewState const* get(ViewState const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewState as the address of a
 * raw XrViewState
 * @relates ViewState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewState* put(ViewState& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrFovf
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFovf>
 * @xrentity{XrFovf}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Fovf {
public:
  //! Constructor initializing all members.
  Fovf(float angleLeft_, float angleRight_, float angleUp_, float angleDown_)
      : angleLeft{angleLeft_}, angleRight{angleRight_}, angleUp{angleUp_}, angleDown{angleDown_} {}

  //! Default/empty constructor
  Fovf()

      : angleLeft{0.0f}, angleRight{0.0f}, angleUp{0.0f}, angleDown{0.0f} {}

  //! Default copy constructor
  Fovf(const Fovf& rhs) = default;
  //! Default copy assignment
  Fovf& operator=(const Fovf& rhs) = default;
  //! Copy construct from raw
  Fovf(const XrFovf& rhs) : Fovf() { *put() = rhs; }
  //! Copy assign from raw
  Fovf& operator=(const XrFovf& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFovf&() const { return *reinterpret_cast<const XrFovf*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFovf&() { return *reinterpret_cast<XrFovf*>(this); }

  //! Accessor for this as the address of a raw XrFovf
  XrFovf const* get() const noexcept { return reinterpret_cast<XrFovf const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFovf.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrFovf* put(bool clear = true) noexcept {
    if (clear) {
      *this = Fovf{};
    }
    return reinterpret_cast<XrFovf*>(this);
  }
  float angleLeft;
  float angleRight;
  float angleUp;
  float angleDown;
};
static_assert(sizeof(XrFovf) == sizeof(Fovf), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFovf pointer to const from a Fovf reference to const.
 * @relates Fovf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFovf const* get(Fovf const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Fovf as the address of a raw
 * XrFovf
 * @relates Fovf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFovf* put(Fovf& s, bool clear = true) noexcept { return s.put(clear); }

/*!
 * C++ projection of XrView
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrView>
 * @xrentity{XrView}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS View : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  View(void* next_ = nullptr)

      : Parent(StructureType::View, next_) {}

  //! Default copy constructor
  View(const View& rhs) = default;
  //! Default copy assignment
  View& operator=(const View& rhs) = default;
  //! Copy construct from raw
  View(const XrView& rhs) : View() { *put() = rhs; }
  //! Copy assign from raw
  View& operator=(const XrView& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrView&() const { return *reinterpret_cast<const XrView*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrView&() { return *reinterpret_cast<XrView*>(this); }

  //! Accessor for this as the address of a raw XrView
  XrView const* get() const noexcept { return reinterpret_cast<XrView const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrView.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrView* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = View{};
      next = oldNext;
    }
    return reinterpret_cast<XrView*>(this);
  }
  Posef pose;
  Fovf fov;
};
static_assert(sizeof(XrView) == sizeof(View), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrView pointer to const from a View reference to const.
 * @relates View
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrView const* get(View const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing View as the address of a raw
 * XrView
 * @relates View
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrView* put(View& s, bool clear = true) noexcept { return s.put(clear); }

/*!
 * C++ projection of XrActionSetCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSetCreateInfo>
 * @xrentity{XrActionSetCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionSetCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionSetCreateInfo(const char* actionSetName_, const char* localizedActionSetName_,
                      uint32_t priority_, const void* next_ = nullptr)
      : Parent(StructureType::ActionSetCreateInfo, next_), priority{priority_} {
    if (nullptr != actionSetName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(actionSetName, XR_MAX_ACTION_SET_NAME_SIZE, actionSetName_,
                XR_MAX_ACTION_SET_NAME_SIZE);
#else
      strncpy(actionSetName, actionSetName_, XR_MAX_ACTION_SET_NAME_SIZE - 1);
      actionSetName[XR_MAX_ACTION_SET_NAME_SIZE - 1] = '\0';
#endif
    }

    if (nullptr != localizedActionSetName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(localizedActionSetName, XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE,
                localizedActionSetName_, XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE);
#else
      strncpy(localizedActionSetName, localizedActionSetName_,
              XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE - 1);
      localizedActionSetName[XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  ActionSetCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::ActionSetCreateInfo, next_), priority{0} {}

  //! Default copy constructor
  ActionSetCreateInfo(const ActionSetCreateInfo& rhs) = default;
  //! Default copy assignment
  ActionSetCreateInfo& operator=(const ActionSetCreateInfo& rhs) = default;
  //! Copy construct from raw
  ActionSetCreateInfo(const XrActionSetCreateInfo& rhs) : ActionSetCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  ActionSetCreateInfo& operator=(const XrActionSetCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionSetCreateInfo&() const {
    return *reinterpret_cast<const XrActionSetCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionSetCreateInfo&() { return *reinterpret_cast<XrActionSetCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionSetCreateInfo
  XrActionSetCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrActionSetCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionSetCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionSetCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionSetCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionSetCreateInfo*>(this);
  }
  char actionSetName[XR_MAX_ACTION_SET_NAME_SIZE];
  char localizedActionSetName[XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE];
  uint32_t priority;
};
static_assert(sizeof(XrActionSetCreateInfo) == sizeof(ActionSetCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionSetCreateInfo pointer to const from a
 * ActionSetCreateInfo reference to const.
 * @relates ActionSetCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSetCreateInfo const* get(ActionSetCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionSetCreateInfo as the
 * address of a raw XrActionSetCreateInfo
 * @relates ActionSetCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSetCreateInfo* put(ActionSetCreateInfo& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionCreateInfo>
 * @xrentity{XrActionCreateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionCreateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionCreateInfo(const char* actionName_, const ActionType& actionType_,
                   uint32_t countSubactionPaths_, const Path* subactionPaths_,
                   const char* localizedActionName_, const void* next_ = nullptr)
      : Parent(StructureType::ActionCreateInfo, next_),
        actionType{actionType_},
        countSubactionPaths{countSubactionPaths_},
        subactionPaths{subactionPaths_} {
    if (nullptr != actionName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(actionName, XR_MAX_ACTION_NAME_SIZE, actionName_, XR_MAX_ACTION_NAME_SIZE);
#else
      strncpy(actionName, actionName_, XR_MAX_ACTION_NAME_SIZE - 1);
      actionName[XR_MAX_ACTION_NAME_SIZE - 1] = '\0';
#endif
    }

    if (nullptr != localizedActionName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(localizedActionName, XR_MAX_LOCALIZED_ACTION_NAME_SIZE, localizedActionName_,
                XR_MAX_LOCALIZED_ACTION_NAME_SIZE);
#else
      strncpy(localizedActionName, localizedActionName_, XR_MAX_LOCALIZED_ACTION_NAME_SIZE - 1);
      localizedActionName[XR_MAX_LOCALIZED_ACTION_NAME_SIZE - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  ActionCreateInfo(const void* next_ = nullptr)

      : Parent(StructureType::ActionCreateInfo, next_),
        actionType{},
        countSubactionPaths{0},
        subactionPaths{nullptr} {}

  //! Default copy constructor
  ActionCreateInfo(const ActionCreateInfo& rhs) = default;
  //! Default copy assignment
  ActionCreateInfo& operator=(const ActionCreateInfo& rhs) = default;
  //! Copy construct from raw
  ActionCreateInfo(const XrActionCreateInfo& rhs) : ActionCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  ActionCreateInfo& operator=(const XrActionCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionCreateInfo&() const {
    return *reinterpret_cast<const XrActionCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionCreateInfo&() { return *reinterpret_cast<XrActionCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionCreateInfo
  XrActionCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrActionCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionCreateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionCreateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionCreateInfo*>(this);
  }
  char actionName[XR_MAX_ACTION_NAME_SIZE];
  ActionType actionType;
  uint32_t countSubactionPaths;
  const Path* subactionPaths;
  char localizedActionName[XR_MAX_LOCALIZED_ACTION_NAME_SIZE];
};
static_assert(sizeof(XrActionCreateInfo) == sizeof(ActionCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionCreateInfo pointer to const from a
 * ActionCreateInfo reference to const.
 * @relates ActionCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionCreateInfo const* get(ActionCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionCreateInfo as the
 * address of a raw XrActionCreateInfo
 * @relates ActionCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionCreateInfo* put(ActionCreateInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionSuggestedBinding
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSuggestedBinding>
 * @xrentity{XrActionSuggestedBinding}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ActionSuggestedBinding {
public:
  //! Constructor initializing all members.
  ActionSuggestedBinding(const Action& action_, const Path& binding_)
      : action{action_}, binding{binding_} {}

  //! Default/empty constructor
  ActionSuggestedBinding()

      : action{}, binding{} {}

  //! Default copy constructor
  ActionSuggestedBinding(const ActionSuggestedBinding& rhs) = default;
  //! Default copy assignment
  ActionSuggestedBinding& operator=(const ActionSuggestedBinding& rhs) = default;
  //! Copy construct from raw
  ActionSuggestedBinding(const XrActionSuggestedBinding& rhs) : ActionSuggestedBinding() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ActionSuggestedBinding& operator=(const XrActionSuggestedBinding& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionSuggestedBinding&() const {
    return *reinterpret_cast<const XrActionSuggestedBinding*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionSuggestedBinding&() {
    return *reinterpret_cast<XrActionSuggestedBinding*>(this);
  }

  //! Accessor for this as the address of a raw XrActionSuggestedBinding
  XrActionSuggestedBinding const* get() const noexcept {
    return reinterpret_cast<XrActionSuggestedBinding const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionSuggestedBinding.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrActionSuggestedBinding* put(bool clear = true) noexcept {
    if (clear) {
      *this = ActionSuggestedBinding{};
    }
    return reinterpret_cast<XrActionSuggestedBinding*>(this);
  }
  Action action;
  Path binding;
};
static_assert(sizeof(XrActionSuggestedBinding) == sizeof(ActionSuggestedBinding),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionSuggestedBinding pointer to const from a
 * ActionSuggestedBinding reference to const.
 * @relates ActionSuggestedBinding
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSuggestedBinding const* get(ActionSuggestedBinding const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionSuggestedBinding as the
 * address of a raw XrActionSuggestedBinding
 * @relates ActionSuggestedBinding
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionSuggestedBinding* put(ActionSuggestedBinding& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInteractionProfileSuggestedBinding
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileSuggestedBinding>
 * @xrentity{XrInteractionProfileSuggestedBinding}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionProfileSuggestedBinding : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InteractionProfileSuggestedBinding(const Path& interactionProfile_,
                                     uint32_t countSuggestedBindings_,
                                     const ActionSuggestedBinding* suggestedBindings_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::InteractionProfileSuggestedBinding, next_),
        interactionProfile{interactionProfile_},
        countSuggestedBindings{countSuggestedBindings_},
        suggestedBindings{suggestedBindings_} {}

  //! Default/empty constructor
  InteractionProfileSuggestedBinding(const void* next_ = nullptr)

      : Parent(StructureType::InteractionProfileSuggestedBinding, next_),
        interactionProfile{},
        countSuggestedBindings{0},
        suggestedBindings{nullptr} {}

  //! Default copy constructor
  InteractionProfileSuggestedBinding(const InteractionProfileSuggestedBinding& rhs) = default;
  //! Default copy assignment
  InteractionProfileSuggestedBinding& operator=(const InteractionProfileSuggestedBinding& rhs) =
      default;
  //! Copy construct from raw
  InteractionProfileSuggestedBinding(const XrInteractionProfileSuggestedBinding& rhs)
      : InteractionProfileSuggestedBinding() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionProfileSuggestedBinding& operator=(const XrInteractionProfileSuggestedBinding& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionProfileSuggestedBinding&() const {
    return *reinterpret_cast<const XrInteractionProfileSuggestedBinding*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionProfileSuggestedBinding&() {
    return *reinterpret_cast<XrInteractionProfileSuggestedBinding*>(this);
  }

  //! Accessor for this as the address of a raw XrInteractionProfileSuggestedBinding
  XrInteractionProfileSuggestedBinding const* get() const noexcept {
    return reinterpret_cast<XrInteractionProfileSuggestedBinding const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionProfileSuggestedBinding.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionProfileSuggestedBinding* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionProfileSuggestedBinding{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionProfileSuggestedBinding*>(this);
  }
  Path interactionProfile;
  uint32_t countSuggestedBindings;
  const ActionSuggestedBinding* suggestedBindings;
};
static_assert(sizeof(XrInteractionProfileSuggestedBinding) ==
                  sizeof(InteractionProfileSuggestedBinding),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionProfileSuggestedBinding pointer to const from
 * a InteractionProfileSuggestedBinding reference to const.
 * @relates InteractionProfileSuggestedBinding
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileSuggestedBinding const* get(
    InteractionProfileSuggestedBinding const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InteractionProfileSuggestedBinding as the address of a raw XrInteractionProfileSuggestedBinding
 * @relates InteractionProfileSuggestedBinding
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileSuggestedBinding* put(
    InteractionProfileSuggestedBinding& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSessionActionSetsAttachInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionActionSetsAttachInfo>
 * @xrentity{XrSessionActionSetsAttachInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SessionActionSetsAttachInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SessionActionSetsAttachInfo(uint32_t countActionSets_, const ActionSet* actionSets_,
                              const void* next_ = nullptr)
      : Parent(StructureType::SessionActionSetsAttachInfo, next_),
        countActionSets{countActionSets_},
        actionSets{actionSets_} {}

  //! Default/empty constructor
  SessionActionSetsAttachInfo(const void* next_ = nullptr)

      : Parent(StructureType::SessionActionSetsAttachInfo, next_),
        countActionSets{0},
        actionSets{nullptr} {}

  //! Default copy constructor
  SessionActionSetsAttachInfo(const SessionActionSetsAttachInfo& rhs) = default;
  //! Default copy assignment
  SessionActionSetsAttachInfo& operator=(const SessionActionSetsAttachInfo& rhs) = default;
  //! Copy construct from raw
  SessionActionSetsAttachInfo(const XrSessionActionSetsAttachInfo& rhs)
      : SessionActionSetsAttachInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SessionActionSetsAttachInfo& operator=(const XrSessionActionSetsAttachInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSessionActionSetsAttachInfo&() const {
    return *reinterpret_cast<const XrSessionActionSetsAttachInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSessionActionSetsAttachInfo&() {
    return *reinterpret_cast<XrSessionActionSetsAttachInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrSessionActionSetsAttachInfo
  XrSessionActionSetsAttachInfo const* get() const noexcept {
    return reinterpret_cast<XrSessionActionSetsAttachInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSessionActionSetsAttachInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSessionActionSetsAttachInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SessionActionSetsAttachInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSessionActionSetsAttachInfo*>(this);
  }
  uint32_t countActionSets;
  const ActionSet* actionSets;
};
static_assert(sizeof(XrSessionActionSetsAttachInfo) == sizeof(SessionActionSetsAttachInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSessionActionSetsAttachInfo pointer to const from a
 * SessionActionSetsAttachInfo reference to const.
 * @relates SessionActionSetsAttachInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionActionSetsAttachInfo const* get(
    SessionActionSetsAttachInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionActionSetsAttachInfo
 * as the address of a raw XrSessionActionSetsAttachInfo
 * @relates SessionActionSetsAttachInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionActionSetsAttachInfo* put(SessionActionSetsAttachInfo& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInteractionProfileState
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileState>
 * @xrentity{XrInteractionProfileState}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionProfileState : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  InteractionProfileState(void* next_ = nullptr)

      : Parent(StructureType::InteractionProfileState, next_) {}

  //! Default copy constructor
  InteractionProfileState(const InteractionProfileState& rhs) = default;
  //! Default copy assignment
  InteractionProfileState& operator=(const InteractionProfileState& rhs) = default;
  //! Copy construct from raw
  InteractionProfileState(const XrInteractionProfileState& rhs) : InteractionProfileState() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionProfileState& operator=(const XrInteractionProfileState& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionProfileState&() const {
    return *reinterpret_cast<const XrInteractionProfileState*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionProfileState&() {
    return *reinterpret_cast<XrInteractionProfileState*>(this);
  }

  //! Accessor for this as the address of a raw XrInteractionProfileState
  XrInteractionProfileState const* get() const noexcept {
    return reinterpret_cast<XrInteractionProfileState const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionProfileState.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionProfileState* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionProfileState{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionProfileState*>(this);
  }
  Path interactionProfile;
};
static_assert(sizeof(XrInteractionProfileState) == sizeof(InteractionProfileState),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionProfileState pointer to const from a
 * InteractionProfileState reference to const.
 * @relates InteractionProfileState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileState const* get(InteractionProfileState const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing InteractionProfileState as
 * the address of a raw XrInteractionProfileState
 * @relates InteractionProfileState
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileState* put(InteractionProfileState& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStateGetInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateGetInfo>
 * @xrentity{XrActionStateGetInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStateGetInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionStateGetInfo(const Action& action_, const Path& subactionPath_, const void* next_ = nullptr)
      : Parent(StructureType::ActionStateGetInfo, next_),
        action{action_},
        subactionPath{subactionPath_} {}

  //! Default/empty constructor
  ActionStateGetInfo(const void* next_ = nullptr)

      : Parent(StructureType::ActionStateGetInfo, next_), action{}, subactionPath{} {}

  //! Default copy constructor
  ActionStateGetInfo(const ActionStateGetInfo& rhs) = default;
  //! Default copy assignment
  ActionStateGetInfo& operator=(const ActionStateGetInfo& rhs) = default;
  //! Copy construct from raw
  ActionStateGetInfo(const XrActionStateGetInfo& rhs) : ActionStateGetInfo() { *put() = rhs; }
  //! Copy assign from raw
  ActionStateGetInfo& operator=(const XrActionStateGetInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStateGetInfo&() const {
    return *reinterpret_cast<const XrActionStateGetInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStateGetInfo&() { return *reinterpret_cast<XrActionStateGetInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionStateGetInfo
  XrActionStateGetInfo const* get() const noexcept {
    return reinterpret_cast<XrActionStateGetInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStateGetInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStateGetInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStateGetInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStateGetInfo*>(this);
  }
  Action action;
  Path subactionPath;
};
static_assert(sizeof(XrActionStateGetInfo) == sizeof(ActionStateGetInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStateGetInfo pointer to const from a
 * ActionStateGetInfo reference to const.
 * @relates ActionStateGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateGetInfo const* get(ActionStateGetInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateGetInfo as the
 * address of a raw XrActionStateGetInfo
 * @relates ActionStateGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateGetInfo* put(ActionStateGetInfo& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStateBoolean
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateBoolean>
 * @xrentity{XrActionStateBoolean}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStateBoolean : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ActionStateBoolean(void* next_ = nullptr)

      : Parent(StructureType::ActionStateBoolean, next_) {}

  //! Default copy constructor
  ActionStateBoolean(const ActionStateBoolean& rhs) = default;
  //! Default copy assignment
  ActionStateBoolean& operator=(const ActionStateBoolean& rhs) = default;
  //! Copy construct from raw
  ActionStateBoolean(const XrActionStateBoolean& rhs) : ActionStateBoolean() { *put() = rhs; }
  //! Copy assign from raw
  ActionStateBoolean& operator=(const XrActionStateBoolean& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStateBoolean&() const {
    return *reinterpret_cast<const XrActionStateBoolean*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStateBoolean&() { return *reinterpret_cast<XrActionStateBoolean*>(this); }

  //! Accessor for this as the address of a raw XrActionStateBoolean
  XrActionStateBoolean const* get() const noexcept {
    return reinterpret_cast<XrActionStateBoolean const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStateBoolean.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStateBoolean* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStateBoolean{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStateBoolean*>(this);
  }
  Bool32 currentState;
  Bool32 changedSinceLastSync;
  Time lastChangeTime;
  Bool32 isActive;
};
static_assert(sizeof(XrActionStateBoolean) == sizeof(ActionStateBoolean),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStateBoolean pointer to const from a
 * ActionStateBoolean reference to const.
 * @relates ActionStateBoolean
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateBoolean const* get(ActionStateBoolean const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateBoolean as the
 * address of a raw XrActionStateBoolean
 * @relates ActionStateBoolean
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateBoolean* put(ActionStateBoolean& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStateFloat
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateFloat>
 * @xrentity{XrActionStateFloat}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStateFloat : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ActionStateFloat(void* next_ = nullptr)

      : Parent(StructureType::ActionStateFloat, next_) {}

  //! Default copy constructor
  ActionStateFloat(const ActionStateFloat& rhs) = default;
  //! Default copy assignment
  ActionStateFloat& operator=(const ActionStateFloat& rhs) = default;
  //! Copy construct from raw
  ActionStateFloat(const XrActionStateFloat& rhs) : ActionStateFloat() { *put() = rhs; }
  //! Copy assign from raw
  ActionStateFloat& operator=(const XrActionStateFloat& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStateFloat&() const {
    return *reinterpret_cast<const XrActionStateFloat*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStateFloat&() { return *reinterpret_cast<XrActionStateFloat*>(this); }

  //! Accessor for this as the address of a raw XrActionStateFloat
  XrActionStateFloat const* get() const noexcept {
    return reinterpret_cast<XrActionStateFloat const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStateFloat.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStateFloat* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStateFloat{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStateFloat*>(this);
  }
  float currentState;
  Bool32 changedSinceLastSync;
  Time lastChangeTime;
  Bool32 isActive;
};
static_assert(sizeof(XrActionStateFloat) == sizeof(ActionStateFloat),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStateFloat pointer to const from a
 * ActionStateFloat reference to const.
 * @relates ActionStateFloat
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateFloat const* get(ActionStateFloat const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateFloat as the
 * address of a raw XrActionStateFloat
 * @relates ActionStateFloat
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateFloat* put(ActionStateFloat& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrVector2f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector2f>
 * @xrentity{XrVector2f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Vector2f {
public:
  //! Constructor initializing all members.
  Vector2f(float x_, float y_) : x{x_}, y{y_} {}

  //! Default/empty constructor
  Vector2f()

      : x{0.0f}, y{0.0f} {}

  //! Default copy constructor
  Vector2f(const Vector2f& rhs) = default;
  //! Default copy assignment
  Vector2f& operator=(const Vector2f& rhs) = default;
  //! Copy construct from raw
  Vector2f(const XrVector2f& rhs) : Vector2f() { *put() = rhs; }
  //! Copy assign from raw
  Vector2f& operator=(const XrVector2f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVector2f&() const { return *reinterpret_cast<const XrVector2f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVector2f&() { return *reinterpret_cast<XrVector2f*>(this); }

  //! Accessor for this as the address of a raw XrVector2f
  XrVector2f const* get() const noexcept { return reinterpret_cast<XrVector2f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVector2f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrVector2f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Vector2f{};
    }
    return reinterpret_cast<XrVector2f*>(this);
  }
  float x;
  float y;
};
static_assert(sizeof(XrVector2f) == sizeof(Vector2f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVector2f pointer to const from a Vector2f reference to
 * const.
 * @relates Vector2f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector2f const* get(Vector2f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector2f as the address of a
 * raw XrVector2f
 * @relates Vector2f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector2f* put(Vector2f& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStateVector2f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStateVector2f>
 * @xrentity{XrActionStateVector2f}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStateVector2f : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ActionStateVector2f(void* next_ = nullptr)

      : Parent(StructureType::ActionStateVector2F, next_) {}

  //! Default copy constructor
  ActionStateVector2f(const ActionStateVector2f& rhs) = default;
  //! Default copy assignment
  ActionStateVector2f& operator=(const ActionStateVector2f& rhs) = default;
  //! Copy construct from raw
  ActionStateVector2f(const XrActionStateVector2f& rhs) : ActionStateVector2f() { *put() = rhs; }
  //! Copy assign from raw
  ActionStateVector2f& operator=(const XrActionStateVector2f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStateVector2f&() const {
    return *reinterpret_cast<const XrActionStateVector2f*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStateVector2f&() { return *reinterpret_cast<XrActionStateVector2f*>(this); }

  //! Accessor for this as the address of a raw XrActionStateVector2f
  XrActionStateVector2f const* get() const noexcept {
    return reinterpret_cast<XrActionStateVector2f const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStateVector2f.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStateVector2f* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStateVector2f{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStateVector2f*>(this);
  }
  Vector2f currentState;
  Bool32 changedSinceLastSync;
  Time lastChangeTime;
  Bool32 isActive;
};
static_assert(sizeof(XrActionStateVector2f) == sizeof(ActionStateVector2f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStateVector2f pointer to const from a
 * ActionStateVector2f reference to const.
 * @relates ActionStateVector2f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateVector2f const* get(ActionStateVector2f const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStateVector2f as the
 * address of a raw XrActionStateVector2f
 * @relates ActionStateVector2f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStateVector2f* put(ActionStateVector2f& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionStatePose
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionStatePose>
 * @xrentity{XrActionStatePose}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionStatePose : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ActionStatePose(void* next_ = nullptr)

      : Parent(StructureType::ActionStatePose, next_) {}

  //! Default copy constructor
  ActionStatePose(const ActionStatePose& rhs) = default;
  //! Default copy assignment
  ActionStatePose& operator=(const ActionStatePose& rhs) = default;
  //! Copy construct from raw
  ActionStatePose(const XrActionStatePose& rhs) : ActionStatePose() { *put() = rhs; }
  //! Copy assign from raw
  ActionStatePose& operator=(const XrActionStatePose& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionStatePose&() const {
    return *reinterpret_cast<const XrActionStatePose*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionStatePose&() { return *reinterpret_cast<XrActionStatePose*>(this); }

  //! Accessor for this as the address of a raw XrActionStatePose
  XrActionStatePose const* get() const noexcept {
    return reinterpret_cast<XrActionStatePose const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionStatePose.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionStatePose* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionStatePose{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionStatePose*>(this);
  }
  Bool32 isActive;
};
static_assert(sizeof(XrActionStatePose) == sizeof(ActionStatePose),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionStatePose pointer to const from a ActionStatePose
 * reference to const.
 * @relates ActionStatePose
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStatePose const* get(ActionStatePose const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionStatePose as the
 * address of a raw XrActionStatePose
 * @relates ActionStatePose
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionStatePose* put(ActionStatePose& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActiveActionSet
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActiveActionSet>
 * @xrentity{XrActiveActionSet}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ActiveActionSet {
public:
  //! Constructor initializing all members.
  ActiveActionSet(const ActionSet& actionSet_, const Path& subactionPath_)
      : actionSet{actionSet_}, subactionPath{subactionPath_} {}

  //! Default/empty constructor
  ActiveActionSet()

      : actionSet{}, subactionPath{} {}

  //! Default copy constructor
  ActiveActionSet(const ActiveActionSet& rhs) = default;
  //! Default copy assignment
  ActiveActionSet& operator=(const ActiveActionSet& rhs) = default;
  //! Copy construct from raw
  ActiveActionSet(const XrActiveActionSet& rhs) : ActiveActionSet() { *put() = rhs; }
  //! Copy assign from raw
  ActiveActionSet& operator=(const XrActiveActionSet& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActiveActionSet&() const {
    return *reinterpret_cast<const XrActiveActionSet*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActiveActionSet&() { return *reinterpret_cast<XrActiveActionSet*>(this); }

  //! Accessor for this as the address of a raw XrActiveActionSet
  XrActiveActionSet const* get() const noexcept {
    return reinterpret_cast<XrActiveActionSet const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActiveActionSet.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrActiveActionSet* put(bool clear = true) noexcept {
    if (clear) {
      *this = ActiveActionSet{};
    }
    return reinterpret_cast<XrActiveActionSet*>(this);
  }
  ActionSet actionSet;
  Path subactionPath;
};
static_assert(sizeof(XrActiveActionSet) == sizeof(ActiveActionSet),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActiveActionSet pointer to const from a ActiveActionSet
 * reference to const.
 * @relates ActiveActionSet
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActiveActionSet const* get(ActiveActionSet const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActiveActionSet as the
 * address of a raw XrActiveActionSet
 * @relates ActiveActionSet
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActiveActionSet* put(ActiveActionSet& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrActionsSyncInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionsSyncInfo>
 * @xrentity{XrActionsSyncInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActionsSyncInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActionsSyncInfo(uint32_t countActiveActionSets_, const ActiveActionSet* activeActionSets_,
                  const void* next_ = nullptr)
      : Parent(StructureType::ActionsSyncInfo, next_),
        countActiveActionSets{countActiveActionSets_},
        activeActionSets{activeActionSets_} {}

  //! Default/empty constructor
  ActionsSyncInfo(const void* next_ = nullptr)

      : Parent(StructureType::ActionsSyncInfo, next_),
        countActiveActionSets{0},
        activeActionSets{nullptr} {}

  //! Default copy constructor
  ActionsSyncInfo(const ActionsSyncInfo& rhs) = default;
  //! Default copy assignment
  ActionsSyncInfo& operator=(const ActionsSyncInfo& rhs) = default;
  //! Copy construct from raw
  ActionsSyncInfo(const XrActionsSyncInfo& rhs) : ActionsSyncInfo() { *put() = rhs; }
  //! Copy assign from raw
  ActionsSyncInfo& operator=(const XrActionsSyncInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActionsSyncInfo&() const {
    return *reinterpret_cast<const XrActionsSyncInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActionsSyncInfo&() { return *reinterpret_cast<XrActionsSyncInfo*>(this); }

  //! Accessor for this as the address of a raw XrActionsSyncInfo
  XrActionsSyncInfo const* get() const noexcept {
    return reinterpret_cast<XrActionsSyncInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrActionsSyncInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActionsSyncInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActionsSyncInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrActionsSyncInfo*>(this);
  }
  uint32_t countActiveActionSets;
  const ActiveActionSet* activeActionSets;
};
static_assert(sizeof(XrActionsSyncInfo) == sizeof(ActionsSyncInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActionsSyncInfo pointer to const from a ActionsSyncInfo
 * reference to const.
 * @relates ActionsSyncInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionsSyncInfo const* get(ActionsSyncInfo const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ActionsSyncInfo as the
 * address of a raw XrActionsSyncInfo
 * @relates ActionsSyncInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActionsSyncInfo* put(ActionsSyncInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrBoundSourcesForActionEnumerateInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBoundSourcesForActionEnumerateInfo>
 * @xrentity{XrBoundSourcesForActionEnumerateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BoundSourcesForActionEnumerateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  BoundSourcesForActionEnumerateInfo(const Action& action_, const void* next_ = nullptr)
      : Parent(StructureType::BoundSourcesForActionEnumerateInfo, next_), action{action_} {}

  //! Default/empty constructor
  BoundSourcesForActionEnumerateInfo(const void* next_ = nullptr)

      : Parent(StructureType::BoundSourcesForActionEnumerateInfo, next_), action{} {}

  //! Default copy constructor
  BoundSourcesForActionEnumerateInfo(const BoundSourcesForActionEnumerateInfo& rhs) = default;
  //! Default copy assignment
  BoundSourcesForActionEnumerateInfo& operator=(const BoundSourcesForActionEnumerateInfo& rhs) =
      default;
  //! Copy construct from raw
  BoundSourcesForActionEnumerateInfo(const XrBoundSourcesForActionEnumerateInfo& rhs)
      : BoundSourcesForActionEnumerateInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BoundSourcesForActionEnumerateInfo& operator=(const XrBoundSourcesForActionEnumerateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBoundSourcesForActionEnumerateInfo&() const {
    return *reinterpret_cast<const XrBoundSourcesForActionEnumerateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBoundSourcesForActionEnumerateInfo&() {
    return *reinterpret_cast<XrBoundSourcesForActionEnumerateInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrBoundSourcesForActionEnumerateInfo
  XrBoundSourcesForActionEnumerateInfo const* get() const noexcept {
    return reinterpret_cast<XrBoundSourcesForActionEnumerateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrBoundSourcesForActionEnumerateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBoundSourcesForActionEnumerateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BoundSourcesForActionEnumerateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrBoundSourcesForActionEnumerateInfo*>(this);
  }
  Action action;
};
static_assert(sizeof(XrBoundSourcesForActionEnumerateInfo) ==
                  sizeof(BoundSourcesForActionEnumerateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBoundSourcesForActionEnumerateInfo pointer to const from
 * a BoundSourcesForActionEnumerateInfo reference to const.
 * @relates BoundSourcesForActionEnumerateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBoundSourcesForActionEnumerateInfo const* get(
    BoundSourcesForActionEnumerateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * BoundSourcesForActionEnumerateInfo as the address of a raw XrBoundSourcesForActionEnumerateInfo
 * @relates BoundSourcesForActionEnumerateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBoundSourcesForActionEnumerateInfo* put(
    BoundSourcesForActionEnumerateInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrInputSourceLocalizedNameGetInfo
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInputSourceLocalizedNameGetInfo>
 * @xrentity{XrInputSourceLocalizedNameGetInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InputSourceLocalizedNameGetInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InputSourceLocalizedNameGetInfo(const Path& sourcePath_,
                                  const InputSourceLocalizedNameFlags& whichComponents_,
                                  const void* next_ = nullptr)
      : Parent(StructureType::InputSourceLocalizedNameGetInfo, next_),
        sourcePath{sourcePath_},
        whichComponents{whichComponents_} {}

  //! Default/empty constructor
  InputSourceLocalizedNameGetInfo(const void* next_ = nullptr)

      : Parent(StructureType::InputSourceLocalizedNameGetInfo, next_),
        sourcePath{},
        whichComponents{} {}

  //! Default copy constructor
  InputSourceLocalizedNameGetInfo(const InputSourceLocalizedNameGetInfo& rhs) = default;
  //! Default copy assignment
  InputSourceLocalizedNameGetInfo& operator=(const InputSourceLocalizedNameGetInfo& rhs) = default;
  //! Copy construct from raw
  InputSourceLocalizedNameGetInfo(const XrInputSourceLocalizedNameGetInfo& rhs)
      : InputSourceLocalizedNameGetInfo() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InputSourceLocalizedNameGetInfo& operator=(const XrInputSourceLocalizedNameGetInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInputSourceLocalizedNameGetInfo&() const {
    return *reinterpret_cast<const XrInputSourceLocalizedNameGetInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInputSourceLocalizedNameGetInfo&() {
    return *reinterpret_cast<XrInputSourceLocalizedNameGetInfo*>(this);
  }

  //! Accessor for this as the address of a raw XrInputSourceLocalizedNameGetInfo
  XrInputSourceLocalizedNameGetInfo const* get() const noexcept {
    return reinterpret_cast<XrInputSourceLocalizedNameGetInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInputSourceLocalizedNameGetInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInputSourceLocalizedNameGetInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InputSourceLocalizedNameGetInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrInputSourceLocalizedNameGetInfo*>(this);
  }
  Path sourcePath;
  InputSourceLocalizedNameFlags whichComponents;
};
static_assert(sizeof(XrInputSourceLocalizedNameGetInfo) == sizeof(InputSourceLocalizedNameGetInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInputSourceLocalizedNameGetInfo pointer to const from a
 * InputSourceLocalizedNameGetInfo reference to const.
 * @relates InputSourceLocalizedNameGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInputSourceLocalizedNameGetInfo const* get(
    InputSourceLocalizedNameGetInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InputSourceLocalizedNameGetInfo as the address of a raw XrInputSourceLocalizedNameGetInfo
 * @relates InputSourceLocalizedNameGetInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInputSourceLocalizedNameGetInfo* put(InputSourceLocalizedNameGetInfo& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrHapticActionInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticActionInfo>
 * @xrentity{XrHapticActionInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HapticActionInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HapticActionInfo(const Action& action_, const Path& subactionPath_, const void* next_ = nullptr)
      : Parent(StructureType::HapticActionInfo, next_),
        action{action_},
        subactionPath{subactionPath_} {}

  //! Default/empty constructor
  HapticActionInfo(const void* next_ = nullptr)

      : Parent(StructureType::HapticActionInfo, next_), action{}, subactionPath{} {}

  //! Default copy constructor
  HapticActionInfo(const HapticActionInfo& rhs) = default;
  //! Default copy assignment
  HapticActionInfo& operator=(const HapticActionInfo& rhs) = default;
  //! Copy construct from raw
  HapticActionInfo(const XrHapticActionInfo& rhs) : HapticActionInfo() { *put() = rhs; }
  //! Copy assign from raw
  HapticActionInfo& operator=(const XrHapticActionInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHapticActionInfo&() const {
    return *reinterpret_cast<const XrHapticActionInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHapticActionInfo&() { return *reinterpret_cast<XrHapticActionInfo*>(this); }

  //! Accessor for this as the address of a raw XrHapticActionInfo
  XrHapticActionInfo const* get() const noexcept {
    return reinterpret_cast<XrHapticActionInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHapticActionInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHapticActionInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HapticActionInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrHapticActionInfo*>(this);
  }
  Action action;
  Path subactionPath;
};
static_assert(sizeof(XrHapticActionInfo) == sizeof(HapticActionInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHapticActionInfo pointer to const from a
 * HapticActionInfo reference to const.
 * @relates HapticActionInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticActionInfo const* get(HapticActionInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HapticActionInfo as the
 * address of a raw XrHapticActionInfo
 * @relates HapticActionInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticActionInfo* put(HapticActionInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrHapticBaseHeader
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticBaseHeader>
 * @xrentity{XrHapticBaseHeader}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS HapticBaseHeader : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  HapticBaseHeader(StructureType type_, const void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHapticBaseHeader&() const {
    return *reinterpret_cast<const XrHapticBaseHeader*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHapticBaseHeader&() { return *reinterpret_cast<XrHapticBaseHeader*>(this); }

  //! Accessor for this as the address of a raw XrHapticBaseHeader
  XrHapticBaseHeader const* get() const noexcept {
    return reinterpret_cast<XrHapticBaseHeader const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw XrHapticBaseHeader.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrHapticBaseHeader* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrHapticBaseHeader*>(this);
  }
};
static_assert(sizeof(XrHapticBaseHeader) == sizeof(HapticBaseHeader),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHapticBaseHeader pointer to const from a
 * HapticBaseHeader reference to const.
 * @relates HapticBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticBaseHeader const* get(HapticBaseHeader const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HapticBaseHeader as the
 * address of a raw XrHapticBaseHeader
 * @relates HapticBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticBaseHeader* put(HapticBaseHeader& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrOffset2Di
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrOffset2Di>
 * @xrentity{XrOffset2Di}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Offset2Di {
public:
  //! Constructor initializing all members.
  Offset2Di(int32_t x_, int32_t y_) : x{x_}, y{y_} {}

  //! Default/empty constructor
  Offset2Di()

      : x{0}, y{0} {}

  //! Default copy constructor
  Offset2Di(const Offset2Di& rhs) = default;
  //! Default copy assignment
  Offset2Di& operator=(const Offset2Di& rhs) = default;
  //! Copy construct from raw
  Offset2Di(const XrOffset2Di& rhs) : Offset2Di() { *put() = rhs; }
  //! Copy assign from raw
  Offset2Di& operator=(const XrOffset2Di& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrOffset2Di&() const { return *reinterpret_cast<const XrOffset2Di*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrOffset2Di&() { return *reinterpret_cast<XrOffset2Di*>(this); }

  //! Accessor for this as the address of a raw XrOffset2Di
  XrOffset2Di const* get() const noexcept { return reinterpret_cast<XrOffset2Di const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrOffset2Di.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrOffset2Di* put(bool clear = true) noexcept {
    if (clear) {
      *this = Offset2Di{};
    }
    return reinterpret_cast<XrOffset2Di*>(this);
  }
  int32_t x;
  int32_t y;
};
static_assert(sizeof(XrOffset2Di) == sizeof(Offset2Di),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrOffset2Di pointer to const from a Offset2Di reference to
 * const.
 * @relates Offset2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset2Di const* get(Offset2Di const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Offset2Di as the address of a
 * raw XrOffset2Di
 * @relates Offset2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset2Di* put(Offset2Di& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrExtent2Di
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtent2Di>
 * @xrentity{XrExtent2Di}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Extent2Di {
public:
  //! Constructor initializing all members.
  Extent2Di(int32_t width_, int32_t height_) : width{width_}, height{height_} {}

  //! Default/empty constructor
  Extent2Di()

      : width{0}, height{0} {}

  //! Default copy constructor
  Extent2Di(const Extent2Di& rhs) = default;
  //! Default copy assignment
  Extent2Di& operator=(const Extent2Di& rhs) = default;
  //! Copy construct from raw
  Extent2Di(const XrExtent2Di& rhs) : Extent2Di() { *put() = rhs; }
  //! Copy assign from raw
  Extent2Di& operator=(const XrExtent2Di& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExtent2Di&() const { return *reinterpret_cast<const XrExtent2Di*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExtent2Di&() { return *reinterpret_cast<XrExtent2Di*>(this); }

  //! Accessor for this as the address of a raw XrExtent2Di
  XrExtent2Di const* get() const noexcept { return reinterpret_cast<XrExtent2Di const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrExtent2Di.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrExtent2Di* put(bool clear = true) noexcept {
    if (clear) {
      *this = Extent2Di{};
    }
    return reinterpret_cast<XrExtent2Di*>(this);
  }
  int32_t width;
  int32_t height;
};
static_assert(sizeof(XrExtent2Di) == sizeof(Extent2Di),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExtent2Di pointer to const from a Extent2Di reference to
 * const.
 * @relates Extent2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent2Di const* get(Extent2Di const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Extent2Di as the address of a
 * raw XrExtent2Di
 * @relates Extent2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent2Di* put(Extent2Di& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrRect2Di
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRect2Di>
 * @xrentity{XrRect2Di}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Rect2Di {
public:
  //! Constructor initializing all members.
  Rect2Di(const Offset2Di& offset_, const Extent2Di& extent_) : offset{offset_}, extent{extent_} {}

  //! Default/empty constructor
  Rect2Di()

      : offset{}, extent{} {}

  //! Default copy constructor
  Rect2Di(const Rect2Di& rhs) = default;
  //! Default copy assignment
  Rect2Di& operator=(const Rect2Di& rhs) = default;
  //! Copy construct from raw
  Rect2Di(const XrRect2Di& rhs) : Rect2Di() { *put() = rhs; }
  //! Copy assign from raw
  Rect2Di& operator=(const XrRect2Di& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRect2Di&() const { return *reinterpret_cast<const XrRect2Di*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRect2Di&() { return *reinterpret_cast<XrRect2Di*>(this); }

  //! Accessor for this as the address of a raw XrRect2Di
  XrRect2Di const* get() const noexcept { return reinterpret_cast<XrRect2Di const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRect2Di.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrRect2Di* put(bool clear = true) noexcept {
    if (clear) {
      *this = Rect2Di{};
    }
    return reinterpret_cast<XrRect2Di*>(this);
  }
  Offset2Di offset;
  Extent2Di extent;
};
static_assert(sizeof(XrRect2Di) == sizeof(Rect2Di),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRect2Di pointer to const from a Rect2Di reference to
 * const.
 * @relates Rect2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect2Di const* get(Rect2Di const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Rect2Di as the address of a
 * raw XrRect2Di
 * @relates Rect2Di
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect2Di* put(Rect2Di& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSwapchainSubImage
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainSubImage>
 * @xrentity{XrSwapchainSubImage}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SwapchainSubImage {
public:
  //! Constructor initializing all members.
  SwapchainSubImage(const Swapchain& swapchain_, const Rect2Di& imageRect_,
                    uint32_t imageArrayIndex_)
      : swapchain{swapchain_}, imageRect{imageRect_}, imageArrayIndex{imageArrayIndex_} {}

  //! Default/empty constructor
  SwapchainSubImage()

      : swapchain{}, imageRect{}, imageArrayIndex{0} {}

  //! Default copy constructor
  SwapchainSubImage(const SwapchainSubImage& rhs) = default;
  //! Default copy assignment
  SwapchainSubImage& operator=(const SwapchainSubImage& rhs) = default;
  //! Copy construct from raw
  SwapchainSubImage(const XrSwapchainSubImage& rhs) : SwapchainSubImage() { *put() = rhs; }
  //! Copy assign from raw
  SwapchainSubImage& operator=(const XrSwapchainSubImage& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainSubImage&() const {
    return *reinterpret_cast<const XrSwapchainSubImage*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainSubImage&() { return *reinterpret_cast<XrSwapchainSubImage*>(this); }

  //! Accessor for this as the address of a raw XrSwapchainSubImage
  XrSwapchainSubImage const* get() const noexcept {
    return reinterpret_cast<XrSwapchainSubImage const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainSubImage.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSwapchainSubImage* put(bool clear = true) noexcept {
    if (clear) {
      *this = SwapchainSubImage{};
    }
    return reinterpret_cast<XrSwapchainSubImage*>(this);
  }
  Swapchain swapchain;
  Rect2Di imageRect;
  uint32_t imageArrayIndex;
};
static_assert(sizeof(XrSwapchainSubImage) == sizeof(SwapchainSubImage),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainSubImage pointer to const from a
 * SwapchainSubImage reference to const.
 * @relates SwapchainSubImage
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainSubImage const* get(SwapchainSubImage const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainSubImage as the
 * address of a raw XrSwapchainSubImage
 * @relates SwapchainSubImage
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainSubImage* put(SwapchainSubImage& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrCompositionLayerProjectionView
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerProjectionView>
 * @xrentity{XrCompositionLayerProjectionView}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerProjectionView : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerProjectionView(const Posef& pose_, const Fovf& fov_,
                                 const SwapchainSubImage& subImage_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerProjectionView, next_),
        pose{pose_},
        fov{fov_},
        subImage{subImage_} {}

  //! Default/empty constructor
  CompositionLayerProjectionView(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerProjectionView, next_), pose{}, fov{}, subImage{} {}

  //! Default copy constructor
  CompositionLayerProjectionView(const CompositionLayerProjectionView& rhs) = default;
  //! Default copy assignment
  CompositionLayerProjectionView& operator=(const CompositionLayerProjectionView& rhs) = default;
  //! Copy construct from raw
  CompositionLayerProjectionView(const XrCompositionLayerProjectionView& rhs)
      : CompositionLayerProjectionView() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerProjectionView& operator=(const XrCompositionLayerProjectionView& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerProjectionView&() const {
    return *reinterpret_cast<const XrCompositionLayerProjectionView*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerProjectionView&() {
    return *reinterpret_cast<XrCompositionLayerProjectionView*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerProjectionView
  XrCompositionLayerProjectionView const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerProjectionView const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerProjectionView.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerProjectionView* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerProjectionView{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerProjectionView*>(this);
  }
  Posef pose;
  Fovf fov;
  SwapchainSubImage subImage;
};
static_assert(sizeof(XrCompositionLayerProjectionView) == sizeof(CompositionLayerProjectionView),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerProjectionView pointer to const from a
 * CompositionLayerProjectionView reference to const.
 * @relates CompositionLayerProjectionView
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerProjectionView const* get(
    CompositionLayerProjectionView const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerProjectionView as the address of a raw XrCompositionLayerProjectionView
 * @relates CompositionLayerProjectionView
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerProjectionView* put(CompositionLayerProjectionView& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrCompositionLayerProjection
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerProjection>
 * @xrentity{XrCompositionLayerProjection}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerProjection : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerProjection(const CompositionLayerFlags& layerFlags_, const Space& space_,
                             uint32_t viewCount_, const CompositionLayerProjectionView* views_,
                             const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerProjection, layerFlags_, space_, next_),
        viewCount{viewCount_},
        views{views_} {}

  //! Default/empty constructor
  CompositionLayerProjection(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerProjection, {}, {}, next_),
        viewCount{0},
        views{nullptr} {}

  //! Default copy constructor
  CompositionLayerProjection(const CompositionLayerProjection& rhs) = default;
  //! Default copy assignment
  CompositionLayerProjection& operator=(const CompositionLayerProjection& rhs) = default;
  //! Copy construct from raw
  CompositionLayerProjection(const XrCompositionLayerProjection& rhs)
      : CompositionLayerProjection() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerProjection& operator=(const XrCompositionLayerProjection& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerProjection&() const {
    return *reinterpret_cast<const XrCompositionLayerProjection*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerProjection&() {
    return *reinterpret_cast<XrCompositionLayerProjection*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerProjection
  XrCompositionLayerProjection const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerProjection const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerProjection.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerProjection* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerProjection{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerProjection*>(this);
  }
  uint32_t viewCount;
  const CompositionLayerProjectionView* views;
};
static_assert(sizeof(XrCompositionLayerProjection) == sizeof(CompositionLayerProjection),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerProjection pointer to const from a
 * CompositionLayerProjection reference to const.
 * @relates CompositionLayerProjection
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerProjection const* get(
    CompositionLayerProjection const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerProjection as
 * the address of a raw XrCompositionLayerProjection
 * @relates CompositionLayerProjection
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerProjection* put(CompositionLayerProjection& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerProjection as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerProjection
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerProjection const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrCompositionLayerQuad
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerQuad>
 * @xrentity{XrCompositionLayerQuad}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerQuad : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerQuad(const CompositionLayerFlags& layerFlags_, const Space& space_,
                       const EyeVisibility& eyeVisibility_, const SwapchainSubImage& subImage_,
                       const Posef& pose_, const Extent2Df& size_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerQuad, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        subImage{subImage_},
        pose{pose_},
        size{size_} {}

  //! Default/empty constructor
  CompositionLayerQuad(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerQuad, {}, {}, next_),
        eyeVisibility{},
        subImage{},
        pose{},
        size{} {}

  //! Default copy constructor
  CompositionLayerQuad(const CompositionLayerQuad& rhs) = default;
  //! Default copy assignment
  CompositionLayerQuad& operator=(const CompositionLayerQuad& rhs) = default;
  //! Copy construct from raw
  CompositionLayerQuad(const XrCompositionLayerQuad& rhs) : CompositionLayerQuad() { *put() = rhs; }
  //! Copy assign from raw
  CompositionLayerQuad& operator=(const XrCompositionLayerQuad& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerQuad&() const {
    return *reinterpret_cast<const XrCompositionLayerQuad*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerQuad&() { return *reinterpret_cast<XrCompositionLayerQuad*>(this); }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerQuad
  XrCompositionLayerQuad const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerQuad const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrCompositionLayerQuad.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerQuad* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerQuad{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerQuad*>(this);
  }
  EyeVisibility eyeVisibility;
  SwapchainSubImage subImage;
  Posef pose;
  Extent2Df size;
};
static_assert(sizeof(XrCompositionLayerQuad) == sizeof(CompositionLayerQuad),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerQuad pointer to const from a
 * CompositionLayerQuad reference to const.
 * @relates CompositionLayerQuad
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerQuad const* get(CompositionLayerQuad const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerQuad as the
 * address of a raw XrCompositionLayerQuad
 * @relates CompositionLayerQuad
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerQuad* put(CompositionLayerQuad& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerQuad as a raw, pointer to
 * const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerQuad
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerQuad const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataBaseHeader
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataBaseHeader>
 * @xrentity{XrEventDataBaseHeader}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS EventDataBaseHeader : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  EventDataBaseHeader(StructureType type_, void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataBaseHeader&() const {
    return *reinterpret_cast<const XrEventDataBaseHeader*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataBaseHeader&() { return *reinterpret_cast<XrEventDataBaseHeader*>(this); }

  //! Accessor for this as the address of a raw XrEventDataBaseHeader
  XrEventDataBaseHeader const* get() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw XrEventDataBaseHeader.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrEventDataBaseHeader* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrEventDataBaseHeader*>(this);
  }
};
static_assert(sizeof(XrEventDataBaseHeader) == sizeof(EventDataBaseHeader),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataBaseHeader pointer to const from a
 * EventDataBaseHeader reference to const.
 * @relates EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get(EventDataBaseHeader const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataBaseHeader as the
 * address of a raw XrEventDataBaseHeader
 * @relates EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader* put(EventDataBaseHeader& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrEventDataEventsLost
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataEventsLost>
 * @xrentity{XrEventDataEventsLost}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataEventsLost : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataEventsLost(void* next_ = nullptr)

      : Parent(StructureType::EventDataEventsLost, next_) {}

  //! Default copy constructor
  EventDataEventsLost(const EventDataEventsLost& rhs) = default;
  //! Default copy assignment
  EventDataEventsLost& operator=(const EventDataEventsLost& rhs) = default;
  //! Copy construct from raw
  EventDataEventsLost(const XrEventDataEventsLost& rhs) : EventDataEventsLost() { *put() = rhs; }
  //! Copy assign from raw
  EventDataEventsLost& operator=(const XrEventDataEventsLost& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataEventsLost&() const {
    return *reinterpret_cast<const XrEventDataEventsLost*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataEventsLost&() { return *reinterpret_cast<XrEventDataEventsLost*>(this); }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataEventsLost
  XrEventDataEventsLost const* get() const noexcept {
    return reinterpret_cast<XrEventDataEventsLost const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrEventDataEventsLost.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataEventsLost* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataEventsLost{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataEventsLost*>(this);
  }
  uint32_t lostEventCount;
};
static_assert(sizeof(XrEventDataEventsLost) == sizeof(EventDataEventsLost),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataEventsLost pointer to const from a
 * EventDataEventsLost reference to const.
 * @relates EventDataEventsLost
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataEventsLost const* get(EventDataEventsLost const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataEventsLost as the
 * address of a raw XrEventDataEventsLost
 * @relates EventDataEventsLost
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataEventsLost* put(EventDataEventsLost& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataEventsLost as a raw, pointer to
 * const XrEventDataBaseHeader (the base type)
 * @relates EventDataEventsLost
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataEventsLost const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataInstanceLossPending
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataInstanceLossPending>
 * @xrentity{XrEventDataInstanceLossPending}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataInstanceLossPending : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataInstanceLossPending(void* next_ = nullptr)

      : Parent(StructureType::EventDataInstanceLossPending, next_) {}

  //! Default copy constructor
  EventDataInstanceLossPending(const EventDataInstanceLossPending& rhs) = default;
  //! Default copy assignment
  EventDataInstanceLossPending& operator=(const EventDataInstanceLossPending& rhs) = default;
  //! Copy construct from raw
  EventDataInstanceLossPending(const XrEventDataInstanceLossPending& rhs)
      : EventDataInstanceLossPending() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataInstanceLossPending& operator=(const XrEventDataInstanceLossPending& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataInstanceLossPending&() const {
    return *reinterpret_cast<const XrEventDataInstanceLossPending*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataInstanceLossPending&() {
    return *reinterpret_cast<XrEventDataInstanceLossPending*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataInstanceLossPending
  XrEventDataInstanceLossPending const* get() const noexcept {
    return reinterpret_cast<XrEventDataInstanceLossPending const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataInstanceLossPending.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataInstanceLossPending* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataInstanceLossPending{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataInstanceLossPending*>(this);
  }
  Time lossTime;
};
static_assert(sizeof(XrEventDataInstanceLossPending) == sizeof(EventDataInstanceLossPending),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataInstanceLossPending pointer to const from a
 * EventDataInstanceLossPending reference to const.
 * @relates EventDataInstanceLossPending
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInstanceLossPending const* get(
    EventDataInstanceLossPending const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataInstanceLossPending
 * as the address of a raw XrEventDataInstanceLossPending
 * @relates EventDataInstanceLossPending
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInstanceLossPending* put(EventDataInstanceLossPending& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataInstanceLossPending as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataInstanceLossPending
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataInstanceLossPending const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataSessionStateChanged
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSessionStateChanged>
 * @xrentity{XrEventDataSessionStateChanged}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSessionStateChanged : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSessionStateChanged(void* next_ = nullptr)

      : Parent(StructureType::EventDataSessionStateChanged, next_) {}

  //! Default copy constructor
  EventDataSessionStateChanged(const EventDataSessionStateChanged& rhs) = default;
  //! Default copy assignment
  EventDataSessionStateChanged& operator=(const EventDataSessionStateChanged& rhs) = default;
  //! Copy construct from raw
  EventDataSessionStateChanged(const XrEventDataSessionStateChanged& rhs)
      : EventDataSessionStateChanged() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSessionStateChanged& operator=(const XrEventDataSessionStateChanged& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSessionStateChanged&() const {
    return *reinterpret_cast<const XrEventDataSessionStateChanged*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSessionStateChanged&() {
    return *reinterpret_cast<XrEventDataSessionStateChanged*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSessionStateChanged
  XrEventDataSessionStateChanged const* get() const noexcept {
    return reinterpret_cast<XrEventDataSessionStateChanged const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSessionStateChanged.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSessionStateChanged* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSessionStateChanged{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSessionStateChanged*>(this);
  }
  Session session;
  SessionState state;
  Time time;
};
static_assert(sizeof(XrEventDataSessionStateChanged) == sizeof(EventDataSessionStateChanged),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSessionStateChanged pointer to const from a
 * EventDataSessionStateChanged reference to const.
 * @relates EventDataSessionStateChanged
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSessionStateChanged const* get(
    EventDataSessionStateChanged const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSessionStateChanged
 * as the address of a raw XrEventDataSessionStateChanged
 * @relates EventDataSessionStateChanged
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSessionStateChanged* put(EventDataSessionStateChanged& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSessionStateChanged as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSessionStateChanged
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSessionStateChanged const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataReferenceSpaceChangePending
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataReferenceSpaceChangePending>
 * @xrentity{XrEventDataReferenceSpaceChangePending}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataReferenceSpaceChangePending : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataReferenceSpaceChangePending(void* next_ = nullptr)

      : Parent(StructureType::EventDataReferenceSpaceChangePending, next_) {}

  //! Default copy constructor
  EventDataReferenceSpaceChangePending(const EventDataReferenceSpaceChangePending& rhs) = default;
  //! Default copy assignment
  EventDataReferenceSpaceChangePending& operator=(const EventDataReferenceSpaceChangePending& rhs) =
      default;
  //! Copy construct from raw
  EventDataReferenceSpaceChangePending(const XrEventDataReferenceSpaceChangePending& rhs)
      : EventDataReferenceSpaceChangePending() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataReferenceSpaceChangePending& operator=(
      const XrEventDataReferenceSpaceChangePending& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataReferenceSpaceChangePending&() const {
    return *reinterpret_cast<const XrEventDataReferenceSpaceChangePending*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataReferenceSpaceChangePending&() {
    return *reinterpret_cast<XrEventDataReferenceSpaceChangePending*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataReferenceSpaceChangePending
  XrEventDataReferenceSpaceChangePending const* get() const noexcept {
    return reinterpret_cast<XrEventDataReferenceSpaceChangePending const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataReferenceSpaceChangePending.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataReferenceSpaceChangePending* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataReferenceSpaceChangePending{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataReferenceSpaceChangePending*>(this);
  }
  Session session;
  ReferenceSpaceType referenceSpaceType;
  Time changeTime;
  Bool32 poseValid;
  Posef poseInPreviousSpace;
};
static_assert(sizeof(XrEventDataReferenceSpaceChangePending) ==
                  sizeof(EventDataReferenceSpaceChangePending),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataReferenceSpaceChangePending pointer to const
 * from a EventDataReferenceSpaceChangePending reference to const.
 * @relates EventDataReferenceSpaceChangePending
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataReferenceSpaceChangePending const* get(
    EventDataReferenceSpaceChangePending const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataReferenceSpaceChangePending as the address of a raw
 * XrEventDataReferenceSpaceChangePending
 * @relates EventDataReferenceSpaceChangePending
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataReferenceSpaceChangePending* put(
    EventDataReferenceSpaceChangePending& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataReferenceSpaceChangePending as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataReferenceSpaceChangePending
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataReferenceSpaceChangePending const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrEventDataInteractionProfileChanged
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataInteractionProfileChanged>
 * @xrentity{XrEventDataInteractionProfileChanged}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataInteractionProfileChanged : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataInteractionProfileChanged(void* next_ = nullptr)

      : Parent(StructureType::EventDataInteractionProfileChanged, next_) {}

  //! Default copy constructor
  EventDataInteractionProfileChanged(const EventDataInteractionProfileChanged& rhs) = default;
  //! Default copy assignment
  EventDataInteractionProfileChanged& operator=(const EventDataInteractionProfileChanged& rhs) =
      default;
  //! Copy construct from raw
  EventDataInteractionProfileChanged(const XrEventDataInteractionProfileChanged& rhs)
      : EventDataInteractionProfileChanged() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataInteractionProfileChanged& operator=(const XrEventDataInteractionProfileChanged& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataInteractionProfileChanged&() const {
    return *reinterpret_cast<const XrEventDataInteractionProfileChanged*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataInteractionProfileChanged&() {
    return *reinterpret_cast<XrEventDataInteractionProfileChanged*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataInteractionProfileChanged
  XrEventDataInteractionProfileChanged const* get() const noexcept {
    return reinterpret_cast<XrEventDataInteractionProfileChanged const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataInteractionProfileChanged.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataInteractionProfileChanged* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataInteractionProfileChanged{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataInteractionProfileChanged*>(this);
  }
  Session session;
};
static_assert(sizeof(XrEventDataInteractionProfileChanged) ==
                  sizeof(EventDataInteractionProfileChanged),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataInteractionProfileChanged pointer to const from
 * a EventDataInteractionProfileChanged reference to const.
 * @relates EventDataInteractionProfileChanged
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInteractionProfileChanged const* get(
    EventDataInteractionProfileChanged const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataInteractionProfileChanged as the address of a raw XrEventDataInteractionProfileChanged
 * @relates EventDataInteractionProfileChanged
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInteractionProfileChanged* put(
    EventDataInteractionProfileChanged& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataInteractionProfileChanged as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataInteractionProfileChanged
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataInteractionProfileChanged const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrHapticVibration
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticVibration>
 * @xrentity{XrHapticVibration}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HapticVibration : public HapticBaseHeader {
private:
  using Parent = HapticBaseHeader;

public:
  //! Constructor initializing all members.
  HapticVibration(const Duration& duration_, float frequency_, float amplitude_,
                  const void* next_ = nullptr)
      : Parent(StructureType::HapticVibration, next_),
        duration{duration_},
        frequency{frequency_},
        amplitude{amplitude_} {}

  //! Default/empty constructor
  HapticVibration(const void* next_ = nullptr)

      : Parent(StructureType::HapticVibration, next_),
        duration{},
        frequency{0.0f},
        amplitude{0.0f} {}

  //! Default copy constructor
  HapticVibration(const HapticVibration& rhs) = default;
  //! Default copy assignment
  HapticVibration& operator=(const HapticVibration& rhs) = default;
  //! Copy construct from raw
  HapticVibration(const XrHapticVibration& rhs) : HapticVibration() { *put() = rhs; }
  //! Copy assign from raw
  HapticVibration& operator=(const XrHapticVibration& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHapticVibration&() const {
    return *reinterpret_cast<const XrHapticVibration*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHapticVibration&() { return *reinterpret_cast<XrHapticVibration*>(this); }

  //! Accessor for this as a raw, base XrHapticBaseHeader const pointer
  XrHapticBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrHapticBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrHapticVibration
  XrHapticVibration const* get() const noexcept {
    return reinterpret_cast<XrHapticVibration const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHapticVibration.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHapticVibration* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HapticVibration{};
      next = oldNext;
    }
    return reinterpret_cast<XrHapticVibration*>(this);
  }
  Duration duration;
  float frequency;
  float amplitude;
};
static_assert(sizeof(XrHapticVibration) == sizeof(HapticVibration),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHapticVibration pointer to const from a HapticVibration
 * reference to const.
 * @relates HapticVibration
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticVibration const* get(HapticVibration const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing HapticVibration as the
 * address of a raw XrHapticVibration
 * @relates HapticVibration
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticVibration* put(HapticVibration& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const HapticVibration as a raw, pointer to const
 * XrHapticBaseHeader (the base type)
 * @relates HapticVibration
 * @relatesalso HapticBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticBaseHeader const* get_base(HapticVibration const& h) {
  return h.get_base();
}

/*!
 * C++ projection of XrOffset2Df
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrOffset2Df>
 * @xrentity{XrOffset2Df}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Offset2Df {
public:
  //! Constructor initializing all members.
  Offset2Df(float x_, float y_) : x{x_}, y{y_} {}

  //! Default/empty constructor
  Offset2Df()

      : x{0.0f}, y{0.0f} {}

  //! Default copy constructor
  Offset2Df(const Offset2Df& rhs) = default;
  //! Default copy assignment
  Offset2Df& operator=(const Offset2Df& rhs) = default;
  //! Copy construct from raw
  Offset2Df(const XrOffset2Df& rhs) : Offset2Df() { *put() = rhs; }
  //! Copy assign from raw
  Offset2Df& operator=(const XrOffset2Df& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrOffset2Df&() const { return *reinterpret_cast<const XrOffset2Df*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrOffset2Df&() { return *reinterpret_cast<XrOffset2Df*>(this); }

  //! Accessor for this as the address of a raw XrOffset2Df
  XrOffset2Df const* get() const noexcept { return reinterpret_cast<XrOffset2Df const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrOffset2Df.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrOffset2Df* put(bool clear = true) noexcept {
    if (clear) {
      *this = Offset2Df{};
    }
    return reinterpret_cast<XrOffset2Df*>(this);
  }
  float x;
  float y;
};
static_assert(sizeof(XrOffset2Df) == sizeof(Offset2Df),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrOffset2Df pointer to const from a Offset2Df reference to
 * const.
 * @relates Offset2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset2Df const* get(Offset2Df const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Offset2Df as the address of a
 * raw XrOffset2Df
 * @relates Offset2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset2Df* put(Offset2Df& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrRect2Df
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRect2Df>
 * @xrentity{XrRect2Df}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Rect2Df {
public:
  //! Constructor initializing all members.
  Rect2Df(const Offset2Df& offset_, const Extent2Df& extent_) : offset{offset_}, extent{extent_} {}

  //! Default/empty constructor
  Rect2Df()

      : offset{}, extent{} {}

  //! Default copy constructor
  Rect2Df(const Rect2Df& rhs) = default;
  //! Default copy assignment
  Rect2Df& operator=(const Rect2Df& rhs) = default;
  //! Copy construct from raw
  Rect2Df(const XrRect2Df& rhs) : Rect2Df() { *put() = rhs; }
  //! Copy assign from raw
  Rect2Df& operator=(const XrRect2Df& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRect2Df&() const { return *reinterpret_cast<const XrRect2Df*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRect2Df&() { return *reinterpret_cast<XrRect2Df*>(this); }

  //! Accessor for this as the address of a raw XrRect2Df
  XrRect2Df const* get() const noexcept { return reinterpret_cast<XrRect2Df const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRect2Df.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrRect2Df* put(bool clear = true) noexcept {
    if (clear) {
      *this = Rect2Df{};
    }
    return reinterpret_cast<XrRect2Df*>(this);
  }
  Offset2Df offset;
  Extent2Df extent;
};
static_assert(sizeof(XrRect2Df) == sizeof(Rect2Df),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRect2Df pointer to const from a Rect2Df reference to
 * const.
 * @relates Rect2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect2Df const* get(Rect2Df const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Rect2Df as the address of a
 * raw XrRect2Df
 * @relates Rect2Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect2Df* put(Rect2Df& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrVector4f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector4f>
 * @xrentity{XrVector4f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Vector4f {
public:
  //! Constructor initializing all members.
  Vector4f(float x_, float y_, float z_, float w_) : x{x_}, y{y_}, z{z_}, w{w_} {}

  //! Default/empty constructor
  Vector4f()

      : x{0.0f}, y{0.0f}, z{0.0f}, w{0.0f} {}

  //! Default copy constructor
  Vector4f(const Vector4f& rhs) = default;
  //! Default copy assignment
  Vector4f& operator=(const Vector4f& rhs) = default;
  //! Copy construct from raw
  Vector4f(const XrVector4f& rhs) : Vector4f() { *put() = rhs; }
  //! Copy assign from raw
  Vector4f& operator=(const XrVector4f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVector4f&() const { return *reinterpret_cast<const XrVector4f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVector4f&() { return *reinterpret_cast<XrVector4f*>(this); }

  //! Accessor for this as the address of a raw XrVector4f
  XrVector4f const* get() const noexcept { return reinterpret_cast<XrVector4f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVector4f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrVector4f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Vector4f{};
    }
    return reinterpret_cast<XrVector4f*>(this);
  }
  float x;
  float y;
  float z;
  float w;
};
static_assert(sizeof(XrVector4f) == sizeof(Vector4f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVector4f pointer to const from a Vector4f reference to
 * const.
 * @relates Vector4f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector4f const* get(Vector4f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector4f as the address of a
 * raw XrVector4f
 * @relates Vector4f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector4f* put(Vector4f& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrColor4f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrColor4f>
 * @xrentity{XrColor4f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Color4f {
public:
  //! Constructor initializing all members.
  Color4f(float r_, float g_, float b_, float a_) : r{r_}, g{g_}, b{b_}, a{a_} {}

  //! Default/empty constructor
  Color4f()

      : r{0.0f}, g{0.0f}, b{0.0f}, a{0.0f} {}

  //! Default copy constructor
  Color4f(const Color4f& rhs) = default;
  //! Default copy assignment
  Color4f& operator=(const Color4f& rhs) = default;
  //! Copy construct from raw
  Color4f(const XrColor4f& rhs) : Color4f() { *put() = rhs; }
  //! Copy assign from raw
  Color4f& operator=(const XrColor4f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrColor4f&() const { return *reinterpret_cast<const XrColor4f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrColor4f&() { return *reinterpret_cast<XrColor4f*>(this); }

  //! Accessor for this as the address of a raw XrColor4f
  XrColor4f const* get() const noexcept { return reinterpret_cast<XrColor4f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrColor4f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrColor4f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Color4f{};
    }
    return reinterpret_cast<XrColor4f*>(this);
  }
  float r;
  float g;
  float b;
  float a;
};
static_assert(sizeof(XrColor4f) == sizeof(Color4f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrColor4f pointer to const from a Color4f reference to
 * const.
 * @relates Color4f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColor4f const* get(Color4f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Color4f as the address of a
 * raw XrColor4f
 * @relates Color4f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColor4f* put(Color4f& s, bool clear = true) noexcept {
  return s.put(clear);
}

#ifdef XR_LOADER_VERSION_1_0
/*!
 * C++ projection of XrApiLayerNextInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrApiLayerNextInfo>
 * @xrentity{XrApiLayerNextInfo}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ApiLayerNextInfo {
public:
  //! Constructor initializing all members.
  ApiLayerNextInfo(const LoaderInterfaceStructs& structType_, uint32_t structVersion_,
                   size_t structSize_, const char* layerName_,
                   PFN_xrGetInstanceProcAddr nextGetInstanceProcAddr_,
                   PFN_xrCreateApiLayerInstance nextCreateApiLayerInstance_,
                   struct XrApiLayerNextInfo* next_)
      : structType{structType_},
        structVersion{structVersion_},
        structSize{structSize_},
        nextGetInstanceProcAddr{nextGetInstanceProcAddr_},
        nextCreateApiLayerInstance{nextCreateApiLayerInstance_},
        next{next_} {
    if (nullptr != layerName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(layerName, XR_MAX_API_LAYER_NAME_SIZE, layerName_, XR_MAX_API_LAYER_NAME_SIZE);
#else
      strncpy(layerName, layerName_, XR_MAX_API_LAYER_NAME_SIZE - 1);
      layerName[XR_MAX_API_LAYER_NAME_SIZE - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  ApiLayerNextInfo()

      : structType{},
        structVersion{0},
        structSize{},
        nextGetInstanceProcAddr{nullptr},
        nextCreateApiLayerInstance{nullptr},
        next{nullptr} {}

  //! Default copy constructor
  ApiLayerNextInfo(const ApiLayerNextInfo& rhs) = default;
  //! Default copy assignment
  ApiLayerNextInfo& operator=(const ApiLayerNextInfo& rhs) = default;
  //! Copy construct from raw
  ApiLayerNextInfo(const XrApiLayerNextInfo& rhs) : ApiLayerNextInfo() { *put() = rhs; }
  //! Copy assign from raw
  ApiLayerNextInfo& operator=(const XrApiLayerNextInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrApiLayerNextInfo&() const {
    return *reinterpret_cast<const XrApiLayerNextInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrApiLayerNextInfo&() { return *reinterpret_cast<XrApiLayerNextInfo*>(this); }

  //! Accessor for this as the address of a raw XrApiLayerNextInfo
  XrApiLayerNextInfo const* get() const noexcept {
    return reinterpret_cast<XrApiLayerNextInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrApiLayerNextInfo.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrApiLayerNextInfo* put(bool clear = true) noexcept {
    if (clear) {
      *this = ApiLayerNextInfo{};
    }
    return reinterpret_cast<XrApiLayerNextInfo*>(this);
  }
  LoaderInterfaceStructs structType;
  uint32_t structVersion;
  size_t structSize;
  char layerName[XR_MAX_API_LAYER_NAME_SIZE];
  PFN_xrGetInstanceProcAddr nextGetInstanceProcAddr;
  PFN_xrCreateApiLayerInstance nextCreateApiLayerInstance;
  struct XrApiLayerNextInfo* next;
};
static_assert(sizeof(XrApiLayerNextInfo) == sizeof(ApiLayerNextInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrApiLayerNextInfo pointer to const from a
 * ApiLayerNextInfo reference to const.
 * @relates ApiLayerNextInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApiLayerNextInfo const* get(ApiLayerNextInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ApiLayerNextInfo as the
 * address of a raw XrApiLayerNextInfo
 * @relates ApiLayerNextInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApiLayerNextInfo* put(ApiLayerNextInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_LOADER_VERSION_1_0

#ifdef XR_LOADER_VERSION_1_0
/*!
 * C++ projection of XrApiLayerCreateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrApiLayerCreateInfo>
 * @xrentity{XrApiLayerCreateInfo}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ApiLayerCreateInfo {
public:
  //! Constructor initializing all members.
  ApiLayerCreateInfo(const LoaderInterfaceStructs& structType_, uint32_t structVersion_,
                     size_t structSize_, void* XR_MAY_ALIAS loaderInstance_,
                     const char* settings_file_location_, ApiLayerNextInfo* nextInfo_)
      : structType{structType_},
        structVersion{structVersion_},
        structSize{structSize_},
        loaderInstance{loaderInstance_},
        nextInfo{nextInfo_} {
    if (nullptr != settings_file_location_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(settings_file_location, XR_API_LAYER_MAX_SETTINGS_PATH_SIZE,
                settings_file_location_, XR_API_LAYER_MAX_SETTINGS_PATH_SIZE);
#else
      strncpy(settings_file_location, settings_file_location_,
              XR_API_LAYER_MAX_SETTINGS_PATH_SIZE - 1);
      settings_file_location[XR_API_LAYER_MAX_SETTINGS_PATH_SIZE - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  ApiLayerCreateInfo()

      : structType{}, structVersion{0}, structSize{}, loaderInstance{nullptr}, nextInfo{nullptr} {}

  //! Default copy constructor
  ApiLayerCreateInfo(const ApiLayerCreateInfo& rhs) = default;
  //! Default copy assignment
  ApiLayerCreateInfo& operator=(const ApiLayerCreateInfo& rhs) = default;
  //! Copy construct from raw
  ApiLayerCreateInfo(const XrApiLayerCreateInfo& rhs) : ApiLayerCreateInfo() { *put() = rhs; }
  //! Copy assign from raw
  ApiLayerCreateInfo& operator=(const XrApiLayerCreateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrApiLayerCreateInfo&() const {
    return *reinterpret_cast<const XrApiLayerCreateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrApiLayerCreateInfo&() { return *reinterpret_cast<XrApiLayerCreateInfo*>(this); }

  //! Accessor for this as the address of a raw XrApiLayerCreateInfo
  XrApiLayerCreateInfo const* get() const noexcept {
    return reinterpret_cast<XrApiLayerCreateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrApiLayerCreateInfo.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrApiLayerCreateInfo* put(bool clear = true) noexcept {
    if (clear) {
      *this = ApiLayerCreateInfo{};
    }
    return reinterpret_cast<XrApiLayerCreateInfo*>(this);
  }
  LoaderInterfaceStructs structType;
  uint32_t structVersion;
  size_t structSize;
  void* XR_MAY_ALIAS loaderInstance;
  char settings_file_location[XR_API_LAYER_MAX_SETTINGS_PATH_SIZE];
  ApiLayerNextInfo* nextInfo;
};
static_assert(sizeof(XrApiLayerCreateInfo) == sizeof(ApiLayerCreateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrApiLayerCreateInfo pointer to const from a
 * ApiLayerCreateInfo reference to const.
 * @relates ApiLayerCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApiLayerCreateInfo const* get(ApiLayerCreateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ApiLayerCreateInfo as the
 * address of a raw XrApiLayerCreateInfo
 * @relates ApiLayerCreateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrApiLayerCreateInfo* put(ApiLayerCreateInfo& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_LOADER_VERSION_1_0

#ifdef XR_LOADER_VERSION_1_0
/*!
 * C++ projection of XrNegotiateLoaderInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrNegotiateLoaderInfo>
 * @xrentity{XrNegotiateLoaderInfo}
 * @ingroup structs
 */
struct XR_MAY_ALIAS NegotiateLoaderInfo {
public:
  //! Constructor initializing all members.
  NegotiateLoaderInfo(const LoaderInterfaceStructs& structType_, uint32_t structVersion_,
                      size_t structSize_, uint32_t minInterfaceVersion_,
                      uint32_t maxInterfaceVersion_, const Version& minApiVersion_,
                      const Version& maxApiVersion_)
      : structType{structType_},
        structVersion{structVersion_},
        structSize{structSize_},
        minInterfaceVersion{minInterfaceVersion_},
        maxInterfaceVersion{maxInterfaceVersion_},
        minApiVersion{minApiVersion_},
        maxApiVersion{maxApiVersion_} {}

  //! Default/empty constructor
  NegotiateLoaderInfo()

      : structType{},
        structVersion{0},
        structSize{},
        minInterfaceVersion{0},
        maxInterfaceVersion{0},
        minApiVersion{},
        maxApiVersion{} {}

  //! Default copy constructor
  NegotiateLoaderInfo(const NegotiateLoaderInfo& rhs) = default;
  //! Default copy assignment
  NegotiateLoaderInfo& operator=(const NegotiateLoaderInfo& rhs) = default;
  //! Copy construct from raw
  NegotiateLoaderInfo(const XrNegotiateLoaderInfo& rhs) : NegotiateLoaderInfo() { *put() = rhs; }
  //! Copy assign from raw
  NegotiateLoaderInfo& operator=(const XrNegotiateLoaderInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrNegotiateLoaderInfo&() const {
    return *reinterpret_cast<const XrNegotiateLoaderInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrNegotiateLoaderInfo&() { return *reinterpret_cast<XrNegotiateLoaderInfo*>(this); }

  //! Accessor for this as the address of a raw XrNegotiateLoaderInfo
  XrNegotiateLoaderInfo const* get() const noexcept {
    return reinterpret_cast<XrNegotiateLoaderInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrNegotiateLoaderInfo.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrNegotiateLoaderInfo* put(bool clear = true) noexcept {
    if (clear) {
      *this = NegotiateLoaderInfo{};
    }
    return reinterpret_cast<XrNegotiateLoaderInfo*>(this);
  }
  LoaderInterfaceStructs structType;
  uint32_t structVersion;
  size_t structSize;
  uint32_t minInterfaceVersion;
  uint32_t maxInterfaceVersion;
  Version minApiVersion;
  Version maxApiVersion;
};
static_assert(sizeof(XrNegotiateLoaderInfo) == sizeof(NegotiateLoaderInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrNegotiateLoaderInfo pointer to const from a
 * NegotiateLoaderInfo reference to const.
 * @relates NegotiateLoaderInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrNegotiateLoaderInfo const* get(NegotiateLoaderInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing NegotiateLoaderInfo as the
 * address of a raw XrNegotiateLoaderInfo
 * @relates NegotiateLoaderInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrNegotiateLoaderInfo* put(NegotiateLoaderInfo& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_LOADER_VERSION_1_0

#ifdef XR_LOADER_VERSION_1_0
/*!
 * C++ projection of XrNegotiateRuntimeRequest
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrNegotiateRuntimeRequest>
 * @xrentity{XrNegotiateRuntimeRequest}
 * @ingroup structs
 */
struct XR_MAY_ALIAS NegotiateRuntimeRequest {
public:
  //! Constructor initializing all members.
  NegotiateRuntimeRequest(const LoaderInterfaceStructs& structType_, uint32_t structVersion_,
                          size_t structSize_, uint32_t runtimeInterfaceVersion_,
                          const Version& runtimeApiVersion_,
                          PFN_xrGetInstanceProcAddr getInstanceProcAddr_)
      : structType{structType_},
        structVersion{structVersion_},
        structSize{structSize_},
        runtimeInterfaceVersion{runtimeInterfaceVersion_},
        runtimeApiVersion{runtimeApiVersion_},
        getInstanceProcAddr{getInstanceProcAddr_} {}

  //! Default/empty constructor
  NegotiateRuntimeRequest()

      : structType{},
        structVersion{0},
        structSize{},
        runtimeInterfaceVersion{0},
        runtimeApiVersion{},
        getInstanceProcAddr{nullptr} {}

  //! Default copy constructor
  NegotiateRuntimeRequest(const NegotiateRuntimeRequest& rhs) = default;
  //! Default copy assignment
  NegotiateRuntimeRequest& operator=(const NegotiateRuntimeRequest& rhs) = default;
  //! Copy construct from raw
  NegotiateRuntimeRequest(const XrNegotiateRuntimeRequest& rhs) : NegotiateRuntimeRequest() {
    *put() = rhs;
  }
  //! Copy assign from raw
  NegotiateRuntimeRequest& operator=(const XrNegotiateRuntimeRequest& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrNegotiateRuntimeRequest&() const {
    return *reinterpret_cast<const XrNegotiateRuntimeRequest*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrNegotiateRuntimeRequest&() {
    return *reinterpret_cast<XrNegotiateRuntimeRequest*>(this);
  }

  //! Accessor for this as the address of a raw XrNegotiateRuntimeRequest
  XrNegotiateRuntimeRequest const* get() const noexcept {
    return reinterpret_cast<XrNegotiateRuntimeRequest const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrNegotiateRuntimeRequest.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrNegotiateRuntimeRequest* put(bool clear = true) noexcept {
    if (clear) {
      *this = NegotiateRuntimeRequest{};
    }
    return reinterpret_cast<XrNegotiateRuntimeRequest*>(this);
  }
  LoaderInterfaceStructs structType;
  uint32_t structVersion;
  size_t structSize;
  uint32_t runtimeInterfaceVersion;
  Version runtimeApiVersion;
  PFN_xrGetInstanceProcAddr getInstanceProcAddr;
};
static_assert(sizeof(XrNegotiateRuntimeRequest) == sizeof(NegotiateRuntimeRequest),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrNegotiateRuntimeRequest pointer to const from a
 * NegotiateRuntimeRequest reference to const.
 * @relates NegotiateRuntimeRequest
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrNegotiateRuntimeRequest const* get(NegotiateRuntimeRequest const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing NegotiateRuntimeRequest as
 * the address of a raw XrNegotiateRuntimeRequest
 * @relates NegotiateRuntimeRequest
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrNegotiateRuntimeRequest* put(NegotiateRuntimeRequest& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_LOADER_VERSION_1_0

#ifdef XR_LOADER_VERSION_1_0
/*!
 * C++ projection of XrNegotiateApiLayerRequest
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrNegotiateApiLayerRequest>
 * @xrentity{XrNegotiateApiLayerRequest}
 * @ingroup structs
 */
struct XR_MAY_ALIAS NegotiateApiLayerRequest {
public:
  //! Constructor initializing all members.
  NegotiateApiLayerRequest(const LoaderInterfaceStructs& structType_, uint32_t structVersion_,
                           size_t structSize_, uint32_t layerInterfaceVersion_,
                           const Version& layerApiVersion_,
                           PFN_xrGetInstanceProcAddr getInstanceProcAddr_,
                           PFN_xrCreateApiLayerInstance createApiLayerInstance_)
      : structType{structType_},
        structVersion{structVersion_},
        structSize{structSize_},
        layerInterfaceVersion{layerInterfaceVersion_},
        layerApiVersion{layerApiVersion_},
        getInstanceProcAddr{getInstanceProcAddr_},
        createApiLayerInstance{createApiLayerInstance_} {}

  //! Default/empty constructor
  NegotiateApiLayerRequest()

      : structType{},
        structVersion{0},
        structSize{},
        layerInterfaceVersion{0},
        layerApiVersion{},
        getInstanceProcAddr{nullptr},
        createApiLayerInstance{nullptr} {}

  //! Default copy constructor
  NegotiateApiLayerRequest(const NegotiateApiLayerRequest& rhs) = default;
  //! Default copy assignment
  NegotiateApiLayerRequest& operator=(const NegotiateApiLayerRequest& rhs) = default;
  //! Copy construct from raw
  NegotiateApiLayerRequest(const XrNegotiateApiLayerRequest& rhs) : NegotiateApiLayerRequest() {
    *put() = rhs;
  }
  //! Copy assign from raw
  NegotiateApiLayerRequest& operator=(const XrNegotiateApiLayerRequest& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrNegotiateApiLayerRequest&() const {
    return *reinterpret_cast<const XrNegotiateApiLayerRequest*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrNegotiateApiLayerRequest&() {
    return *reinterpret_cast<XrNegotiateApiLayerRequest*>(this);
  }

  //! Accessor for this as the address of a raw XrNegotiateApiLayerRequest
  XrNegotiateApiLayerRequest const* get() const noexcept {
    return reinterpret_cast<XrNegotiateApiLayerRequest const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrNegotiateApiLayerRequest.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrNegotiateApiLayerRequest* put(bool clear = true) noexcept {
    if (clear) {
      *this = NegotiateApiLayerRequest{};
    }
    return reinterpret_cast<XrNegotiateApiLayerRequest*>(this);
  }
  LoaderInterfaceStructs structType;
  uint32_t structVersion;
  size_t structSize;
  uint32_t layerInterfaceVersion;
  Version layerApiVersion;
  PFN_xrGetInstanceProcAddr getInstanceProcAddr;
  PFN_xrCreateApiLayerInstance createApiLayerInstance;
};
static_assert(sizeof(XrNegotiateApiLayerRequest) == sizeof(NegotiateApiLayerRequest),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrNegotiateApiLayerRequest pointer to const from a
 * NegotiateApiLayerRequest reference to const.
 * @relates NegotiateApiLayerRequest
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrNegotiateApiLayerRequest const* get(NegotiateApiLayerRequest const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing NegotiateApiLayerRequest as
 * the address of a raw XrNegotiateApiLayerRequest
 * @relates NegotiateApiLayerRequest
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrNegotiateApiLayerRequest* put(NegotiateApiLayerRequest& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_LOADER_VERSION_1_0

/*!
 * C++ projection of XrColor3f
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrColor3f>
 * @xrentity{XrColor3f}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Color3f {
public:
  //! Constructor initializing all members.
  Color3f(float r_, float g_, float b_) : r{r_}, g{g_}, b{b_} {}

  //! Default/empty constructor
  Color3f()

      : r{0.0f}, g{0.0f}, b{0.0f} {}

  //! Default copy constructor
  Color3f(const Color3f& rhs) = default;
  //! Default copy assignment
  Color3f& operator=(const Color3f& rhs) = default;
  //! Copy construct from raw
  Color3f(const XrColor3f& rhs) : Color3f() { *put() = rhs; }
  //! Copy assign from raw
  Color3f& operator=(const XrColor3f& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrColor3f&() const { return *reinterpret_cast<const XrColor3f*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrColor3f&() { return *reinterpret_cast<XrColor3f*>(this); }

  //! Accessor for this as the address of a raw XrColor3f
  XrColor3f const* get() const noexcept { return reinterpret_cast<XrColor3f const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrColor3f.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrColor3f* put(bool clear = true) noexcept {
    if (clear) {
      *this = Color3f{};
    }
    return reinterpret_cast<XrColor3f*>(this);
  }
  float r;
  float g;
  float b;
};
static_assert(sizeof(XrColor3f) == sizeof(Color3f),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrColor3f pointer to const from a Color3f reference to
 * const.
 * @relates Color3f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColor3f const* get(Color3f const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Color3f as the address of a
 * raw XrColor3f
 * @relates Color3f
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColor3f* put(Color3f& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrExtent3Df
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExtent3Df>
 * @xrentity{XrExtent3Df}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Extent3Df {
public:
  //! Constructor initializing all members.
  Extent3Df(float width_, float height_, float depth_)
      : width{width_}, height{height_}, depth{depth_} {}

  //! Default/empty constructor
  Extent3Df()

      : width{0.0f}, height{0.0f}, depth{0.0f} {}

  //! Default copy constructor
  Extent3Df(const Extent3Df& rhs) = default;
  //! Default copy assignment
  Extent3Df& operator=(const Extent3Df& rhs) = default;
  //! Copy construct from raw
  Extent3Df(const XrExtent3Df& rhs) : Extent3Df() { *put() = rhs; }
  //! Copy assign from raw
  Extent3Df& operator=(const XrExtent3Df& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExtent3Df&() const { return *reinterpret_cast<const XrExtent3Df*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExtent3Df&() { return *reinterpret_cast<XrExtent3Df*>(this); }

  //! Accessor for this as the address of a raw XrExtent3Df
  XrExtent3Df const* get() const noexcept { return reinterpret_cast<XrExtent3Df const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrExtent3Df.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrExtent3Df* put(bool clear = true) noexcept {
    if (clear) {
      *this = Extent3Df{};
    }
    return reinterpret_cast<XrExtent3Df*>(this);
  }
  float width;
  float height;
  float depth;
};
static_assert(sizeof(XrExtent3Df) == sizeof(Extent3Df),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExtent3Df pointer to const from a Extent3Df reference to
 * const.
 * @relates Extent3Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent3Df const* get(Extent3Df const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Extent3Df as the address of a
 * raw XrExtent3Df
 * @relates Extent3Df
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExtent3Df* put(Extent3Df& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSpheref
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpheref>
 * @xrentity{XrSpheref}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Spheref {
public:
  //! Constructor initializing all members.
  Spheref(const Posef& center_, float radius_) : center{center_}, radius{radius_} {}

  //! Default/empty constructor
  Spheref()

      : center{}, radius{0.0f} {}

  //! Default copy constructor
  Spheref(const Spheref& rhs) = default;
  //! Default copy assignment
  Spheref& operator=(const Spheref& rhs) = default;
  //! Copy construct from raw
  Spheref(const XrSpheref& rhs) : Spheref() { *put() = rhs; }
  //! Copy assign from raw
  Spheref& operator=(const XrSpheref& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpheref&() const { return *reinterpret_cast<const XrSpheref*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpheref&() { return *reinterpret_cast<XrSpheref*>(this); }

  //! Accessor for this as the address of a raw XrSpheref
  XrSpheref const* get() const noexcept { return reinterpret_cast<XrSpheref const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpheref.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpheref* put(bool clear = true) noexcept {
    if (clear) {
      *this = Spheref{};
    }
    return reinterpret_cast<XrSpheref*>(this);
  }
  Posef center;
  float radius;
};
static_assert(sizeof(XrSpheref) == sizeof(Spheref),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpheref pointer to const from a Spheref reference to
 * const.
 * @relates Spheref
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpheref const* get(Spheref const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Spheref as the address of a
 * raw XrSpheref
 * @relates Spheref
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpheref* put(Spheref& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrBoxf
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBoxf>
 * @xrentity{XrBoxf}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Boxf {
public:
  //! Constructor initializing all members.
  Boxf(const Posef& center_, const Extent3Df& extents_) : center{center_}, extents{extents_} {}

  //! Default/empty constructor
  Boxf()

      : center{}, extents{} {}

  //! Default copy constructor
  Boxf(const Boxf& rhs) = default;
  //! Default copy assignment
  Boxf& operator=(const Boxf& rhs) = default;
  //! Copy construct from raw
  Boxf(const XrBoxf& rhs) : Boxf() { *put() = rhs; }
  //! Copy assign from raw
  Boxf& operator=(const XrBoxf& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBoxf&() const { return *reinterpret_cast<const XrBoxf*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBoxf&() { return *reinterpret_cast<XrBoxf*>(this); }

  //! Accessor for this as the address of a raw XrBoxf
  XrBoxf const* get() const noexcept { return reinterpret_cast<XrBoxf const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBoxf.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrBoxf* put(bool clear = true) noexcept {
    if (clear) {
      *this = Boxf{};
    }
    return reinterpret_cast<XrBoxf*>(this);
  }
  Posef center;
  Extent3Df extents;
};
static_assert(sizeof(XrBoxf) == sizeof(Boxf), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBoxf pointer to const from a Boxf reference to const.
 * @relates Boxf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBoxf const* get(Boxf const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Boxf as the address of a raw
 * XrBoxf
 * @relates Boxf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBoxf* put(Boxf& s, bool clear = true) noexcept { return s.put(clear); }

/*!
 * C++ projection of XrFrustumf
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrustumf>
 * @xrentity{XrFrustumf}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Frustumf {
public:
  //! Constructor initializing all members.
  Frustumf(const Posef& pose_, const Fovf& fov_, float nearZ_, float farZ_)
      : pose{pose_}, fov{fov_}, nearZ{nearZ_}, farZ{farZ_} {}

  //! Default/empty constructor
  Frustumf()

      : pose{}, fov{}, nearZ{0.0f}, farZ{0.0f} {}

  //! Default copy constructor
  Frustumf(const Frustumf& rhs) = default;
  //! Default copy assignment
  Frustumf& operator=(const Frustumf& rhs) = default;
  //! Copy construct from raw
  Frustumf(const XrFrustumf& rhs) : Frustumf() { *put() = rhs; }
  //! Copy assign from raw
  Frustumf& operator=(const XrFrustumf& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrustumf&() const { return *reinterpret_cast<const XrFrustumf*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrustumf&() { return *reinterpret_cast<XrFrustumf*>(this); }

  //! Accessor for this as the address of a raw XrFrustumf
  XrFrustumf const* get() const noexcept { return reinterpret_cast<XrFrustumf const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrustumf.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrFrustumf* put(bool clear = true) noexcept {
    if (clear) {
      *this = Frustumf{};
    }
    return reinterpret_cast<XrFrustumf*>(this);
  }
  Posef pose;
  Fovf fov;
  float nearZ;
  float farZ;
};
static_assert(sizeof(XrFrustumf) == sizeof(Frustumf),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrustumf pointer to const from a Frustumf reference to
 * const.
 * @relates Frustumf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrustumf const* get(Frustumf const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Frustumf as the address of a
 * raw XrFrustumf
 * @relates Frustumf
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrustumf* put(Frustumf& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrUuid
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrUuid>
 * @xrentity{XrUuid}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Uuid {
public:
  //! Constructor initializing all members.
  Uuid(uint8_t data_[XR_UUID_SIZE]) { memcpy(data, data_, sizeof(data)); }

  //! Default/empty constructor
  Uuid()

      : data{0} {}

  //! Default copy constructor
  Uuid(const Uuid& rhs) = default;
  //! Default copy assignment
  Uuid& operator=(const Uuid& rhs) = default;
  //! Copy construct from raw
  Uuid(const XrUuid& rhs) : Uuid() { *put() = rhs; }
  //! Copy assign from raw
  Uuid& operator=(const XrUuid& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrUuid&() const { return *reinterpret_cast<const XrUuid*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrUuid&() { return *reinterpret_cast<XrUuid*>(this); }

  //! Accessor for this as the address of a raw XrUuid
  XrUuid const* get() const noexcept { return reinterpret_cast<XrUuid const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrUuid.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrUuid* put(bool clear = true) noexcept {
    if (clear) {
      *this = Uuid{};
    }
    return reinterpret_cast<XrUuid*>(this);
  }
  uint8_t data[XR_UUID_SIZE];
};
static_assert(sizeof(XrUuid) == sizeof(Uuid), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrUuid pointer to const from a Uuid reference to const.
 * @relates Uuid
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrUuid const* get(Uuid const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Uuid as the address of a raw
 * XrUuid
 * @relates Uuid
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrUuid* put(Uuid& s, bool clear = true) noexcept { return s.put(clear); }

/*!
 * C++ projection of XrSpacesLocateInfo
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpacesLocateInfo>
 * @xrentity{XrSpacesLocateInfo}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpacesLocateInfo : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpacesLocateInfo(const Space& baseSpace_, const Time& time_, uint32_t spaceCount_,
                   const Space* spaces_, const void* next_ = nullptr)
      : Parent(StructureType::SpacesLocateInfo, next_),
        baseSpace{baseSpace_},
        time{time_},
        spaceCount{spaceCount_},
        spaces{spaces_} {}

  //! Default/empty constructor
  SpacesLocateInfo(const void* next_ = nullptr)

      : Parent(StructureType::SpacesLocateInfo, next_),
        baseSpace{},
        time{},
        spaceCount{0},
        spaces{nullptr} {}

  //! Default copy constructor
  SpacesLocateInfo(const SpacesLocateInfo& rhs) = default;
  //! Default copy assignment
  SpacesLocateInfo& operator=(const SpacesLocateInfo& rhs) = default;
  //! Copy construct from raw
  SpacesLocateInfo(const XrSpacesLocateInfo& rhs) : SpacesLocateInfo() { *put() = rhs; }
  //! Copy assign from raw
  SpacesLocateInfo& operator=(const XrSpacesLocateInfo& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpacesLocateInfo&() const {
    return *reinterpret_cast<const XrSpacesLocateInfo*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpacesLocateInfo&() { return *reinterpret_cast<XrSpacesLocateInfo*>(this); }

  //! Accessor for this as the address of a raw XrSpacesLocateInfo
  XrSpacesLocateInfo const* get() const noexcept {
    return reinterpret_cast<XrSpacesLocateInfo const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpacesLocateInfo.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpacesLocateInfo* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpacesLocateInfo{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpacesLocateInfo*>(this);
  }
  Space baseSpace;
  Time time;
  uint32_t spaceCount;
  const Space* spaces;
};
static_assert(sizeof(XrSpacesLocateInfo) == sizeof(SpacesLocateInfo),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpacesLocateInfo pointer to const from a
 * SpacesLocateInfo reference to const.
 * @relates SpacesLocateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpacesLocateInfo const* get(SpacesLocateInfo const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpacesLocateInfo as the
 * address of a raw XrSpacesLocateInfo
 * @relates SpacesLocateInfo
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpacesLocateInfo* put(SpacesLocateInfo& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSpaceLocationData
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceLocationData>
 * @xrentity{XrSpaceLocationData}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpaceLocationData {
public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceLocationData()

  {}

  //! Default copy constructor
  SpaceLocationData(const SpaceLocationData& rhs) = default;
  //! Default copy assignment
  SpaceLocationData& operator=(const SpaceLocationData& rhs) = default;
  //! Copy construct from raw
  SpaceLocationData(const XrSpaceLocationData& rhs) : SpaceLocationData() { *put() = rhs; }
  //! Copy assign from raw
  SpaceLocationData& operator=(const XrSpaceLocationData& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceLocationData&() const {
    return *reinterpret_cast<const XrSpaceLocationData*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceLocationData&() { return *reinterpret_cast<XrSpaceLocationData*>(this); }

  //! Accessor for this as the address of a raw XrSpaceLocationData
  XrSpaceLocationData const* get() const noexcept {
    return reinterpret_cast<XrSpaceLocationData const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceLocationData.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpaceLocationData* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpaceLocationData{};
    }
    return reinterpret_cast<XrSpaceLocationData*>(this);
  }
  SpaceLocationFlags locationFlags;
  Posef pose;
};
static_assert(sizeof(XrSpaceLocationData) == sizeof(SpaceLocationData),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceLocationData pointer to const from a
 * SpaceLocationData reference to const.
 * @relates SpaceLocationData
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceLocationData const* get(SpaceLocationData const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceLocationData as the
 * address of a raw XrSpaceLocationData
 * @relates SpaceLocationData
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceLocationData* put(SpaceLocationData& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSpaceLocations
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceLocations>
 * @xrentity{XrSpaceLocations}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceLocations : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceLocations(void* next_ = nullptr)

      : Parent(StructureType::SpaceLocations, next_) {}

  //! Default copy constructor
  SpaceLocations(const SpaceLocations& rhs) = default;
  //! Default copy assignment
  SpaceLocations& operator=(const SpaceLocations& rhs) = default;
  //! Copy construct from raw
  SpaceLocations(const XrSpaceLocations& rhs) : SpaceLocations() { *put() = rhs; }
  //! Copy assign from raw
  SpaceLocations& operator=(const XrSpaceLocations& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceLocations&() const {
    return *reinterpret_cast<const XrSpaceLocations*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceLocations&() { return *reinterpret_cast<XrSpaceLocations*>(this); }

  //! Accessor for this as the address of a raw XrSpaceLocations
  XrSpaceLocations const* get() const noexcept {
    return reinterpret_cast<XrSpaceLocations const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceLocations.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceLocations* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceLocations{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceLocations*>(this);
  }
  uint32_t locationCount;
  SpaceLocationData* locations;
};
static_assert(sizeof(XrSpaceLocations) == sizeof(SpaceLocations),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceLocations pointer to const from a SpaceLocations
 * reference to const.
 * @relates SpaceLocations
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceLocations const* get(SpaceLocations const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceLocations as the address
 * of a raw XrSpaceLocations
 * @relates SpaceLocations
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceLocations* put(SpaceLocations& s, bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSpaceVelocityData
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceVelocityData>
 * @xrentity{XrSpaceVelocityData}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpaceVelocityData {
public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceVelocityData()

  {}

  //! Default copy constructor
  SpaceVelocityData(const SpaceVelocityData& rhs) = default;
  //! Default copy assignment
  SpaceVelocityData& operator=(const SpaceVelocityData& rhs) = default;
  //! Copy construct from raw
  SpaceVelocityData(const XrSpaceVelocityData& rhs) : SpaceVelocityData() { *put() = rhs; }
  //! Copy assign from raw
  SpaceVelocityData& operator=(const XrSpaceVelocityData& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceVelocityData&() const {
    return *reinterpret_cast<const XrSpaceVelocityData*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceVelocityData&() { return *reinterpret_cast<XrSpaceVelocityData*>(this); }

  //! Accessor for this as the address of a raw XrSpaceVelocityData
  XrSpaceVelocityData const* get() const noexcept {
    return reinterpret_cast<XrSpaceVelocityData const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceVelocityData.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpaceVelocityData* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpaceVelocityData{};
    }
    return reinterpret_cast<XrSpaceVelocityData*>(this);
  }
  SpaceVelocityFlags velocityFlags;
  Vector3f linearVelocity;
  Vector3f angularVelocity;
};
static_assert(sizeof(XrSpaceVelocityData) == sizeof(SpaceVelocityData),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceVelocityData pointer to const from a
 * SpaceVelocityData reference to const.
 * @relates SpaceVelocityData
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceVelocityData const* get(SpaceVelocityData const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceVelocityData as the
 * address of a raw XrSpaceVelocityData
 * @relates SpaceVelocityData
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceVelocityData* put(SpaceVelocityData& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}

/*!
 * C++ projection of XrSpaceVelocities
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceVelocities>
 * @xrentity{XrSpaceVelocities}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceVelocities : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceVelocities(void* next_ = nullptr)

      : Parent(StructureType::SpaceVelocities, next_) {}

  //! Default copy constructor
  SpaceVelocities(const SpaceVelocities& rhs) = default;
  //! Default copy assignment
  SpaceVelocities& operator=(const SpaceVelocities& rhs) = default;
  //! Copy construct from raw
  SpaceVelocities(const XrSpaceVelocities& rhs) : SpaceVelocities() { *put() = rhs; }
  //! Copy assign from raw
  SpaceVelocities& operator=(const XrSpaceVelocities& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceVelocities&() const {
    return *reinterpret_cast<const XrSpaceVelocities*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceVelocities&() { return *reinterpret_cast<XrSpaceVelocities*>(this); }

  //! Accessor for this as the address of a raw XrSpaceVelocities
  XrSpaceVelocities const* get() const noexcept {
    return reinterpret_cast<XrSpaceVelocities const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceVelocities.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceVelocities* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceVelocities{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceVelocities*>(this);
  }
  uint32_t velocityCount;
  SpaceVelocityData* velocities;
};
static_assert(sizeof(XrSpaceVelocities) == sizeof(SpaceVelocities),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceVelocities pointer to const from a SpaceVelocities
 * reference to const.
 * @relates SpaceVelocities
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceVelocities const* get(SpaceVelocities const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceVelocities as the
 * address of a raw XrSpaceVelocities
 * @relates SpaceVelocities
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceVelocities* put(SpaceVelocities& s, bool clear = true) noexcept {
  return s.put(clear);
}

#ifdef XR_KHR_composition_layer_cube
/*!
 * C++ projection of XrCompositionLayerCubeKHR
 *
 * Provided by the `XR_KHR_composition_layer_cube` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerCubeKHR>
 * @xrentity{XrCompositionLayerCubeKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerCubeKHR : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerCubeKHR(const CompositionLayerFlags& layerFlags_, const Space& space_,
                          const EyeVisibility& eyeVisibility_, const Swapchain& swapchain_,
                          uint32_t imageArrayIndex_, const Quaternionf& orientation_,
                          const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerCubeKHR, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        swapchain{swapchain_},
        imageArrayIndex{imageArrayIndex_},
        orientation{orientation_} {}

  //! Default/empty constructor
  CompositionLayerCubeKHR(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerCubeKHR, {}, {}, next_),
        eyeVisibility{},
        swapchain{},
        imageArrayIndex{0},
        orientation{} {}

  //! Default copy constructor
  CompositionLayerCubeKHR(const CompositionLayerCubeKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerCubeKHR& operator=(const CompositionLayerCubeKHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerCubeKHR(const XrCompositionLayerCubeKHR& rhs) : CompositionLayerCubeKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerCubeKHR& operator=(const XrCompositionLayerCubeKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerCubeKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerCubeKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerCubeKHR&() {
    return *reinterpret_cast<XrCompositionLayerCubeKHR*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerCubeKHR
  XrCompositionLayerCubeKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerCubeKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerCubeKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerCubeKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerCubeKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerCubeKHR*>(this);
  }
  EyeVisibility eyeVisibility;
  Swapchain swapchain;
  uint32_t imageArrayIndex;
  Quaternionf orientation;
};
static_assert(sizeof(XrCompositionLayerCubeKHR) == sizeof(CompositionLayerCubeKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerCubeKHR pointer to const from a
 * CompositionLayerCubeKHR reference to const.
 * @relates CompositionLayerCubeKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerCubeKHR const* get(CompositionLayerCubeKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerCubeKHR as
 * the address of a raw XrCompositionLayerCubeKHR
 * @relates CompositionLayerCubeKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerCubeKHR* put(CompositionLayerCubeKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerCubeKHR as a raw, pointer
 * to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerCubeKHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerCubeKHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_composition_layer_cube

#ifdef XR_KHR_android_create_instance
#if defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrInstanceCreateInfoAndroidKHR
 *
 * Provided by the `XR_KHR_android_create_instance` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstanceCreateInfoAndroidKHR>
 * @xrentity{XrInstanceCreateInfoAndroidKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InstanceCreateInfoAndroidKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InstanceCreateInfoAndroidKHR(void* XR_MAY_ALIAS applicationVM_,
                               void* XR_MAY_ALIAS applicationActivity_, const void* next_ = nullptr)
      : Parent(StructureType::InstanceCreateInfoAndroidKHR, next_),
        applicationVM{applicationVM_},
        applicationActivity{applicationActivity_} {}

  //! Default/empty constructor
  InstanceCreateInfoAndroidKHR(const void* next_ = nullptr)

      : Parent(StructureType::InstanceCreateInfoAndroidKHR, next_),
        applicationVM{nullptr},
        applicationActivity{nullptr} {}

  //! Default copy constructor
  InstanceCreateInfoAndroidKHR(const InstanceCreateInfoAndroidKHR& rhs) = default;
  //! Default copy assignment
  InstanceCreateInfoAndroidKHR& operator=(const InstanceCreateInfoAndroidKHR& rhs) = default;
  //! Copy construct from raw
  InstanceCreateInfoAndroidKHR(const XrInstanceCreateInfoAndroidKHR& rhs)
      : InstanceCreateInfoAndroidKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InstanceCreateInfoAndroidKHR& operator=(const XrInstanceCreateInfoAndroidKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInstanceCreateInfoAndroidKHR&() const {
    return *reinterpret_cast<const XrInstanceCreateInfoAndroidKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInstanceCreateInfoAndroidKHR&() {
    return *reinterpret_cast<XrInstanceCreateInfoAndroidKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrInstanceCreateInfoAndroidKHR
  XrInstanceCreateInfoAndroidKHR const* get() const noexcept {
    return reinterpret_cast<XrInstanceCreateInfoAndroidKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInstanceCreateInfoAndroidKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInstanceCreateInfoAndroidKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InstanceCreateInfoAndroidKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrInstanceCreateInfoAndroidKHR*>(this);
  }
  void* XR_MAY_ALIAS applicationVM;
  void* XR_MAY_ALIAS applicationActivity;
};
static_assert(sizeof(XrInstanceCreateInfoAndroidKHR) == sizeof(InstanceCreateInfoAndroidKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInstanceCreateInfoAndroidKHR pointer to const from a
 * InstanceCreateInfoAndroidKHR reference to const.
 * @relates InstanceCreateInfoAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceCreateInfoAndroidKHR const* get(
    InstanceCreateInfoAndroidKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing InstanceCreateInfoAndroidKHR
 * as the address of a raw XrInstanceCreateInfoAndroidKHR
 * @relates InstanceCreateInfoAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInstanceCreateInfoAndroidKHR* put(InstanceCreateInfoAndroidKHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_create_instance

#ifdef XR_KHR_composition_layer_depth
/*!
 * C++ projection of XrCompositionLayerDepthInfoKHR
 *
 * Provided by the `XR_KHR_composition_layer_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerDepthInfoKHR>
 * @xrentity{XrCompositionLayerDepthInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerDepthInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerDepthInfoKHR(const SwapchainSubImage& subImage_, float minDepth_, float maxDepth_,
                               float nearZ_, float farZ_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerDepthInfoKHR, next_),
        subImage{subImage_},
        minDepth{minDepth_},
        maxDepth{maxDepth_},
        nearZ{nearZ_},
        farZ{farZ_} {}

  //! Default/empty constructor
  CompositionLayerDepthInfoKHR(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerDepthInfoKHR, next_),
        subImage{},
        minDepth{0.0f},
        maxDepth{0.0f},
        nearZ{0.0f},
        farZ{0.0f} {}

  //! Default copy constructor
  CompositionLayerDepthInfoKHR(const CompositionLayerDepthInfoKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerDepthInfoKHR& operator=(const CompositionLayerDepthInfoKHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerDepthInfoKHR(const XrCompositionLayerDepthInfoKHR& rhs)
      : CompositionLayerDepthInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerDepthInfoKHR& operator=(const XrCompositionLayerDepthInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerDepthInfoKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerDepthInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerDepthInfoKHR&() {
    return *reinterpret_cast<XrCompositionLayerDepthInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerDepthInfoKHR
  XrCompositionLayerDepthInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerDepthInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerDepthInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerDepthInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerDepthInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerDepthInfoKHR*>(this);
  }
  SwapchainSubImage subImage;
  float minDepth;
  float maxDepth;
  float nearZ;
  float farZ;
};
static_assert(sizeof(XrCompositionLayerDepthInfoKHR) == sizeof(CompositionLayerDepthInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerDepthInfoKHR pointer to const from a
 * CompositionLayerDepthInfoKHR reference to const.
 * @relates CompositionLayerDepthInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerDepthInfoKHR const* get(
    CompositionLayerDepthInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerDepthInfoKHR
 * as the address of a raw XrCompositionLayerDepthInfoKHR
 * @relates CompositionLayerDepthInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerDepthInfoKHR* put(CompositionLayerDepthInfoKHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_composition_layer_depth

#ifdef XR_KHR_vulkan_swapchain_format_list
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanSwapchainFormatListCreateInfoKHR
 *
 * Provided by the `XR_KHR_vulkan_swapchain_format_list` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanSwapchainFormatListCreateInfoKHR>
 * @xrentity{XrVulkanSwapchainFormatListCreateInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanSwapchainFormatListCreateInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanSwapchainFormatListCreateInfoKHR(uint32_t viewFormatCount_, const VkFormat* viewFormats_,
                                         const void* next_ = nullptr)
      : Parent(StructureType::VulkanSwapchainFormatListCreateInfoKHR, next_),
        viewFormatCount{viewFormatCount_},
        viewFormats{viewFormats_} {}

  //! Default/empty constructor
  VulkanSwapchainFormatListCreateInfoKHR(const void* next_ = nullptr)

      : Parent(StructureType::VulkanSwapchainFormatListCreateInfoKHR, next_),
        viewFormatCount{0},
        viewFormats{nullptr} {}

  //! Default copy constructor
  VulkanSwapchainFormatListCreateInfoKHR(const VulkanSwapchainFormatListCreateInfoKHR& rhs) =
      default;
  //! Default copy assignment
  VulkanSwapchainFormatListCreateInfoKHR& operator=(
      const VulkanSwapchainFormatListCreateInfoKHR& rhs) = default;
  //! Copy construct from raw
  VulkanSwapchainFormatListCreateInfoKHR(const XrVulkanSwapchainFormatListCreateInfoKHR& rhs)
      : VulkanSwapchainFormatListCreateInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanSwapchainFormatListCreateInfoKHR& operator=(
      const XrVulkanSwapchainFormatListCreateInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanSwapchainFormatListCreateInfoKHR&() const {
    return *reinterpret_cast<const XrVulkanSwapchainFormatListCreateInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanSwapchainFormatListCreateInfoKHR&() {
    return *reinterpret_cast<XrVulkanSwapchainFormatListCreateInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanSwapchainFormatListCreateInfoKHR
  XrVulkanSwapchainFormatListCreateInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrVulkanSwapchainFormatListCreateInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanSwapchainFormatListCreateInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanSwapchainFormatListCreateInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanSwapchainFormatListCreateInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanSwapchainFormatListCreateInfoKHR*>(this);
  }
  uint32_t viewFormatCount;
  const VkFormat* viewFormats;
};
static_assert(sizeof(XrVulkanSwapchainFormatListCreateInfoKHR) ==
                  sizeof(VulkanSwapchainFormatListCreateInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanSwapchainFormatListCreateInfoKHR pointer to const
 * from a VulkanSwapchainFormatListCreateInfoKHR reference to const.
 * @relates VulkanSwapchainFormatListCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanSwapchainFormatListCreateInfoKHR const* get(
    VulkanSwapchainFormatListCreateInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VulkanSwapchainFormatListCreateInfoKHR as the address of a raw
 * XrVulkanSwapchainFormatListCreateInfoKHR
 * @relates VulkanSwapchainFormatListCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanSwapchainFormatListCreateInfoKHR* put(
    VulkanSwapchainFormatListCreateInfoKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_swapchain_format_list

#ifdef XR_KHR_composition_layer_cylinder
/*!
 * C++ projection of XrCompositionLayerCylinderKHR
 *
 * Provided by the `XR_KHR_composition_layer_cylinder` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerCylinderKHR>
 * @xrentity{XrCompositionLayerCylinderKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerCylinderKHR : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerCylinderKHR(const CompositionLayerFlags& layerFlags_, const Space& space_,
                              const EyeVisibility& eyeVisibility_,
                              const SwapchainSubImage& subImage_, const Posef& pose_, float radius_,
                              float centralAngle_, float aspectRatio_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerCylinderKHR, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        subImage{subImage_},
        pose{pose_},
        radius{radius_},
        centralAngle{centralAngle_},
        aspectRatio{aspectRatio_} {}

  //! Default/empty constructor
  CompositionLayerCylinderKHR(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerCylinderKHR, {}, {}, next_),
        eyeVisibility{},
        subImage{},
        pose{},
        radius{0.0f},
        centralAngle{0.0f},
        aspectRatio{0.0f} {}

  //! Default copy constructor
  CompositionLayerCylinderKHR(const CompositionLayerCylinderKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerCylinderKHR& operator=(const CompositionLayerCylinderKHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerCylinderKHR(const XrCompositionLayerCylinderKHR& rhs)
      : CompositionLayerCylinderKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerCylinderKHR& operator=(const XrCompositionLayerCylinderKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerCylinderKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerCylinderKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerCylinderKHR&() {
    return *reinterpret_cast<XrCompositionLayerCylinderKHR*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerCylinderKHR
  XrCompositionLayerCylinderKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerCylinderKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerCylinderKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerCylinderKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerCylinderKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerCylinderKHR*>(this);
  }
  EyeVisibility eyeVisibility;
  SwapchainSubImage subImage;
  Posef pose;
  float radius;
  float centralAngle;
  float aspectRatio;
};
static_assert(sizeof(XrCompositionLayerCylinderKHR) == sizeof(CompositionLayerCylinderKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerCylinderKHR pointer to const from a
 * CompositionLayerCylinderKHR reference to const.
 * @relates CompositionLayerCylinderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerCylinderKHR const* get(
    CompositionLayerCylinderKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerCylinderKHR
 * as the address of a raw XrCompositionLayerCylinderKHR
 * @relates CompositionLayerCylinderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerCylinderKHR* put(CompositionLayerCylinderKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerCylinderKHR as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerCylinderKHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerCylinderKHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_composition_layer_cylinder

#ifdef XR_KHR_composition_layer_equirect
/*!
 * C++ projection of XrCompositionLayerEquirectKHR
 *
 * Provided by the `XR_KHR_composition_layer_equirect` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerEquirectKHR>
 * @xrentity{XrCompositionLayerEquirectKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerEquirectKHR : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerEquirectKHR(const CompositionLayerFlags& layerFlags_, const Space& space_,
                              const EyeVisibility& eyeVisibility_,
                              const SwapchainSubImage& subImage_, const Posef& pose_, float radius_,
                              const Vector2f& scale_, const Vector2f& bias_,
                              const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerEquirectKHR, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        subImage{subImage_},
        pose{pose_},
        radius{radius_},
        scale{scale_},
        bias{bias_} {}

  //! Default/empty constructor
  CompositionLayerEquirectKHR(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerEquirectKHR, {}, {}, next_),
        eyeVisibility{},
        subImage{},
        pose{},
        radius{0.0f},
        scale{},
        bias{} {}

  //! Default copy constructor
  CompositionLayerEquirectKHR(const CompositionLayerEquirectKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerEquirectKHR& operator=(const CompositionLayerEquirectKHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerEquirectKHR(const XrCompositionLayerEquirectKHR& rhs)
      : CompositionLayerEquirectKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerEquirectKHR& operator=(const XrCompositionLayerEquirectKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerEquirectKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerEquirectKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerEquirectKHR&() {
    return *reinterpret_cast<XrCompositionLayerEquirectKHR*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerEquirectKHR
  XrCompositionLayerEquirectKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerEquirectKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerEquirectKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerEquirectKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerEquirectKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerEquirectKHR*>(this);
  }
  EyeVisibility eyeVisibility;
  SwapchainSubImage subImage;
  Posef pose;
  float radius;
  Vector2f scale;
  Vector2f bias;
};
static_assert(sizeof(XrCompositionLayerEquirectKHR) == sizeof(CompositionLayerEquirectKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerEquirectKHR pointer to const from a
 * CompositionLayerEquirectKHR reference to const.
 * @relates CompositionLayerEquirectKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerEquirectKHR const* get(
    CompositionLayerEquirectKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerEquirectKHR
 * as the address of a raw XrCompositionLayerEquirectKHR
 * @relates CompositionLayerEquirectKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerEquirectKHR* put(CompositionLayerEquirectKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerEquirectKHR as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerEquirectKHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerEquirectKHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_composition_layer_equirect

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
/*!
 * C++ projection of XrGraphicsBindingOpenGLWin32KHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLWin32KHR>
 * @xrentity{XrGraphicsBindingOpenGLWin32KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLWin32KHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLWin32KHR(HDC hDC_, HGLRC hGLRC_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLWin32KHR, next_), hDC{hDC_}, hGLRC{hGLRC_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLWin32KHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingOpenGLWin32KHR, next_), hDC{}, hGLRC{} {}

  //! Default copy constructor
  GraphicsBindingOpenGLWin32KHR(const GraphicsBindingOpenGLWin32KHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLWin32KHR& operator=(const GraphicsBindingOpenGLWin32KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingOpenGLWin32KHR(const XrGraphicsBindingOpenGLWin32KHR& rhs)
      : GraphicsBindingOpenGLWin32KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLWin32KHR& operator=(const XrGraphicsBindingOpenGLWin32KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLWin32KHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLWin32KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLWin32KHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLWin32KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLWin32KHR
  XrGraphicsBindingOpenGLWin32KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLWin32KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLWin32KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLWin32KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLWin32KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLWin32KHR*>(this);
  }
  HDC hDC;
  HGLRC hGLRC;
};
static_assert(sizeof(XrGraphicsBindingOpenGLWin32KHR) == sizeof(GraphicsBindingOpenGLWin32KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLWin32KHR pointer to const from a
 * GraphicsBindingOpenGLWin32KHR reference to const.
 * @relates GraphicsBindingOpenGLWin32KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWin32KHR const* get(
    GraphicsBindingOpenGLWin32KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLWin32KHR
 * as the address of a raw XrGraphicsBindingOpenGLWin32KHR
 * @relates GraphicsBindingOpenGLWin32KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWin32KHR* put(GraphicsBindingOpenGLWin32KHR& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
/*!
 * C++ projection of XrGraphicsBindingOpenGLXlibKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLXlibKHR>
 * @xrentity{XrGraphicsBindingOpenGLXlibKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLXlibKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLXlibKHR(Display* xDisplay_, uint32_t visualid_, GLXFBConfig glxFBConfig_,
                               GLXDrawable glxDrawable_, GLXContext glxContext_,
                               const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLXlibKHR, next_),
        xDisplay{xDisplay_},
        visualid{visualid_},
        glxFBConfig{glxFBConfig_},
        glxDrawable{glxDrawable_},
        glxContext{glxContext_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLXlibKHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingOpenGLXlibKHR, next_),
        xDisplay{nullptr},
        visualid{0},
        glxFBConfig{},
        glxDrawable{},
        glxContext{} {}

  //! Default copy constructor
  GraphicsBindingOpenGLXlibKHR(const GraphicsBindingOpenGLXlibKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLXlibKHR& operator=(const GraphicsBindingOpenGLXlibKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingOpenGLXlibKHR(const XrGraphicsBindingOpenGLXlibKHR& rhs)
      : GraphicsBindingOpenGLXlibKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLXlibKHR& operator=(const XrGraphicsBindingOpenGLXlibKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLXlibKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLXlibKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLXlibKHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLXlibKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLXlibKHR
  XrGraphicsBindingOpenGLXlibKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLXlibKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLXlibKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLXlibKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLXlibKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLXlibKHR*>(this);
  }
  Display* xDisplay;
  uint32_t visualid;
  GLXFBConfig glxFBConfig;
  GLXDrawable glxDrawable;
  GLXContext glxContext;
};
static_assert(sizeof(XrGraphicsBindingOpenGLXlibKHR) == sizeof(GraphicsBindingOpenGLXlibKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLXlibKHR pointer to const from a
 * GraphicsBindingOpenGLXlibKHR reference to const.
 * @relates GraphicsBindingOpenGLXlibKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXlibKHR const* get(
    GraphicsBindingOpenGLXlibKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLXlibKHR
 * as the address of a raw XrGraphicsBindingOpenGLXlibKHR
 * @relates GraphicsBindingOpenGLXlibKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXlibKHR* put(GraphicsBindingOpenGLXlibKHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
/*!
 * C++ projection of XrGraphicsBindingOpenGLXcbKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLXcbKHR>
 * @xrentity{XrGraphicsBindingOpenGLXcbKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLXcbKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLXcbKHR(xcb_connection_t* connection_, uint32_t screenNumber_,
                              xcb_glx_fbconfig_t fbconfigid_, xcb_visualid_t visualid_,
                              xcb_glx_drawable_t glxDrawable_, xcb_glx_context_t glxContext_,
                              const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLXcbKHR, next_),
        connection{connection_},
        screenNumber{screenNumber_},
        fbconfigid{fbconfigid_},
        visualid{visualid_},
        glxDrawable{glxDrawable_},
        glxContext{glxContext_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLXcbKHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingOpenGLXcbKHR, next_),
        connection{},
        screenNumber{0},
        fbconfigid{},
        visualid{},
        glxDrawable{},
        glxContext{} {}

  //! Default copy constructor
  GraphicsBindingOpenGLXcbKHR(const GraphicsBindingOpenGLXcbKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLXcbKHR& operator=(const GraphicsBindingOpenGLXcbKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingOpenGLXcbKHR(const XrGraphicsBindingOpenGLXcbKHR& rhs)
      : GraphicsBindingOpenGLXcbKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLXcbKHR& operator=(const XrGraphicsBindingOpenGLXcbKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLXcbKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLXcbKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLXcbKHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLXcbKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLXcbKHR
  XrGraphicsBindingOpenGLXcbKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLXcbKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLXcbKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLXcbKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLXcbKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLXcbKHR*>(this);
  }
  xcb_connection_t* connection;
  uint32_t screenNumber;
  xcb_glx_fbconfig_t fbconfigid;
  xcb_visualid_t visualid;
  xcb_glx_drawable_t glxDrawable;
  xcb_glx_context_t glxContext;
};
static_assert(sizeof(XrGraphicsBindingOpenGLXcbKHR) == sizeof(GraphicsBindingOpenGLXcbKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLXcbKHR pointer to const from a
 * GraphicsBindingOpenGLXcbKHR reference to const.
 * @relates GraphicsBindingOpenGLXcbKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXcbKHR const* get(
    GraphicsBindingOpenGLXcbKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingOpenGLXcbKHR
 * as the address of a raw XrGraphicsBindingOpenGLXcbKHR
 * @relates GraphicsBindingOpenGLXcbKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLXcbKHR* put(GraphicsBindingOpenGLXcbKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
/*!
 * C++ projection of XrGraphicsBindingOpenGLWaylandKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLWaylandKHR>
 * @xrentity{XrGraphicsBindingOpenGLWaylandKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLWaylandKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLWaylandKHR(struct wl_display* display_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLWaylandKHR, next_), display{display_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLWaylandKHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingOpenGLWaylandKHR, next_), display{} {}

  //! Default copy constructor
  GraphicsBindingOpenGLWaylandKHR(const GraphicsBindingOpenGLWaylandKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLWaylandKHR& operator=(const GraphicsBindingOpenGLWaylandKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingOpenGLWaylandKHR(const XrGraphicsBindingOpenGLWaylandKHR& rhs)
      : GraphicsBindingOpenGLWaylandKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLWaylandKHR& operator=(const XrGraphicsBindingOpenGLWaylandKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLWaylandKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLWaylandKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLWaylandKHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLWaylandKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLWaylandKHR
  XrGraphicsBindingOpenGLWaylandKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLWaylandKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLWaylandKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLWaylandKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLWaylandKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLWaylandKHR*>(this);
  }
  struct wl_display* display;
};
static_assert(sizeof(XrGraphicsBindingOpenGLWaylandKHR) == sizeof(GraphicsBindingOpenGLWaylandKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLWaylandKHR pointer to const from a
 * GraphicsBindingOpenGLWaylandKHR reference to const.
 * @relates GraphicsBindingOpenGLWaylandKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWaylandKHR const* get(
    GraphicsBindingOpenGLWaylandKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * GraphicsBindingOpenGLWaylandKHR as the address of a raw XrGraphicsBindingOpenGLWaylandKHR
 * @relates GraphicsBindingOpenGLWaylandKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLWaylandKHR* put(GraphicsBindingOpenGLWaylandKHR& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)
/*!
 * C++ projection of XrSwapchainImageOpenGLKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageOpenGLKHR>
 * @xrentity{XrSwapchainImageOpenGLKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageOpenGLKHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageOpenGLKHR(void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageOpenGLKHR, next_) {}

  //! Default copy constructor
  SwapchainImageOpenGLKHR(const SwapchainImageOpenGLKHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageOpenGLKHR& operator=(const SwapchainImageOpenGLKHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageOpenGLKHR(const XrSwapchainImageOpenGLKHR& rhs) : SwapchainImageOpenGLKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageOpenGLKHR& operator=(const XrSwapchainImageOpenGLKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageOpenGLKHR&() const {
    return *reinterpret_cast<const XrSwapchainImageOpenGLKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageOpenGLKHR&() {
    return *reinterpret_cast<XrSwapchainImageOpenGLKHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageOpenGLKHR
  XrSwapchainImageOpenGLKHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageOpenGLKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageOpenGLKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageOpenGLKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageOpenGLKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageOpenGLKHR*>(this);
  }
  uint32_t image;
};
static_assert(sizeof(XrSwapchainImageOpenGLKHR) == sizeof(SwapchainImageOpenGLKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageOpenGLKHR pointer to const from a
 * SwapchainImageOpenGLKHR reference to const.
 * @relates SwapchainImageOpenGLKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageOpenGLKHR const* get(SwapchainImageOpenGLKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageOpenGLKHR as
 * the address of a raw XrSwapchainImageOpenGLKHR
 * @relates SwapchainImageOpenGLKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageOpenGLKHR* put(SwapchainImageOpenGLKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageOpenGLKHR as a raw, pointer
 * to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageOpenGLKHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageOpenGLKHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)
/*!
 * C++ projection of XrGraphicsRequirementsOpenGLKHR
 *
 * Provided by the `XR_KHR_opengl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsOpenGLKHR>
 * @xrentity{XrGraphicsRequirementsOpenGLKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsOpenGLKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsOpenGLKHR(void* next_ = nullptr)

      : Parent(StructureType::GraphicsRequirementsOpenGLKHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsOpenGLKHR(const GraphicsRequirementsOpenGLKHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsOpenGLKHR& operator=(const GraphicsRequirementsOpenGLKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsOpenGLKHR(const XrGraphicsRequirementsOpenGLKHR& rhs)
      : GraphicsRequirementsOpenGLKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsOpenGLKHR& operator=(const XrGraphicsRequirementsOpenGLKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsOpenGLKHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsOpenGLKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsOpenGLKHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsOpenGLKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsOpenGLKHR
  XrGraphicsRequirementsOpenGLKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsOpenGLKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsOpenGLKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsOpenGLKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsOpenGLKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsOpenGLKHR*>(this);
  }
  Version minApiVersionSupported;
  Version maxApiVersionSupported;
};
static_assert(sizeof(XrGraphicsRequirementsOpenGLKHR) == sizeof(GraphicsRequirementsOpenGLKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsOpenGLKHR pointer to const from a
 * GraphicsRequirementsOpenGLKHR reference to const.
 * @relates GraphicsRequirementsOpenGLKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLKHR const* get(
    GraphicsRequirementsOpenGLKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsOpenGLKHR
 * as the address of a raw XrGraphicsRequirementsOpenGLKHR
 * @relates GraphicsRequirementsOpenGLKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLKHR* put(GraphicsRequirementsOpenGLKHR& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrGraphicsBindingOpenGLESAndroidKHR
 *
 * Provided by the `XR_KHR_opengl_es_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingOpenGLESAndroidKHR>
 * @xrentity{XrGraphicsBindingOpenGLESAndroidKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingOpenGLESAndroidKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingOpenGLESAndroidKHR(EGLDisplay display_, EGLConfig config_, EGLContext context_,
                                    const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingOpenGLESAndroidKHR, next_),
        display{display_},
        config{config_},
        context{context_} {}

  //! Default/empty constructor
  GraphicsBindingOpenGLESAndroidKHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingOpenGLESAndroidKHR, next_),
        display{},
        config{},
        context{} {}

  //! Default copy constructor
  GraphicsBindingOpenGLESAndroidKHR(const GraphicsBindingOpenGLESAndroidKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingOpenGLESAndroidKHR& operator=(const GraphicsBindingOpenGLESAndroidKHR& rhs) =
      default;
  //! Copy construct from raw
  GraphicsBindingOpenGLESAndroidKHR(const XrGraphicsBindingOpenGLESAndroidKHR& rhs)
      : GraphicsBindingOpenGLESAndroidKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingOpenGLESAndroidKHR& operator=(const XrGraphicsBindingOpenGLESAndroidKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingOpenGLESAndroidKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingOpenGLESAndroidKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingOpenGLESAndroidKHR&() {
    return *reinterpret_cast<XrGraphicsBindingOpenGLESAndroidKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingOpenGLESAndroidKHR
  XrGraphicsBindingOpenGLESAndroidKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingOpenGLESAndroidKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingOpenGLESAndroidKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingOpenGLESAndroidKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingOpenGLESAndroidKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingOpenGLESAndroidKHR*>(this);
  }
  EGLDisplay display;
  EGLConfig config;
  EGLContext context;
};
static_assert(sizeof(XrGraphicsBindingOpenGLESAndroidKHR) ==
                  sizeof(GraphicsBindingOpenGLESAndroidKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingOpenGLESAndroidKHR pointer to const from
 * a GraphicsBindingOpenGLESAndroidKHR reference to const.
 * @relates GraphicsBindingOpenGLESAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLESAndroidKHR const* get(
    GraphicsBindingOpenGLESAndroidKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * GraphicsBindingOpenGLESAndroidKHR as the address of a raw XrGraphicsBindingOpenGLESAndroidKHR
 * @relates GraphicsBindingOpenGLESAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingOpenGLESAndroidKHR* put(
    GraphicsBindingOpenGLESAndroidKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
/*!
 * C++ projection of XrSwapchainImageOpenGLESKHR
 *
 * Provided by the `XR_KHR_opengl_es_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageOpenGLESKHR>
 * @xrentity{XrSwapchainImageOpenGLESKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageOpenGLESKHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageOpenGLESKHR(void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageOpenGLESKHR, next_) {}

  //! Default copy constructor
  SwapchainImageOpenGLESKHR(const SwapchainImageOpenGLESKHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageOpenGLESKHR& operator=(const SwapchainImageOpenGLESKHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageOpenGLESKHR(const XrSwapchainImageOpenGLESKHR& rhs) : SwapchainImageOpenGLESKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageOpenGLESKHR& operator=(const XrSwapchainImageOpenGLESKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageOpenGLESKHR&() const {
    return *reinterpret_cast<const XrSwapchainImageOpenGLESKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageOpenGLESKHR&() {
    return *reinterpret_cast<XrSwapchainImageOpenGLESKHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageOpenGLESKHR
  XrSwapchainImageOpenGLESKHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageOpenGLESKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageOpenGLESKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageOpenGLESKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageOpenGLESKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageOpenGLESKHR*>(this);
  }
  uint32_t image;
};
static_assert(sizeof(XrSwapchainImageOpenGLESKHR) == sizeof(SwapchainImageOpenGLESKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageOpenGLESKHR pointer to const from a
 * SwapchainImageOpenGLESKHR reference to const.
 * @relates SwapchainImageOpenGLESKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageOpenGLESKHR const* get(
    SwapchainImageOpenGLESKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageOpenGLESKHR as
 * the address of a raw XrSwapchainImageOpenGLESKHR
 * @relates SwapchainImageOpenGLESKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageOpenGLESKHR* put(SwapchainImageOpenGLESKHR& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageOpenGLESKHR as a raw,
 * pointer to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageOpenGLESKHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageOpenGLESKHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
/*!
 * C++ projection of XrGraphicsRequirementsOpenGLESKHR
 *
 * Provided by the `XR_KHR_opengl_es_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsOpenGLESKHR>
 * @xrentity{XrGraphicsRequirementsOpenGLESKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsOpenGLESKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsOpenGLESKHR(void* next_ = nullptr)

      : Parent(StructureType::GraphicsRequirementsOpenGLESKHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsOpenGLESKHR(const GraphicsRequirementsOpenGLESKHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsOpenGLESKHR& operator=(const GraphicsRequirementsOpenGLESKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsOpenGLESKHR(const XrGraphicsRequirementsOpenGLESKHR& rhs)
      : GraphicsRequirementsOpenGLESKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsOpenGLESKHR& operator=(const XrGraphicsRequirementsOpenGLESKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsOpenGLESKHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsOpenGLESKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsOpenGLESKHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsOpenGLESKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsOpenGLESKHR
  XrGraphicsRequirementsOpenGLESKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsOpenGLESKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsOpenGLESKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsOpenGLESKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsOpenGLESKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsOpenGLESKHR*>(this);
  }
  Version minApiVersionSupported;
  Version maxApiVersionSupported;
};
static_assert(sizeof(XrGraphicsRequirementsOpenGLESKHR) == sizeof(GraphicsRequirementsOpenGLESKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsOpenGLESKHR pointer to const from a
 * GraphicsRequirementsOpenGLESKHR reference to const.
 * @relates GraphicsRequirementsOpenGLESKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLESKHR const* get(
    GraphicsRequirementsOpenGLESKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * GraphicsRequirementsOpenGLESKHR as the address of a raw XrGraphicsRequirementsOpenGLESKHR
 * @relates GraphicsRequirementsOpenGLESKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsOpenGLESKHR* put(GraphicsRequirementsOpenGLESKHR& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrGraphicsBindingVulkanKHR
 *
 * Provided by the `XR_KHR_vulkan_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingVulkanKHR>
 * @xrentity{XrGraphicsBindingVulkanKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingVulkanKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingVulkanKHR(VkInstance instance_, VkPhysicalDevice physicalDevice_, VkDevice device_,
                           uint32_t queueFamilyIndex_, uint32_t queueIndex_,
                           const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingVulkanKHR, next_),
        instance{instance_},
        physicalDevice{physicalDevice_},
        device{device_},
        queueFamilyIndex{queueFamilyIndex_},
        queueIndex{queueIndex_} {}

  //! Default/empty constructor
  GraphicsBindingVulkanKHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingVulkanKHR, next_),
        instance{},
        physicalDevice{},
        device{},
        queueFamilyIndex{0},
        queueIndex{0} {}

  //! Default copy constructor
  GraphicsBindingVulkanKHR(const GraphicsBindingVulkanKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingVulkanKHR& operator=(const GraphicsBindingVulkanKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingVulkanKHR(const XrGraphicsBindingVulkanKHR& rhs) : GraphicsBindingVulkanKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingVulkanKHR& operator=(const XrGraphicsBindingVulkanKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingVulkanKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingVulkanKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingVulkanKHR&() {
    return *reinterpret_cast<XrGraphicsBindingVulkanKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingVulkanKHR
  XrGraphicsBindingVulkanKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingVulkanKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingVulkanKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingVulkanKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingVulkanKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingVulkanKHR*>(this);
  }
  VkInstance instance;
  VkPhysicalDevice physicalDevice;
  VkDevice device;
  uint32_t queueFamilyIndex;
  uint32_t queueIndex;
};
static_assert(sizeof(XrGraphicsBindingVulkanKHR) == sizeof(GraphicsBindingVulkanKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingVulkanKHR pointer to const from a
 * GraphicsBindingVulkanKHR reference to const.
 * @relates GraphicsBindingVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingVulkanKHR const* get(GraphicsBindingVulkanKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingVulkanKHR as
 * the address of a raw XrGraphicsBindingVulkanKHR
 * @relates GraphicsBindingVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingVulkanKHR* put(GraphicsBindingVulkanKHR& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrSwapchainImageVulkanKHR
 *
 * Provided by the `XR_KHR_vulkan_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageVulkanKHR>
 * @xrentity{XrSwapchainImageVulkanKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageVulkanKHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageVulkanKHR(void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageVulkanKHR, next_) {}

  //! Default copy constructor
  SwapchainImageVulkanKHR(const SwapchainImageVulkanKHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageVulkanKHR& operator=(const SwapchainImageVulkanKHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageVulkanKHR(const XrSwapchainImageVulkanKHR& rhs) : SwapchainImageVulkanKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageVulkanKHR& operator=(const XrSwapchainImageVulkanKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageVulkanKHR&() const {
    return *reinterpret_cast<const XrSwapchainImageVulkanKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageVulkanKHR&() {
    return *reinterpret_cast<XrSwapchainImageVulkanKHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageVulkanKHR
  XrSwapchainImageVulkanKHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageVulkanKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageVulkanKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageVulkanKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageVulkanKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageVulkanKHR*>(this);
  }
  VkImage image;
};
static_assert(sizeof(XrSwapchainImageVulkanKHR) == sizeof(SwapchainImageVulkanKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageVulkanKHR pointer to const from a
 * SwapchainImageVulkanKHR reference to const.
 * @relates SwapchainImageVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageVulkanKHR const* get(SwapchainImageVulkanKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageVulkanKHR as
 * the address of a raw XrSwapchainImageVulkanKHR
 * @relates SwapchainImageVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageVulkanKHR* put(SwapchainImageVulkanKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageVulkanKHR as a raw, pointer
 * to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageVulkanKHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageVulkanKHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrGraphicsRequirementsVulkanKHR
 *
 * Provided by the `XR_KHR_vulkan_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsVulkanKHR>
 * @xrentity{XrGraphicsRequirementsVulkanKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsVulkanKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsVulkanKHR(void* next_ = nullptr)

      : Parent(StructureType::GraphicsRequirementsVulkanKHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsVulkanKHR(const GraphicsRequirementsVulkanKHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsVulkanKHR& operator=(const GraphicsRequirementsVulkanKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsVulkanKHR(const XrGraphicsRequirementsVulkanKHR& rhs)
      : GraphicsRequirementsVulkanKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsVulkanKHR& operator=(const XrGraphicsRequirementsVulkanKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsVulkanKHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsVulkanKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsVulkanKHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsVulkanKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsVulkanKHR
  XrGraphicsRequirementsVulkanKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsVulkanKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsVulkanKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsVulkanKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsVulkanKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsVulkanKHR*>(this);
  }
  Version minApiVersionSupported;
  Version maxApiVersionSupported;
};
static_assert(sizeof(XrGraphicsRequirementsVulkanKHR) == sizeof(GraphicsRequirementsVulkanKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsVulkanKHR pointer to const from a
 * GraphicsRequirementsVulkanKHR reference to const.
 * @relates GraphicsRequirementsVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsVulkanKHR const* get(
    GraphicsRequirementsVulkanKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsVulkanKHR
 * as the address of a raw XrGraphicsRequirementsVulkanKHR
 * @relates GraphicsRequirementsVulkanKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsVulkanKHR* put(GraphicsRequirementsVulkanKHR& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)
/*!
 * C++ projection of XrGraphicsBindingD3D11KHR
 *
 * Provided by the `XR_KHR_D3D11_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingD3D11KHR>
 * @xrentity{XrGraphicsBindingD3D11KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingD3D11KHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingD3D11KHR(ID3D11Device* device_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingD3D11KHR, next_), device{device_} {}

  //! Default/empty constructor
  GraphicsBindingD3D11KHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingD3D11KHR, next_), device{nullptr} {}

  //! Default copy constructor
  GraphicsBindingD3D11KHR(const GraphicsBindingD3D11KHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingD3D11KHR& operator=(const GraphicsBindingD3D11KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingD3D11KHR(const XrGraphicsBindingD3D11KHR& rhs) : GraphicsBindingD3D11KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingD3D11KHR& operator=(const XrGraphicsBindingD3D11KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingD3D11KHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingD3D11KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingD3D11KHR&() {
    return *reinterpret_cast<XrGraphicsBindingD3D11KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingD3D11KHR
  XrGraphicsBindingD3D11KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingD3D11KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingD3D11KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingD3D11KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingD3D11KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingD3D11KHR*>(this);
  }
  ID3D11Device* device;
};
static_assert(sizeof(XrGraphicsBindingD3D11KHR) == sizeof(GraphicsBindingD3D11KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingD3D11KHR pointer to const from a
 * GraphicsBindingD3D11KHR reference to const.
 * @relates GraphicsBindingD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingD3D11KHR const* get(GraphicsBindingD3D11KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingD3D11KHR as
 * the address of a raw XrGraphicsBindingD3D11KHR
 * @relates GraphicsBindingD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingD3D11KHR* put(GraphicsBindingD3D11KHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)
/*!
 * C++ projection of XrSwapchainImageD3D11KHR
 *
 * Provided by the `XR_KHR_D3D11_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageD3D11KHR>
 * @xrentity{XrSwapchainImageD3D11KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageD3D11KHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageD3D11KHR(void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageD3D11KHR, next_) {}

  //! Default copy constructor
  SwapchainImageD3D11KHR(const SwapchainImageD3D11KHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageD3D11KHR& operator=(const SwapchainImageD3D11KHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageD3D11KHR(const XrSwapchainImageD3D11KHR& rhs) : SwapchainImageD3D11KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageD3D11KHR& operator=(const XrSwapchainImageD3D11KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageD3D11KHR&() const {
    return *reinterpret_cast<const XrSwapchainImageD3D11KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageD3D11KHR&() {
    return *reinterpret_cast<XrSwapchainImageD3D11KHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageD3D11KHR
  XrSwapchainImageD3D11KHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageD3D11KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageD3D11KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageD3D11KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageD3D11KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageD3D11KHR*>(this);
  }
  ID3D11Texture2D* texture;
};
static_assert(sizeof(XrSwapchainImageD3D11KHR) == sizeof(SwapchainImageD3D11KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageD3D11KHR pointer to const from a
 * SwapchainImageD3D11KHR reference to const.
 * @relates SwapchainImageD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageD3D11KHR const* get(SwapchainImageD3D11KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageD3D11KHR as the
 * address of a raw XrSwapchainImageD3D11KHR
 * @relates SwapchainImageD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageD3D11KHR* put(SwapchainImageD3D11KHR& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageD3D11KHR as a raw, pointer
 * to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageD3D11KHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageD3D11KHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)
/*!
 * C++ projection of XrGraphicsRequirementsD3D11KHR
 *
 * Provided by the `XR_KHR_D3D11_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsD3D11KHR>
 * @xrentity{XrGraphicsRequirementsD3D11KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsD3D11KHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsD3D11KHR(void* next_ = nullptr)

      : Parent(StructureType::GraphicsRequirementsD3D11KHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsD3D11KHR(const GraphicsRequirementsD3D11KHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsD3D11KHR& operator=(const GraphicsRequirementsD3D11KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsD3D11KHR(const XrGraphicsRequirementsD3D11KHR& rhs)
      : GraphicsRequirementsD3D11KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsD3D11KHR& operator=(const XrGraphicsRequirementsD3D11KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsD3D11KHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsD3D11KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsD3D11KHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsD3D11KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsD3D11KHR
  XrGraphicsRequirementsD3D11KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsD3D11KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsD3D11KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsD3D11KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsD3D11KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsD3D11KHR*>(this);
  }
  LUID adapterLuid;
  D3D_FEATURE_LEVEL minFeatureLevel;
};
static_assert(sizeof(XrGraphicsRequirementsD3D11KHR) == sizeof(GraphicsRequirementsD3D11KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsD3D11KHR pointer to const from a
 * GraphicsRequirementsD3D11KHR reference to const.
 * @relates GraphicsRequirementsD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D11KHR const* get(
    GraphicsRequirementsD3D11KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsD3D11KHR
 * as the address of a raw XrGraphicsRequirementsD3D11KHR
 * @relates GraphicsRequirementsD3D11KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D11KHR* put(GraphicsRequirementsD3D11KHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)
/*!
 * C++ projection of XrGraphicsBindingD3D12KHR
 *
 * Provided by the `XR_KHR_D3D12_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingD3D12KHR>
 * @xrentity{XrGraphicsBindingD3D12KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingD3D12KHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingD3D12KHR(ID3D12Device* device_, ID3D12CommandQueue* queue_,
                          const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingD3D12KHR, next_), device{device_}, queue{queue_} {}

  //! Default/empty constructor
  GraphicsBindingD3D12KHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingD3D12KHR, next_), device{nullptr}, queue{nullptr} {}

  //! Default copy constructor
  GraphicsBindingD3D12KHR(const GraphicsBindingD3D12KHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingD3D12KHR& operator=(const GraphicsBindingD3D12KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingD3D12KHR(const XrGraphicsBindingD3D12KHR& rhs) : GraphicsBindingD3D12KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingD3D12KHR& operator=(const XrGraphicsBindingD3D12KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingD3D12KHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingD3D12KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingD3D12KHR&() {
    return *reinterpret_cast<XrGraphicsBindingD3D12KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingD3D12KHR
  XrGraphicsBindingD3D12KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingD3D12KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingD3D12KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingD3D12KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingD3D12KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingD3D12KHR*>(this);
  }
  ID3D12Device* device;
  ID3D12CommandQueue* queue;
};
static_assert(sizeof(XrGraphicsBindingD3D12KHR) == sizeof(GraphicsBindingD3D12KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingD3D12KHR pointer to const from a
 * GraphicsBindingD3D12KHR reference to const.
 * @relates GraphicsBindingD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingD3D12KHR const* get(GraphicsBindingD3D12KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingD3D12KHR as
 * the address of a raw XrGraphicsBindingD3D12KHR
 * @relates GraphicsBindingD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingD3D12KHR* put(GraphicsBindingD3D12KHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)
/*!
 * C++ projection of XrSwapchainImageD3D12KHR
 *
 * Provided by the `XR_KHR_D3D12_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageD3D12KHR>
 * @xrentity{XrSwapchainImageD3D12KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageD3D12KHR : public SwapchainImageBaseHeader {
private:
  using Parent = SwapchainImageBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageD3D12KHR(void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageD3D12KHR, next_) {}

  //! Default copy constructor
  SwapchainImageD3D12KHR(const SwapchainImageD3D12KHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageD3D12KHR& operator=(const SwapchainImageD3D12KHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageD3D12KHR(const XrSwapchainImageD3D12KHR& rhs) : SwapchainImageD3D12KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageD3D12KHR& operator=(const XrSwapchainImageD3D12KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageD3D12KHR&() const {
    return *reinterpret_cast<const XrSwapchainImageD3D12KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageD3D12KHR&() {
    return *reinterpret_cast<XrSwapchainImageD3D12KHR*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainImageBaseHeader const pointer
  XrSwapchainImageBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainImageBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainImageD3D12KHR
  XrSwapchainImageD3D12KHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageD3D12KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageD3D12KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageD3D12KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageD3D12KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageD3D12KHR*>(this);
  }
  ID3D12Resource* texture;
};
static_assert(sizeof(XrSwapchainImageD3D12KHR) == sizeof(SwapchainImageD3D12KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageD3D12KHR pointer to const from a
 * SwapchainImageD3D12KHR reference to const.
 * @relates SwapchainImageD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageD3D12KHR const* get(SwapchainImageD3D12KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageD3D12KHR as the
 * address of a raw XrSwapchainImageD3D12KHR
 * @relates SwapchainImageD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageD3D12KHR* put(SwapchainImageD3D12KHR& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainImageD3D12KHR as a raw, pointer
 * to const XrSwapchainImageBaseHeader (the base type)
 * @relates SwapchainImageD3D12KHR
 * @relatesalso SwapchainImageBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageBaseHeader const* get_base(
    SwapchainImageD3D12KHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)
/*!
 * C++ projection of XrGraphicsRequirementsD3D12KHR
 *
 * Provided by the `XR_KHR_D3D12_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsD3D12KHR>
 * @xrentity{XrGraphicsRequirementsD3D12KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsD3D12KHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsD3D12KHR(void* next_ = nullptr)

      : Parent(StructureType::GraphicsRequirementsD3D12KHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsD3D12KHR(const GraphicsRequirementsD3D12KHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsD3D12KHR& operator=(const GraphicsRequirementsD3D12KHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsD3D12KHR(const XrGraphicsRequirementsD3D12KHR& rhs)
      : GraphicsRequirementsD3D12KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsD3D12KHR& operator=(const XrGraphicsRequirementsD3D12KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsD3D12KHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsD3D12KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsD3D12KHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsD3D12KHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsD3D12KHR
  XrGraphicsRequirementsD3D12KHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsD3D12KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsD3D12KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsD3D12KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsD3D12KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsD3D12KHR*>(this);
  }
  LUID adapterLuid;
  D3D_FEATURE_LEVEL minFeatureLevel;
};
static_assert(sizeof(XrGraphicsRequirementsD3D12KHR) == sizeof(GraphicsRequirementsD3D12KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsD3D12KHR pointer to const from a
 * GraphicsRequirementsD3D12KHR reference to const.
 * @relates GraphicsRequirementsD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D12KHR const* get(
    GraphicsRequirementsD3D12KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsD3D12KHR
 * as the address of a raw XrGraphicsRequirementsD3D12KHR
 * @relates GraphicsRequirementsD3D12KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsD3D12KHR* put(GraphicsRequirementsD3D12KHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_metal_enable
#if defined(XR_USE_GRAPHICS_API_METAL)
/*!
 * C++ projection of XrGraphicsBindingMetalKHR
 *
 * Provided by the `XR_KHR_metal_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingMetalKHR>
 * @xrentity{XrGraphicsBindingMetalKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingMetalKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingMetalKHR(void* XR_MAY_ALIAS commandQueue_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingMetalKHR, next_), commandQueue{commandQueue_} {}

  //! Default/empty constructor
  GraphicsBindingMetalKHR(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingMetalKHR, next_), commandQueue{nullptr} {}

  //! Default copy constructor
  GraphicsBindingMetalKHR(const GraphicsBindingMetalKHR& rhs) = default;
  //! Default copy assignment
  GraphicsBindingMetalKHR& operator=(const GraphicsBindingMetalKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingMetalKHR(const XrGraphicsBindingMetalKHR& rhs) : GraphicsBindingMetalKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingMetalKHR& operator=(const XrGraphicsBindingMetalKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingMetalKHR&() const {
    return *reinterpret_cast<const XrGraphicsBindingMetalKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingMetalKHR&() {
    return *reinterpret_cast<XrGraphicsBindingMetalKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingMetalKHR
  XrGraphicsBindingMetalKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingMetalKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsBindingMetalKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingMetalKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingMetalKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingMetalKHR*>(this);
  }
  void* XR_MAY_ALIAS commandQueue;
};
static_assert(sizeof(XrGraphicsBindingMetalKHR) == sizeof(GraphicsBindingMetalKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingMetalKHR pointer to const from a
 * GraphicsBindingMetalKHR reference to const.
 * @relates GraphicsBindingMetalKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingMetalKHR const* get(GraphicsBindingMetalKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingMetalKHR as
 * the address of a raw XrGraphicsBindingMetalKHR
 * @relates GraphicsBindingMetalKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingMetalKHR* put(GraphicsBindingMetalKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_METAL)
#endif  // XR_KHR_metal_enable

#ifdef XR_KHR_metal_enable
#if defined(XR_USE_GRAPHICS_API_METAL)
/*!
 * C++ projection of XrSwapchainImageMetalKHR
 *
 * Provided by the `XR_KHR_metal_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageMetalKHR>
 * @xrentity{XrSwapchainImageMetalKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageMetalKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SwapchainImageMetalKHR(void* XR_MAY_ALIAS texture_, const void* next_ = nullptr)
      : Parent(StructureType::SwapchainImageMetalKHR, next_), texture{texture_} {}

  //! Default/empty constructor
  SwapchainImageMetalKHR(const void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageMetalKHR, next_), texture{nullptr} {}

  //! Default copy constructor
  SwapchainImageMetalKHR(const SwapchainImageMetalKHR& rhs) = default;
  //! Default copy assignment
  SwapchainImageMetalKHR& operator=(const SwapchainImageMetalKHR& rhs) = default;
  //! Copy construct from raw
  SwapchainImageMetalKHR(const XrSwapchainImageMetalKHR& rhs) : SwapchainImageMetalKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageMetalKHR& operator=(const XrSwapchainImageMetalKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageMetalKHR&() const {
    return *reinterpret_cast<const XrSwapchainImageMetalKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageMetalKHR&() {
    return *reinterpret_cast<XrSwapchainImageMetalKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageMetalKHR
  XrSwapchainImageMetalKHR const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageMetalKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSwapchainImageMetalKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageMetalKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageMetalKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageMetalKHR*>(this);
  }
  void* XR_MAY_ALIAS texture;
};
static_assert(sizeof(XrSwapchainImageMetalKHR) == sizeof(SwapchainImageMetalKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageMetalKHR pointer to const from a
 * SwapchainImageMetalKHR reference to const.
 * @relates SwapchainImageMetalKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageMetalKHR const* get(SwapchainImageMetalKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainImageMetalKHR as the
 * address of a raw XrSwapchainImageMetalKHR
 * @relates SwapchainImageMetalKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageMetalKHR* put(SwapchainImageMetalKHR& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_METAL)
#endif  // XR_KHR_metal_enable

#ifdef XR_KHR_metal_enable
#if defined(XR_USE_GRAPHICS_API_METAL)
/*!
 * C++ projection of XrGraphicsRequirementsMetalKHR
 *
 * Provided by the `XR_KHR_metal_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsRequirementsMetalKHR>
 * @xrentity{XrGraphicsRequirementsMetalKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsRequirementsMetalKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  GraphicsRequirementsMetalKHR(void* next_ = nullptr)

      : Parent(StructureType::GraphicsRequirementsMetalKHR, next_) {}

  //! Default copy constructor
  GraphicsRequirementsMetalKHR(const GraphicsRequirementsMetalKHR& rhs) = default;
  //! Default copy assignment
  GraphicsRequirementsMetalKHR& operator=(const GraphicsRequirementsMetalKHR& rhs) = default;
  //! Copy construct from raw
  GraphicsRequirementsMetalKHR(const XrGraphicsRequirementsMetalKHR& rhs)
      : GraphicsRequirementsMetalKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsRequirementsMetalKHR& operator=(const XrGraphicsRequirementsMetalKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsRequirementsMetalKHR&() const {
    return *reinterpret_cast<const XrGraphicsRequirementsMetalKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsRequirementsMetalKHR&() {
    return *reinterpret_cast<XrGraphicsRequirementsMetalKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsRequirementsMetalKHR
  XrGraphicsRequirementsMetalKHR const* get() const noexcept {
    return reinterpret_cast<XrGraphicsRequirementsMetalKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGraphicsRequirementsMetalKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsRequirementsMetalKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsRequirementsMetalKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsRequirementsMetalKHR*>(this);
  }
  void* XR_MAY_ALIAS metalDevice;
};
static_assert(sizeof(XrGraphicsRequirementsMetalKHR) == sizeof(GraphicsRequirementsMetalKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsRequirementsMetalKHR pointer to const from a
 * GraphicsRequirementsMetalKHR reference to const.
 * @relates GraphicsRequirementsMetalKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsMetalKHR const* get(
    GraphicsRequirementsMetalKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsRequirementsMetalKHR
 * as the address of a raw XrGraphicsRequirementsMetalKHR
 * @relates GraphicsRequirementsMetalKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsRequirementsMetalKHR* put(GraphicsRequirementsMetalKHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_METAL)
#endif  // XR_KHR_metal_enable

#ifdef XR_KHR_visibility_mask
/*!
 * C++ projection of XrVisibilityMaskKHR
 *
 * Provided by the `XR_KHR_visibility_mask` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVisibilityMaskKHR>
 * @xrentity{XrVisibilityMaskKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VisibilityMaskKHR : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  VisibilityMaskKHR(void* next_ = nullptr)

      : Parent(StructureType::VisibilityMaskKHR, next_) {}

  //! Default copy constructor
  VisibilityMaskKHR(const VisibilityMaskKHR& rhs) = default;
  //! Default copy assignment
  VisibilityMaskKHR& operator=(const VisibilityMaskKHR& rhs) = default;
  //! Copy construct from raw
  VisibilityMaskKHR(const XrVisibilityMaskKHR& rhs) : VisibilityMaskKHR() { *put() = rhs; }
  //! Copy assign from raw
  VisibilityMaskKHR& operator=(const XrVisibilityMaskKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVisibilityMaskKHR&() const {
    return *reinterpret_cast<const XrVisibilityMaskKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVisibilityMaskKHR&() { return *reinterpret_cast<XrVisibilityMaskKHR*>(this); }

  //! Accessor for this as the address of a raw XrVisibilityMaskKHR
  XrVisibilityMaskKHR const* get() const noexcept {
    return reinterpret_cast<XrVisibilityMaskKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVisibilityMaskKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVisibilityMaskKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VisibilityMaskKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVisibilityMaskKHR*>(this);
  }
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  Vector2f* vertices;
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  uint32_t* indices;
};
static_assert(sizeof(XrVisibilityMaskKHR) == sizeof(VisibilityMaskKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVisibilityMaskKHR pointer to const from a
 * VisibilityMaskKHR reference to const.
 * @relates VisibilityMaskKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVisibilityMaskKHR const* get(VisibilityMaskKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VisibilityMaskKHR as the
 * address of a raw XrVisibilityMaskKHR
 * @relates VisibilityMaskKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVisibilityMaskKHR* put(VisibilityMaskKHR& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_visibility_mask

#ifdef XR_KHR_visibility_mask
/*!
 * C++ projection of XrEventDataVisibilityMaskChangedKHR
 *
 * Provided by the `XR_KHR_visibility_mask` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVisibilityMaskChangedKHR>
 * @xrentity{XrEventDataVisibilityMaskChangedKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataVisibilityMaskChangedKHR : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataVisibilityMaskChangedKHR(void* next_ = nullptr)

      : Parent(StructureType::EventDataVisibilityMaskChangedKHR, next_) {}

  //! Default copy constructor
  EventDataVisibilityMaskChangedKHR(const EventDataVisibilityMaskChangedKHR& rhs) = default;
  //! Default copy assignment
  EventDataVisibilityMaskChangedKHR& operator=(const EventDataVisibilityMaskChangedKHR& rhs) =
      default;
  //! Copy construct from raw
  EventDataVisibilityMaskChangedKHR(const XrEventDataVisibilityMaskChangedKHR& rhs)
      : EventDataVisibilityMaskChangedKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataVisibilityMaskChangedKHR& operator=(const XrEventDataVisibilityMaskChangedKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataVisibilityMaskChangedKHR&() const {
    return *reinterpret_cast<const XrEventDataVisibilityMaskChangedKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataVisibilityMaskChangedKHR&() {
    return *reinterpret_cast<XrEventDataVisibilityMaskChangedKHR*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataVisibilityMaskChangedKHR
  XrEventDataVisibilityMaskChangedKHR const* get() const noexcept {
    return reinterpret_cast<XrEventDataVisibilityMaskChangedKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataVisibilityMaskChangedKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataVisibilityMaskChangedKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataVisibilityMaskChangedKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataVisibilityMaskChangedKHR*>(this);
  }
  Session session;
  ViewConfigurationType viewConfigurationType;
  uint32_t viewIndex;
};
static_assert(sizeof(XrEventDataVisibilityMaskChangedKHR) ==
                  sizeof(EventDataVisibilityMaskChangedKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataVisibilityMaskChangedKHR pointer to const from
 * a EventDataVisibilityMaskChangedKHR reference to const.
 * @relates EventDataVisibilityMaskChangedKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVisibilityMaskChangedKHR const* get(
    EventDataVisibilityMaskChangedKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataVisibilityMaskChangedKHR as the address of a raw XrEventDataVisibilityMaskChangedKHR
 * @relates EventDataVisibilityMaskChangedKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVisibilityMaskChangedKHR* put(
    EventDataVisibilityMaskChangedKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataVisibilityMaskChangedKHR as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataVisibilityMaskChangedKHR
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataVisibilityMaskChangedKHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_visibility_mask

#ifdef XR_KHR_composition_layer_color_scale_bias
/*!
 * C++ projection of XrCompositionLayerColorScaleBiasKHR
 *
 * Provided by the `XR_KHR_composition_layer_color_scale_bias` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerColorScaleBiasKHR>
 * @xrentity{XrCompositionLayerColorScaleBiasKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerColorScaleBiasKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerColorScaleBiasKHR(const Color4f& colorScale_, const Color4f& colorBias_,
                                    const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerColorScaleBiasKHR, next_),
        colorScale{colorScale_},
        colorBias{colorBias_} {}

  //! Default/empty constructor
  CompositionLayerColorScaleBiasKHR(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerColorScaleBiasKHR, next_),
        colorScale{},
        colorBias{} {}

  //! Default copy constructor
  CompositionLayerColorScaleBiasKHR(const CompositionLayerColorScaleBiasKHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerColorScaleBiasKHR& operator=(const CompositionLayerColorScaleBiasKHR& rhs) =
      default;
  //! Copy construct from raw
  CompositionLayerColorScaleBiasKHR(const XrCompositionLayerColorScaleBiasKHR& rhs)
      : CompositionLayerColorScaleBiasKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerColorScaleBiasKHR& operator=(const XrCompositionLayerColorScaleBiasKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerColorScaleBiasKHR&() const {
    return *reinterpret_cast<const XrCompositionLayerColorScaleBiasKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerColorScaleBiasKHR&() {
    return *reinterpret_cast<XrCompositionLayerColorScaleBiasKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerColorScaleBiasKHR
  XrCompositionLayerColorScaleBiasKHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerColorScaleBiasKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerColorScaleBiasKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerColorScaleBiasKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerColorScaleBiasKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerColorScaleBiasKHR*>(this);
  }
  Color4f colorScale;
  Color4f colorBias;
};
static_assert(sizeof(XrCompositionLayerColorScaleBiasKHR) ==
                  sizeof(CompositionLayerColorScaleBiasKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerColorScaleBiasKHR pointer to const from
 * a CompositionLayerColorScaleBiasKHR reference to const.
 * @relates CompositionLayerColorScaleBiasKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerColorScaleBiasKHR const* get(
    CompositionLayerColorScaleBiasKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerColorScaleBiasKHR as the address of a raw XrCompositionLayerColorScaleBiasKHR
 * @relates CompositionLayerColorScaleBiasKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerColorScaleBiasKHR* put(
    CompositionLayerColorScaleBiasKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_composition_layer_color_scale_bias

#ifdef XR_KHR_loader_init
/*!
 * C++ projection of XrLoaderInitInfoBaseHeaderKHR
 *
 * Provided by the `XR_KHR_loader_init` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLoaderInitInfoBaseHeaderKHR>
 * @xrentity{XrLoaderInitInfoBaseHeaderKHR}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS LoaderInitInfoBaseHeaderKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  LoaderInitInfoBaseHeaderKHR(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrLoaderInitInfoBaseHeaderKHR&() const {
    return *reinterpret_cast<const XrLoaderInitInfoBaseHeaderKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrLoaderInitInfoBaseHeaderKHR&() {
    return *reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrLoaderInitInfoBaseHeaderKHR
  XrLoaderInitInfoBaseHeaderKHR const* get() const noexcept {
    return reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw XrLoaderInitInfoBaseHeaderKHR.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrLoaderInitInfoBaseHeaderKHR* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR*>(this);
  }
};
static_assert(sizeof(XrLoaderInitInfoBaseHeaderKHR) == sizeof(LoaderInitInfoBaseHeaderKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrLoaderInitInfoBaseHeaderKHR pointer to const from a
 * LoaderInitInfoBaseHeaderKHR reference to const.
 * @relates LoaderInitInfoBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoBaseHeaderKHR const* get(
    LoaderInitInfoBaseHeaderKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing LoaderInitInfoBaseHeaderKHR
 * as the address of a raw XrLoaderInitInfoBaseHeaderKHR
 * @relates LoaderInitInfoBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoBaseHeaderKHR* put(LoaderInitInfoBaseHeaderKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_loader_init

#ifdef XR_KHR_loader_init_android
#if defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrLoaderInitInfoAndroidKHR
 *
 * Provided by the `XR_KHR_loader_init_android` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLoaderInitInfoAndroidKHR>
 * @xrentity{XrLoaderInitInfoAndroidKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS LoaderInitInfoAndroidKHR : public LoaderInitInfoBaseHeaderKHR {
private:
  using Parent = LoaderInitInfoBaseHeaderKHR;

public:
  //! Constructor initializing all members.
  LoaderInitInfoAndroidKHR(void* XR_MAY_ALIAS applicationVM_,
                           void* XR_MAY_ALIAS applicationContext_, const void* next_ = nullptr)
      : Parent(StructureType::LoaderInitInfoAndroidKHR, next_),
        applicationVM{applicationVM_},
        applicationContext{applicationContext_} {}

  //! Default/empty constructor
  LoaderInitInfoAndroidKHR(const void* next_ = nullptr)

      : Parent(StructureType::LoaderInitInfoAndroidKHR, next_),
        applicationVM{nullptr},
        applicationContext{nullptr} {}

  //! Default copy constructor
  LoaderInitInfoAndroidKHR(const LoaderInitInfoAndroidKHR& rhs) = default;
  //! Default copy assignment
  LoaderInitInfoAndroidKHR& operator=(const LoaderInitInfoAndroidKHR& rhs) = default;
  //! Copy construct from raw
  LoaderInitInfoAndroidKHR(const XrLoaderInitInfoAndroidKHR& rhs) : LoaderInitInfoAndroidKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  LoaderInitInfoAndroidKHR& operator=(const XrLoaderInitInfoAndroidKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrLoaderInitInfoAndroidKHR&() const {
    return *reinterpret_cast<const XrLoaderInitInfoAndroidKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrLoaderInitInfoAndroidKHR&() {
    return *reinterpret_cast<XrLoaderInitInfoAndroidKHR*>(this);
  }

  //! Accessor for this as a raw, base XrLoaderInitInfoBaseHeaderKHR const pointer
  XrLoaderInitInfoBaseHeaderKHR const* get_base() const noexcept {
    return reinterpret_cast<XrLoaderInitInfoBaseHeaderKHR const*>(this);
  }
  //! Accessor for this as the address of a raw XrLoaderInitInfoAndroidKHR
  XrLoaderInitInfoAndroidKHR const* get() const noexcept {
    return reinterpret_cast<XrLoaderInitInfoAndroidKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrLoaderInitInfoAndroidKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrLoaderInitInfoAndroidKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = LoaderInitInfoAndroidKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrLoaderInitInfoAndroidKHR*>(this);
  }
  void* XR_MAY_ALIAS applicationVM;
  void* XR_MAY_ALIAS applicationContext;
};
static_assert(sizeof(XrLoaderInitInfoAndroidKHR) == sizeof(LoaderInitInfoAndroidKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrLoaderInitInfoAndroidKHR pointer to const from a
 * LoaderInitInfoAndroidKHR reference to const.
 * @relates LoaderInitInfoAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoAndroidKHR const* get(LoaderInitInfoAndroidKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing LoaderInitInfoAndroidKHR as
 * the address of a raw XrLoaderInitInfoAndroidKHR
 * @relates LoaderInitInfoAndroidKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoAndroidKHR* put(LoaderInitInfoAndroidKHR& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const LoaderInitInfoAndroidKHR as a raw, pointer
 * to const XrLoaderInitInfoBaseHeaderKHR (the base type)
 * @relates LoaderInitInfoAndroidKHR
 * @relatesalso LoaderInitInfoBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLoaderInitInfoBaseHeaderKHR const* get_base(
    LoaderInitInfoAndroidKHR const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_loader_init_android

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanInstanceCreateInfoKHR
 *
 * Provided by the `XR_KHR_vulkan_enable2` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanInstanceCreateInfoKHR>
 * @xrentity{XrVulkanInstanceCreateInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanInstanceCreateInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanInstanceCreateInfoKHR(const SystemId& systemId_,
                              const VulkanInstanceCreateFlagsKHR& createFlags_,
                              PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr_,
                              const VkInstanceCreateInfo* vulkanCreateInfo_,
                              const VkAllocationCallbacks* vulkanAllocator_,
                              const void* next_ = nullptr)
      : Parent(StructureType::VulkanInstanceCreateInfoKHR, next_),
        systemId{systemId_},
        createFlags{createFlags_},
        pfnGetInstanceProcAddr{pfnGetInstanceProcAddr_},
        vulkanCreateInfo{vulkanCreateInfo_},
        vulkanAllocator{vulkanAllocator_} {}

  //! Default/empty constructor
  VulkanInstanceCreateInfoKHR(const void* next_ = nullptr)

      : Parent(StructureType::VulkanInstanceCreateInfoKHR, next_),
        systemId{},
        createFlags{},
        pfnGetInstanceProcAddr{nullptr},
        vulkanCreateInfo{nullptr},
        vulkanAllocator{nullptr} {}

  //! Default copy constructor
  VulkanInstanceCreateInfoKHR(const VulkanInstanceCreateInfoKHR& rhs) = default;
  //! Default copy assignment
  VulkanInstanceCreateInfoKHR& operator=(const VulkanInstanceCreateInfoKHR& rhs) = default;
  //! Copy construct from raw
  VulkanInstanceCreateInfoKHR(const XrVulkanInstanceCreateInfoKHR& rhs)
      : VulkanInstanceCreateInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanInstanceCreateInfoKHR& operator=(const XrVulkanInstanceCreateInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanInstanceCreateInfoKHR&() const {
    return *reinterpret_cast<const XrVulkanInstanceCreateInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanInstanceCreateInfoKHR&() {
    return *reinterpret_cast<XrVulkanInstanceCreateInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanInstanceCreateInfoKHR
  XrVulkanInstanceCreateInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrVulkanInstanceCreateInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanInstanceCreateInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanInstanceCreateInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanInstanceCreateInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanInstanceCreateInfoKHR*>(this);
  }
  SystemId systemId;
  VulkanInstanceCreateFlagsKHR createFlags;
  PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr;
  const VkInstanceCreateInfo* vulkanCreateInfo;
  const VkAllocationCallbacks* vulkanAllocator;
};
static_assert(sizeof(XrVulkanInstanceCreateInfoKHR) == sizeof(VulkanInstanceCreateInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanInstanceCreateInfoKHR pointer to const from a
 * VulkanInstanceCreateInfoKHR reference to const.
 * @relates VulkanInstanceCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanInstanceCreateInfoKHR const* get(
    VulkanInstanceCreateInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VulkanInstanceCreateInfoKHR
 * as the address of a raw XrVulkanInstanceCreateInfoKHR
 * @relates VulkanInstanceCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanInstanceCreateInfoKHR* put(VulkanInstanceCreateInfoKHR& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanDeviceCreateInfoKHR
 *
 * Provided by the `XR_KHR_vulkan_enable2` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanDeviceCreateInfoKHR>
 * @xrentity{XrVulkanDeviceCreateInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanDeviceCreateInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanDeviceCreateInfoKHR(const SystemId& systemId_,
                            const VulkanDeviceCreateFlagsKHR& createFlags_,
                            PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr_,
                            VkPhysicalDevice vulkanPhysicalDevice_,
                            const VkDeviceCreateInfo* vulkanCreateInfo_,
                            const VkAllocationCallbacks* vulkanAllocator_,
                            const void* next_ = nullptr)
      : Parent(StructureType::VulkanDeviceCreateInfoKHR, next_),
        systemId{systemId_},
        createFlags{createFlags_},
        pfnGetInstanceProcAddr{pfnGetInstanceProcAddr_},
        vulkanPhysicalDevice{vulkanPhysicalDevice_},
        vulkanCreateInfo{vulkanCreateInfo_},
        vulkanAllocator{vulkanAllocator_} {}

  //! Default/empty constructor
  VulkanDeviceCreateInfoKHR(const void* next_ = nullptr)

      : Parent(StructureType::VulkanDeviceCreateInfoKHR, next_),
        systemId{},
        createFlags{},
        pfnGetInstanceProcAddr{nullptr},
        vulkanPhysicalDevice{},
        vulkanCreateInfo{nullptr},
        vulkanAllocator{nullptr} {}

  //! Default copy constructor
  VulkanDeviceCreateInfoKHR(const VulkanDeviceCreateInfoKHR& rhs) = default;
  //! Default copy assignment
  VulkanDeviceCreateInfoKHR& operator=(const VulkanDeviceCreateInfoKHR& rhs) = default;
  //! Copy construct from raw
  VulkanDeviceCreateInfoKHR(const XrVulkanDeviceCreateInfoKHR& rhs) : VulkanDeviceCreateInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanDeviceCreateInfoKHR& operator=(const XrVulkanDeviceCreateInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanDeviceCreateInfoKHR&() const {
    return *reinterpret_cast<const XrVulkanDeviceCreateInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanDeviceCreateInfoKHR&() {
    return *reinterpret_cast<XrVulkanDeviceCreateInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanDeviceCreateInfoKHR
  XrVulkanDeviceCreateInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrVulkanDeviceCreateInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanDeviceCreateInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanDeviceCreateInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanDeviceCreateInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanDeviceCreateInfoKHR*>(this);
  }
  SystemId systemId;
  VulkanDeviceCreateFlagsKHR createFlags;
  PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr;
  VkPhysicalDevice vulkanPhysicalDevice;
  const VkDeviceCreateInfo* vulkanCreateInfo;
  const VkAllocationCallbacks* vulkanAllocator;
};
static_assert(sizeof(XrVulkanDeviceCreateInfoKHR) == sizeof(VulkanDeviceCreateInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanDeviceCreateInfoKHR pointer to const from a
 * VulkanDeviceCreateInfoKHR reference to const.
 * @relates VulkanDeviceCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanDeviceCreateInfoKHR const* get(
    VulkanDeviceCreateInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VulkanDeviceCreateInfoKHR as
 * the address of a raw XrVulkanDeviceCreateInfoKHR
 * @relates VulkanDeviceCreateInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanDeviceCreateInfoKHR* put(VulkanDeviceCreateInfoKHR& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanGraphicsDeviceGetInfoKHR
 *
 * Provided by the `XR_KHR_vulkan_enable2` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanGraphicsDeviceGetInfoKHR>
 * @xrentity{XrVulkanGraphicsDeviceGetInfoKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanGraphicsDeviceGetInfoKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanGraphicsDeviceGetInfoKHR(const SystemId& systemId_, VkInstance vulkanInstance_,
                                 const void* next_ = nullptr)
      : Parent(StructureType::VulkanGraphicsDeviceGetInfoKHR, next_),
        systemId{systemId_},
        vulkanInstance{vulkanInstance_} {}

  //! Default/empty constructor
  VulkanGraphicsDeviceGetInfoKHR(const void* next_ = nullptr)

      : Parent(StructureType::VulkanGraphicsDeviceGetInfoKHR, next_),
        systemId{},
        vulkanInstance{} {}

  //! Default copy constructor
  VulkanGraphicsDeviceGetInfoKHR(const VulkanGraphicsDeviceGetInfoKHR& rhs) = default;
  //! Default copy assignment
  VulkanGraphicsDeviceGetInfoKHR& operator=(const VulkanGraphicsDeviceGetInfoKHR& rhs) = default;
  //! Copy construct from raw
  VulkanGraphicsDeviceGetInfoKHR(const XrVulkanGraphicsDeviceGetInfoKHR& rhs)
      : VulkanGraphicsDeviceGetInfoKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanGraphicsDeviceGetInfoKHR& operator=(const XrVulkanGraphicsDeviceGetInfoKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanGraphicsDeviceGetInfoKHR&() const {
    return *reinterpret_cast<const XrVulkanGraphicsDeviceGetInfoKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanGraphicsDeviceGetInfoKHR&() {
    return *reinterpret_cast<XrVulkanGraphicsDeviceGetInfoKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanGraphicsDeviceGetInfoKHR
  XrVulkanGraphicsDeviceGetInfoKHR const* get() const noexcept {
    return reinterpret_cast<XrVulkanGraphicsDeviceGetInfoKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanGraphicsDeviceGetInfoKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanGraphicsDeviceGetInfoKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanGraphicsDeviceGetInfoKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanGraphicsDeviceGetInfoKHR*>(this);
  }
  SystemId systemId;
  VkInstance vulkanInstance;
};
static_assert(sizeof(XrVulkanGraphicsDeviceGetInfoKHR) == sizeof(VulkanGraphicsDeviceGetInfoKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanGraphicsDeviceGetInfoKHR pointer to const from a
 * VulkanGraphicsDeviceGetInfoKHR reference to const.
 * @relates VulkanGraphicsDeviceGetInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanGraphicsDeviceGetInfoKHR const* get(
    VulkanGraphicsDeviceGetInfoKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VulkanGraphicsDeviceGetInfoKHR as the address of a raw XrVulkanGraphicsDeviceGetInfoKHR
 * @relates VulkanGraphicsDeviceGetInfoKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanGraphicsDeviceGetInfoKHR* put(VulkanGraphicsDeviceGetInfoKHR& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_composition_layer_equirect2
/*!
 * C++ projection of XrCompositionLayerEquirect2KHR
 *
 * Provided by the `XR_KHR_composition_layer_equirect2` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerEquirect2KHR>
 * @xrentity{XrCompositionLayerEquirect2KHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerEquirect2KHR : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerEquirect2KHR(const CompositionLayerFlags& layerFlags_, const Space& space_,
                               const EyeVisibility& eyeVisibility_,
                               const SwapchainSubImage& subImage_, const Posef& pose_,
                               float radius_, float centralHorizontalAngle_,
                               float upperVerticalAngle_, float lowerVerticalAngle_,
                               const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerEquirect2KHR, layerFlags_, space_, next_),
        eyeVisibility{eyeVisibility_},
        subImage{subImage_},
        pose{pose_},
        radius{radius_},
        centralHorizontalAngle{centralHorizontalAngle_},
        upperVerticalAngle{upperVerticalAngle_},
        lowerVerticalAngle{lowerVerticalAngle_} {}

  //! Default/empty constructor
  CompositionLayerEquirect2KHR(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerEquirect2KHR, {}, {}, next_),
        eyeVisibility{},
        subImage{},
        pose{},
        radius{0.0f},
        centralHorizontalAngle{0.0f},
        upperVerticalAngle{0.0f},
        lowerVerticalAngle{0.0f} {}

  //! Default copy constructor
  CompositionLayerEquirect2KHR(const CompositionLayerEquirect2KHR& rhs) = default;
  //! Default copy assignment
  CompositionLayerEquirect2KHR& operator=(const CompositionLayerEquirect2KHR& rhs) = default;
  //! Copy construct from raw
  CompositionLayerEquirect2KHR(const XrCompositionLayerEquirect2KHR& rhs)
      : CompositionLayerEquirect2KHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerEquirect2KHR& operator=(const XrCompositionLayerEquirect2KHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerEquirect2KHR&() const {
    return *reinterpret_cast<const XrCompositionLayerEquirect2KHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerEquirect2KHR&() {
    return *reinterpret_cast<XrCompositionLayerEquirect2KHR*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerEquirect2KHR
  XrCompositionLayerEquirect2KHR const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerEquirect2KHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerEquirect2KHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerEquirect2KHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerEquirect2KHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerEquirect2KHR*>(this);
  }
  EyeVisibility eyeVisibility;
  SwapchainSubImage subImage;
  Posef pose;
  float radius;
  float centralHorizontalAngle;
  float upperVerticalAngle;
  float lowerVerticalAngle;
};
static_assert(sizeof(XrCompositionLayerEquirect2KHR) == sizeof(CompositionLayerEquirect2KHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerEquirect2KHR pointer to const from a
 * CompositionLayerEquirect2KHR reference to const.
 * @relates CompositionLayerEquirect2KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerEquirect2KHR const* get(
    CompositionLayerEquirect2KHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerEquirect2KHR
 * as the address of a raw XrCompositionLayerEquirect2KHR
 * @relates CompositionLayerEquirect2KHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerEquirect2KHR* put(CompositionLayerEquirect2KHR& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerEquirect2KHR as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerEquirect2KHR
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerEquirect2KHR const& h) {
  return h.get_base();
}
#endif  // XR_KHR_composition_layer_equirect2

#ifdef XR_KHR_binding_modification
/*!
 * C++ projection of XrBindingModificationBaseHeaderKHR
 *
 * Provided by the `XR_KHR_binding_modification` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBindingModificationBaseHeaderKHR>
 * @xrentity{XrBindingModificationBaseHeaderKHR}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS BindingModificationBaseHeaderKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  BindingModificationBaseHeaderKHR(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBindingModificationBaseHeaderKHR&() const {
    return *reinterpret_cast<const XrBindingModificationBaseHeaderKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBindingModificationBaseHeaderKHR&() {
    return *reinterpret_cast<XrBindingModificationBaseHeaderKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrBindingModificationBaseHeaderKHR
  XrBindingModificationBaseHeaderKHR const* get() const noexcept {
    return reinterpret_cast<XrBindingModificationBaseHeaderKHR const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw XrBindingModificationBaseHeaderKHR.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrBindingModificationBaseHeaderKHR* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrBindingModificationBaseHeaderKHR*>(this);
  }
};
static_assert(sizeof(XrBindingModificationBaseHeaderKHR) ==
                  sizeof(BindingModificationBaseHeaderKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBindingModificationBaseHeaderKHR pointer to const from a
 * BindingModificationBaseHeaderKHR reference to const.
 * @relates BindingModificationBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationBaseHeaderKHR const* get(
    BindingModificationBaseHeaderKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * BindingModificationBaseHeaderKHR as the address of a raw XrBindingModificationBaseHeaderKHR
 * @relates BindingModificationBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationBaseHeaderKHR* put(
    BindingModificationBaseHeaderKHR& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_binding_modification

#ifdef XR_KHR_binding_modification
/*!
 * C++ projection of XrBindingModificationsKHR
 *
 * Provided by the `XR_KHR_binding_modification` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBindingModificationsKHR>
 * @xrentity{XrBindingModificationsKHR}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BindingModificationsKHR : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  BindingModificationsKHR(uint32_t bindingModificationCount_,
                          const BindingModificationBaseHeaderKHR* const* bindingModifications_,
                          const void* next_ = nullptr)
      : Parent(StructureType::BindingModificationsKHR, next_),
        bindingModificationCount{bindingModificationCount_},
        bindingModifications{bindingModifications_} {}

  //! Default/empty constructor
  BindingModificationsKHR(const void* next_ = nullptr)

      : Parent(StructureType::BindingModificationsKHR, next_),
        bindingModificationCount{0},
        bindingModifications{nullptr} {}

  //! Default copy constructor
  BindingModificationsKHR(const BindingModificationsKHR& rhs) = default;
  //! Default copy assignment
  BindingModificationsKHR& operator=(const BindingModificationsKHR& rhs) = default;
  //! Copy construct from raw
  BindingModificationsKHR(const XrBindingModificationsKHR& rhs) : BindingModificationsKHR() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BindingModificationsKHR& operator=(const XrBindingModificationsKHR& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBindingModificationsKHR&() const {
    return *reinterpret_cast<const XrBindingModificationsKHR*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBindingModificationsKHR&() {
    return *reinterpret_cast<XrBindingModificationsKHR*>(this);
  }

  //! Accessor for this as the address of a raw XrBindingModificationsKHR
  XrBindingModificationsKHR const* get() const noexcept {
    return reinterpret_cast<XrBindingModificationsKHR const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrBindingModificationsKHR.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBindingModificationsKHR* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BindingModificationsKHR{};
      next = oldNext;
    }
    return reinterpret_cast<XrBindingModificationsKHR*>(this);
  }
  uint32_t bindingModificationCount;
  const BindingModificationBaseHeaderKHR* const* bindingModifications;
};
static_assert(sizeof(XrBindingModificationsKHR) == sizeof(BindingModificationsKHR),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBindingModificationsKHR pointer to const from a
 * BindingModificationsKHR reference to const.
 * @relates BindingModificationsKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationsKHR const* get(BindingModificationsKHR const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BindingModificationsKHR as
 * the address of a raw XrBindingModificationsKHR
 * @relates BindingModificationsKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationsKHR* put(BindingModificationsKHR& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_KHR_binding_modification

#ifdef XR_EXT_performance_settings
/*!
 * C++ projection of XrEventDataPerfSettingsEXT
 *
 * Provided by the `XR_EXT_performance_settings` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataPerfSettingsEXT>
 * @xrentity{XrEventDataPerfSettingsEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataPerfSettingsEXT : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataPerfSettingsEXT(void* next_ = nullptr)

      : Parent(StructureType::EventDataPerfSettingsEXT, next_) {}

  //! Default copy constructor
  EventDataPerfSettingsEXT(const EventDataPerfSettingsEXT& rhs) = default;
  //! Default copy assignment
  EventDataPerfSettingsEXT& operator=(const EventDataPerfSettingsEXT& rhs) = default;
  //! Copy construct from raw
  EventDataPerfSettingsEXT(const XrEventDataPerfSettingsEXT& rhs) : EventDataPerfSettingsEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataPerfSettingsEXT& operator=(const XrEventDataPerfSettingsEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataPerfSettingsEXT&() const {
    return *reinterpret_cast<const XrEventDataPerfSettingsEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataPerfSettingsEXT&() {
    return *reinterpret_cast<XrEventDataPerfSettingsEXT*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataPerfSettingsEXT
  XrEventDataPerfSettingsEXT const* get() const noexcept {
    return reinterpret_cast<XrEventDataPerfSettingsEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataPerfSettingsEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataPerfSettingsEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataPerfSettingsEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataPerfSettingsEXT*>(this);
  }
  PerfSettingsDomainEXT domain;
  PerfSettingsSubDomainEXT subDomain;
  PerfSettingsNotificationLevelEXT fromLevel;
  PerfSettingsNotificationLevelEXT toLevel;
};
static_assert(sizeof(XrEventDataPerfSettingsEXT) == sizeof(EventDataPerfSettingsEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataPerfSettingsEXT pointer to const from a
 * EventDataPerfSettingsEXT reference to const.
 * @relates EventDataPerfSettingsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataPerfSettingsEXT const* get(EventDataPerfSettingsEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataPerfSettingsEXT as
 * the address of a raw XrEventDataPerfSettingsEXT
 * @relates EventDataPerfSettingsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataPerfSettingsEXT* put(EventDataPerfSettingsEXT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataPerfSettingsEXT as a raw, pointer
 * to const XrEventDataBaseHeader (the base type)
 * @relates EventDataPerfSettingsEXT
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(EventDataPerfSettingsEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsObjectNameInfoEXT
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsObjectNameInfoEXT>
 * @xrentity{XrDebugUtilsObjectNameInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DebugUtilsObjectNameInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DebugUtilsObjectNameInfoEXT(const ObjectType& objectType_, uint64_t objectHandle_,
                              const char* objectName_, const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsObjectNameInfoEXT, next_),
        objectType{objectType_},
        objectHandle{objectHandle_},
        objectName{objectName_} {}

  //! Default/empty constructor
  DebugUtilsObjectNameInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::DebugUtilsObjectNameInfoEXT, next_),
        objectType{},
        objectHandle{0},
        objectName{nullptr} {}

  //! Default copy constructor
  DebugUtilsObjectNameInfoEXT(const DebugUtilsObjectNameInfoEXT& rhs) = default;
  //! Default copy assignment
  DebugUtilsObjectNameInfoEXT& operator=(const DebugUtilsObjectNameInfoEXT& rhs) = default;
  //! Copy construct from raw
  DebugUtilsObjectNameInfoEXT(const XrDebugUtilsObjectNameInfoEXT& rhs)
      : DebugUtilsObjectNameInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DebugUtilsObjectNameInfoEXT& operator=(const XrDebugUtilsObjectNameInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDebugUtilsObjectNameInfoEXT&() const {
    return *reinterpret_cast<const XrDebugUtilsObjectNameInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDebugUtilsObjectNameInfoEXT&() {
    return *reinterpret_cast<XrDebugUtilsObjectNameInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrDebugUtilsObjectNameInfoEXT
  XrDebugUtilsObjectNameInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrDebugUtilsObjectNameInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDebugUtilsObjectNameInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDebugUtilsObjectNameInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DebugUtilsObjectNameInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrDebugUtilsObjectNameInfoEXT*>(this);
  }
  ObjectType objectType;
  uint64_t objectHandle;
  const char* objectName;
};
static_assert(sizeof(XrDebugUtilsObjectNameInfoEXT) == sizeof(DebugUtilsObjectNameInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDebugUtilsObjectNameInfoEXT pointer to const from a
 * DebugUtilsObjectNameInfoEXT reference to const.
 * @relates DebugUtilsObjectNameInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsObjectNameInfoEXT const* get(
    DebugUtilsObjectNameInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing DebugUtilsObjectNameInfoEXT
 * as the address of a raw XrDebugUtilsObjectNameInfoEXT
 * @relates DebugUtilsObjectNameInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsObjectNameInfoEXT* put(DebugUtilsObjectNameInfoEXT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsLabelEXT
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsLabelEXT>
 * @xrentity{XrDebugUtilsLabelEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DebugUtilsLabelEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DebugUtilsLabelEXT(const char* labelName_, const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsLabelEXT, next_), labelName{labelName_} {}

  //! Default/empty constructor
  DebugUtilsLabelEXT(const void* next_ = nullptr)

      : Parent(StructureType::DebugUtilsLabelEXT, next_), labelName{nullptr} {}

  //! Default copy constructor
  DebugUtilsLabelEXT(const DebugUtilsLabelEXT& rhs) = default;
  //! Default copy assignment
  DebugUtilsLabelEXT& operator=(const DebugUtilsLabelEXT& rhs) = default;
  //! Copy construct from raw
  DebugUtilsLabelEXT(const XrDebugUtilsLabelEXT& rhs) : DebugUtilsLabelEXT() { *put() = rhs; }
  //! Copy assign from raw
  DebugUtilsLabelEXT& operator=(const XrDebugUtilsLabelEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDebugUtilsLabelEXT&() const {
    return *reinterpret_cast<const XrDebugUtilsLabelEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDebugUtilsLabelEXT&() { return *reinterpret_cast<XrDebugUtilsLabelEXT*>(this); }

  //! Accessor for this as the address of a raw XrDebugUtilsLabelEXT
  XrDebugUtilsLabelEXT const* get() const noexcept {
    return reinterpret_cast<XrDebugUtilsLabelEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrDebugUtilsLabelEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDebugUtilsLabelEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DebugUtilsLabelEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrDebugUtilsLabelEXT*>(this);
  }
  const char* labelName;
};
static_assert(sizeof(XrDebugUtilsLabelEXT) == sizeof(DebugUtilsLabelEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDebugUtilsLabelEXT pointer to const from a
 * DebugUtilsLabelEXT reference to const.
 * @relates DebugUtilsLabelEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsLabelEXT const* get(DebugUtilsLabelEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing DebugUtilsLabelEXT as the
 * address of a raw XrDebugUtilsLabelEXT
 * @relates DebugUtilsLabelEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsLabelEXT* put(DebugUtilsLabelEXT& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsMessengerCallbackDataEXT
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsMessengerCallbackDataEXT>
 * @xrentity{XrDebugUtilsMessengerCallbackDataEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DebugUtilsMessengerCallbackDataEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DebugUtilsMessengerCallbackDataEXT(const char* messageId_, const char* functionName_,
                                     const char* message_, uint32_t objectCount_,
                                     DebugUtilsObjectNameInfoEXT* objects_,
                                     uint32_t sessionLabelCount_,
                                     DebugUtilsLabelEXT* sessionLabels_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsMessengerCallbackDataEXT, next_),
        messageId{messageId_},
        functionName{functionName_},
        message{message_},
        objectCount{objectCount_},
        objects{objects_},
        sessionLabelCount{sessionLabelCount_},
        sessionLabels{sessionLabels_} {}

  //! Default/empty constructor
  DebugUtilsMessengerCallbackDataEXT(const void* next_ = nullptr)

      : Parent(StructureType::DebugUtilsMessengerCallbackDataEXT, next_),
        messageId{nullptr},
        functionName{nullptr},
        message{nullptr},
        objectCount{0},
        objects{nullptr},
        sessionLabelCount{0},
        sessionLabels{nullptr} {}

  //! Default copy constructor
  DebugUtilsMessengerCallbackDataEXT(const DebugUtilsMessengerCallbackDataEXT& rhs) = default;
  //! Default copy assignment
  DebugUtilsMessengerCallbackDataEXT& operator=(const DebugUtilsMessengerCallbackDataEXT& rhs) =
      default;
  //! Copy construct from raw
  DebugUtilsMessengerCallbackDataEXT(const XrDebugUtilsMessengerCallbackDataEXT& rhs)
      : DebugUtilsMessengerCallbackDataEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DebugUtilsMessengerCallbackDataEXT& operator=(const XrDebugUtilsMessengerCallbackDataEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDebugUtilsMessengerCallbackDataEXT&() const {
    return *reinterpret_cast<const XrDebugUtilsMessengerCallbackDataEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDebugUtilsMessengerCallbackDataEXT&() {
    return *reinterpret_cast<XrDebugUtilsMessengerCallbackDataEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrDebugUtilsMessengerCallbackDataEXT
  XrDebugUtilsMessengerCallbackDataEXT const* get() const noexcept {
    return reinterpret_cast<XrDebugUtilsMessengerCallbackDataEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDebugUtilsMessengerCallbackDataEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDebugUtilsMessengerCallbackDataEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DebugUtilsMessengerCallbackDataEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrDebugUtilsMessengerCallbackDataEXT*>(this);
  }
  const char* messageId;
  const char* functionName;
  const char* message;
  uint32_t objectCount;
  DebugUtilsObjectNameInfoEXT* objects;
  uint32_t sessionLabelCount;
  DebugUtilsLabelEXT* sessionLabels;
};
static_assert(sizeof(XrDebugUtilsMessengerCallbackDataEXT) ==
                  sizeof(DebugUtilsMessengerCallbackDataEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDebugUtilsMessengerCallbackDataEXT pointer to const from
 * a DebugUtilsMessengerCallbackDataEXT reference to const.
 * @relates DebugUtilsMessengerCallbackDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerCallbackDataEXT const* get(
    DebugUtilsMessengerCallbackDataEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * DebugUtilsMessengerCallbackDataEXT as the address of a raw XrDebugUtilsMessengerCallbackDataEXT
 * @relates DebugUtilsMessengerCallbackDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerCallbackDataEXT* put(
    DebugUtilsMessengerCallbackDataEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils
/*!
 * C++ projection of XrDebugUtilsMessengerCreateInfoEXT
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsMessengerCreateInfoEXT>
 * @xrentity{XrDebugUtilsMessengerCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DebugUtilsMessengerCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DebugUtilsMessengerCreateInfoEXT(const DebugUtilsMessageSeverityFlagsEXT& messageSeverities_,
                                   const DebugUtilsMessageTypeFlagsEXT& messageTypes_,
                                   PFN_xrDebugUtilsMessengerCallbackEXT userCallback_,
                                   void* XR_MAY_ALIAS userData_, const void* next_ = nullptr)
      : Parent(StructureType::DebugUtilsMessengerCreateInfoEXT, next_),
        messageSeverities{messageSeverities_},
        messageTypes{messageTypes_},
        userCallback{userCallback_},
        userData{userData_} {}

  //! Default/empty constructor
  DebugUtilsMessengerCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::DebugUtilsMessengerCreateInfoEXT, next_),
        messageSeverities{},
        messageTypes{},
        userCallback{nullptr},
        userData{nullptr} {}

  //! Default copy constructor
  DebugUtilsMessengerCreateInfoEXT(const DebugUtilsMessengerCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  DebugUtilsMessengerCreateInfoEXT& operator=(const DebugUtilsMessengerCreateInfoEXT& rhs) =
      default;
  //! Copy construct from raw
  DebugUtilsMessengerCreateInfoEXT(const XrDebugUtilsMessengerCreateInfoEXT& rhs)
      : DebugUtilsMessengerCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DebugUtilsMessengerCreateInfoEXT& operator=(const XrDebugUtilsMessengerCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDebugUtilsMessengerCreateInfoEXT&() const {
    return *reinterpret_cast<const XrDebugUtilsMessengerCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDebugUtilsMessengerCreateInfoEXT&() {
    return *reinterpret_cast<XrDebugUtilsMessengerCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrDebugUtilsMessengerCreateInfoEXT
  XrDebugUtilsMessengerCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrDebugUtilsMessengerCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDebugUtilsMessengerCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDebugUtilsMessengerCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DebugUtilsMessengerCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrDebugUtilsMessengerCreateInfoEXT*>(this);
  }
  DebugUtilsMessageSeverityFlagsEXT messageSeverities;
  DebugUtilsMessageTypeFlagsEXT messageTypes;
  PFN_xrDebugUtilsMessengerCallbackEXT userCallback;
  void* XR_MAY_ALIAS userData;
};
static_assert(sizeof(XrDebugUtilsMessengerCreateInfoEXT) ==
                  sizeof(DebugUtilsMessengerCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDebugUtilsMessengerCreateInfoEXT pointer to const from a
 * DebugUtilsMessengerCreateInfoEXT reference to const.
 * @relates DebugUtilsMessengerCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerCreateInfoEXT const* get(
    DebugUtilsMessengerCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * DebugUtilsMessengerCreateInfoEXT as the address of a raw XrDebugUtilsMessengerCreateInfoEXT
 * @relates DebugUtilsMessengerCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerCreateInfoEXT* put(
    DebugUtilsMessengerCreateInfoEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_eye_gaze_interaction
/*!
 * C++ projection of XrSystemEyeGazeInteractionPropertiesEXT
 *
 * Provided by the `XR_EXT_eye_gaze_interaction` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemEyeGazeInteractionPropertiesEXT>
 * @xrentity{XrSystemEyeGazeInteractionPropertiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemEyeGazeInteractionPropertiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemEyeGazeInteractionPropertiesEXT(void* next_ = nullptr)

      : Parent(StructureType::SystemEyeGazeInteractionPropertiesEXT, next_) {}

  //! Default copy constructor
  SystemEyeGazeInteractionPropertiesEXT(const SystemEyeGazeInteractionPropertiesEXT& rhs) = default;
  //! Default copy assignment
  SystemEyeGazeInteractionPropertiesEXT& operator=(
      const SystemEyeGazeInteractionPropertiesEXT& rhs) = default;
  //! Copy construct from raw
  SystemEyeGazeInteractionPropertiesEXT(const XrSystemEyeGazeInteractionPropertiesEXT& rhs)
      : SystemEyeGazeInteractionPropertiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemEyeGazeInteractionPropertiesEXT& operator=(
      const XrSystemEyeGazeInteractionPropertiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemEyeGazeInteractionPropertiesEXT&() const {
    return *reinterpret_cast<const XrSystemEyeGazeInteractionPropertiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemEyeGazeInteractionPropertiesEXT&() {
    return *reinterpret_cast<XrSystemEyeGazeInteractionPropertiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemEyeGazeInteractionPropertiesEXT
  XrSystemEyeGazeInteractionPropertiesEXT const* get() const noexcept {
    return reinterpret_cast<XrSystemEyeGazeInteractionPropertiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemEyeGazeInteractionPropertiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemEyeGazeInteractionPropertiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemEyeGazeInteractionPropertiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemEyeGazeInteractionPropertiesEXT*>(this);
  }
  Bool32 supportsEyeGazeInteraction;
};
static_assert(sizeof(XrSystemEyeGazeInteractionPropertiesEXT) ==
                  sizeof(SystemEyeGazeInteractionPropertiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemEyeGazeInteractionPropertiesEXT pointer to const
 * from a SystemEyeGazeInteractionPropertiesEXT reference to const.
 * @relates SystemEyeGazeInteractionPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemEyeGazeInteractionPropertiesEXT const* get(
    SystemEyeGazeInteractionPropertiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemEyeGazeInteractionPropertiesEXT as the address of a raw
 * XrSystemEyeGazeInteractionPropertiesEXT
 * @relates SystemEyeGazeInteractionPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemEyeGazeInteractionPropertiesEXT* put(
    SystemEyeGazeInteractionPropertiesEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_eye_gaze_interaction

#ifdef XR_EXT_eye_gaze_interaction
/*!
 * C++ projection of XrEyeGazeSampleTimeEXT
 *
 * Provided by the `XR_EXT_eye_gaze_interaction` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeGazeSampleTimeEXT>
 * @xrentity{XrEyeGazeSampleTimeEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EyeGazeSampleTimeEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EyeGazeSampleTimeEXT(void* next_ = nullptr)

      : Parent(StructureType::EyeGazeSampleTimeEXT, next_) {}

  //! Default copy constructor
  EyeGazeSampleTimeEXT(const EyeGazeSampleTimeEXT& rhs) = default;
  //! Default copy assignment
  EyeGazeSampleTimeEXT& operator=(const EyeGazeSampleTimeEXT& rhs) = default;
  //! Copy construct from raw
  EyeGazeSampleTimeEXT(const XrEyeGazeSampleTimeEXT& rhs) : EyeGazeSampleTimeEXT() { *put() = rhs; }
  //! Copy assign from raw
  EyeGazeSampleTimeEXT& operator=(const XrEyeGazeSampleTimeEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEyeGazeSampleTimeEXT&() const {
    return *reinterpret_cast<const XrEyeGazeSampleTimeEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEyeGazeSampleTimeEXT&() { return *reinterpret_cast<XrEyeGazeSampleTimeEXT*>(this); }

  //! Accessor for this as the address of a raw XrEyeGazeSampleTimeEXT
  XrEyeGazeSampleTimeEXT const* get() const noexcept {
    return reinterpret_cast<XrEyeGazeSampleTimeEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrEyeGazeSampleTimeEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEyeGazeSampleTimeEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EyeGazeSampleTimeEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrEyeGazeSampleTimeEXT*>(this);
  }
  Time time;
};
static_assert(sizeof(XrEyeGazeSampleTimeEXT) == sizeof(EyeGazeSampleTimeEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEyeGazeSampleTimeEXT pointer to const from a
 * EyeGazeSampleTimeEXT reference to const.
 * @relates EyeGazeSampleTimeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeGazeSampleTimeEXT const* get(EyeGazeSampleTimeEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EyeGazeSampleTimeEXT as the
 * address of a raw XrEyeGazeSampleTimeEXT
 * @relates EyeGazeSampleTimeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeGazeSampleTimeEXT* put(EyeGazeSampleTimeEXT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_eye_gaze_interaction

#ifdef XR_EXTX_overlay
/*!
 * C++ projection of XrSessionCreateInfoOverlayEXTX
 *
 * Provided by the `XR_EXTX_overlay` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSessionCreateInfoOverlayEXTX>
 * @xrentity{XrSessionCreateInfoOverlayEXTX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SessionCreateInfoOverlayEXTX : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SessionCreateInfoOverlayEXTX(const OverlaySessionCreateFlagsEXTX& createFlags_,
                               uint32_t sessionLayersPlacement_, const void* next_ = nullptr)
      : Parent(StructureType::SessionCreateInfoOverlayEXTX, next_),
        createFlags{createFlags_},
        sessionLayersPlacement{sessionLayersPlacement_} {}

  //! Default/empty constructor
  SessionCreateInfoOverlayEXTX(const void* next_ = nullptr)

      : Parent(StructureType::SessionCreateInfoOverlayEXTX, next_),
        createFlags{},
        sessionLayersPlacement{0} {}

  //! Default copy constructor
  SessionCreateInfoOverlayEXTX(const SessionCreateInfoOverlayEXTX& rhs) = default;
  //! Default copy assignment
  SessionCreateInfoOverlayEXTX& operator=(const SessionCreateInfoOverlayEXTX& rhs) = default;
  //! Copy construct from raw
  SessionCreateInfoOverlayEXTX(const XrSessionCreateInfoOverlayEXTX& rhs)
      : SessionCreateInfoOverlayEXTX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SessionCreateInfoOverlayEXTX& operator=(const XrSessionCreateInfoOverlayEXTX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSessionCreateInfoOverlayEXTX&() const {
    return *reinterpret_cast<const XrSessionCreateInfoOverlayEXTX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSessionCreateInfoOverlayEXTX&() {
    return *reinterpret_cast<XrSessionCreateInfoOverlayEXTX*>(this);
  }

  //! Accessor for this as the address of a raw XrSessionCreateInfoOverlayEXTX
  XrSessionCreateInfoOverlayEXTX const* get() const noexcept {
    return reinterpret_cast<XrSessionCreateInfoOverlayEXTX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSessionCreateInfoOverlayEXTX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSessionCreateInfoOverlayEXTX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SessionCreateInfoOverlayEXTX{};
      next = oldNext;
    }
    return reinterpret_cast<XrSessionCreateInfoOverlayEXTX*>(this);
  }
  OverlaySessionCreateFlagsEXTX createFlags;
  uint32_t sessionLayersPlacement;
};
static_assert(sizeof(XrSessionCreateInfoOverlayEXTX) == sizeof(SessionCreateInfoOverlayEXTX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSessionCreateInfoOverlayEXTX pointer to const from a
 * SessionCreateInfoOverlayEXTX reference to const.
 * @relates SessionCreateInfoOverlayEXTX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionCreateInfoOverlayEXTX const* get(
    SessionCreateInfoOverlayEXTX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SessionCreateInfoOverlayEXTX
 * as the address of a raw XrSessionCreateInfoOverlayEXTX
 * @relates SessionCreateInfoOverlayEXTX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSessionCreateInfoOverlayEXTX* put(SessionCreateInfoOverlayEXTX& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXTX_overlay

#ifdef XR_EXTX_overlay
/*!
 * C++ projection of XrEventDataMainSessionVisibilityChangedEXTX
 *
 * Provided by the `XR_EXTX_overlay` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataMainSessionVisibilityChangedEXTX>
 * @xrentity{XrEventDataMainSessionVisibilityChangedEXTX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataMainSessionVisibilityChangedEXTX : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataMainSessionVisibilityChangedEXTX(void* next_ = nullptr)

      : Parent(StructureType::EventDataMainSessionVisibilityChangedEXTX, next_) {}

  //! Default copy constructor
  EventDataMainSessionVisibilityChangedEXTX(const EventDataMainSessionVisibilityChangedEXTX& rhs) =
      default;
  //! Default copy assignment
  EventDataMainSessionVisibilityChangedEXTX& operator=(
      const EventDataMainSessionVisibilityChangedEXTX& rhs) = default;
  //! Copy construct from raw
  EventDataMainSessionVisibilityChangedEXTX(const XrEventDataMainSessionVisibilityChangedEXTX& rhs)
      : EventDataMainSessionVisibilityChangedEXTX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataMainSessionVisibilityChangedEXTX& operator=(
      const XrEventDataMainSessionVisibilityChangedEXTX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataMainSessionVisibilityChangedEXTX&() const {
    return *reinterpret_cast<const XrEventDataMainSessionVisibilityChangedEXTX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataMainSessionVisibilityChangedEXTX&() {
    return *reinterpret_cast<XrEventDataMainSessionVisibilityChangedEXTX*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataMainSessionVisibilityChangedEXTX
  XrEventDataMainSessionVisibilityChangedEXTX const* get() const noexcept {
    return reinterpret_cast<XrEventDataMainSessionVisibilityChangedEXTX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataMainSessionVisibilityChangedEXTX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataMainSessionVisibilityChangedEXTX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataMainSessionVisibilityChangedEXTX{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataMainSessionVisibilityChangedEXTX*>(this);
  }
  Bool32 visible;
  OverlayMainSessionFlagsEXTX flags;
};
static_assert(sizeof(XrEventDataMainSessionVisibilityChangedEXTX) ==
                  sizeof(EventDataMainSessionVisibilityChangedEXTX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataMainSessionVisibilityChangedEXTX pointer to
 * const from a EventDataMainSessionVisibilityChangedEXTX reference to const.
 * @relates EventDataMainSessionVisibilityChangedEXTX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataMainSessionVisibilityChangedEXTX const* get(
    EventDataMainSessionVisibilityChangedEXTX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataMainSessionVisibilityChangedEXTX as the address of a raw
 * XrEventDataMainSessionVisibilityChangedEXTX
 * @relates EventDataMainSessionVisibilityChangedEXTX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataMainSessionVisibilityChangedEXTX* put(
    EventDataMainSessionVisibilityChangedEXTX& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataMainSessionVisibilityChangedEXTX
 * as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataMainSessionVisibilityChangedEXTX
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataMainSessionVisibilityChangedEXTX const& h) {
  return h.get_base();
}
#endif  // XR_EXTX_overlay

#ifdef XR_MSFT_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorCreateInfoMSFT>
 * @xrentity{XrSpatialAnchorCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorCreateInfoMSFT(const Space& space_, const Posef& pose_, const Time& time_,
                              const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorCreateInfoMSFT, next_),
        space{space_},
        pose{pose_},
        time{time_} {}

  //! Default/empty constructor
  SpatialAnchorCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorCreateInfoMSFT, next_), space{}, pose{}, time{} {}

  //! Default copy constructor
  SpatialAnchorCreateInfoMSFT(const SpatialAnchorCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorCreateInfoMSFT& operator=(const SpatialAnchorCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorCreateInfoMSFT(const XrSpatialAnchorCreateInfoMSFT& rhs)
      : SpatialAnchorCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorCreateInfoMSFT& operator=(const XrSpatialAnchorCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialAnchorCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorCreateInfoMSFT&() {
    return *reinterpret_cast<XrSpatialAnchorCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorCreateInfoMSFT
  XrSpatialAnchorCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorCreateInfoMSFT*>(this);
  }
  Space space;
  Posef pose;
  Time time;
};
static_assert(sizeof(XrSpatialAnchorCreateInfoMSFT) == sizeof(SpatialAnchorCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorCreateInfoMSFT pointer to const from a
 * SpatialAnchorCreateInfoMSFT reference to const.
 * @relates SpatialAnchorCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoMSFT const* get(
    SpatialAnchorCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorCreateInfoMSFT
 * as the address of a raw XrSpatialAnchorCreateInfoMSFT
 * @relates SpatialAnchorCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoMSFT* put(SpatialAnchorCreateInfoMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_anchor

#ifdef XR_MSFT_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorSpaceCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorSpaceCreateInfoMSFT>
 * @xrentity{XrSpatialAnchorSpaceCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorSpaceCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorSpaceCreateInfoMSFT(const SpatialAnchorMSFT& anchor_,
                                   const Posef& poseInAnchorSpace_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorSpaceCreateInfoMSFT, next_),
        anchor{anchor_},
        poseInAnchorSpace{poseInAnchorSpace_} {}

  //! Default/empty constructor
  SpatialAnchorSpaceCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorSpaceCreateInfoMSFT, next_),
        anchor{},
        poseInAnchorSpace{} {}

  //! Default copy constructor
  SpatialAnchorSpaceCreateInfoMSFT(const SpatialAnchorSpaceCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorSpaceCreateInfoMSFT& operator=(const SpatialAnchorSpaceCreateInfoMSFT& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorSpaceCreateInfoMSFT(const XrSpatialAnchorSpaceCreateInfoMSFT& rhs)
      : SpatialAnchorSpaceCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorSpaceCreateInfoMSFT& operator=(const XrSpatialAnchorSpaceCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorSpaceCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialAnchorSpaceCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorSpaceCreateInfoMSFT&() {
    return *reinterpret_cast<XrSpatialAnchorSpaceCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorSpaceCreateInfoMSFT
  XrSpatialAnchorSpaceCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorSpaceCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorSpaceCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorSpaceCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorSpaceCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorSpaceCreateInfoMSFT*>(this);
  }
  SpatialAnchorMSFT anchor;
  Posef poseInAnchorSpace;
};
static_assert(sizeof(XrSpatialAnchorSpaceCreateInfoMSFT) ==
                  sizeof(SpatialAnchorSpaceCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorSpaceCreateInfoMSFT pointer to const from a
 * SpatialAnchorSpaceCreateInfoMSFT reference to const.
 * @relates SpatialAnchorSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorSpaceCreateInfoMSFT const* get(
    SpatialAnchorSpaceCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorSpaceCreateInfoMSFT as the address of a raw XrSpatialAnchorSpaceCreateInfoMSFT
 * @relates SpatialAnchorSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorSpaceCreateInfoMSFT* put(
    SpatialAnchorSpaceCreateInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_anchor

#ifdef XR_FB_composition_layer_image_layout
/*!
 * C++ projection of XrCompositionLayerImageLayoutFB
 *
 * Provided by the `XR_FB_composition_layer_image_layout` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerImageLayoutFB>
 * @xrentity{XrCompositionLayerImageLayoutFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerImageLayoutFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  CompositionLayerImageLayoutFB(void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerImageLayoutFB, next_) {}

  //! Default copy constructor
  CompositionLayerImageLayoutFB(const CompositionLayerImageLayoutFB& rhs) = default;
  //! Default copy assignment
  CompositionLayerImageLayoutFB& operator=(const CompositionLayerImageLayoutFB& rhs) = default;
  //! Copy construct from raw
  CompositionLayerImageLayoutFB(const XrCompositionLayerImageLayoutFB& rhs)
      : CompositionLayerImageLayoutFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerImageLayoutFB& operator=(const XrCompositionLayerImageLayoutFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerImageLayoutFB&() const {
    return *reinterpret_cast<const XrCompositionLayerImageLayoutFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerImageLayoutFB&() {
    return *reinterpret_cast<XrCompositionLayerImageLayoutFB*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerImageLayoutFB
  XrCompositionLayerImageLayoutFB const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerImageLayoutFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerImageLayoutFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerImageLayoutFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerImageLayoutFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerImageLayoutFB*>(this);
  }
  CompositionLayerImageLayoutFlagsFB flags;
};
static_assert(sizeof(XrCompositionLayerImageLayoutFB) == sizeof(CompositionLayerImageLayoutFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerImageLayoutFB pointer to const from a
 * CompositionLayerImageLayoutFB reference to const.
 * @relates CompositionLayerImageLayoutFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerImageLayoutFB const* get(
    CompositionLayerImageLayoutFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerImageLayoutFB
 * as the address of a raw XrCompositionLayerImageLayoutFB
 * @relates CompositionLayerImageLayoutFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerImageLayoutFB* put(CompositionLayerImageLayoutFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_composition_layer_image_layout

#ifdef XR_FB_composition_layer_alpha_blend
/*!
 * C++ projection of XrCompositionLayerAlphaBlendFB
 *
 * Provided by the `XR_FB_composition_layer_alpha_blend` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerAlphaBlendFB>
 * @xrentity{XrCompositionLayerAlphaBlendFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerAlphaBlendFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  CompositionLayerAlphaBlendFB(void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerAlphaBlendFB, next_) {}

  //! Default copy constructor
  CompositionLayerAlphaBlendFB(const CompositionLayerAlphaBlendFB& rhs) = default;
  //! Default copy assignment
  CompositionLayerAlphaBlendFB& operator=(const CompositionLayerAlphaBlendFB& rhs) = default;
  //! Copy construct from raw
  CompositionLayerAlphaBlendFB(const XrCompositionLayerAlphaBlendFB& rhs)
      : CompositionLayerAlphaBlendFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerAlphaBlendFB& operator=(const XrCompositionLayerAlphaBlendFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerAlphaBlendFB&() const {
    return *reinterpret_cast<const XrCompositionLayerAlphaBlendFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerAlphaBlendFB&() {
    return *reinterpret_cast<XrCompositionLayerAlphaBlendFB*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerAlphaBlendFB
  XrCompositionLayerAlphaBlendFB const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerAlphaBlendFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerAlphaBlendFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerAlphaBlendFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerAlphaBlendFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerAlphaBlendFB*>(this);
  }
  BlendFactorFB srcFactorColor;
  BlendFactorFB dstFactorColor;
  BlendFactorFB srcFactorAlpha;
  BlendFactorFB dstFactorAlpha;
};
static_assert(sizeof(XrCompositionLayerAlphaBlendFB) == sizeof(CompositionLayerAlphaBlendFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerAlphaBlendFB pointer to const from a
 * CompositionLayerAlphaBlendFB reference to const.
 * @relates CompositionLayerAlphaBlendFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerAlphaBlendFB const* get(
    CompositionLayerAlphaBlendFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerAlphaBlendFB
 * as the address of a raw XrCompositionLayerAlphaBlendFB
 * @relates CompositionLayerAlphaBlendFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerAlphaBlendFB* put(CompositionLayerAlphaBlendFB& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_composition_layer_alpha_blend

#ifdef XR_EXT_view_configuration_depth_range
/*!
 * C++ projection of XrViewConfigurationDepthRangeEXT
 *
 * Provided by the `XR_EXT_view_configuration_depth_range` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationDepthRangeEXT>
 * @xrentity{XrViewConfigurationDepthRangeEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewConfigurationDepthRangeEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViewConfigurationDepthRangeEXT(void* next_ = nullptr)

      : Parent(StructureType::ViewConfigurationDepthRangeEXT, next_) {}

  //! Default copy constructor
  ViewConfigurationDepthRangeEXT(const ViewConfigurationDepthRangeEXT& rhs) = default;
  //! Default copy assignment
  ViewConfigurationDepthRangeEXT& operator=(const ViewConfigurationDepthRangeEXT& rhs) = default;
  //! Copy construct from raw
  ViewConfigurationDepthRangeEXT(const XrViewConfigurationDepthRangeEXT& rhs)
      : ViewConfigurationDepthRangeEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewConfigurationDepthRangeEXT& operator=(const XrViewConfigurationDepthRangeEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewConfigurationDepthRangeEXT&() const {
    return *reinterpret_cast<const XrViewConfigurationDepthRangeEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewConfigurationDepthRangeEXT&() {
    return *reinterpret_cast<XrViewConfigurationDepthRangeEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrViewConfigurationDepthRangeEXT
  XrViewConfigurationDepthRangeEXT const* get() const noexcept {
    return reinterpret_cast<XrViewConfigurationDepthRangeEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrViewConfigurationDepthRangeEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewConfigurationDepthRangeEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewConfigurationDepthRangeEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewConfigurationDepthRangeEXT*>(this);
  }
  float recommendedNearZ;
  float minNearZ;
  float recommendedFarZ;
  float maxFarZ;
};
static_assert(sizeof(XrViewConfigurationDepthRangeEXT) == sizeof(ViewConfigurationDepthRangeEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewConfigurationDepthRangeEXT pointer to const from a
 * ViewConfigurationDepthRangeEXT reference to const.
 * @relates ViewConfigurationDepthRangeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationDepthRangeEXT const* get(
    ViewConfigurationDepthRangeEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ViewConfigurationDepthRangeEXT as the address of a raw XrViewConfigurationDepthRangeEXT
 * @relates ViewConfigurationDepthRangeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationDepthRangeEXT* put(ViewConfigurationDepthRangeEXT& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_view_configuration_depth_range

#ifdef XR_MNDX_egl_enable
#if defined(XR_USE_PLATFORM_EGL)
/*!
 * C++ projection of XrGraphicsBindingEGLMNDX
 *
 * Provided by the `XR_MNDX_egl_enable` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGraphicsBindingEGLMNDX>
 * @xrentity{XrGraphicsBindingEGLMNDX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GraphicsBindingEGLMNDX : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GraphicsBindingEGLMNDX(PFN_xrEglGetProcAddressMNDX getProcAddress_, EGLDisplay display_,
                         EGLConfig config_, EGLContext context_, const void* next_ = nullptr)
      : Parent(StructureType::GraphicsBindingEGLMNDX, next_),
        getProcAddress{getProcAddress_},
        display{display_},
        config{config_},
        context{context_} {}

  //! Default/empty constructor
  GraphicsBindingEGLMNDX(const void* next_ = nullptr)

      : Parent(StructureType::GraphicsBindingEGLMNDX, next_),
        getProcAddress{nullptr},
        display{},
        config{},
        context{} {}

  //! Default copy constructor
  GraphicsBindingEGLMNDX(const GraphicsBindingEGLMNDX& rhs) = default;
  //! Default copy assignment
  GraphicsBindingEGLMNDX& operator=(const GraphicsBindingEGLMNDX& rhs) = default;
  //! Copy construct from raw
  GraphicsBindingEGLMNDX(const XrGraphicsBindingEGLMNDX& rhs) : GraphicsBindingEGLMNDX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GraphicsBindingEGLMNDX& operator=(const XrGraphicsBindingEGLMNDX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGraphicsBindingEGLMNDX&() const {
    return *reinterpret_cast<const XrGraphicsBindingEGLMNDX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGraphicsBindingEGLMNDX&() {
    return *reinterpret_cast<XrGraphicsBindingEGLMNDX*>(this);
  }

  //! Accessor for this as the address of a raw XrGraphicsBindingEGLMNDX
  XrGraphicsBindingEGLMNDX const* get() const noexcept {
    return reinterpret_cast<XrGraphicsBindingEGLMNDX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrGraphicsBindingEGLMNDX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGraphicsBindingEGLMNDX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GraphicsBindingEGLMNDX{};
      next = oldNext;
    }
    return reinterpret_cast<XrGraphicsBindingEGLMNDX*>(this);
  }
  PFN_xrEglGetProcAddressMNDX getProcAddress;
  EGLDisplay display;
  EGLConfig config;
  EGLContext context;
};
static_assert(sizeof(XrGraphicsBindingEGLMNDX) == sizeof(GraphicsBindingEGLMNDX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGraphicsBindingEGLMNDX pointer to const from a
 * GraphicsBindingEGLMNDX reference to const.
 * @relates GraphicsBindingEGLMNDX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingEGLMNDX const* get(GraphicsBindingEGLMNDX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GraphicsBindingEGLMNDX as the
 * address of a raw XrGraphicsBindingEGLMNDX
 * @relates GraphicsBindingEGLMNDX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGraphicsBindingEGLMNDX* put(GraphicsBindingEGLMNDX& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_PLATFORM_EGL)
#endif  // XR_MNDX_egl_enable

#ifdef XR_MSFT_spatial_graph_bridge
/*!
 * C++ projection of XrSpatialGraphNodeSpaceCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_graph_bridge` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialGraphNodeSpaceCreateInfoMSFT>
 * @xrentity{XrSpatialGraphNodeSpaceCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialGraphNodeSpaceCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialGraphNodeSpaceCreateInfoMSFT(const SpatialGraphNodeTypeMSFT& nodeType_,
                                      uint8_t nodeId_[XR_GUID_SIZE_MSFT], const Posef& pose_,
                                      const void* next_ = nullptr)
      : Parent(StructureType::SpatialGraphNodeSpaceCreateInfoMSFT, next_),
        nodeType{nodeType_},
        pose{pose_} {
    memcpy(nodeId, nodeId_, sizeof(nodeId));
  }

  //! Default/empty constructor
  SpatialGraphNodeSpaceCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialGraphNodeSpaceCreateInfoMSFT, next_),
        nodeType{},
        nodeId{0},
        pose{} {}

  //! Default copy constructor
  SpatialGraphNodeSpaceCreateInfoMSFT(const SpatialGraphNodeSpaceCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialGraphNodeSpaceCreateInfoMSFT& operator=(const SpatialGraphNodeSpaceCreateInfoMSFT& rhs) =
      default;
  //! Copy construct from raw
  SpatialGraphNodeSpaceCreateInfoMSFT(const XrSpatialGraphNodeSpaceCreateInfoMSFT& rhs)
      : SpatialGraphNodeSpaceCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialGraphNodeSpaceCreateInfoMSFT& operator=(const XrSpatialGraphNodeSpaceCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialGraphNodeSpaceCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialGraphNodeSpaceCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialGraphNodeSpaceCreateInfoMSFT&() {
    return *reinterpret_cast<XrSpatialGraphNodeSpaceCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialGraphNodeSpaceCreateInfoMSFT
  XrSpatialGraphNodeSpaceCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialGraphNodeSpaceCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialGraphNodeSpaceCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialGraphNodeSpaceCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialGraphNodeSpaceCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialGraphNodeSpaceCreateInfoMSFT*>(this);
  }
  SpatialGraphNodeTypeMSFT nodeType;
  uint8_t nodeId[XR_GUID_SIZE_MSFT];
  Posef pose;
};
static_assert(sizeof(XrSpatialGraphNodeSpaceCreateInfoMSFT) ==
                  sizeof(SpatialGraphNodeSpaceCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialGraphNodeSpaceCreateInfoMSFT pointer to const
 * from a SpatialGraphNodeSpaceCreateInfoMSFT reference to const.
 * @relates SpatialGraphNodeSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialGraphNodeSpaceCreateInfoMSFT const* get(
    SpatialGraphNodeSpaceCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialGraphNodeSpaceCreateInfoMSFT as the address of a raw XrSpatialGraphNodeSpaceCreateInfoMSFT
 * @relates SpatialGraphNodeSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialGraphNodeSpaceCreateInfoMSFT* put(
    SpatialGraphNodeSpaceCreateInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_graph_bridge

#ifdef XR_MSFT_spatial_graph_bridge
/*!
 * C++ projection of XrSpatialGraphStaticNodeBindingCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_graph_bridge` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialGraphStaticNodeBindingCreateInfoMSFT>
 * @xrentity{XrSpatialGraphStaticNodeBindingCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialGraphStaticNodeBindingCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialGraphStaticNodeBindingCreateInfoMSFT(const Space& space_, const Posef& poseInSpace_,
                                              const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialGraphStaticNodeBindingCreateInfoMSFT, next_),
        space{space_},
        poseInSpace{poseInSpace_},
        time{time_} {}

  //! Default/empty constructor
  SpatialGraphStaticNodeBindingCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialGraphStaticNodeBindingCreateInfoMSFT, next_),
        space{},
        poseInSpace{},
        time{} {}

  //! Default copy constructor
  SpatialGraphStaticNodeBindingCreateInfoMSFT(
      const SpatialGraphStaticNodeBindingCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialGraphStaticNodeBindingCreateInfoMSFT& operator=(
      const SpatialGraphStaticNodeBindingCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SpatialGraphStaticNodeBindingCreateInfoMSFT(
      const XrSpatialGraphStaticNodeBindingCreateInfoMSFT& rhs)
      : SpatialGraphStaticNodeBindingCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialGraphStaticNodeBindingCreateInfoMSFT& operator=(
      const XrSpatialGraphStaticNodeBindingCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialGraphStaticNodeBindingCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialGraphStaticNodeBindingCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialGraphStaticNodeBindingCreateInfoMSFT&() {
    return *reinterpret_cast<XrSpatialGraphStaticNodeBindingCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialGraphStaticNodeBindingCreateInfoMSFT
  XrSpatialGraphStaticNodeBindingCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialGraphStaticNodeBindingCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialGraphStaticNodeBindingCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialGraphStaticNodeBindingCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialGraphStaticNodeBindingCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialGraphStaticNodeBindingCreateInfoMSFT*>(this);
  }
  Space space;
  Posef poseInSpace;
  Time time;
};
static_assert(sizeof(XrSpatialGraphStaticNodeBindingCreateInfoMSFT) ==
                  sizeof(SpatialGraphStaticNodeBindingCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialGraphStaticNodeBindingCreateInfoMSFT pointer to
 * const from a SpatialGraphStaticNodeBindingCreateInfoMSFT reference to const.
 * @relates SpatialGraphStaticNodeBindingCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialGraphStaticNodeBindingCreateInfoMSFT const* get(
    SpatialGraphStaticNodeBindingCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialGraphStaticNodeBindingCreateInfoMSFT as the address of a raw
 * XrSpatialGraphStaticNodeBindingCreateInfoMSFT
 * @relates SpatialGraphStaticNodeBindingCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialGraphStaticNodeBindingCreateInfoMSFT* put(
    SpatialGraphStaticNodeBindingCreateInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_graph_bridge

#ifdef XR_MSFT_spatial_graph_bridge
/*!
 * C++ projection of XrSpatialGraphNodeBindingPropertiesGetInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_graph_bridge` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialGraphNodeBindingPropertiesGetInfoMSFT>
 * @xrentity{XrSpatialGraphNodeBindingPropertiesGetInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialGraphNodeBindingPropertiesGetInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SpatialGraphNodeBindingPropertiesGetInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialGraphNodeBindingPropertiesGetInfoMSFT, next_) {}

  //! Default copy constructor
  SpatialGraphNodeBindingPropertiesGetInfoMSFT(
      const SpatialGraphNodeBindingPropertiesGetInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialGraphNodeBindingPropertiesGetInfoMSFT& operator=(
      const SpatialGraphNodeBindingPropertiesGetInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SpatialGraphNodeBindingPropertiesGetInfoMSFT(
      const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT& rhs)
      : SpatialGraphNodeBindingPropertiesGetInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialGraphNodeBindingPropertiesGetInfoMSFT& operator=(
      const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialGraphNodeBindingPropertiesGetInfoMSFT&() {
    return *reinterpret_cast<XrSpatialGraphNodeBindingPropertiesGetInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialGraphNodeBindingPropertiesGetInfoMSFT
  XrSpatialGraphNodeBindingPropertiesGetInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialGraphNodeBindingPropertiesGetInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialGraphNodeBindingPropertiesGetInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialGraphNodeBindingPropertiesGetInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialGraphNodeBindingPropertiesGetInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialGraphNodeBindingPropertiesGetInfoMSFT*>(this);
  }
};
static_assert(sizeof(XrSpatialGraphNodeBindingPropertiesGetInfoMSFT) ==
                  sizeof(SpatialGraphNodeBindingPropertiesGetInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialGraphNodeBindingPropertiesGetInfoMSFT pointer to
 * const from a SpatialGraphNodeBindingPropertiesGetInfoMSFT reference to const.
 * @relates SpatialGraphNodeBindingPropertiesGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialGraphNodeBindingPropertiesGetInfoMSFT const* get(
    SpatialGraphNodeBindingPropertiesGetInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialGraphNodeBindingPropertiesGetInfoMSFT as the address of a raw
 * XrSpatialGraphNodeBindingPropertiesGetInfoMSFT
 * @relates SpatialGraphNodeBindingPropertiesGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialGraphNodeBindingPropertiesGetInfoMSFT* put(
    SpatialGraphNodeBindingPropertiesGetInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_graph_bridge

#ifdef XR_MSFT_spatial_graph_bridge
/*!
 * C++ projection of XrSpatialGraphNodeBindingPropertiesMSFT
 *
 * Provided by the `XR_MSFT_spatial_graph_bridge` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialGraphNodeBindingPropertiesMSFT>
 * @xrentity{XrSpatialGraphNodeBindingPropertiesMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialGraphNodeBindingPropertiesMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialGraphNodeBindingPropertiesMSFT(void* next_ = nullptr)

      : Parent(StructureType::SpatialGraphNodeBindingPropertiesMSFT, next_) {}

  //! Default copy constructor
  SpatialGraphNodeBindingPropertiesMSFT(const SpatialGraphNodeBindingPropertiesMSFT& rhs) = default;
  //! Default copy assignment
  SpatialGraphNodeBindingPropertiesMSFT& operator=(
      const SpatialGraphNodeBindingPropertiesMSFT& rhs) = default;
  //! Copy construct from raw
  SpatialGraphNodeBindingPropertiesMSFT(const XrSpatialGraphNodeBindingPropertiesMSFT& rhs)
      : SpatialGraphNodeBindingPropertiesMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialGraphNodeBindingPropertiesMSFT& operator=(
      const XrSpatialGraphNodeBindingPropertiesMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialGraphNodeBindingPropertiesMSFT&() const {
    return *reinterpret_cast<const XrSpatialGraphNodeBindingPropertiesMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialGraphNodeBindingPropertiesMSFT&() {
    return *reinterpret_cast<XrSpatialGraphNodeBindingPropertiesMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialGraphNodeBindingPropertiesMSFT
  XrSpatialGraphNodeBindingPropertiesMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialGraphNodeBindingPropertiesMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialGraphNodeBindingPropertiesMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialGraphNodeBindingPropertiesMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialGraphNodeBindingPropertiesMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialGraphNodeBindingPropertiesMSFT*>(this);
  }
  uint8_t nodeId[XR_GUID_SIZE_MSFT];
  Posef poseInNodeSpace;
};
static_assert(sizeof(XrSpatialGraphNodeBindingPropertiesMSFT) ==
                  sizeof(SpatialGraphNodeBindingPropertiesMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialGraphNodeBindingPropertiesMSFT pointer to const
 * from a SpatialGraphNodeBindingPropertiesMSFT reference to const.
 * @relates SpatialGraphNodeBindingPropertiesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialGraphNodeBindingPropertiesMSFT const* get(
    SpatialGraphNodeBindingPropertiesMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialGraphNodeBindingPropertiesMSFT as the address of a raw
 * XrSpatialGraphNodeBindingPropertiesMSFT
 * @relates SpatialGraphNodeBindingPropertiesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialGraphNodeBindingPropertiesMSFT* put(
    SpatialGraphNodeBindingPropertiesMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_graph_bridge

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrSystemHandTrackingPropertiesEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemHandTrackingPropertiesEXT>
 * @xrentity{XrSystemHandTrackingPropertiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemHandTrackingPropertiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemHandTrackingPropertiesEXT(void* next_ = nullptr)

      : Parent(StructureType::SystemHandTrackingPropertiesEXT, next_) {}

  //! Default copy constructor
  SystemHandTrackingPropertiesEXT(const SystemHandTrackingPropertiesEXT& rhs) = default;
  //! Default copy assignment
  SystemHandTrackingPropertiesEXT& operator=(const SystemHandTrackingPropertiesEXT& rhs) = default;
  //! Copy construct from raw
  SystemHandTrackingPropertiesEXT(const XrSystemHandTrackingPropertiesEXT& rhs)
      : SystemHandTrackingPropertiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemHandTrackingPropertiesEXT& operator=(const XrSystemHandTrackingPropertiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemHandTrackingPropertiesEXT&() const {
    return *reinterpret_cast<const XrSystemHandTrackingPropertiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemHandTrackingPropertiesEXT&() {
    return *reinterpret_cast<XrSystemHandTrackingPropertiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemHandTrackingPropertiesEXT
  XrSystemHandTrackingPropertiesEXT const* get() const noexcept {
    return reinterpret_cast<XrSystemHandTrackingPropertiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemHandTrackingPropertiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemHandTrackingPropertiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemHandTrackingPropertiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemHandTrackingPropertiesEXT*>(this);
  }
  Bool32 supportsHandTracking;
};
static_assert(sizeof(XrSystemHandTrackingPropertiesEXT) == sizeof(SystemHandTrackingPropertiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemHandTrackingPropertiesEXT pointer to const from a
 * SystemHandTrackingPropertiesEXT reference to const.
 * @relates SystemHandTrackingPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHandTrackingPropertiesEXT const* get(
    SystemHandTrackingPropertiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemHandTrackingPropertiesEXT as the address of a raw XrSystemHandTrackingPropertiesEXT
 * @relates SystemHandTrackingPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHandTrackingPropertiesEXT* put(SystemHandTrackingPropertiesEXT& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandTrackerCreateInfoEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackerCreateInfoEXT>
 * @xrentity{XrHandTrackerCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackerCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandTrackerCreateInfoEXT(const HandEXT& hand_, const HandJointSetEXT& handJointSet_,
                           const void* next_ = nullptr)
      : Parent(StructureType::HandTrackerCreateInfoEXT, next_),
        hand{hand_},
        handJointSet{handJointSet_} {}

  //! Default/empty constructor
  HandTrackerCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::HandTrackerCreateInfoEXT, next_), hand{}, handJointSet{} {}

  //! Default copy constructor
  HandTrackerCreateInfoEXT(const HandTrackerCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  HandTrackerCreateInfoEXT& operator=(const HandTrackerCreateInfoEXT& rhs) = default;
  //! Copy construct from raw
  HandTrackerCreateInfoEXT(const XrHandTrackerCreateInfoEXT& rhs) : HandTrackerCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandTrackerCreateInfoEXT& operator=(const XrHandTrackerCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackerCreateInfoEXT&() const {
    return *reinterpret_cast<const XrHandTrackerCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackerCreateInfoEXT&() {
    return *reinterpret_cast<XrHandTrackerCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandTrackerCreateInfoEXT
  XrHandTrackerCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrHandTrackerCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandTrackerCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackerCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackerCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackerCreateInfoEXT*>(this);
  }
  HandEXT hand;
  HandJointSetEXT handJointSet;
};
static_assert(sizeof(XrHandTrackerCreateInfoEXT) == sizeof(HandTrackerCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackerCreateInfoEXT pointer to const from a
 * HandTrackerCreateInfoEXT reference to const.
 * @relates HandTrackerCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackerCreateInfoEXT const* get(HandTrackerCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackerCreateInfoEXT as
 * the address of a raw XrHandTrackerCreateInfoEXT
 * @relates HandTrackerCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackerCreateInfoEXT* put(HandTrackerCreateInfoEXT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointsLocateInfoEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointsLocateInfoEXT>
 * @xrentity{XrHandJointsLocateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandJointsLocateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandJointsLocateInfoEXT(const Space& baseSpace_, const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::HandJointsLocateInfoEXT, next_), baseSpace{baseSpace_}, time{time_} {}

  //! Default/empty constructor
  HandJointsLocateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::HandJointsLocateInfoEXT, next_), baseSpace{}, time{} {}

  //! Default copy constructor
  HandJointsLocateInfoEXT(const HandJointsLocateInfoEXT& rhs) = default;
  //! Default copy assignment
  HandJointsLocateInfoEXT& operator=(const HandJointsLocateInfoEXT& rhs) = default;
  //! Copy construct from raw
  HandJointsLocateInfoEXT(const XrHandJointsLocateInfoEXT& rhs) : HandJointsLocateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandJointsLocateInfoEXT& operator=(const XrHandJointsLocateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointsLocateInfoEXT&() const {
    return *reinterpret_cast<const XrHandJointsLocateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointsLocateInfoEXT&() {
    return *reinterpret_cast<XrHandJointsLocateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandJointsLocateInfoEXT
  XrHandJointsLocateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointsLocateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandJointsLocateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandJointsLocateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandJointsLocateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandJointsLocateInfoEXT*>(this);
  }
  Space baseSpace;
  Time time;
};
static_assert(sizeof(XrHandJointsLocateInfoEXT) == sizeof(HandJointsLocateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointsLocateInfoEXT pointer to const from a
 * HandJointsLocateInfoEXT reference to const.
 * @relates HandJointsLocateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointsLocateInfoEXT const* get(HandJointsLocateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointsLocateInfoEXT as
 * the address of a raw XrHandJointsLocateInfoEXT
 * @relates HandJointsLocateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointsLocateInfoEXT* put(HandJointsLocateInfoEXT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointLocationEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointLocationEXT>
 * @xrentity{XrHandJointLocationEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandJointLocationEXT {
public:
  //! Constructor initializing all members.
  HandJointLocationEXT(const SpaceLocationFlags& locationFlags_, const Posef& pose_, float radius_)
      : locationFlags{locationFlags_}, pose{pose_}, radius{radius_} {}

  //! Default/empty constructor
  HandJointLocationEXT()

      : locationFlags{}, pose{}, radius{0.0f} {}

  //! Default copy constructor
  HandJointLocationEXT(const HandJointLocationEXT& rhs) = default;
  //! Default copy assignment
  HandJointLocationEXT& operator=(const HandJointLocationEXT& rhs) = default;
  //! Copy construct from raw
  HandJointLocationEXT(const XrHandJointLocationEXT& rhs) : HandJointLocationEXT() { *put() = rhs; }
  //! Copy assign from raw
  HandJointLocationEXT& operator=(const XrHandJointLocationEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointLocationEXT&() const {
    return *reinterpret_cast<const XrHandJointLocationEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointLocationEXT&() { return *reinterpret_cast<XrHandJointLocationEXT*>(this); }

  //! Accessor for this as the address of a raw XrHandJointLocationEXT
  XrHandJointLocationEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointLocationEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandJointLocationEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandJointLocationEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandJointLocationEXT{};
    }
    return reinterpret_cast<XrHandJointLocationEXT*>(this);
  }
  SpaceLocationFlags locationFlags;
  Posef pose;
  float radius;
};
static_assert(sizeof(XrHandJointLocationEXT) == sizeof(HandJointLocationEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointLocationEXT pointer to const from a
 * HandJointLocationEXT reference to const.
 * @relates HandJointLocationEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointLocationEXT const* get(HandJointLocationEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointLocationEXT as the
 * address of a raw XrHandJointLocationEXT
 * @relates HandJointLocationEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointLocationEXT* put(HandJointLocationEXT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointVelocityEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointVelocityEXT>
 * @xrentity{XrHandJointVelocityEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandJointVelocityEXT {
public:
  //! Constructor initializing all members.
  HandJointVelocityEXT(const SpaceVelocityFlags& velocityFlags_, const Vector3f& linearVelocity_,
                       const Vector3f& angularVelocity_)
      : velocityFlags{velocityFlags_},
        linearVelocity{linearVelocity_},
        angularVelocity{angularVelocity_} {}

  //! Default/empty constructor
  HandJointVelocityEXT()

      : velocityFlags{}, linearVelocity{}, angularVelocity{} {}

  //! Default copy constructor
  HandJointVelocityEXT(const HandJointVelocityEXT& rhs) = default;
  //! Default copy assignment
  HandJointVelocityEXT& operator=(const HandJointVelocityEXT& rhs) = default;
  //! Copy construct from raw
  HandJointVelocityEXT(const XrHandJointVelocityEXT& rhs) : HandJointVelocityEXT() { *put() = rhs; }
  //! Copy assign from raw
  HandJointVelocityEXT& operator=(const XrHandJointVelocityEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointVelocityEXT&() const {
    return *reinterpret_cast<const XrHandJointVelocityEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointVelocityEXT&() { return *reinterpret_cast<XrHandJointVelocityEXT*>(this); }

  //! Accessor for this as the address of a raw XrHandJointVelocityEXT
  XrHandJointVelocityEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointVelocityEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandJointVelocityEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandJointVelocityEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandJointVelocityEXT{};
    }
    return reinterpret_cast<XrHandJointVelocityEXT*>(this);
  }
  SpaceVelocityFlags velocityFlags;
  Vector3f linearVelocity;
  Vector3f angularVelocity;
};
static_assert(sizeof(XrHandJointVelocityEXT) == sizeof(HandJointVelocityEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointVelocityEXT pointer to const from a
 * HandJointVelocityEXT reference to const.
 * @relates HandJointVelocityEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointVelocityEXT const* get(HandJointVelocityEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointVelocityEXT as the
 * address of a raw XrHandJointVelocityEXT
 * @relates HandJointVelocityEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointVelocityEXT* put(HandJointVelocityEXT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointLocationsEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointLocationsEXT>
 * @xrentity{XrHandJointLocationsEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandJointLocationsEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandJointLocationsEXT(void* next_ = nullptr)

      : Parent(StructureType::HandJointLocationsEXT, next_) {}

  //! Default copy constructor
  HandJointLocationsEXT(const HandJointLocationsEXT& rhs) = default;
  //! Default copy assignment
  HandJointLocationsEXT& operator=(const HandJointLocationsEXT& rhs) = default;
  //! Copy construct from raw
  HandJointLocationsEXT(const XrHandJointLocationsEXT& rhs) : HandJointLocationsEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandJointLocationsEXT& operator=(const XrHandJointLocationsEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointLocationsEXT&() const {
    return *reinterpret_cast<const XrHandJointLocationsEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointLocationsEXT&() { return *reinterpret_cast<XrHandJointLocationsEXT*>(this); }

  //! Accessor for this as the address of a raw XrHandJointLocationsEXT
  XrHandJointLocationsEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointLocationsEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandJointLocationsEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandJointLocationsEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandJointLocationsEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandJointLocationsEXT*>(this);
  }
  Bool32 isActive;
  uint32_t jointCount;
  HandJointLocationEXT* jointLocations;
};
static_assert(sizeof(XrHandJointLocationsEXT) == sizeof(HandJointLocationsEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointLocationsEXT pointer to const from a
 * HandJointLocationsEXT reference to const.
 * @relates HandJointLocationsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointLocationsEXT const* get(HandJointLocationsEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointLocationsEXT as the
 * address of a raw XrHandJointLocationsEXT
 * @relates HandJointLocationsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointLocationsEXT* put(HandJointLocationsEXT& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_EXT_hand_tracking
/*!
 * C++ projection of XrHandJointVelocitiesEXT
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointVelocitiesEXT>
 * @xrentity{XrHandJointVelocitiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandJointVelocitiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandJointVelocitiesEXT(void* next_ = nullptr)

      : Parent(StructureType::HandJointVelocitiesEXT, next_) {}

  //! Default copy constructor
  HandJointVelocitiesEXT(const HandJointVelocitiesEXT& rhs) = default;
  //! Default copy assignment
  HandJointVelocitiesEXT& operator=(const HandJointVelocitiesEXT& rhs) = default;
  //! Copy construct from raw
  HandJointVelocitiesEXT(const XrHandJointVelocitiesEXT& rhs) : HandJointVelocitiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandJointVelocitiesEXT& operator=(const XrHandJointVelocitiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointVelocitiesEXT&() const {
    return *reinterpret_cast<const XrHandJointVelocitiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointVelocitiesEXT&() {
    return *reinterpret_cast<XrHandJointVelocitiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandJointVelocitiesEXT
  XrHandJointVelocitiesEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointVelocitiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandJointVelocitiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandJointVelocitiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandJointVelocitiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandJointVelocitiesEXT*>(this);
  }
  uint32_t jointCount;
  HandJointVelocityEXT* jointVelocities;
};
static_assert(sizeof(XrHandJointVelocitiesEXT) == sizeof(HandJointVelocitiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointVelocitiesEXT pointer to const from a
 * HandJointVelocitiesEXT reference to const.
 * @relates HandJointVelocitiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointVelocitiesEXT const* get(HandJointVelocitiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointVelocitiesEXT as the
 * address of a raw XrHandJointVelocitiesEXT
 * @relates HandJointVelocitiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointVelocitiesEXT* put(HandJointVelocitiesEXT& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrSystemHandTrackingMeshPropertiesMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemHandTrackingMeshPropertiesMSFT>
 * @xrentity{XrSystemHandTrackingMeshPropertiesMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemHandTrackingMeshPropertiesMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemHandTrackingMeshPropertiesMSFT(void* next_ = nullptr)

      : Parent(StructureType::SystemHandTrackingMeshPropertiesMSFT, next_) {}

  //! Default copy constructor
  SystemHandTrackingMeshPropertiesMSFT(const SystemHandTrackingMeshPropertiesMSFT& rhs) = default;
  //! Default copy assignment
  SystemHandTrackingMeshPropertiesMSFT& operator=(const SystemHandTrackingMeshPropertiesMSFT& rhs) =
      default;
  //! Copy construct from raw
  SystemHandTrackingMeshPropertiesMSFT(const XrSystemHandTrackingMeshPropertiesMSFT& rhs)
      : SystemHandTrackingMeshPropertiesMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemHandTrackingMeshPropertiesMSFT& operator=(
      const XrSystemHandTrackingMeshPropertiesMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemHandTrackingMeshPropertiesMSFT&() const {
    return *reinterpret_cast<const XrSystemHandTrackingMeshPropertiesMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemHandTrackingMeshPropertiesMSFT&() {
    return *reinterpret_cast<XrSystemHandTrackingMeshPropertiesMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemHandTrackingMeshPropertiesMSFT
  XrSystemHandTrackingMeshPropertiesMSFT const* get() const noexcept {
    return reinterpret_cast<XrSystemHandTrackingMeshPropertiesMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemHandTrackingMeshPropertiesMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemHandTrackingMeshPropertiesMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemHandTrackingMeshPropertiesMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemHandTrackingMeshPropertiesMSFT*>(this);
  }
  Bool32 supportsHandTrackingMesh;
  uint32_t maxHandMeshIndexCount;
  uint32_t maxHandMeshVertexCount;
};
static_assert(sizeof(XrSystemHandTrackingMeshPropertiesMSFT) ==
                  sizeof(SystemHandTrackingMeshPropertiesMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemHandTrackingMeshPropertiesMSFT pointer to const
 * from a SystemHandTrackingMeshPropertiesMSFT reference to const.
 * @relates SystemHandTrackingMeshPropertiesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHandTrackingMeshPropertiesMSFT const* get(
    SystemHandTrackingMeshPropertiesMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemHandTrackingMeshPropertiesMSFT as the address of a raw
 * XrSystemHandTrackingMeshPropertiesMSFT
 * @relates SystemHandTrackingMeshPropertiesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHandTrackingMeshPropertiesMSFT* put(
    SystemHandTrackingMeshPropertiesMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshSpaceCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshSpaceCreateInfoMSFT>
 * @xrentity{XrHandMeshSpaceCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandMeshSpaceCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandMeshSpaceCreateInfoMSFT(const HandPoseTypeMSFT& handPoseType_,
                              const Posef& poseInHandMeshSpace_, const void* next_ = nullptr)
      : Parent(StructureType::HandMeshSpaceCreateInfoMSFT, next_),
        handPoseType{handPoseType_},
        poseInHandMeshSpace{poseInHandMeshSpace_} {}

  //! Default/empty constructor
  HandMeshSpaceCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::HandMeshSpaceCreateInfoMSFT, next_),
        handPoseType{},
        poseInHandMeshSpace{} {}

  //! Default copy constructor
  HandMeshSpaceCreateInfoMSFT(const HandMeshSpaceCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshSpaceCreateInfoMSFT& operator=(const HandMeshSpaceCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshSpaceCreateInfoMSFT(const XrHandMeshSpaceCreateInfoMSFT& rhs)
      : HandMeshSpaceCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandMeshSpaceCreateInfoMSFT& operator=(const XrHandMeshSpaceCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshSpaceCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrHandMeshSpaceCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshSpaceCreateInfoMSFT&() {
    return *reinterpret_cast<XrHandMeshSpaceCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandMeshSpaceCreateInfoMSFT
  XrHandMeshSpaceCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshSpaceCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandMeshSpaceCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandMeshSpaceCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandMeshSpaceCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandMeshSpaceCreateInfoMSFT*>(this);
  }
  HandPoseTypeMSFT handPoseType;
  Posef poseInHandMeshSpace;
};
static_assert(sizeof(XrHandMeshSpaceCreateInfoMSFT) == sizeof(HandMeshSpaceCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshSpaceCreateInfoMSFT pointer to const from a
 * HandMeshSpaceCreateInfoMSFT reference to const.
 * @relates HandMeshSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshSpaceCreateInfoMSFT const* get(
    HandMeshSpaceCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshSpaceCreateInfoMSFT
 * as the address of a raw XrHandMeshSpaceCreateInfoMSFT
 * @relates HandMeshSpaceCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshSpaceCreateInfoMSFT* put(HandMeshSpaceCreateInfoMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshUpdateInfoMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshUpdateInfoMSFT>
 * @xrentity{XrHandMeshUpdateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandMeshUpdateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandMeshUpdateInfoMSFT(const Time& time_, const HandPoseTypeMSFT& handPoseType_,
                         const void* next_ = nullptr)
      : Parent(StructureType::HandMeshUpdateInfoMSFT, next_),
        time{time_},
        handPoseType{handPoseType_} {}

  //! Default/empty constructor
  HandMeshUpdateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::HandMeshUpdateInfoMSFT, next_), time{}, handPoseType{} {}

  //! Default copy constructor
  HandMeshUpdateInfoMSFT(const HandMeshUpdateInfoMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshUpdateInfoMSFT& operator=(const HandMeshUpdateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshUpdateInfoMSFT(const XrHandMeshUpdateInfoMSFT& rhs) : HandMeshUpdateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandMeshUpdateInfoMSFT& operator=(const XrHandMeshUpdateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshUpdateInfoMSFT&() const {
    return *reinterpret_cast<const XrHandMeshUpdateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshUpdateInfoMSFT&() {
    return *reinterpret_cast<XrHandMeshUpdateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandMeshUpdateInfoMSFT
  XrHandMeshUpdateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshUpdateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshUpdateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandMeshUpdateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandMeshUpdateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandMeshUpdateInfoMSFT*>(this);
  }
  Time time;
  HandPoseTypeMSFT handPoseType;
};
static_assert(sizeof(XrHandMeshUpdateInfoMSFT) == sizeof(HandMeshUpdateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshUpdateInfoMSFT pointer to const from a
 * HandMeshUpdateInfoMSFT reference to const.
 * @relates HandMeshUpdateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshUpdateInfoMSFT const* get(HandMeshUpdateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshUpdateInfoMSFT as the
 * address of a raw XrHandMeshUpdateInfoMSFT
 * @relates HandMeshUpdateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshUpdateInfoMSFT* put(HandMeshUpdateInfoMSFT& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshIndexBufferMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshIndexBufferMSFT>
 * @xrentity{XrHandMeshIndexBufferMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandMeshIndexBufferMSFT {
public:
  //! Constructor initializing all members.
  HandMeshIndexBufferMSFT(uint32_t indexBufferKey_, uint32_t indexCapacityInput_,
                          uint32_t indexCountOutput_, uint32_t* indices_)
      : indexBufferKey{indexBufferKey_},
        indexCapacityInput{indexCapacityInput_},
        indexCountOutput{indexCountOutput_},
        indices{indices_} {}

  //! Default/empty constructor
  HandMeshIndexBufferMSFT()

      : indexBufferKey{0}, indexCapacityInput{0}, indexCountOutput{0}, indices{nullptr} {}

  //! Default copy constructor
  HandMeshIndexBufferMSFT(const HandMeshIndexBufferMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshIndexBufferMSFT& operator=(const HandMeshIndexBufferMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshIndexBufferMSFT(const XrHandMeshIndexBufferMSFT& rhs) : HandMeshIndexBufferMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandMeshIndexBufferMSFT& operator=(const XrHandMeshIndexBufferMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshIndexBufferMSFT&() const {
    return *reinterpret_cast<const XrHandMeshIndexBufferMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshIndexBufferMSFT&() {
    return *reinterpret_cast<XrHandMeshIndexBufferMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandMeshIndexBufferMSFT
  XrHandMeshIndexBufferMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshIndexBufferMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandMeshIndexBufferMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandMeshIndexBufferMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandMeshIndexBufferMSFT{};
    }
    return reinterpret_cast<XrHandMeshIndexBufferMSFT*>(this);
  }
  uint32_t indexBufferKey;
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  uint32_t* indices;
};
static_assert(sizeof(XrHandMeshIndexBufferMSFT) == sizeof(HandMeshIndexBufferMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshIndexBufferMSFT pointer to const from a
 * HandMeshIndexBufferMSFT reference to const.
 * @relates HandMeshIndexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshIndexBufferMSFT const* get(HandMeshIndexBufferMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshIndexBufferMSFT as
 * the address of a raw XrHandMeshIndexBufferMSFT
 * @relates HandMeshIndexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshIndexBufferMSFT* put(HandMeshIndexBufferMSFT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshVertexMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshVertexMSFT>
 * @xrentity{XrHandMeshVertexMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandMeshVertexMSFT {
public:
  //! Constructor initializing all members.
  HandMeshVertexMSFT(const Vector3f& position_, const Vector3f& normal_)
      : position{position_}, normal{normal_} {}

  //! Default/empty constructor
  HandMeshVertexMSFT()

      : position{}, normal{} {}

  //! Default copy constructor
  HandMeshVertexMSFT(const HandMeshVertexMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshVertexMSFT& operator=(const HandMeshVertexMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshVertexMSFT(const XrHandMeshVertexMSFT& rhs) : HandMeshVertexMSFT() { *put() = rhs; }
  //! Copy assign from raw
  HandMeshVertexMSFT& operator=(const XrHandMeshVertexMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshVertexMSFT&() const {
    return *reinterpret_cast<const XrHandMeshVertexMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshVertexMSFT&() { return *reinterpret_cast<XrHandMeshVertexMSFT*>(this); }

  //! Accessor for this as the address of a raw XrHandMeshVertexMSFT
  XrHandMeshVertexMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshVertexMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshVertexMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandMeshVertexMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandMeshVertexMSFT{};
    }
    return reinterpret_cast<XrHandMeshVertexMSFT*>(this);
  }
  Vector3f position;
  Vector3f normal;
};
static_assert(sizeof(XrHandMeshVertexMSFT) == sizeof(HandMeshVertexMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshVertexMSFT pointer to const from a
 * HandMeshVertexMSFT reference to const.
 * @relates HandMeshVertexMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshVertexMSFT const* get(HandMeshVertexMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshVertexMSFT as the
 * address of a raw XrHandMeshVertexMSFT
 * @relates HandMeshVertexMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshVertexMSFT* put(HandMeshVertexMSFT& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshVertexBufferMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshVertexBufferMSFT>
 * @xrentity{XrHandMeshVertexBufferMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandMeshVertexBufferMSFT {
public:
  //! Constructor initializing all members.
  HandMeshVertexBufferMSFT(const Time& vertexUpdateTime_, uint32_t vertexCapacityInput_,
                           uint32_t vertexCountOutput_, HandMeshVertexMSFT* vertices_)
      : vertexUpdateTime{vertexUpdateTime_},
        vertexCapacityInput{vertexCapacityInput_},
        vertexCountOutput{vertexCountOutput_},
        vertices{vertices_} {}

  //! Default/empty constructor
  HandMeshVertexBufferMSFT()

      : vertexUpdateTime{}, vertexCapacityInput{0}, vertexCountOutput{0}, vertices{nullptr} {}

  //! Default copy constructor
  HandMeshVertexBufferMSFT(const HandMeshVertexBufferMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshVertexBufferMSFT& operator=(const HandMeshVertexBufferMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshVertexBufferMSFT(const XrHandMeshVertexBufferMSFT& rhs) : HandMeshVertexBufferMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandMeshVertexBufferMSFT& operator=(const XrHandMeshVertexBufferMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshVertexBufferMSFT&() const {
    return *reinterpret_cast<const XrHandMeshVertexBufferMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshVertexBufferMSFT&() {
    return *reinterpret_cast<XrHandMeshVertexBufferMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandMeshVertexBufferMSFT
  XrHandMeshVertexBufferMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshVertexBufferMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandMeshVertexBufferMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandMeshVertexBufferMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandMeshVertexBufferMSFT{};
    }
    return reinterpret_cast<XrHandMeshVertexBufferMSFT*>(this);
  }
  Time vertexUpdateTime;
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  HandMeshVertexMSFT* vertices;
};
static_assert(sizeof(XrHandMeshVertexBufferMSFT) == sizeof(HandMeshVertexBufferMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshVertexBufferMSFT pointer to const from a
 * HandMeshVertexBufferMSFT reference to const.
 * @relates HandMeshVertexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshVertexBufferMSFT const* get(HandMeshVertexBufferMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshVertexBufferMSFT as
 * the address of a raw XrHandMeshVertexBufferMSFT
 * @relates HandMeshVertexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshVertexBufferMSFT* put(HandMeshVertexBufferMSFT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandMeshMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandMeshMSFT>
 * @xrentity{XrHandMeshMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandMeshMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandMeshMSFT(void* next_ = nullptr)

      : Parent(StructureType::HandMeshMSFT, next_) {}

  //! Default copy constructor
  HandMeshMSFT(const HandMeshMSFT& rhs) = default;
  //! Default copy assignment
  HandMeshMSFT& operator=(const HandMeshMSFT& rhs) = default;
  //! Copy construct from raw
  HandMeshMSFT(const XrHandMeshMSFT& rhs) : HandMeshMSFT() { *put() = rhs; }
  //! Copy assign from raw
  HandMeshMSFT& operator=(const XrHandMeshMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandMeshMSFT&() const { return *reinterpret_cast<const XrHandMeshMSFT*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandMeshMSFT&() { return *reinterpret_cast<XrHandMeshMSFT*>(this); }

  //! Accessor for this as the address of a raw XrHandMeshMSFT
  XrHandMeshMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandMeshMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandMeshMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandMeshMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandMeshMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandMeshMSFT*>(this);
  }
  Bool32 isActive;
  Bool32 indexBufferChanged;
  Bool32 vertexBufferChanged;
  HandMeshIndexBufferMSFT indexBuffer;
  HandMeshVertexBufferMSFT vertexBuffer;
};
static_assert(sizeof(XrHandMeshMSFT) == sizeof(HandMeshMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandMeshMSFT pointer to const from a HandMeshMSFT
 * reference to const.
 * @relates HandMeshMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshMSFT const* get(HandMeshMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandMeshMSFT as the address
 * of a raw XrHandMeshMSFT
 * @relates HandMeshMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandMeshMSFT* put(HandMeshMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh
/*!
 * C++ projection of XrHandPoseTypeInfoMSFT
 *
 * Provided by the `XR_MSFT_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandPoseTypeInfoMSFT>
 * @xrentity{XrHandPoseTypeInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandPoseTypeInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandPoseTypeInfoMSFT(const HandPoseTypeMSFT& handPoseType_, const void* next_ = nullptr)
      : Parent(StructureType::HandPoseTypeInfoMSFT, next_), handPoseType{handPoseType_} {}

  //! Default/empty constructor
  HandPoseTypeInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::HandPoseTypeInfoMSFT, next_), handPoseType{} {}

  //! Default copy constructor
  HandPoseTypeInfoMSFT(const HandPoseTypeInfoMSFT& rhs) = default;
  //! Default copy assignment
  HandPoseTypeInfoMSFT& operator=(const HandPoseTypeInfoMSFT& rhs) = default;
  //! Copy construct from raw
  HandPoseTypeInfoMSFT(const XrHandPoseTypeInfoMSFT& rhs) : HandPoseTypeInfoMSFT() { *put() = rhs; }
  //! Copy assign from raw
  HandPoseTypeInfoMSFT& operator=(const XrHandPoseTypeInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandPoseTypeInfoMSFT&() const {
    return *reinterpret_cast<const XrHandPoseTypeInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandPoseTypeInfoMSFT&() { return *reinterpret_cast<XrHandPoseTypeInfoMSFT*>(this); }

  //! Accessor for this as the address of a raw XrHandPoseTypeInfoMSFT
  XrHandPoseTypeInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrHandPoseTypeInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandPoseTypeInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandPoseTypeInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandPoseTypeInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandPoseTypeInfoMSFT*>(this);
  }
  HandPoseTypeMSFT handPoseType;
};
static_assert(sizeof(XrHandPoseTypeInfoMSFT) == sizeof(HandPoseTypeInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandPoseTypeInfoMSFT pointer to const from a
 * HandPoseTypeInfoMSFT reference to const.
 * @relates HandPoseTypeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandPoseTypeInfoMSFT const* get(HandPoseTypeInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandPoseTypeInfoMSFT as the
 * address of a raw XrHandPoseTypeInfoMSFT
 * @relates HandPoseTypeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandPoseTypeInfoMSFT* put(HandPoseTypeInfoMSFT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationSessionBeginInfoMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationSessionBeginInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationSessionBeginInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationSessionBeginInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SecondaryViewConfigurationSessionBeginInfoMSFT(
      uint32_t viewConfigurationCount_, const ViewConfigurationType* enabledViewConfigurationTypes_,
      const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationSessionBeginInfoMSFT, next_),
        viewConfigurationCount{viewConfigurationCount_},
        enabledViewConfigurationTypes{enabledViewConfigurationTypes_} {}

  //! Default/empty constructor
  SecondaryViewConfigurationSessionBeginInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SecondaryViewConfigurationSessionBeginInfoMSFT, next_),
        viewConfigurationCount{0},
        enabledViewConfigurationTypes{nullptr} {}

  //! Default copy constructor
  SecondaryViewConfigurationSessionBeginInfoMSFT(
      const SecondaryViewConfigurationSessionBeginInfoMSFT& rhs) = default;
  //! Default copy assignment
  SecondaryViewConfigurationSessionBeginInfoMSFT& operator=(
      const SecondaryViewConfigurationSessionBeginInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationSessionBeginInfoMSFT(
      const XrSecondaryViewConfigurationSessionBeginInfoMSFT& rhs)
      : SecondaryViewConfigurationSessionBeginInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationSessionBeginInfoMSFT& operator=(
      const XrSecondaryViewConfigurationSessionBeginInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationSessionBeginInfoMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationSessionBeginInfoMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationSessionBeginInfoMSFT
  XrSecondaryViewConfigurationSessionBeginInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationSessionBeginInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationSessionBeginInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationSessionBeginInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationSessionBeginInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(this);
  }
  uint32_t viewConfigurationCount;
  const ViewConfigurationType* enabledViewConfigurationTypes;
};
static_assert(sizeof(XrSecondaryViewConfigurationSessionBeginInfoMSFT) ==
                  sizeof(SecondaryViewConfigurationSessionBeginInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationSessionBeginInfoMSFT pointer
 * to const from a SecondaryViewConfigurationSessionBeginInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationSessionBeginInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSessionBeginInfoMSFT const* get(
    SecondaryViewConfigurationSessionBeginInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationSessionBeginInfoMSFT as the address of a raw
 * XrSecondaryViewConfigurationSessionBeginInfoMSFT
 * @relates SecondaryViewConfigurationSessionBeginInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSessionBeginInfoMSFT* put(
    SecondaryViewConfigurationSessionBeginInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationStateMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationStateMSFT>
 * @xrentity{XrSecondaryViewConfigurationStateMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationStateMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SecondaryViewConfigurationStateMSFT(void* next_ = nullptr)

      : Parent(StructureType::SecondaryViewConfigurationStateMSFT, next_) {}

  //! Default copy constructor
  SecondaryViewConfigurationStateMSFT(const SecondaryViewConfigurationStateMSFT& rhs) = default;
  //! Default copy assignment
  SecondaryViewConfigurationStateMSFT& operator=(const SecondaryViewConfigurationStateMSFT& rhs) =
      default;
  //! Copy construct from raw
  SecondaryViewConfigurationStateMSFT(const XrSecondaryViewConfigurationStateMSFT& rhs)
      : SecondaryViewConfigurationStateMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationStateMSFT& operator=(const XrSecondaryViewConfigurationStateMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationStateMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationStateMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationStateMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationStateMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationStateMSFT
  XrSecondaryViewConfigurationStateMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationStateMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationStateMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationStateMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationStateMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationStateMSFT*>(this);
  }
  ViewConfigurationType viewConfigurationType;
  Bool32 active;
};
static_assert(sizeof(XrSecondaryViewConfigurationStateMSFT) ==
                  sizeof(SecondaryViewConfigurationStateMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationStateMSFT pointer to const
 * from a SecondaryViewConfigurationStateMSFT reference to const.
 * @relates SecondaryViewConfigurationStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationStateMSFT const* get(
    SecondaryViewConfigurationStateMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationStateMSFT as the address of a raw XrSecondaryViewConfigurationStateMSFT
 * @relates SecondaryViewConfigurationStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationStateMSFT* put(
    SecondaryViewConfigurationStateMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationFrameStateMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationFrameStateMSFT>
 * @xrentity{XrSecondaryViewConfigurationFrameStateMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationFrameStateMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SecondaryViewConfigurationFrameStateMSFT(void* next_ = nullptr)

      : Parent(StructureType::SecondaryViewConfigurationFrameStateMSFT, next_) {}

  //! Default copy constructor
  SecondaryViewConfigurationFrameStateMSFT(const SecondaryViewConfigurationFrameStateMSFT& rhs) =
      default;
  //! Default copy assignment
  SecondaryViewConfigurationFrameStateMSFT& operator=(
      const SecondaryViewConfigurationFrameStateMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationFrameStateMSFT(const XrSecondaryViewConfigurationFrameStateMSFT& rhs)
      : SecondaryViewConfigurationFrameStateMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationFrameStateMSFT& operator=(
      const XrSecondaryViewConfigurationFrameStateMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationFrameStateMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationFrameStateMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationFrameStateMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationFrameStateMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationFrameStateMSFT
  XrSecondaryViewConfigurationFrameStateMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationFrameStateMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationFrameStateMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationFrameStateMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationFrameStateMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationFrameStateMSFT*>(this);
  }
  uint32_t viewConfigurationCount;
  SecondaryViewConfigurationStateMSFT* viewConfigurationStates;
};
static_assert(sizeof(XrSecondaryViewConfigurationFrameStateMSFT) ==
                  sizeof(SecondaryViewConfigurationFrameStateMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationFrameStateMSFT pointer to
 * const from a SecondaryViewConfigurationFrameStateMSFT reference to const.
 * @relates SecondaryViewConfigurationFrameStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameStateMSFT const* get(
    SecondaryViewConfigurationFrameStateMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationFrameStateMSFT as the address of a raw
 * XrSecondaryViewConfigurationFrameStateMSFT
 * @relates SecondaryViewConfigurationFrameStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameStateMSFT* put(
    SecondaryViewConfigurationFrameStateMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationLayerInfoMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationLayerInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationLayerInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationLayerInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SecondaryViewConfigurationLayerInfoMSFT(const ViewConfigurationType& viewConfigurationType_,
                                          const EnvironmentBlendMode& environmentBlendMode_,
                                          uint32_t layerCount_,
                                          const CompositionLayerBaseHeader* const* layers_,
                                          const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationLayerInfoMSFT, next_),
        viewConfigurationType{viewConfigurationType_},
        environmentBlendMode{environmentBlendMode_},
        layerCount{layerCount_},
        layers{layers_} {}

  //! Default/empty constructor
  SecondaryViewConfigurationLayerInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SecondaryViewConfigurationLayerInfoMSFT, next_),
        viewConfigurationType{},
        environmentBlendMode{},
        layerCount{0},
        layers{nullptr} {}

  //! Default copy constructor
  SecondaryViewConfigurationLayerInfoMSFT(const SecondaryViewConfigurationLayerInfoMSFT& rhs) =
      default;
  //! Default copy assignment
  SecondaryViewConfigurationLayerInfoMSFT& operator=(
      const SecondaryViewConfigurationLayerInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationLayerInfoMSFT(const XrSecondaryViewConfigurationLayerInfoMSFT& rhs)
      : SecondaryViewConfigurationLayerInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationLayerInfoMSFT& operator=(
      const XrSecondaryViewConfigurationLayerInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationLayerInfoMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationLayerInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationLayerInfoMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationLayerInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationLayerInfoMSFT
  XrSecondaryViewConfigurationLayerInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationLayerInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationLayerInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationLayerInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationLayerInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationLayerInfoMSFT*>(this);
  }
  ViewConfigurationType viewConfigurationType;
  EnvironmentBlendMode environmentBlendMode;
  uint32_t layerCount;
  const CompositionLayerBaseHeader* const* layers;
};
static_assert(sizeof(XrSecondaryViewConfigurationLayerInfoMSFT) ==
                  sizeof(SecondaryViewConfigurationLayerInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationLayerInfoMSFT pointer to const
 * from a SecondaryViewConfigurationLayerInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationLayerInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationLayerInfoMSFT const* get(
    SecondaryViewConfigurationLayerInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationLayerInfoMSFT as the address of a raw
 * XrSecondaryViewConfigurationLayerInfoMSFT
 * @relates SecondaryViewConfigurationLayerInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationLayerInfoMSFT* put(
    SecondaryViewConfigurationLayerInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationFrameEndInfoMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationFrameEndInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationFrameEndInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationFrameEndInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SecondaryViewConfigurationFrameEndInfoMSFT(
      uint32_t viewConfigurationCount_,
      const SecondaryViewConfigurationLayerInfoMSFT* viewConfigurationLayersInfo_,
      const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationFrameEndInfoMSFT, next_),
        viewConfigurationCount{viewConfigurationCount_},
        viewConfigurationLayersInfo{viewConfigurationLayersInfo_} {}

  //! Default/empty constructor
  SecondaryViewConfigurationFrameEndInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SecondaryViewConfigurationFrameEndInfoMSFT, next_),
        viewConfigurationCount{0},
        viewConfigurationLayersInfo{nullptr} {}

  //! Default copy constructor
  SecondaryViewConfigurationFrameEndInfoMSFT(
      const SecondaryViewConfigurationFrameEndInfoMSFT& rhs) = default;
  //! Default copy assignment
  SecondaryViewConfigurationFrameEndInfoMSFT& operator=(
      const SecondaryViewConfigurationFrameEndInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationFrameEndInfoMSFT(
      const XrSecondaryViewConfigurationFrameEndInfoMSFT& rhs)
      : SecondaryViewConfigurationFrameEndInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationFrameEndInfoMSFT& operator=(
      const XrSecondaryViewConfigurationFrameEndInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationFrameEndInfoMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationFrameEndInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationFrameEndInfoMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationFrameEndInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationFrameEndInfoMSFT
  XrSecondaryViewConfigurationFrameEndInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationFrameEndInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationFrameEndInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationFrameEndInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationFrameEndInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationFrameEndInfoMSFT*>(this);
  }
  uint32_t viewConfigurationCount;
  const SecondaryViewConfigurationLayerInfoMSFT* viewConfigurationLayersInfo;
};
static_assert(sizeof(XrSecondaryViewConfigurationFrameEndInfoMSFT) ==
                  sizeof(SecondaryViewConfigurationFrameEndInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationFrameEndInfoMSFT pointer to
 * const from a SecondaryViewConfigurationFrameEndInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationFrameEndInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameEndInfoMSFT const* get(
    SecondaryViewConfigurationFrameEndInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationFrameEndInfoMSFT as the address of a raw
 * XrSecondaryViewConfigurationFrameEndInfoMSFT
 * @relates SecondaryViewConfigurationFrameEndInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationFrameEndInfoMSFT* put(
    SecondaryViewConfigurationFrameEndInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_secondary_view_configuration
/*!
 * C++ projection of XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_secondary_view_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSecondaryViewConfigurationSwapchainCreateInfoMSFT>
 * @xrentity{XrSecondaryViewConfigurationSwapchainCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SecondaryViewConfigurationSwapchainCreateInfoMSFT
    : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SecondaryViewConfigurationSwapchainCreateInfoMSFT(
      const ViewConfigurationType& viewConfigurationType_, const void* next_ = nullptr)
      : Parent(StructureType::SecondaryViewConfigurationSwapchainCreateInfoMSFT, next_),
        viewConfigurationType{viewConfigurationType_} {}

  //! Default/empty constructor
  SecondaryViewConfigurationSwapchainCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SecondaryViewConfigurationSwapchainCreateInfoMSFT, next_),
        viewConfigurationType{} {}

  //! Default copy constructor
  SecondaryViewConfigurationSwapchainCreateInfoMSFT(
      const SecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SecondaryViewConfigurationSwapchainCreateInfoMSFT& operator=(
      const SecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SecondaryViewConfigurationSwapchainCreateInfoMSFT(
      const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs)
      : SecondaryViewConfigurationSwapchainCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SecondaryViewConfigurationSwapchainCreateInfoMSFT& operator=(
      const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSecondaryViewConfigurationSwapchainCreateInfoMSFT&() {
    return *reinterpret_cast<XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
  XrSecondaryViewConfigurationSwapchainCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSecondaryViewConfigurationSwapchainCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSecondaryViewConfigurationSwapchainCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSecondaryViewConfigurationSwapchainCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SecondaryViewConfigurationSwapchainCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(this);
  }
  ViewConfigurationType viewConfigurationType;
};
static_assert(sizeof(XrSecondaryViewConfigurationSwapchainCreateInfoMSFT) ==
                  sizeof(SecondaryViewConfigurationSwapchainCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
 * pointer to const from a SecondaryViewConfigurationSwapchainCreateInfoMSFT reference to const.
 * @relates SecondaryViewConfigurationSwapchainCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSwapchainCreateInfoMSFT const* get(
    SecondaryViewConfigurationSwapchainCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SecondaryViewConfigurationSwapchainCreateInfoMSFT as the address of a raw
 * XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
 * @relates SecondaryViewConfigurationSwapchainCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSecondaryViewConfigurationSwapchainCreateInfoMSFT* put(
    SecondaryViewConfigurationSwapchainCreateInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_secondary_view_configuration

#ifdef XR_MSFT_controller_model
/*!
 * C++ projection of XrControllerModelKeyStateMSFT
 *
 * Provided by the `XR_MSFT_controller_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrControllerModelKeyStateMSFT>
 * @xrentity{XrControllerModelKeyStateMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ControllerModelKeyStateMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ControllerModelKeyStateMSFT(void* next_ = nullptr)

      : Parent(StructureType::ControllerModelKeyStateMSFT, next_) {}

  //! Default copy constructor
  ControllerModelKeyStateMSFT(const ControllerModelKeyStateMSFT& rhs) = default;
  //! Default copy assignment
  ControllerModelKeyStateMSFT& operator=(const ControllerModelKeyStateMSFT& rhs) = default;
  //! Copy construct from raw
  ControllerModelKeyStateMSFT(const XrControllerModelKeyStateMSFT& rhs)
      : ControllerModelKeyStateMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ControllerModelKeyStateMSFT& operator=(const XrControllerModelKeyStateMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrControllerModelKeyStateMSFT&() const {
    return *reinterpret_cast<const XrControllerModelKeyStateMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrControllerModelKeyStateMSFT&() {
    return *reinterpret_cast<XrControllerModelKeyStateMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrControllerModelKeyStateMSFT
  XrControllerModelKeyStateMSFT const* get() const noexcept {
    return reinterpret_cast<XrControllerModelKeyStateMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrControllerModelKeyStateMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrControllerModelKeyStateMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ControllerModelKeyStateMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrControllerModelKeyStateMSFT*>(this);
  }
  ControllerModelKeyMSFT modelKey;
};
static_assert(sizeof(XrControllerModelKeyStateMSFT) == sizeof(ControllerModelKeyStateMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrControllerModelKeyStateMSFT pointer to const from a
 * ControllerModelKeyStateMSFT reference to const.
 * @relates ControllerModelKeyStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrControllerModelKeyStateMSFT const* get(
    ControllerModelKeyStateMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ControllerModelKeyStateMSFT
 * as the address of a raw XrControllerModelKeyStateMSFT
 * @relates ControllerModelKeyStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrControllerModelKeyStateMSFT* put(ControllerModelKeyStateMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_controller_model

#ifdef XR_MSFT_controller_model
/*!
 * C++ projection of XrControllerModelNodePropertiesMSFT
 *
 * Provided by the `XR_MSFT_controller_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrControllerModelNodePropertiesMSFT>
 * @xrentity{XrControllerModelNodePropertiesMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ControllerModelNodePropertiesMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ControllerModelNodePropertiesMSFT(void* next_ = nullptr)

      : Parent(StructureType::ControllerModelNodePropertiesMSFT, next_) {}

  //! Default copy constructor
  ControllerModelNodePropertiesMSFT(const ControllerModelNodePropertiesMSFT& rhs) = default;
  //! Default copy assignment
  ControllerModelNodePropertiesMSFT& operator=(const ControllerModelNodePropertiesMSFT& rhs) =
      default;
  //! Copy construct from raw
  ControllerModelNodePropertiesMSFT(const XrControllerModelNodePropertiesMSFT& rhs)
      : ControllerModelNodePropertiesMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ControllerModelNodePropertiesMSFT& operator=(const XrControllerModelNodePropertiesMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrControllerModelNodePropertiesMSFT&() const {
    return *reinterpret_cast<const XrControllerModelNodePropertiesMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrControllerModelNodePropertiesMSFT&() {
    return *reinterpret_cast<XrControllerModelNodePropertiesMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrControllerModelNodePropertiesMSFT
  XrControllerModelNodePropertiesMSFT const* get() const noexcept {
    return reinterpret_cast<XrControllerModelNodePropertiesMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrControllerModelNodePropertiesMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrControllerModelNodePropertiesMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ControllerModelNodePropertiesMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrControllerModelNodePropertiesMSFT*>(this);
  }
  char parentNodeName[XR_MAX_CONTROLLER_MODEL_NODE_NAME_SIZE_MSFT];
  char nodeName[XR_MAX_CONTROLLER_MODEL_NODE_NAME_SIZE_MSFT];
};
static_assert(sizeof(XrControllerModelNodePropertiesMSFT) ==
                  sizeof(ControllerModelNodePropertiesMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrControllerModelNodePropertiesMSFT pointer to const from
 * a ControllerModelNodePropertiesMSFT reference to const.
 * @relates ControllerModelNodePropertiesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrControllerModelNodePropertiesMSFT const* get(
    ControllerModelNodePropertiesMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ControllerModelNodePropertiesMSFT as the address of a raw XrControllerModelNodePropertiesMSFT
 * @relates ControllerModelNodePropertiesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrControllerModelNodePropertiesMSFT* put(
    ControllerModelNodePropertiesMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_controller_model

#ifdef XR_MSFT_controller_model
/*!
 * C++ projection of XrControllerModelPropertiesMSFT
 *
 * Provided by the `XR_MSFT_controller_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrControllerModelPropertiesMSFT>
 * @xrentity{XrControllerModelPropertiesMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ControllerModelPropertiesMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ControllerModelPropertiesMSFT(void* next_ = nullptr)

      : Parent(StructureType::ControllerModelPropertiesMSFT, next_) {}

  //! Default copy constructor
  ControllerModelPropertiesMSFT(const ControllerModelPropertiesMSFT& rhs) = default;
  //! Default copy assignment
  ControllerModelPropertiesMSFT& operator=(const ControllerModelPropertiesMSFT& rhs) = default;
  //! Copy construct from raw
  ControllerModelPropertiesMSFT(const XrControllerModelPropertiesMSFT& rhs)
      : ControllerModelPropertiesMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ControllerModelPropertiesMSFT& operator=(const XrControllerModelPropertiesMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrControllerModelPropertiesMSFT&() const {
    return *reinterpret_cast<const XrControllerModelPropertiesMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrControllerModelPropertiesMSFT&() {
    return *reinterpret_cast<XrControllerModelPropertiesMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrControllerModelPropertiesMSFT
  XrControllerModelPropertiesMSFT const* get() const noexcept {
    return reinterpret_cast<XrControllerModelPropertiesMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrControllerModelPropertiesMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrControllerModelPropertiesMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ControllerModelPropertiesMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrControllerModelPropertiesMSFT*>(this);
  }
  uint32_t nodeCapacityInput;
  uint32_t nodeCountOutput;
  ControllerModelNodePropertiesMSFT* nodeProperties;
};
static_assert(sizeof(XrControllerModelPropertiesMSFT) == sizeof(ControllerModelPropertiesMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrControllerModelPropertiesMSFT pointer to const from a
 * ControllerModelPropertiesMSFT reference to const.
 * @relates ControllerModelPropertiesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrControllerModelPropertiesMSFT const* get(
    ControllerModelPropertiesMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ControllerModelPropertiesMSFT
 * as the address of a raw XrControllerModelPropertiesMSFT
 * @relates ControllerModelPropertiesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrControllerModelPropertiesMSFT* put(ControllerModelPropertiesMSFT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_controller_model

#ifdef XR_MSFT_controller_model
/*!
 * C++ projection of XrControllerModelNodeStateMSFT
 *
 * Provided by the `XR_MSFT_controller_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrControllerModelNodeStateMSFT>
 * @xrentity{XrControllerModelNodeStateMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ControllerModelNodeStateMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ControllerModelNodeStateMSFT(void* next_ = nullptr)

      : Parent(StructureType::ControllerModelNodeStateMSFT, next_) {}

  //! Default copy constructor
  ControllerModelNodeStateMSFT(const ControllerModelNodeStateMSFT& rhs) = default;
  //! Default copy assignment
  ControllerModelNodeStateMSFT& operator=(const ControllerModelNodeStateMSFT& rhs) = default;
  //! Copy construct from raw
  ControllerModelNodeStateMSFT(const XrControllerModelNodeStateMSFT& rhs)
      : ControllerModelNodeStateMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ControllerModelNodeStateMSFT& operator=(const XrControllerModelNodeStateMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrControllerModelNodeStateMSFT&() const {
    return *reinterpret_cast<const XrControllerModelNodeStateMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrControllerModelNodeStateMSFT&() {
    return *reinterpret_cast<XrControllerModelNodeStateMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrControllerModelNodeStateMSFT
  XrControllerModelNodeStateMSFT const* get() const noexcept {
    return reinterpret_cast<XrControllerModelNodeStateMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrControllerModelNodeStateMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrControllerModelNodeStateMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ControllerModelNodeStateMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrControllerModelNodeStateMSFT*>(this);
  }
  Posef nodePose;
};
static_assert(sizeof(XrControllerModelNodeStateMSFT) == sizeof(ControllerModelNodeStateMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrControllerModelNodeStateMSFT pointer to const from a
 * ControllerModelNodeStateMSFT reference to const.
 * @relates ControllerModelNodeStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrControllerModelNodeStateMSFT const* get(
    ControllerModelNodeStateMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ControllerModelNodeStateMSFT
 * as the address of a raw XrControllerModelNodeStateMSFT
 * @relates ControllerModelNodeStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrControllerModelNodeStateMSFT* put(ControllerModelNodeStateMSFT& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_controller_model

#ifdef XR_MSFT_controller_model
/*!
 * C++ projection of XrControllerModelStateMSFT
 *
 * Provided by the `XR_MSFT_controller_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrControllerModelStateMSFT>
 * @xrentity{XrControllerModelStateMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ControllerModelStateMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ControllerModelStateMSFT(void* next_ = nullptr)

      : Parent(StructureType::ControllerModelStateMSFT, next_) {}

  //! Default copy constructor
  ControllerModelStateMSFT(const ControllerModelStateMSFT& rhs) = default;
  //! Default copy assignment
  ControllerModelStateMSFT& operator=(const ControllerModelStateMSFT& rhs) = default;
  //! Copy construct from raw
  ControllerModelStateMSFT(const XrControllerModelStateMSFT& rhs) : ControllerModelStateMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ControllerModelStateMSFT& operator=(const XrControllerModelStateMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrControllerModelStateMSFT&() const {
    return *reinterpret_cast<const XrControllerModelStateMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrControllerModelStateMSFT&() {
    return *reinterpret_cast<XrControllerModelStateMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrControllerModelStateMSFT
  XrControllerModelStateMSFT const* get() const noexcept {
    return reinterpret_cast<XrControllerModelStateMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrControllerModelStateMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrControllerModelStateMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ControllerModelStateMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrControllerModelStateMSFT*>(this);
  }
  uint32_t nodeCapacityInput;
  uint32_t nodeCountOutput;
  ControllerModelNodeStateMSFT* nodeStates;
};
static_assert(sizeof(XrControllerModelStateMSFT) == sizeof(ControllerModelStateMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrControllerModelStateMSFT pointer to const from a
 * ControllerModelStateMSFT reference to const.
 * @relates ControllerModelStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrControllerModelStateMSFT const* get(ControllerModelStateMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ControllerModelStateMSFT as
 * the address of a raw XrControllerModelStateMSFT
 * @relates ControllerModelStateMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrControllerModelStateMSFT* put(ControllerModelStateMSFT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_controller_model

#ifdef XR_EPIC_view_configuration_fov
/*!
 * C++ projection of XrViewConfigurationViewFovEPIC
 *
 * Provided by the `XR_EPIC_view_configuration_fov` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewConfigurationViewFovEPIC>
 * @xrentity{XrViewConfigurationViewFovEPIC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewConfigurationViewFovEPIC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ViewConfigurationViewFovEPIC(const Fovf& recommendedFov_, const Fovf& maxMutableFov_,
                               const void* next_ = nullptr)
      : Parent(StructureType::ViewConfigurationViewFovEPIC, next_),
        recommendedFov{recommendedFov_},
        maxMutableFov{maxMutableFov_} {}

  //! Default/empty constructor
  ViewConfigurationViewFovEPIC(const void* next_ = nullptr)

      : Parent(StructureType::ViewConfigurationViewFovEPIC, next_),
        recommendedFov{},
        maxMutableFov{} {}

  //! Default copy constructor
  ViewConfigurationViewFovEPIC(const ViewConfigurationViewFovEPIC& rhs) = default;
  //! Default copy assignment
  ViewConfigurationViewFovEPIC& operator=(const ViewConfigurationViewFovEPIC& rhs) = default;
  //! Copy construct from raw
  ViewConfigurationViewFovEPIC(const XrViewConfigurationViewFovEPIC& rhs)
      : ViewConfigurationViewFovEPIC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewConfigurationViewFovEPIC& operator=(const XrViewConfigurationViewFovEPIC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewConfigurationViewFovEPIC&() const {
    return *reinterpret_cast<const XrViewConfigurationViewFovEPIC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewConfigurationViewFovEPIC&() {
    return *reinterpret_cast<XrViewConfigurationViewFovEPIC*>(this);
  }

  //! Accessor for this as the address of a raw XrViewConfigurationViewFovEPIC
  XrViewConfigurationViewFovEPIC const* get() const noexcept {
    return reinterpret_cast<XrViewConfigurationViewFovEPIC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrViewConfigurationViewFovEPIC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewConfigurationViewFovEPIC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewConfigurationViewFovEPIC{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewConfigurationViewFovEPIC*>(this);
  }
  Fovf recommendedFov;
  Fovf maxMutableFov;
};
static_assert(sizeof(XrViewConfigurationViewFovEPIC) == sizeof(ViewConfigurationViewFovEPIC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewConfigurationViewFovEPIC pointer to const from a
 * ViewConfigurationViewFovEPIC reference to const.
 * @relates ViewConfigurationViewFovEPIC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationViewFovEPIC const* get(
    ViewConfigurationViewFovEPIC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ViewConfigurationViewFovEPIC
 * as the address of a raw XrViewConfigurationViewFovEPIC
 * @relates ViewConfigurationViewFovEPIC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewConfigurationViewFovEPIC* put(ViewConfigurationViewFovEPIC& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EPIC_view_configuration_fov

#ifdef XR_MSFT_holographic_window_attachment
#if defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
/*!
 * C++ projection of XrHolographicWindowAttachmentMSFT
 *
 * Provided by the `XR_MSFT_holographic_window_attachment` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHolographicWindowAttachmentMSFT>
 * @xrentity{XrHolographicWindowAttachmentMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HolographicWindowAttachmentMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HolographicWindowAttachmentMSFT(IUnknown* holographicSpace_, IUnknown* coreWindow_,
                                  const void* next_ = nullptr)
      : Parent(StructureType::HolographicWindowAttachmentMSFT, next_),
        holographicSpace{holographicSpace_},
        coreWindow{coreWindow_} {}

  //! Default/empty constructor
  HolographicWindowAttachmentMSFT(const void* next_ = nullptr)

      : Parent(StructureType::HolographicWindowAttachmentMSFT, next_),
        holographicSpace{nullptr},
        coreWindow{nullptr} {}

  //! Default copy constructor
  HolographicWindowAttachmentMSFT(const HolographicWindowAttachmentMSFT& rhs) = default;
  //! Default copy assignment
  HolographicWindowAttachmentMSFT& operator=(const HolographicWindowAttachmentMSFT& rhs) = default;
  //! Copy construct from raw
  HolographicWindowAttachmentMSFT(const XrHolographicWindowAttachmentMSFT& rhs)
      : HolographicWindowAttachmentMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HolographicWindowAttachmentMSFT& operator=(const XrHolographicWindowAttachmentMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHolographicWindowAttachmentMSFT&() const {
    return *reinterpret_cast<const XrHolographicWindowAttachmentMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHolographicWindowAttachmentMSFT&() {
    return *reinterpret_cast<XrHolographicWindowAttachmentMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrHolographicWindowAttachmentMSFT
  XrHolographicWindowAttachmentMSFT const* get() const noexcept {
    return reinterpret_cast<XrHolographicWindowAttachmentMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHolographicWindowAttachmentMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHolographicWindowAttachmentMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HolographicWindowAttachmentMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHolographicWindowAttachmentMSFT*>(this);
  }
  IUnknown* holographicSpace;
  IUnknown* coreWindow;
};
static_assert(sizeof(XrHolographicWindowAttachmentMSFT) == sizeof(HolographicWindowAttachmentMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHolographicWindowAttachmentMSFT pointer to const from a
 * HolographicWindowAttachmentMSFT reference to const.
 * @relates HolographicWindowAttachmentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHolographicWindowAttachmentMSFT const* get(
    HolographicWindowAttachmentMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * HolographicWindowAttachmentMSFT as the address of a raw XrHolographicWindowAttachmentMSFT
 * @relates HolographicWindowAttachmentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHolographicWindowAttachmentMSFT* put(HolographicWindowAttachmentMSFT& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_holographic_window_attachment

#ifdef XR_MSFT_composition_layer_reprojection
/*!
 * C++ projection of XrCompositionLayerReprojectionInfoMSFT
 *
 * Provided by the `XR_MSFT_composition_layer_reprojection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerReprojectionInfoMSFT>
 * @xrentity{XrCompositionLayerReprojectionInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerReprojectionInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerReprojectionInfoMSFT(const ReprojectionModeMSFT& reprojectionMode_,
                                       const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerReprojectionInfoMSFT, next_),
        reprojectionMode{reprojectionMode_} {}

  //! Default/empty constructor
  CompositionLayerReprojectionInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerReprojectionInfoMSFT, next_), reprojectionMode{} {}

  //! Default copy constructor
  CompositionLayerReprojectionInfoMSFT(const CompositionLayerReprojectionInfoMSFT& rhs) = default;
  //! Default copy assignment
  CompositionLayerReprojectionInfoMSFT& operator=(const CompositionLayerReprojectionInfoMSFT& rhs) =
      default;
  //! Copy construct from raw
  CompositionLayerReprojectionInfoMSFT(const XrCompositionLayerReprojectionInfoMSFT& rhs)
      : CompositionLayerReprojectionInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerReprojectionInfoMSFT& operator=(
      const XrCompositionLayerReprojectionInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerReprojectionInfoMSFT&() const {
    return *reinterpret_cast<const XrCompositionLayerReprojectionInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerReprojectionInfoMSFT&() {
    return *reinterpret_cast<XrCompositionLayerReprojectionInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerReprojectionInfoMSFT
  XrCompositionLayerReprojectionInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerReprojectionInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerReprojectionInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerReprojectionInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerReprojectionInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerReprojectionInfoMSFT*>(this);
  }
  ReprojectionModeMSFT reprojectionMode;
};
static_assert(sizeof(XrCompositionLayerReprojectionInfoMSFT) ==
                  sizeof(CompositionLayerReprojectionInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerReprojectionInfoMSFT pointer to const
 * from a CompositionLayerReprojectionInfoMSFT reference to const.
 * @relates CompositionLayerReprojectionInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerReprojectionInfoMSFT const* get(
    CompositionLayerReprojectionInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerReprojectionInfoMSFT as the address of a raw
 * XrCompositionLayerReprojectionInfoMSFT
 * @relates CompositionLayerReprojectionInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerReprojectionInfoMSFT* put(
    CompositionLayerReprojectionInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_composition_layer_reprojection

#ifdef XR_MSFT_composition_layer_reprojection
/*!
 * C++ projection of XrCompositionLayerReprojectionPlaneOverrideMSFT
 *
 * Provided by the `XR_MSFT_composition_layer_reprojection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerReprojectionPlaneOverrideMSFT>
 * @xrentity{XrCompositionLayerReprojectionPlaneOverrideMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerReprojectionPlaneOverrideMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerReprojectionPlaneOverrideMSFT(const Vector3f& position_, const Vector3f& normal_,
                                                const Vector3f& velocity_,
                                                const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerReprojectionPlaneOverrideMSFT, next_),
        position{position_},
        normal{normal_},
        velocity{velocity_} {}

  //! Default/empty constructor
  CompositionLayerReprojectionPlaneOverrideMSFT(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerReprojectionPlaneOverrideMSFT, next_),
        position{},
        normal{},
        velocity{} {}

  //! Default copy constructor
  CompositionLayerReprojectionPlaneOverrideMSFT(
      const CompositionLayerReprojectionPlaneOverrideMSFT& rhs) = default;
  //! Default copy assignment
  CompositionLayerReprojectionPlaneOverrideMSFT& operator=(
      const CompositionLayerReprojectionPlaneOverrideMSFT& rhs) = default;
  //! Copy construct from raw
  CompositionLayerReprojectionPlaneOverrideMSFT(
      const XrCompositionLayerReprojectionPlaneOverrideMSFT& rhs)
      : CompositionLayerReprojectionPlaneOverrideMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerReprojectionPlaneOverrideMSFT& operator=(
      const XrCompositionLayerReprojectionPlaneOverrideMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerReprojectionPlaneOverrideMSFT&() const {
    return *reinterpret_cast<const XrCompositionLayerReprojectionPlaneOverrideMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerReprojectionPlaneOverrideMSFT&() {
    return *reinterpret_cast<XrCompositionLayerReprojectionPlaneOverrideMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerReprojectionPlaneOverrideMSFT
  XrCompositionLayerReprojectionPlaneOverrideMSFT const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerReprojectionPlaneOverrideMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerReprojectionPlaneOverrideMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerReprojectionPlaneOverrideMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerReprojectionPlaneOverrideMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerReprojectionPlaneOverrideMSFT*>(this);
  }
  Vector3f position;
  Vector3f normal;
  Vector3f velocity;
};
static_assert(sizeof(XrCompositionLayerReprojectionPlaneOverrideMSFT) ==
                  sizeof(CompositionLayerReprojectionPlaneOverrideMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerReprojectionPlaneOverrideMSFT pointer to
 * const from a CompositionLayerReprojectionPlaneOverrideMSFT reference to const.
 * @relates CompositionLayerReprojectionPlaneOverrideMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerReprojectionPlaneOverrideMSFT const* get(
    CompositionLayerReprojectionPlaneOverrideMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerReprojectionPlaneOverrideMSFT as the address of a raw
 * XrCompositionLayerReprojectionPlaneOverrideMSFT
 * @relates CompositionLayerReprojectionPlaneOverrideMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerReprojectionPlaneOverrideMSFT* put(
    CompositionLayerReprojectionPlaneOverrideMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_composition_layer_reprojection

#ifdef XR_FB_android_surface_swapchain_create
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrAndroidSurfaceSwapchainCreateInfoFB
 *
 * Provided by the `XR_FB_android_surface_swapchain_create` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrAndroidSurfaceSwapchainCreateInfoFB>
 * @xrentity{XrAndroidSurfaceSwapchainCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS AndroidSurfaceSwapchainCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  AndroidSurfaceSwapchainCreateInfoFB(const AndroidSurfaceSwapchainFlagsFB& createFlags_,
                                      const void* next_ = nullptr)
      : Parent(StructureType::AndroidSurfaceSwapchainCreateInfoFB, next_),
        createFlags{createFlags_} {}

  //! Default/empty constructor
  AndroidSurfaceSwapchainCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::AndroidSurfaceSwapchainCreateInfoFB, next_), createFlags{} {}

  //! Default copy constructor
  AndroidSurfaceSwapchainCreateInfoFB(const AndroidSurfaceSwapchainCreateInfoFB& rhs) = default;
  //! Default copy assignment
  AndroidSurfaceSwapchainCreateInfoFB& operator=(const AndroidSurfaceSwapchainCreateInfoFB& rhs) =
      default;
  //! Copy construct from raw
  AndroidSurfaceSwapchainCreateInfoFB(const XrAndroidSurfaceSwapchainCreateInfoFB& rhs)
      : AndroidSurfaceSwapchainCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  AndroidSurfaceSwapchainCreateInfoFB& operator=(const XrAndroidSurfaceSwapchainCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrAndroidSurfaceSwapchainCreateInfoFB&() const {
    return *reinterpret_cast<const XrAndroidSurfaceSwapchainCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrAndroidSurfaceSwapchainCreateInfoFB&() {
    return *reinterpret_cast<XrAndroidSurfaceSwapchainCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrAndroidSurfaceSwapchainCreateInfoFB
  XrAndroidSurfaceSwapchainCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrAndroidSurfaceSwapchainCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrAndroidSurfaceSwapchainCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrAndroidSurfaceSwapchainCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = AndroidSurfaceSwapchainCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrAndroidSurfaceSwapchainCreateInfoFB*>(this);
  }
  AndroidSurfaceSwapchainFlagsFB createFlags;
};
static_assert(sizeof(XrAndroidSurfaceSwapchainCreateInfoFB) ==
                  sizeof(AndroidSurfaceSwapchainCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrAndroidSurfaceSwapchainCreateInfoFB pointer to const
 * from a AndroidSurfaceSwapchainCreateInfoFB reference to const.
 * @relates AndroidSurfaceSwapchainCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrAndroidSurfaceSwapchainCreateInfoFB const* get(
    AndroidSurfaceSwapchainCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * AndroidSurfaceSwapchainCreateInfoFB as the address of a raw XrAndroidSurfaceSwapchainCreateInfoFB
 * @relates AndroidSurfaceSwapchainCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrAndroidSurfaceSwapchainCreateInfoFB* put(
    AndroidSurfaceSwapchainCreateInfoFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_FB_android_surface_swapchain_create

#ifdef XR_FB_swapchain_update_state
/*!
 * C++ projection of XrSwapchainStateBaseHeaderFB
 *
 * Provided by the `XR_FB_swapchain_update_state` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateBaseHeaderFB>
 * @xrentity{XrSwapchainStateBaseHeaderFB}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS SwapchainStateBaseHeaderFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  SwapchainStateBaseHeaderFB(StructureType type_, void* next_ = nullptr) : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainStateBaseHeaderFB&() const {
    return *reinterpret_cast<const XrSwapchainStateBaseHeaderFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainStateBaseHeaderFB&() {
    return *reinterpret_cast<XrSwapchainStateBaseHeaderFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainStateBaseHeaderFB
  XrSwapchainStateBaseHeaderFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw XrSwapchainStateBaseHeaderFB.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrSwapchainStateBaseHeaderFB* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrSwapchainStateBaseHeaderFB*>(this);
  }
};
static_assert(sizeof(XrSwapchainStateBaseHeaderFB) == sizeof(SwapchainStateBaseHeaderFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainStateBaseHeaderFB pointer to const from a
 * SwapchainStateBaseHeaderFB reference to const.
 * @relates SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get(
    SwapchainStateBaseHeaderFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainStateBaseHeaderFB as
 * the address of a raw XrSwapchainStateBaseHeaderFB
 * @relates SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB* put(SwapchainStateBaseHeaderFB& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_swapchain_update_state

#ifdef XR_FB_composition_layer_secure_content
/*!
 * C++ projection of XrCompositionLayerSecureContentFB
 *
 * Provided by the `XR_FB_composition_layer_secure_content` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerSecureContentFB>
 * @xrentity{XrCompositionLayerSecureContentFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerSecureContentFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerSecureContentFB(const CompositionLayerSecureContentFlagsFB& flags_,
                                  const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerSecureContentFB, next_), flags{flags_} {}

  //! Default/empty constructor
  CompositionLayerSecureContentFB(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerSecureContentFB, next_), flags{} {}

  //! Default copy constructor
  CompositionLayerSecureContentFB(const CompositionLayerSecureContentFB& rhs) = default;
  //! Default copy assignment
  CompositionLayerSecureContentFB& operator=(const CompositionLayerSecureContentFB& rhs) = default;
  //! Copy construct from raw
  CompositionLayerSecureContentFB(const XrCompositionLayerSecureContentFB& rhs)
      : CompositionLayerSecureContentFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerSecureContentFB& operator=(const XrCompositionLayerSecureContentFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerSecureContentFB&() const {
    return *reinterpret_cast<const XrCompositionLayerSecureContentFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerSecureContentFB&() {
    return *reinterpret_cast<XrCompositionLayerSecureContentFB*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerSecureContentFB
  XrCompositionLayerSecureContentFB const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerSecureContentFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerSecureContentFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerSecureContentFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerSecureContentFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerSecureContentFB*>(this);
  }
  CompositionLayerSecureContentFlagsFB flags;
};
static_assert(sizeof(XrCompositionLayerSecureContentFB) == sizeof(CompositionLayerSecureContentFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerSecureContentFB pointer to const from a
 * CompositionLayerSecureContentFB reference to const.
 * @relates CompositionLayerSecureContentFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerSecureContentFB const* get(
    CompositionLayerSecureContentFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerSecureContentFB as the address of a raw XrCompositionLayerSecureContentFB
 * @relates CompositionLayerSecureContentFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerSecureContentFB* put(CompositionLayerSecureContentFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_composition_layer_secure_content

#ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrBodyJointLocationFB
 *
 * Provided by the `XR_FB_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointLocationFB>
 * @xrentity{XrBodyJointLocationFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS BodyJointLocationFB {
public:
  //! Constructor initializing all members.
  BodyJointLocationFB(const SpaceLocationFlags& locationFlags_, const Posef& pose_)
      : locationFlags{locationFlags_}, pose{pose_} {}

  //! Default/empty constructor
  BodyJointLocationFB()

      : locationFlags{}, pose{} {}

  //! Default copy constructor
  BodyJointLocationFB(const BodyJointLocationFB& rhs) = default;
  //! Default copy assignment
  BodyJointLocationFB& operator=(const BodyJointLocationFB& rhs) = default;
  //! Copy construct from raw
  BodyJointLocationFB(const XrBodyJointLocationFB& rhs) : BodyJointLocationFB() { *put() = rhs; }
  //! Copy assign from raw
  BodyJointLocationFB& operator=(const XrBodyJointLocationFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodyJointLocationFB&() const {
    return *reinterpret_cast<const XrBodyJointLocationFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodyJointLocationFB&() { return *reinterpret_cast<XrBodyJointLocationFB*>(this); }

  //! Accessor for this as the address of a raw XrBodyJointLocationFB
  XrBodyJointLocationFB const* get() const noexcept {
    return reinterpret_cast<XrBodyJointLocationFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBodyJointLocationFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrBodyJointLocationFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = BodyJointLocationFB{};
    }
    return reinterpret_cast<XrBodyJointLocationFB*>(this);
  }
  SpaceLocationFlags locationFlags;
  Posef pose;
};
static_assert(sizeof(XrBodyJointLocationFB) == sizeof(BodyJointLocationFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodyJointLocationFB pointer to const from a
 * BodyJointLocationFB reference to const.
 * @relates BodyJointLocationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointLocationFB const* get(BodyJointLocationFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyJointLocationFB as the
 * address of a raw XrBodyJointLocationFB
 * @relates BodyJointLocationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointLocationFB* put(BodyJointLocationFB& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_body_tracking

#ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrSystemBodyTrackingPropertiesFB
 *
 * Provided by the `XR_FB_body_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemBodyTrackingPropertiesFB>
 * @xrentity{XrSystemBodyTrackingPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemBodyTrackingPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemBodyTrackingPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemBodyTrackingPropertiesFB, next_) {}

  //! Default copy constructor
  SystemBodyTrackingPropertiesFB(const SystemBodyTrackingPropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemBodyTrackingPropertiesFB& operator=(const SystemBodyTrackingPropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemBodyTrackingPropertiesFB(const XrSystemBodyTrackingPropertiesFB& rhs)
      : SystemBodyTrackingPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemBodyTrackingPropertiesFB& operator=(const XrSystemBodyTrackingPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemBodyTrackingPropertiesFB&() const {
    return *reinterpret_cast<const XrSystemBodyTrackingPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemBodyTrackingPropertiesFB&() {
    return *reinterpret_cast<XrSystemBodyTrackingPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemBodyTrackingPropertiesFB
  XrSystemBodyTrackingPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemBodyTrackingPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemBodyTrackingPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemBodyTrackingPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemBodyTrackingPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemBodyTrackingPropertiesFB*>(this);
  }
  Bool32 supportsBodyTracking;
};
static_assert(sizeof(XrSystemBodyTrackingPropertiesFB) == sizeof(SystemBodyTrackingPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemBodyTrackingPropertiesFB pointer to const from a
 * SystemBodyTrackingPropertiesFB reference to const.
 * @relates SystemBodyTrackingPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemBodyTrackingPropertiesFB const* get(
    SystemBodyTrackingPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemBodyTrackingPropertiesFB as the address of a raw XrSystemBodyTrackingPropertiesFB
 * @relates SystemBodyTrackingPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemBodyTrackingPropertiesFB* put(SystemBodyTrackingPropertiesFB& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_body_tracking

#ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrBodyTrackerCreateInfoFB
 *
 * Provided by the `XR_FB_body_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyTrackerCreateInfoFB>
 * @xrentity{XrBodyTrackerCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BodyTrackerCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  BodyTrackerCreateInfoFB(const BodyJointSetFB& bodyJointSet_, const void* next_ = nullptr)
      : Parent(StructureType::BodyTrackerCreateInfoFB, next_), bodyJointSet{bodyJointSet_} {}

  //! Default/empty constructor
  BodyTrackerCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::BodyTrackerCreateInfoFB, next_), bodyJointSet{} {}

  //! Default copy constructor
  BodyTrackerCreateInfoFB(const BodyTrackerCreateInfoFB& rhs) = default;
  //! Default copy assignment
  BodyTrackerCreateInfoFB& operator=(const BodyTrackerCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  BodyTrackerCreateInfoFB(const XrBodyTrackerCreateInfoFB& rhs) : BodyTrackerCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BodyTrackerCreateInfoFB& operator=(const XrBodyTrackerCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodyTrackerCreateInfoFB&() const {
    return *reinterpret_cast<const XrBodyTrackerCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodyTrackerCreateInfoFB&() {
    return *reinterpret_cast<XrBodyTrackerCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrBodyTrackerCreateInfoFB
  XrBodyTrackerCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrBodyTrackerCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrBodyTrackerCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBodyTrackerCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BodyTrackerCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrBodyTrackerCreateInfoFB*>(this);
  }
  BodyJointSetFB bodyJointSet;
};
static_assert(sizeof(XrBodyTrackerCreateInfoFB) == sizeof(BodyTrackerCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodyTrackerCreateInfoFB pointer to const from a
 * BodyTrackerCreateInfoFB reference to const.
 * @relates BodyTrackerCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyTrackerCreateInfoFB const* get(BodyTrackerCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyTrackerCreateInfoFB as
 * the address of a raw XrBodyTrackerCreateInfoFB
 * @relates BodyTrackerCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyTrackerCreateInfoFB* put(BodyTrackerCreateInfoFB& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_body_tracking

#ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrBodySkeletonJointFB
 *
 * Provided by the `XR_FB_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodySkeletonJointFB>
 * @xrentity{XrBodySkeletonJointFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS BodySkeletonJointFB {
public:
  //! Constructor initializing all members.
  BodySkeletonJointFB(int32_t joint_, int32_t parentJoint_, const Posef& pose_)
      : joint{joint_}, parentJoint{parentJoint_}, pose{pose_} {}

  //! Default/empty constructor
  BodySkeletonJointFB()

      : joint{0}, parentJoint{0}, pose{} {}

  //! Default copy constructor
  BodySkeletonJointFB(const BodySkeletonJointFB& rhs) = default;
  //! Default copy assignment
  BodySkeletonJointFB& operator=(const BodySkeletonJointFB& rhs) = default;
  //! Copy construct from raw
  BodySkeletonJointFB(const XrBodySkeletonJointFB& rhs) : BodySkeletonJointFB() { *put() = rhs; }
  //! Copy assign from raw
  BodySkeletonJointFB& operator=(const XrBodySkeletonJointFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodySkeletonJointFB&() const {
    return *reinterpret_cast<const XrBodySkeletonJointFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodySkeletonJointFB&() { return *reinterpret_cast<XrBodySkeletonJointFB*>(this); }

  //! Accessor for this as the address of a raw XrBodySkeletonJointFB
  XrBodySkeletonJointFB const* get() const noexcept {
    return reinterpret_cast<XrBodySkeletonJointFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBodySkeletonJointFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrBodySkeletonJointFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = BodySkeletonJointFB{};
    }
    return reinterpret_cast<XrBodySkeletonJointFB*>(this);
  }
  int32_t joint;
  int32_t parentJoint;
  Posef pose;
};
static_assert(sizeof(XrBodySkeletonJointFB) == sizeof(BodySkeletonJointFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodySkeletonJointFB pointer to const from a
 * BodySkeletonJointFB reference to const.
 * @relates BodySkeletonJointFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodySkeletonJointFB const* get(BodySkeletonJointFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodySkeletonJointFB as the
 * address of a raw XrBodySkeletonJointFB
 * @relates BodySkeletonJointFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodySkeletonJointFB* put(BodySkeletonJointFB& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_body_tracking

#ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrBodySkeletonFB
 *
 * Provided by the `XR_FB_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodySkeletonFB>
 * @xrentity{XrBodySkeletonFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BodySkeletonFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  BodySkeletonFB(void* next_ = nullptr)

      : Parent(StructureType::BodySkeletonFB, next_) {}

  //! Default copy constructor
  BodySkeletonFB(const BodySkeletonFB& rhs) = default;
  //! Default copy assignment
  BodySkeletonFB& operator=(const BodySkeletonFB& rhs) = default;
  //! Copy construct from raw
  BodySkeletonFB(const XrBodySkeletonFB& rhs) : BodySkeletonFB() { *put() = rhs; }
  //! Copy assign from raw
  BodySkeletonFB& operator=(const XrBodySkeletonFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodySkeletonFB&() const {
    return *reinterpret_cast<const XrBodySkeletonFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodySkeletonFB&() { return *reinterpret_cast<XrBodySkeletonFB*>(this); }

  //! Accessor for this as the address of a raw XrBodySkeletonFB
  XrBodySkeletonFB const* get() const noexcept {
    return reinterpret_cast<XrBodySkeletonFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBodySkeletonFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBodySkeletonFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BodySkeletonFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrBodySkeletonFB*>(this);
  }
  uint32_t jointCount;
  BodySkeletonJointFB* joints;
};
static_assert(sizeof(XrBodySkeletonFB) == sizeof(BodySkeletonFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodySkeletonFB pointer to const from a BodySkeletonFB
 * reference to const.
 * @relates BodySkeletonFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodySkeletonFB const* get(BodySkeletonFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing BodySkeletonFB as the address
 * of a raw XrBodySkeletonFB
 * @relates BodySkeletonFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodySkeletonFB* put(BodySkeletonFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_body_tracking

#ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrBodyJointsLocateInfoFB
 *
 * Provided by the `XR_FB_body_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointsLocateInfoFB>
 * @xrentity{XrBodyJointsLocateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BodyJointsLocateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  BodyJointsLocateInfoFB(const Space& baseSpace_, const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::BodyJointsLocateInfoFB, next_), baseSpace{baseSpace_}, time{time_} {}

  //! Default/empty constructor
  BodyJointsLocateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::BodyJointsLocateInfoFB, next_), baseSpace{}, time{} {}

  //! Default copy constructor
  BodyJointsLocateInfoFB(const BodyJointsLocateInfoFB& rhs) = default;
  //! Default copy assignment
  BodyJointsLocateInfoFB& operator=(const BodyJointsLocateInfoFB& rhs) = default;
  //! Copy construct from raw
  BodyJointsLocateInfoFB(const XrBodyJointsLocateInfoFB& rhs) : BodyJointsLocateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BodyJointsLocateInfoFB& operator=(const XrBodyJointsLocateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodyJointsLocateInfoFB&() const {
    return *reinterpret_cast<const XrBodyJointsLocateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodyJointsLocateInfoFB&() {
    return *reinterpret_cast<XrBodyJointsLocateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrBodyJointsLocateInfoFB
  XrBodyJointsLocateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrBodyJointsLocateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBodyJointsLocateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBodyJointsLocateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BodyJointsLocateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrBodyJointsLocateInfoFB*>(this);
  }
  Space baseSpace;
  Time time;
};
static_assert(sizeof(XrBodyJointsLocateInfoFB) == sizeof(BodyJointsLocateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodyJointsLocateInfoFB pointer to const from a
 * BodyJointsLocateInfoFB reference to const.
 * @relates BodyJointsLocateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointsLocateInfoFB const* get(BodyJointsLocateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyJointsLocateInfoFB as the
 * address of a raw XrBodyJointsLocateInfoFB
 * @relates BodyJointsLocateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointsLocateInfoFB* put(BodyJointsLocateInfoFB& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_body_tracking

#ifdef XR_FB_body_tracking
/*!
 * C++ projection of XrBodyJointLocationsFB
 *
 * Provided by the `XR_FB_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointLocationsFB>
 * @xrentity{XrBodyJointLocationsFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BodyJointLocationsFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  BodyJointLocationsFB(void* next_ = nullptr)

      : Parent(StructureType::BodyJointLocationsFB, next_) {}

  //! Default copy constructor
  BodyJointLocationsFB(const BodyJointLocationsFB& rhs) = default;
  //! Default copy assignment
  BodyJointLocationsFB& operator=(const BodyJointLocationsFB& rhs) = default;
  //! Copy construct from raw
  BodyJointLocationsFB(const XrBodyJointLocationsFB& rhs) : BodyJointLocationsFB() { *put() = rhs; }
  //! Copy assign from raw
  BodyJointLocationsFB& operator=(const XrBodyJointLocationsFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodyJointLocationsFB&() const {
    return *reinterpret_cast<const XrBodyJointLocationsFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodyJointLocationsFB&() { return *reinterpret_cast<XrBodyJointLocationsFB*>(this); }

  //! Accessor for this as the address of a raw XrBodyJointLocationsFB
  XrBodyJointLocationsFB const* get() const noexcept {
    return reinterpret_cast<XrBodyJointLocationsFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBodyJointLocationsFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBodyJointLocationsFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BodyJointLocationsFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrBodyJointLocationsFB*>(this);
  }
  Bool32 isActive;
  float confidence;
  uint32_t jointCount;
  BodyJointLocationFB* jointLocations;
  uint32_t skeletonChangedCount;
  Time time;
};
static_assert(sizeof(XrBodyJointLocationsFB) == sizeof(BodyJointLocationsFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodyJointLocationsFB pointer to const from a
 * BodyJointLocationsFB reference to const.
 * @relates BodyJointLocationsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointLocationsFB const* get(BodyJointLocationsFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyJointLocationsFB as the
 * address of a raw XrBodyJointLocationsFB
 * @relates BodyJointLocationsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointLocationsFB* put(BodyJointLocationsFB& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_body_tracking

#ifdef XR_EXT_dpad_binding
/*!
 * C++ projection of XrInteractionProfileDpadBindingEXT
 *
 * Provided by the `XR_EXT_dpad_binding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileDpadBindingEXT>
 * @xrentity{XrInteractionProfileDpadBindingEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionProfileDpadBindingEXT : public BindingModificationBaseHeaderKHR {
private:
  using Parent = BindingModificationBaseHeaderKHR;

public:
  //! Constructor initializing all members.
  InteractionProfileDpadBindingEXT(const Path& binding_, const ActionSet& actionSet_,
                                   float forceThreshold_, float forceThresholdReleased_,
                                   float centerRegion_, float wedgeAngle_, const Bool32& isSticky_,
                                   const HapticBaseHeader* onHaptic_,
                                   const HapticBaseHeader* offHaptic_, const void* next_ = nullptr)
      : Parent(StructureType::InteractionProfileDpadBindingEXT, next_),
        binding{binding_},
        actionSet{actionSet_},
        forceThreshold{forceThreshold_},
        forceThresholdReleased{forceThresholdReleased_},
        centerRegion{centerRegion_},
        wedgeAngle{wedgeAngle_},
        isSticky{isSticky_},
        onHaptic{onHaptic_},
        offHaptic{offHaptic_} {}

  //! Default/empty constructor
  InteractionProfileDpadBindingEXT(const void* next_ = nullptr)

      : Parent(StructureType::InteractionProfileDpadBindingEXT, next_),
        binding{},
        actionSet{},
        forceThreshold{0.0f},
        forceThresholdReleased{0.0f},
        centerRegion{0.0f},
        wedgeAngle{0.0f},
        isSticky{false},
        onHaptic{nullptr},
        offHaptic{nullptr} {}

  //! Default copy constructor
  InteractionProfileDpadBindingEXT(const InteractionProfileDpadBindingEXT& rhs) = default;
  //! Default copy assignment
  InteractionProfileDpadBindingEXT& operator=(const InteractionProfileDpadBindingEXT& rhs) =
      default;
  //! Copy construct from raw
  InteractionProfileDpadBindingEXT(const XrInteractionProfileDpadBindingEXT& rhs)
      : InteractionProfileDpadBindingEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionProfileDpadBindingEXT& operator=(const XrInteractionProfileDpadBindingEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionProfileDpadBindingEXT&() const {
    return *reinterpret_cast<const XrInteractionProfileDpadBindingEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionProfileDpadBindingEXT&() {
    return *reinterpret_cast<XrInteractionProfileDpadBindingEXT*>(this);
  }

  //! Accessor for this as a raw, base XrBindingModificationBaseHeaderKHR const pointer
  XrBindingModificationBaseHeaderKHR const* get_base() const noexcept {
    return reinterpret_cast<XrBindingModificationBaseHeaderKHR const*>(this);
  }
  //! Accessor for this as the address of a raw XrInteractionProfileDpadBindingEXT
  XrInteractionProfileDpadBindingEXT const* get() const noexcept {
    return reinterpret_cast<XrInteractionProfileDpadBindingEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionProfileDpadBindingEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionProfileDpadBindingEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionProfileDpadBindingEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionProfileDpadBindingEXT*>(this);
  }
  Path binding;
  ActionSet actionSet;
  float forceThreshold;
  float forceThresholdReleased;
  float centerRegion;
  float wedgeAngle;
  Bool32 isSticky;
  const HapticBaseHeader* onHaptic;
  const HapticBaseHeader* offHaptic;
};
static_assert(sizeof(XrInteractionProfileDpadBindingEXT) ==
                  sizeof(InteractionProfileDpadBindingEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionProfileDpadBindingEXT pointer to const from a
 * InteractionProfileDpadBindingEXT reference to const.
 * @relates InteractionProfileDpadBindingEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileDpadBindingEXT const* get(
    InteractionProfileDpadBindingEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InteractionProfileDpadBindingEXT as the address of a raw XrInteractionProfileDpadBindingEXT
 * @relates InteractionProfileDpadBindingEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileDpadBindingEXT* put(
    InteractionProfileDpadBindingEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const InteractionProfileDpadBindingEXT as a raw,
 * pointer to const XrBindingModificationBaseHeaderKHR (the base type)
 * @relates InteractionProfileDpadBindingEXT
 * @relatesalso BindingModificationBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationBaseHeaderKHR const* get_base(
    InteractionProfileDpadBindingEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_dpad_binding

#ifdef XR_VALVE_analog_threshold
/*!
 * C++ projection of XrInteractionProfileAnalogThresholdVALVE
 *
 * Provided by the `XR_VALVE_analog_threshold` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionProfileAnalogThresholdVALVE>
 * @xrentity{XrInteractionProfileAnalogThresholdVALVE}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionProfileAnalogThresholdVALVE
    : public BindingModificationBaseHeaderKHR {
private:
  using Parent = BindingModificationBaseHeaderKHR;

public:
  //! Constructor initializing all members.
  InteractionProfileAnalogThresholdVALVE(const Action& action_, const Path& binding_,
                                         float onThreshold_, float offThreshold_,
                                         const HapticBaseHeader* onHaptic_,
                                         const HapticBaseHeader* offHaptic_,
                                         const void* next_ = nullptr)
      : Parent(StructureType::InteractionProfileAnalogThresholdVALVE, next_),
        action{action_},
        binding{binding_},
        onThreshold{onThreshold_},
        offThreshold{offThreshold_},
        onHaptic{onHaptic_},
        offHaptic{offHaptic_} {}

  //! Default/empty constructor
  InteractionProfileAnalogThresholdVALVE(const void* next_ = nullptr)

      : Parent(StructureType::InteractionProfileAnalogThresholdVALVE, next_),
        action{},
        binding{},
        onThreshold{0.0f},
        offThreshold{0.0f},
        onHaptic{nullptr},
        offHaptic{nullptr} {}

  //! Default copy constructor
  InteractionProfileAnalogThresholdVALVE(const InteractionProfileAnalogThresholdVALVE& rhs) =
      default;
  //! Default copy assignment
  InteractionProfileAnalogThresholdVALVE& operator=(
      const InteractionProfileAnalogThresholdVALVE& rhs) = default;
  //! Copy construct from raw
  InteractionProfileAnalogThresholdVALVE(const XrInteractionProfileAnalogThresholdVALVE& rhs)
      : InteractionProfileAnalogThresholdVALVE() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionProfileAnalogThresholdVALVE& operator=(
      const XrInteractionProfileAnalogThresholdVALVE& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionProfileAnalogThresholdVALVE&() const {
    return *reinterpret_cast<const XrInteractionProfileAnalogThresholdVALVE*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionProfileAnalogThresholdVALVE&() {
    return *reinterpret_cast<XrInteractionProfileAnalogThresholdVALVE*>(this);
  }

  //! Accessor for this as a raw, base XrBindingModificationBaseHeaderKHR const pointer
  XrBindingModificationBaseHeaderKHR const* get_base() const noexcept {
    return reinterpret_cast<XrBindingModificationBaseHeaderKHR const*>(this);
  }
  //! Accessor for this as the address of a raw XrInteractionProfileAnalogThresholdVALVE
  XrInteractionProfileAnalogThresholdVALVE const* get() const noexcept {
    return reinterpret_cast<XrInteractionProfileAnalogThresholdVALVE const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionProfileAnalogThresholdVALVE.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionProfileAnalogThresholdVALVE* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionProfileAnalogThresholdVALVE{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionProfileAnalogThresholdVALVE*>(this);
  }
  Action action;
  Path binding;
  float onThreshold;
  float offThreshold;
  const HapticBaseHeader* onHaptic;
  const HapticBaseHeader* offHaptic;
};
static_assert(sizeof(XrInteractionProfileAnalogThresholdVALVE) ==
                  sizeof(InteractionProfileAnalogThresholdVALVE),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionProfileAnalogThresholdVALVE pointer to const
 * from a InteractionProfileAnalogThresholdVALVE reference to const.
 * @relates InteractionProfileAnalogThresholdVALVE
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileAnalogThresholdVALVE const* get(
    InteractionProfileAnalogThresholdVALVE const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InteractionProfileAnalogThresholdVALVE as the address of a raw
 * XrInteractionProfileAnalogThresholdVALVE
 * @relates InteractionProfileAnalogThresholdVALVE
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionProfileAnalogThresholdVALVE* put(
    InteractionProfileAnalogThresholdVALVE& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const InteractionProfileAnalogThresholdVALVE as
 * a raw, pointer to const XrBindingModificationBaseHeaderKHR (the base type)
 * @relates InteractionProfileAnalogThresholdVALVE
 * @relatesalso BindingModificationBaseHeaderKHR
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBindingModificationBaseHeaderKHR const* get_base(
    InteractionProfileAnalogThresholdVALVE const& h) {
  return h.get_base();
}
#endif  // XR_VALVE_analog_threshold

#ifdef XR_EXT_hand_joints_motion_range
/*!
 * C++ projection of XrHandJointsMotionRangeInfoEXT
 *
 * Provided by the `XR_EXT_hand_joints_motion_range` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandJointsMotionRangeInfoEXT>
 * @xrentity{XrHandJointsMotionRangeInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandJointsMotionRangeInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandJointsMotionRangeInfoEXT(const HandJointsMotionRangeEXT& handJointsMotionRange_,
                               const void* next_ = nullptr)
      : Parent(StructureType::HandJointsMotionRangeInfoEXT, next_),
        handJointsMotionRange{handJointsMotionRange_} {}

  //! Default/empty constructor
  HandJointsMotionRangeInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::HandJointsMotionRangeInfoEXT, next_), handJointsMotionRange{} {}

  //! Default copy constructor
  HandJointsMotionRangeInfoEXT(const HandJointsMotionRangeInfoEXT& rhs) = default;
  //! Default copy assignment
  HandJointsMotionRangeInfoEXT& operator=(const HandJointsMotionRangeInfoEXT& rhs) = default;
  //! Copy construct from raw
  HandJointsMotionRangeInfoEXT(const XrHandJointsMotionRangeInfoEXT& rhs)
      : HandJointsMotionRangeInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandJointsMotionRangeInfoEXT& operator=(const XrHandJointsMotionRangeInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandJointsMotionRangeInfoEXT&() const {
    return *reinterpret_cast<const XrHandJointsMotionRangeInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandJointsMotionRangeInfoEXT&() {
    return *reinterpret_cast<XrHandJointsMotionRangeInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandJointsMotionRangeInfoEXT
  XrHandJointsMotionRangeInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrHandJointsMotionRangeInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandJointsMotionRangeInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandJointsMotionRangeInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandJointsMotionRangeInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandJointsMotionRangeInfoEXT*>(this);
  }
  HandJointsMotionRangeEXT handJointsMotionRange;
};
static_assert(sizeof(XrHandJointsMotionRangeInfoEXT) == sizeof(HandJointsMotionRangeInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandJointsMotionRangeInfoEXT pointer to const from a
 * HandJointsMotionRangeInfoEXT reference to const.
 * @relates HandJointsMotionRangeInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointsMotionRangeInfoEXT const* get(
    HandJointsMotionRangeInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandJointsMotionRangeInfoEXT
 * as the address of a raw XrHandJointsMotionRangeInfoEXT
 * @relates HandJointsMotionRangeInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandJointsMotionRangeInfoEXT* put(HandJointsMotionRangeInfoEXT& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_joints_motion_range

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrUuidMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrUuidMSFT>
 * @xrentity{XrUuidMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS UuidMSFT {
public:
  //! Constructor initializing all members.
  UuidMSFT(uint8_t bytes_[16]) { memcpy(bytes, bytes_, sizeof(bytes)); }

  //! Default/empty constructor
  UuidMSFT()

      : bytes{0} {}

  //! Default copy constructor
  UuidMSFT(const UuidMSFT& rhs) = default;
  //! Default copy assignment
  UuidMSFT& operator=(const UuidMSFT& rhs) = default;
  //! Copy construct from raw
  UuidMSFT(const XrUuidMSFT& rhs) : UuidMSFT() { *put() = rhs; }
  //! Copy assign from raw
  UuidMSFT& operator=(const XrUuidMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrUuidMSFT&() const { return *reinterpret_cast<const XrUuidMSFT*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrUuidMSFT&() { return *reinterpret_cast<XrUuidMSFT*>(this); }

  //! Accessor for this as the address of a raw XrUuidMSFT
  XrUuidMSFT const* get() const noexcept { return reinterpret_cast<XrUuidMSFT const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrUuidMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrUuidMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = UuidMSFT{};
    }
    return reinterpret_cast<XrUuidMSFT*>(this);
  }
  uint8_t bytes[16];
};
static_assert(sizeof(XrUuidMSFT) == sizeof(UuidMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrUuidMSFT pointer to const from a UuidMSFT reference to
 * const.
 * @relates UuidMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrUuidMSFT const* get(UuidMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing UuidMSFT as the address of a
 * raw XrUuidMSFT
 * @relates UuidMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrUuidMSFT* put(UuidMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneObserverCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneObserverCreateInfoMSFT>
 * @xrentity{XrSceneObserverCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneObserverCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SceneObserverCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneObserverCreateInfoMSFT, next_) {}

  //! Default copy constructor
  SceneObserverCreateInfoMSFT(const SceneObserverCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneObserverCreateInfoMSFT& operator=(const SceneObserverCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneObserverCreateInfoMSFT(const XrSceneObserverCreateInfoMSFT& rhs)
      : SceneObserverCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneObserverCreateInfoMSFT& operator=(const XrSceneObserverCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneObserverCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneObserverCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneObserverCreateInfoMSFT&() {
    return *reinterpret_cast<XrSceneObserverCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneObserverCreateInfoMSFT
  XrSceneObserverCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneObserverCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneObserverCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneObserverCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneObserverCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneObserverCreateInfoMSFT*>(this);
  }
};
static_assert(sizeof(XrSceneObserverCreateInfoMSFT) == sizeof(SceneObserverCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneObserverCreateInfoMSFT pointer to const from a
 * SceneObserverCreateInfoMSFT reference to const.
 * @relates SceneObserverCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObserverCreateInfoMSFT const* get(
    SceneObserverCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneObserverCreateInfoMSFT
 * as the address of a raw XrSceneObserverCreateInfoMSFT
 * @relates SceneObserverCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObserverCreateInfoMSFT* put(SceneObserverCreateInfoMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneCreateInfoMSFT>
 * @xrentity{XrSceneCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SceneCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneCreateInfoMSFT, next_) {}

  //! Default copy constructor
  SceneCreateInfoMSFT(const SceneCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneCreateInfoMSFT& operator=(const SceneCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneCreateInfoMSFT(const XrSceneCreateInfoMSFT& rhs) : SceneCreateInfoMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneCreateInfoMSFT& operator=(const XrSceneCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneCreateInfoMSFT&() { return *reinterpret_cast<XrSceneCreateInfoMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneCreateInfoMSFT
  XrSceneCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneCreateInfoMSFT*>(this);
  }
};
static_assert(sizeof(XrSceneCreateInfoMSFT) == sizeof(SceneCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneCreateInfoMSFT pointer to const from a
 * SceneCreateInfoMSFT reference to const.
 * @relates SceneCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneCreateInfoMSFT const* get(SceneCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneCreateInfoMSFT as the
 * address of a raw XrSceneCreateInfoMSFT
 * @relates SceneCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneCreateInfoMSFT* put(SceneCreateInfoMSFT& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneSphereBoundMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneSphereBoundMSFT>
 * @xrentity{XrSceneSphereBoundMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneSphereBoundMSFT {
public:
  //! Constructor initializing all members.
  SceneSphereBoundMSFT(const Vector3f& center_, float radius_) : center{center_}, radius{radius_} {}

  //! Default/empty constructor
  SceneSphereBoundMSFT()

      : center{}, radius{0.0f} {}

  //! Default copy constructor
  SceneSphereBoundMSFT(const SceneSphereBoundMSFT& rhs) = default;
  //! Default copy assignment
  SceneSphereBoundMSFT& operator=(const SceneSphereBoundMSFT& rhs) = default;
  //! Copy construct from raw
  SceneSphereBoundMSFT(const XrSceneSphereBoundMSFT& rhs) : SceneSphereBoundMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneSphereBoundMSFT& operator=(const XrSceneSphereBoundMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneSphereBoundMSFT&() const {
    return *reinterpret_cast<const XrSceneSphereBoundMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneSphereBoundMSFT&() { return *reinterpret_cast<XrSceneSphereBoundMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneSphereBoundMSFT
  XrSceneSphereBoundMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneSphereBoundMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneSphereBoundMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneSphereBoundMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneSphereBoundMSFT{};
    }
    return reinterpret_cast<XrSceneSphereBoundMSFT*>(this);
  }
  Vector3f center;
  float radius;
};
static_assert(sizeof(XrSceneSphereBoundMSFT) == sizeof(SceneSphereBoundMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneSphereBoundMSFT pointer to const from a
 * SceneSphereBoundMSFT reference to const.
 * @relates SceneSphereBoundMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneSphereBoundMSFT const* get(SceneSphereBoundMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneSphereBoundMSFT as the
 * address of a raw XrSceneSphereBoundMSFT
 * @relates SceneSphereBoundMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneSphereBoundMSFT* put(SceneSphereBoundMSFT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneOrientedBoxBoundMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneOrientedBoxBoundMSFT>
 * @xrentity{XrSceneOrientedBoxBoundMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneOrientedBoxBoundMSFT {
public:
  //! Constructor initializing all members.
  SceneOrientedBoxBoundMSFT(const Posef& pose_, const Vector3f& extents_)
      : pose{pose_}, extents{extents_} {}

  //! Default/empty constructor
  SceneOrientedBoxBoundMSFT()

      : pose{}, extents{} {}

  //! Default copy constructor
  SceneOrientedBoxBoundMSFT(const SceneOrientedBoxBoundMSFT& rhs) = default;
  //! Default copy assignment
  SceneOrientedBoxBoundMSFT& operator=(const SceneOrientedBoxBoundMSFT& rhs) = default;
  //! Copy construct from raw
  SceneOrientedBoxBoundMSFT(const XrSceneOrientedBoxBoundMSFT& rhs) : SceneOrientedBoxBoundMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneOrientedBoxBoundMSFT& operator=(const XrSceneOrientedBoxBoundMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneOrientedBoxBoundMSFT&() const {
    return *reinterpret_cast<const XrSceneOrientedBoxBoundMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneOrientedBoxBoundMSFT&() {
    return *reinterpret_cast<XrSceneOrientedBoxBoundMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneOrientedBoxBoundMSFT
  XrSceneOrientedBoxBoundMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneOrientedBoxBoundMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneOrientedBoxBoundMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneOrientedBoxBoundMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneOrientedBoxBoundMSFT{};
    }
    return reinterpret_cast<XrSceneOrientedBoxBoundMSFT*>(this);
  }
  Posef pose;
  Vector3f extents;
};
static_assert(sizeof(XrSceneOrientedBoxBoundMSFT) == sizeof(SceneOrientedBoxBoundMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneOrientedBoxBoundMSFT pointer to const from a
 * SceneOrientedBoxBoundMSFT reference to const.
 * @relates SceneOrientedBoxBoundMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneOrientedBoxBoundMSFT const* get(
    SceneOrientedBoxBoundMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneOrientedBoxBoundMSFT as
 * the address of a raw XrSceneOrientedBoxBoundMSFT
 * @relates SceneOrientedBoxBoundMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneOrientedBoxBoundMSFT* put(SceneOrientedBoxBoundMSFT& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneFrustumBoundMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneFrustumBoundMSFT>
 * @xrentity{XrSceneFrustumBoundMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneFrustumBoundMSFT {
public:
  //! Constructor initializing all members.
  SceneFrustumBoundMSFT(const Posef& pose_, const Fovf& fov_, float farDistance_)
      : pose{pose_}, fov{fov_}, farDistance{farDistance_} {}

  //! Default/empty constructor
  SceneFrustumBoundMSFT()

      : pose{}, fov{}, farDistance{0.0f} {}

  //! Default copy constructor
  SceneFrustumBoundMSFT(const SceneFrustumBoundMSFT& rhs) = default;
  //! Default copy assignment
  SceneFrustumBoundMSFT& operator=(const SceneFrustumBoundMSFT& rhs) = default;
  //! Copy construct from raw
  SceneFrustumBoundMSFT(const XrSceneFrustumBoundMSFT& rhs) : SceneFrustumBoundMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneFrustumBoundMSFT& operator=(const XrSceneFrustumBoundMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneFrustumBoundMSFT&() const {
    return *reinterpret_cast<const XrSceneFrustumBoundMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneFrustumBoundMSFT&() { return *reinterpret_cast<XrSceneFrustumBoundMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneFrustumBoundMSFT
  XrSceneFrustumBoundMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneFrustumBoundMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneFrustumBoundMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneFrustumBoundMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneFrustumBoundMSFT{};
    }
    return reinterpret_cast<XrSceneFrustumBoundMSFT*>(this);
  }
  Posef pose;
  Fovf fov;
  float farDistance;
};
static_assert(sizeof(XrSceneFrustumBoundMSFT) == sizeof(SceneFrustumBoundMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneFrustumBoundMSFT pointer to const from a
 * SceneFrustumBoundMSFT reference to const.
 * @relates SceneFrustumBoundMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneFrustumBoundMSFT const* get(SceneFrustumBoundMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneFrustumBoundMSFT as the
 * address of a raw XrSceneFrustumBoundMSFT
 * @relates SceneFrustumBoundMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneFrustumBoundMSFT* put(SceneFrustumBoundMSFT& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneBoundsMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneBoundsMSFT>
 * @xrentity{XrSceneBoundsMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneBoundsMSFT {
public:
  //! Constructor initializing all members.
  SceneBoundsMSFT(const Space& space_, const Time& time_, uint32_t sphereCount_,
                  const SceneSphereBoundMSFT* spheres_, uint32_t boxCount_,
                  const SceneOrientedBoxBoundMSFT* boxes_, uint32_t frustumCount_,
                  const SceneFrustumBoundMSFT* frustums_)
      : space{space_},
        time{time_},
        sphereCount{sphereCount_},
        spheres{spheres_},
        boxCount{boxCount_},
        boxes{boxes_},
        frustumCount{frustumCount_},
        frustums{frustums_} {}

  //! Default/empty constructor
  SceneBoundsMSFT()

      : space{},
        time{},
        sphereCount{0},
        spheres{nullptr},
        boxCount{0},
        boxes{nullptr},
        frustumCount{0},
        frustums{nullptr} {}

  //! Default copy constructor
  SceneBoundsMSFT(const SceneBoundsMSFT& rhs) = default;
  //! Default copy assignment
  SceneBoundsMSFT& operator=(const SceneBoundsMSFT& rhs) = default;
  //! Copy construct from raw
  SceneBoundsMSFT(const XrSceneBoundsMSFT& rhs) : SceneBoundsMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneBoundsMSFT& operator=(const XrSceneBoundsMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneBoundsMSFT&() const {
    return *reinterpret_cast<const XrSceneBoundsMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneBoundsMSFT&() { return *reinterpret_cast<XrSceneBoundsMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneBoundsMSFT
  XrSceneBoundsMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneBoundsMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneBoundsMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneBoundsMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneBoundsMSFT{};
    }
    return reinterpret_cast<XrSceneBoundsMSFT*>(this);
  }
  Space space;
  Time time;
  uint32_t sphereCount;
  const SceneSphereBoundMSFT* spheres;
  uint32_t boxCount;
  const SceneOrientedBoxBoundMSFT* boxes;
  uint32_t frustumCount;
  const SceneFrustumBoundMSFT* frustums;
};
static_assert(sizeof(XrSceneBoundsMSFT) == sizeof(SceneBoundsMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneBoundsMSFT pointer to const from a SceneBoundsMSFT
 * reference to const.
 * @relates SceneBoundsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneBoundsMSFT const* get(SceneBoundsMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneBoundsMSFT as the
 * address of a raw XrSceneBoundsMSFT
 * @relates SceneBoundsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneBoundsMSFT* put(SceneBoundsMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrNewSceneComputeInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrNewSceneComputeInfoMSFT>
 * @xrentity{XrNewSceneComputeInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS NewSceneComputeInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  NewSceneComputeInfoMSFT(uint32_t requestedFeatureCount_,
                          const SceneComputeFeatureMSFT* requestedFeatures_,
                          const SceneComputeConsistencyMSFT& consistency_,
                          const SceneBoundsMSFT& bounds_, const void* next_ = nullptr)
      : Parent(StructureType::NewSceneComputeInfoMSFT, next_),
        requestedFeatureCount{requestedFeatureCount_},
        requestedFeatures{requestedFeatures_},
        consistency{consistency_},
        bounds{bounds_} {}

  //! Default/empty constructor
  NewSceneComputeInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::NewSceneComputeInfoMSFT, next_),
        requestedFeatureCount{0},
        requestedFeatures{nullptr},
        consistency{},
        bounds{} {}

  //! Default copy constructor
  NewSceneComputeInfoMSFT(const NewSceneComputeInfoMSFT& rhs) = default;
  //! Default copy assignment
  NewSceneComputeInfoMSFT& operator=(const NewSceneComputeInfoMSFT& rhs) = default;
  //! Copy construct from raw
  NewSceneComputeInfoMSFT(const XrNewSceneComputeInfoMSFT& rhs) : NewSceneComputeInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  NewSceneComputeInfoMSFT& operator=(const XrNewSceneComputeInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrNewSceneComputeInfoMSFT&() const {
    return *reinterpret_cast<const XrNewSceneComputeInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrNewSceneComputeInfoMSFT&() {
    return *reinterpret_cast<XrNewSceneComputeInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrNewSceneComputeInfoMSFT
  XrNewSceneComputeInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrNewSceneComputeInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrNewSceneComputeInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrNewSceneComputeInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = NewSceneComputeInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrNewSceneComputeInfoMSFT*>(this);
  }
  uint32_t requestedFeatureCount;
  const SceneComputeFeatureMSFT* requestedFeatures;
  SceneComputeConsistencyMSFT consistency;
  SceneBoundsMSFT bounds;
};
static_assert(sizeof(XrNewSceneComputeInfoMSFT) == sizeof(NewSceneComputeInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrNewSceneComputeInfoMSFT pointer to const from a
 * NewSceneComputeInfoMSFT reference to const.
 * @relates NewSceneComputeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrNewSceneComputeInfoMSFT const* get(NewSceneComputeInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing NewSceneComputeInfoMSFT as
 * the address of a raw XrNewSceneComputeInfoMSFT
 * @relates NewSceneComputeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrNewSceneComputeInfoMSFT* put(NewSceneComputeInfoMSFT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrVisualMeshComputeLodInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVisualMeshComputeLodInfoMSFT>
 * @xrentity{XrVisualMeshComputeLodInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VisualMeshComputeLodInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VisualMeshComputeLodInfoMSFT(const MeshComputeLodMSFT& lod_, const void* next_ = nullptr)
      : Parent(StructureType::VisualMeshComputeLodInfoMSFT, next_), lod{lod_} {}

  //! Default/empty constructor
  VisualMeshComputeLodInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::VisualMeshComputeLodInfoMSFT, next_), lod{} {}

  //! Default copy constructor
  VisualMeshComputeLodInfoMSFT(const VisualMeshComputeLodInfoMSFT& rhs) = default;
  //! Default copy assignment
  VisualMeshComputeLodInfoMSFT& operator=(const VisualMeshComputeLodInfoMSFT& rhs) = default;
  //! Copy construct from raw
  VisualMeshComputeLodInfoMSFT(const XrVisualMeshComputeLodInfoMSFT& rhs)
      : VisualMeshComputeLodInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VisualMeshComputeLodInfoMSFT& operator=(const XrVisualMeshComputeLodInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVisualMeshComputeLodInfoMSFT&() const {
    return *reinterpret_cast<const XrVisualMeshComputeLodInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVisualMeshComputeLodInfoMSFT&() {
    return *reinterpret_cast<XrVisualMeshComputeLodInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrVisualMeshComputeLodInfoMSFT
  XrVisualMeshComputeLodInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrVisualMeshComputeLodInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVisualMeshComputeLodInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVisualMeshComputeLodInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VisualMeshComputeLodInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrVisualMeshComputeLodInfoMSFT*>(this);
  }
  MeshComputeLodMSFT lod;
};
static_assert(sizeof(XrVisualMeshComputeLodInfoMSFT) == sizeof(VisualMeshComputeLodInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVisualMeshComputeLodInfoMSFT pointer to const from a
 * VisualMeshComputeLodInfoMSFT reference to const.
 * @relates VisualMeshComputeLodInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVisualMeshComputeLodInfoMSFT const* get(
    VisualMeshComputeLodInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VisualMeshComputeLodInfoMSFT
 * as the address of a raw XrVisualMeshComputeLodInfoMSFT
 * @relates VisualMeshComputeLodInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVisualMeshComputeLodInfoMSFT* put(VisualMeshComputeLodInfoMSFT& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentMSFT>
 * @xrentity{XrSceneComponentMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneComponentMSFT {
public:
  //! Constructor initializing all members.
  SceneComponentMSFT(const SceneComponentTypeMSFT& componentType_, const UuidMSFT& id_,
                     const UuidMSFT& parentId_, const Time& updateTime_)
      : componentType{componentType_}, id{id_}, parentId{parentId_}, updateTime{updateTime_} {}

  //! Default/empty constructor
  SceneComponentMSFT()

      : componentType{}, id{}, parentId{}, updateTime{} {}

  //! Default copy constructor
  SceneComponentMSFT(const SceneComponentMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentMSFT& operator=(const SceneComponentMSFT& rhs) = default;
  //! Copy construct from raw
  SceneComponentMSFT(const XrSceneComponentMSFT& rhs) : SceneComponentMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneComponentMSFT& operator=(const XrSceneComponentMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentMSFT&() { return *reinterpret_cast<XrSceneComponentMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneComponentMSFT
  XrSceneComponentMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneComponentMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneComponentMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneComponentMSFT{};
    }
    return reinterpret_cast<XrSceneComponentMSFT*>(this);
  }
  SceneComponentTypeMSFT componentType;
  UuidMSFT id;
  UuidMSFT parentId;
  Time updateTime;
};
static_assert(sizeof(XrSceneComponentMSFT) == sizeof(SceneComponentMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentMSFT pointer to const from a
 * SceneComponentMSFT reference to const.
 * @relates SceneComponentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentMSFT const* get(SceneComponentMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneComponentMSFT as the
 * address of a raw XrSceneComponentMSFT
 * @relates SceneComponentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentMSFT* put(SceneComponentMSFT& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentsMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentsMSFT>
 * @xrentity{XrSceneComponentsMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneComponentsMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneComponentsMSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneComponentsMSFT, next_) {}

  //! Default copy constructor
  SceneComponentsMSFT(const SceneComponentsMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentsMSFT& operator=(const SceneComponentsMSFT& rhs) = default;
  //! Copy construct from raw
  SceneComponentsMSFT(const XrSceneComponentsMSFT& rhs) : SceneComponentsMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneComponentsMSFT& operator=(const XrSceneComponentsMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentsMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentsMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentsMSFT&() { return *reinterpret_cast<XrSceneComponentsMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneComponentsMSFT
  XrSceneComponentsMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentsMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneComponentsMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneComponentsMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneComponentsMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneComponentsMSFT*>(this);
  }
  uint32_t componentCapacityInput;
  uint32_t componentCountOutput;
  SceneComponentMSFT* components;
};
static_assert(sizeof(XrSceneComponentsMSFT) == sizeof(SceneComponentsMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentsMSFT pointer to const from a
 * SceneComponentsMSFT reference to const.
 * @relates SceneComponentsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentsMSFT const* get(SceneComponentsMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneComponentsMSFT as the
 * address of a raw XrSceneComponentsMSFT
 * @relates SceneComponentsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentsMSFT* put(SceneComponentsMSFT& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentsGetInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentsGetInfoMSFT>
 * @xrentity{XrSceneComponentsGetInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneComponentsGetInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneComponentsGetInfoMSFT(const SceneComponentTypeMSFT& componentType_,
                             const void* next_ = nullptr)
      : Parent(StructureType::SceneComponentsGetInfoMSFT, next_), componentType{componentType_} {}

  //! Default/empty constructor
  SceneComponentsGetInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneComponentsGetInfoMSFT, next_), componentType{} {}

  //! Default copy constructor
  SceneComponentsGetInfoMSFT(const SceneComponentsGetInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentsGetInfoMSFT& operator=(const SceneComponentsGetInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneComponentsGetInfoMSFT(const XrSceneComponentsGetInfoMSFT& rhs)
      : SceneComponentsGetInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneComponentsGetInfoMSFT& operator=(const XrSceneComponentsGetInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentsGetInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentsGetInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentsGetInfoMSFT&() {
    return *reinterpret_cast<XrSceneComponentsGetInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneComponentsGetInfoMSFT
  XrSceneComponentsGetInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentsGetInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneComponentsGetInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneComponentsGetInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneComponentsGetInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneComponentsGetInfoMSFT*>(this);
  }
  SceneComponentTypeMSFT componentType;
};
static_assert(sizeof(XrSceneComponentsGetInfoMSFT) == sizeof(SceneComponentsGetInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentsGetInfoMSFT pointer to const from a
 * SceneComponentsGetInfoMSFT reference to const.
 * @relates SceneComponentsGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentsGetInfoMSFT const* get(
    SceneComponentsGetInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneComponentsGetInfoMSFT as
 * the address of a raw XrSceneComponentsGetInfoMSFT
 * @relates SceneComponentsGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentsGetInfoMSFT* put(SceneComponentsGetInfoMSFT& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentLocationMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentLocationMSFT>
 * @xrentity{XrSceneComponentLocationMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneComponentLocationMSFT {
public:
  //! Constructor initializing all members.
  SceneComponentLocationMSFT(const SpaceLocationFlags& flags_, const Posef& pose_)
      : flags{flags_}, pose{pose_} {}

  //! Default/empty constructor
  SceneComponentLocationMSFT()

      : flags{}, pose{} {}

  //! Default copy constructor
  SceneComponentLocationMSFT(const SceneComponentLocationMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentLocationMSFT& operator=(const SceneComponentLocationMSFT& rhs) = default;
  //! Copy construct from raw
  SceneComponentLocationMSFT(const XrSceneComponentLocationMSFT& rhs)
      : SceneComponentLocationMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneComponentLocationMSFT& operator=(const XrSceneComponentLocationMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentLocationMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentLocationMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentLocationMSFT&() {
    return *reinterpret_cast<XrSceneComponentLocationMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneComponentLocationMSFT
  XrSceneComponentLocationMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentLocationMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneComponentLocationMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneComponentLocationMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneComponentLocationMSFT{};
    }
    return reinterpret_cast<XrSceneComponentLocationMSFT*>(this);
  }
  SpaceLocationFlags flags;
  Posef pose;
};
static_assert(sizeof(XrSceneComponentLocationMSFT) == sizeof(SceneComponentLocationMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentLocationMSFT pointer to const from a
 * SceneComponentLocationMSFT reference to const.
 * @relates SceneComponentLocationMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentLocationMSFT const* get(
    SceneComponentLocationMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneComponentLocationMSFT as
 * the address of a raw XrSceneComponentLocationMSFT
 * @relates SceneComponentLocationMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentLocationMSFT* put(SceneComponentLocationMSFT& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentLocationsMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentLocationsMSFT>
 * @xrentity{XrSceneComponentLocationsMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneComponentLocationsMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneComponentLocationsMSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneComponentLocationsMSFT, next_) {}

  //! Default copy constructor
  SceneComponentLocationsMSFT(const SceneComponentLocationsMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentLocationsMSFT& operator=(const SceneComponentLocationsMSFT& rhs) = default;
  //! Copy construct from raw
  SceneComponentLocationsMSFT(const XrSceneComponentLocationsMSFT& rhs)
      : SceneComponentLocationsMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneComponentLocationsMSFT& operator=(const XrSceneComponentLocationsMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentLocationsMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentLocationsMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentLocationsMSFT&() {
    return *reinterpret_cast<XrSceneComponentLocationsMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneComponentLocationsMSFT
  XrSceneComponentLocationsMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentLocationsMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneComponentLocationsMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneComponentLocationsMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneComponentLocationsMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneComponentLocationsMSFT*>(this);
  }
  uint32_t locationCount;
  SceneComponentLocationMSFT* locations;
};
static_assert(sizeof(XrSceneComponentLocationsMSFT) == sizeof(SceneComponentLocationsMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentLocationsMSFT pointer to const from a
 * SceneComponentLocationsMSFT reference to const.
 * @relates SceneComponentLocationsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentLocationsMSFT const* get(
    SceneComponentLocationsMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneComponentLocationsMSFT
 * as the address of a raw XrSceneComponentLocationsMSFT
 * @relates SceneComponentLocationsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentLocationsMSFT* put(SceneComponentLocationsMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentsLocateInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentsLocateInfoMSFT>
 * @xrentity{XrSceneComponentsLocateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneComponentsLocateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneComponentsLocateInfoMSFT(const Space& baseSpace_, const Time& time_,
                                uint32_t componentIdCount_, const UuidMSFT* componentIds_,
                                const void* next_ = nullptr)
      : Parent(StructureType::SceneComponentsLocateInfoMSFT, next_),
        baseSpace{baseSpace_},
        time{time_},
        componentIdCount{componentIdCount_},
        componentIds{componentIds_} {}

  //! Default/empty constructor
  SceneComponentsLocateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneComponentsLocateInfoMSFT, next_),
        baseSpace{},
        time{},
        componentIdCount{0},
        componentIds{nullptr} {}

  //! Default copy constructor
  SceneComponentsLocateInfoMSFT(const SceneComponentsLocateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentsLocateInfoMSFT& operator=(const SceneComponentsLocateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneComponentsLocateInfoMSFT(const XrSceneComponentsLocateInfoMSFT& rhs)
      : SceneComponentsLocateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneComponentsLocateInfoMSFT& operator=(const XrSceneComponentsLocateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentsLocateInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentsLocateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentsLocateInfoMSFT&() {
    return *reinterpret_cast<XrSceneComponentsLocateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneComponentsLocateInfoMSFT
  XrSceneComponentsLocateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentsLocateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneComponentsLocateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneComponentsLocateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneComponentsLocateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneComponentsLocateInfoMSFT*>(this);
  }
  Space baseSpace;
  Time time;
  uint32_t componentIdCount;
  const UuidMSFT* componentIds;
};
static_assert(sizeof(XrSceneComponentsLocateInfoMSFT) == sizeof(SceneComponentsLocateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentsLocateInfoMSFT pointer to const from a
 * SceneComponentsLocateInfoMSFT reference to const.
 * @relates SceneComponentsLocateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentsLocateInfoMSFT const* get(
    SceneComponentsLocateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneComponentsLocateInfoMSFT
 * as the address of a raw XrSceneComponentsLocateInfoMSFT
 * @relates SceneComponentsLocateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentsLocateInfoMSFT* put(SceneComponentsLocateInfoMSFT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneObjectMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneObjectMSFT>
 * @xrentity{XrSceneObjectMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneObjectMSFT {
public:
  //! Constructor initializing all members.
  SceneObjectMSFT(const SceneObjectTypeMSFT& objectType_) : objectType{objectType_} {}

  //! Default/empty constructor
  SceneObjectMSFT()

      : objectType{} {}

  //! Default copy constructor
  SceneObjectMSFT(const SceneObjectMSFT& rhs) = default;
  //! Default copy assignment
  SceneObjectMSFT& operator=(const SceneObjectMSFT& rhs) = default;
  //! Copy construct from raw
  SceneObjectMSFT(const XrSceneObjectMSFT& rhs) : SceneObjectMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneObjectMSFT& operator=(const XrSceneObjectMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneObjectMSFT&() const {
    return *reinterpret_cast<const XrSceneObjectMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneObjectMSFT&() { return *reinterpret_cast<XrSceneObjectMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneObjectMSFT
  XrSceneObjectMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneObjectMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneObjectMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneObjectMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneObjectMSFT{};
    }
    return reinterpret_cast<XrSceneObjectMSFT*>(this);
  }
  SceneObjectTypeMSFT objectType;
};
static_assert(sizeof(XrSceneObjectMSFT) == sizeof(SceneObjectMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneObjectMSFT pointer to const from a SceneObjectMSFT
 * reference to const.
 * @relates SceneObjectMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObjectMSFT const* get(SceneObjectMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneObjectMSFT as the
 * address of a raw XrSceneObjectMSFT
 * @relates SceneObjectMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObjectMSFT* put(SceneObjectMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneObjectsMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneObjectsMSFT>
 * @xrentity{XrSceneObjectsMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneObjectsMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneObjectsMSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneObjectsMSFT, next_) {}

  //! Default copy constructor
  SceneObjectsMSFT(const SceneObjectsMSFT& rhs) = default;
  //! Default copy assignment
  SceneObjectsMSFT& operator=(const SceneObjectsMSFT& rhs) = default;
  //! Copy construct from raw
  SceneObjectsMSFT(const XrSceneObjectsMSFT& rhs) : SceneObjectsMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneObjectsMSFT& operator=(const XrSceneObjectsMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneObjectsMSFT&() const {
    return *reinterpret_cast<const XrSceneObjectsMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneObjectsMSFT&() { return *reinterpret_cast<XrSceneObjectsMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneObjectsMSFT
  XrSceneObjectsMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneObjectsMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneObjectsMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneObjectsMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneObjectsMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneObjectsMSFT*>(this);
  }
  uint32_t sceneObjectCount;
  SceneObjectMSFT* sceneObjects;
};
static_assert(sizeof(XrSceneObjectsMSFT) == sizeof(SceneObjectsMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneObjectsMSFT pointer to const from a
 * SceneObjectsMSFT reference to const.
 * @relates SceneObjectsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObjectsMSFT const* get(SceneObjectsMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneObjectsMSFT as the
 * address of a raw XrSceneObjectsMSFT
 * @relates SceneObjectsMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObjectsMSFT* put(SceneObjectsMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneComponentParentFilterInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneComponentParentFilterInfoMSFT>
 * @xrentity{XrSceneComponentParentFilterInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneComponentParentFilterInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneComponentParentFilterInfoMSFT(const UuidMSFT& parentId_, const void* next_ = nullptr)
      : Parent(StructureType::SceneComponentParentFilterInfoMSFT, next_), parentId{parentId_} {}

  //! Default/empty constructor
  SceneComponentParentFilterInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneComponentParentFilterInfoMSFT, next_), parentId{} {}

  //! Default copy constructor
  SceneComponentParentFilterInfoMSFT(const SceneComponentParentFilterInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneComponentParentFilterInfoMSFT& operator=(const SceneComponentParentFilterInfoMSFT& rhs) =
      default;
  //! Copy construct from raw
  SceneComponentParentFilterInfoMSFT(const XrSceneComponentParentFilterInfoMSFT& rhs)
      : SceneComponentParentFilterInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneComponentParentFilterInfoMSFT& operator=(const XrSceneComponentParentFilterInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneComponentParentFilterInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneComponentParentFilterInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneComponentParentFilterInfoMSFT&() {
    return *reinterpret_cast<XrSceneComponentParentFilterInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneComponentParentFilterInfoMSFT
  XrSceneComponentParentFilterInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneComponentParentFilterInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneComponentParentFilterInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneComponentParentFilterInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneComponentParentFilterInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneComponentParentFilterInfoMSFT*>(this);
  }
  UuidMSFT parentId;
};
static_assert(sizeof(XrSceneComponentParentFilterInfoMSFT) ==
                  sizeof(SceneComponentParentFilterInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneComponentParentFilterInfoMSFT pointer to const from
 * a SceneComponentParentFilterInfoMSFT reference to const.
 * @relates SceneComponentParentFilterInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentParentFilterInfoMSFT const* get(
    SceneComponentParentFilterInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SceneComponentParentFilterInfoMSFT as the address of a raw XrSceneComponentParentFilterInfoMSFT
 * @relates SceneComponentParentFilterInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneComponentParentFilterInfoMSFT* put(
    SceneComponentParentFilterInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneObjectTypesFilterInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneObjectTypesFilterInfoMSFT>
 * @xrentity{XrSceneObjectTypesFilterInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneObjectTypesFilterInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneObjectTypesFilterInfoMSFT(uint32_t objectTypeCount_, const SceneObjectTypeMSFT* objectTypes_,
                                 const void* next_ = nullptr)
      : Parent(StructureType::SceneObjectTypesFilterInfoMSFT, next_),
        objectTypeCount{objectTypeCount_},
        objectTypes{objectTypes_} {}

  //! Default/empty constructor
  SceneObjectTypesFilterInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneObjectTypesFilterInfoMSFT, next_),
        objectTypeCount{0},
        objectTypes{nullptr} {}

  //! Default copy constructor
  SceneObjectTypesFilterInfoMSFT(const SceneObjectTypesFilterInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneObjectTypesFilterInfoMSFT& operator=(const SceneObjectTypesFilterInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneObjectTypesFilterInfoMSFT(const XrSceneObjectTypesFilterInfoMSFT& rhs)
      : SceneObjectTypesFilterInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneObjectTypesFilterInfoMSFT& operator=(const XrSceneObjectTypesFilterInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneObjectTypesFilterInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneObjectTypesFilterInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneObjectTypesFilterInfoMSFT&() {
    return *reinterpret_cast<XrSceneObjectTypesFilterInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneObjectTypesFilterInfoMSFT
  XrSceneObjectTypesFilterInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneObjectTypesFilterInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneObjectTypesFilterInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneObjectTypesFilterInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneObjectTypesFilterInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneObjectTypesFilterInfoMSFT*>(this);
  }
  uint32_t objectTypeCount;
  const SceneObjectTypeMSFT* objectTypes;
};
static_assert(sizeof(XrSceneObjectTypesFilterInfoMSFT) == sizeof(SceneObjectTypesFilterInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneObjectTypesFilterInfoMSFT pointer to const from a
 * SceneObjectTypesFilterInfoMSFT reference to const.
 * @relates SceneObjectTypesFilterInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObjectTypesFilterInfoMSFT const* get(
    SceneObjectTypesFilterInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SceneObjectTypesFilterInfoMSFT as the address of a raw XrSceneObjectTypesFilterInfoMSFT
 * @relates SceneObjectTypesFilterInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneObjectTypesFilterInfoMSFT* put(SceneObjectTypesFilterInfoMSFT& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrScenePlaneMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrScenePlaneMSFT>
 * @xrentity{XrScenePlaneMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ScenePlaneMSFT {
public:
  //! Constructor initializing all members.
  ScenePlaneMSFT(const ScenePlaneAlignmentTypeMSFT& alignment_, const Extent2Df& size_,
                 uint64_t meshBufferId_, const Bool32& supportsIndicesUint16_)
      : alignment{alignment_},
        size{size_},
        meshBufferId{meshBufferId_},
        supportsIndicesUint16{supportsIndicesUint16_} {}

  //! Default/empty constructor
  ScenePlaneMSFT()

      : alignment{}, size{}, meshBufferId{0}, supportsIndicesUint16{false} {}

  //! Default copy constructor
  ScenePlaneMSFT(const ScenePlaneMSFT& rhs) = default;
  //! Default copy assignment
  ScenePlaneMSFT& operator=(const ScenePlaneMSFT& rhs) = default;
  //! Copy construct from raw
  ScenePlaneMSFT(const XrScenePlaneMSFT& rhs) : ScenePlaneMSFT() { *put() = rhs; }
  //! Copy assign from raw
  ScenePlaneMSFT& operator=(const XrScenePlaneMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrScenePlaneMSFT&() const {
    return *reinterpret_cast<const XrScenePlaneMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrScenePlaneMSFT&() { return *reinterpret_cast<XrScenePlaneMSFT*>(this); }

  //! Accessor for this as the address of a raw XrScenePlaneMSFT
  XrScenePlaneMSFT const* get() const noexcept {
    return reinterpret_cast<XrScenePlaneMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrScenePlaneMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrScenePlaneMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = ScenePlaneMSFT{};
    }
    return reinterpret_cast<XrScenePlaneMSFT*>(this);
  }
  ScenePlaneAlignmentTypeMSFT alignment;
  Extent2Df size;
  uint64_t meshBufferId;
  Bool32 supportsIndicesUint16;
};
static_assert(sizeof(XrScenePlaneMSFT) == sizeof(ScenePlaneMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrScenePlaneMSFT pointer to const from a ScenePlaneMSFT
 * reference to const.
 * @relates ScenePlaneMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrScenePlaneMSFT const* get(ScenePlaneMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ScenePlaneMSFT as the address
 * of a raw XrScenePlaneMSFT
 * @relates ScenePlaneMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrScenePlaneMSFT* put(ScenePlaneMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrScenePlanesMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrScenePlanesMSFT>
 * @xrentity{XrScenePlanesMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ScenePlanesMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ScenePlanesMSFT(void* next_ = nullptr)

      : Parent(StructureType::ScenePlanesMSFT, next_) {}

  //! Default copy constructor
  ScenePlanesMSFT(const ScenePlanesMSFT& rhs) = default;
  //! Default copy assignment
  ScenePlanesMSFT& operator=(const ScenePlanesMSFT& rhs) = default;
  //! Copy construct from raw
  ScenePlanesMSFT(const XrScenePlanesMSFT& rhs) : ScenePlanesMSFT() { *put() = rhs; }
  //! Copy assign from raw
  ScenePlanesMSFT& operator=(const XrScenePlanesMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrScenePlanesMSFT&() const {
    return *reinterpret_cast<const XrScenePlanesMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrScenePlanesMSFT&() { return *reinterpret_cast<XrScenePlanesMSFT*>(this); }

  //! Accessor for this as the address of a raw XrScenePlanesMSFT
  XrScenePlanesMSFT const* get() const noexcept {
    return reinterpret_cast<XrScenePlanesMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrScenePlanesMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrScenePlanesMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ScenePlanesMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrScenePlanesMSFT*>(this);
  }
  uint32_t scenePlaneCount;
  ScenePlaneMSFT* scenePlanes;
};
static_assert(sizeof(XrScenePlanesMSFT) == sizeof(ScenePlanesMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrScenePlanesMSFT pointer to const from a ScenePlanesMSFT
 * reference to const.
 * @relates ScenePlanesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrScenePlanesMSFT const* get(ScenePlanesMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing ScenePlanesMSFT as the
 * address of a raw XrScenePlanesMSFT
 * @relates ScenePlanesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrScenePlanesMSFT* put(ScenePlanesMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrScenePlaneAlignmentFilterInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrScenePlaneAlignmentFilterInfoMSFT>
 * @xrentity{XrScenePlaneAlignmentFilterInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ScenePlaneAlignmentFilterInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ScenePlaneAlignmentFilterInfoMSFT(uint32_t alignmentCount_,
                                    const ScenePlaneAlignmentTypeMSFT* alignments_,
                                    const void* next_ = nullptr)
      : Parent(StructureType::ScenePlaneAlignmentFilterInfoMSFT, next_),
        alignmentCount{alignmentCount_},
        alignments{alignments_} {}

  //! Default/empty constructor
  ScenePlaneAlignmentFilterInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::ScenePlaneAlignmentFilterInfoMSFT, next_),
        alignmentCount{0},
        alignments{nullptr} {}

  //! Default copy constructor
  ScenePlaneAlignmentFilterInfoMSFT(const ScenePlaneAlignmentFilterInfoMSFT& rhs) = default;
  //! Default copy assignment
  ScenePlaneAlignmentFilterInfoMSFT& operator=(const ScenePlaneAlignmentFilterInfoMSFT& rhs) =
      default;
  //! Copy construct from raw
  ScenePlaneAlignmentFilterInfoMSFT(const XrScenePlaneAlignmentFilterInfoMSFT& rhs)
      : ScenePlaneAlignmentFilterInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ScenePlaneAlignmentFilterInfoMSFT& operator=(const XrScenePlaneAlignmentFilterInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrScenePlaneAlignmentFilterInfoMSFT&() const {
    return *reinterpret_cast<const XrScenePlaneAlignmentFilterInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrScenePlaneAlignmentFilterInfoMSFT&() {
    return *reinterpret_cast<XrScenePlaneAlignmentFilterInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrScenePlaneAlignmentFilterInfoMSFT
  XrScenePlaneAlignmentFilterInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrScenePlaneAlignmentFilterInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrScenePlaneAlignmentFilterInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrScenePlaneAlignmentFilterInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ScenePlaneAlignmentFilterInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrScenePlaneAlignmentFilterInfoMSFT*>(this);
  }
  uint32_t alignmentCount;
  const ScenePlaneAlignmentTypeMSFT* alignments;
};
static_assert(sizeof(XrScenePlaneAlignmentFilterInfoMSFT) ==
                  sizeof(ScenePlaneAlignmentFilterInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrScenePlaneAlignmentFilterInfoMSFT pointer to const from
 * a ScenePlaneAlignmentFilterInfoMSFT reference to const.
 * @relates ScenePlaneAlignmentFilterInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrScenePlaneAlignmentFilterInfoMSFT const* get(
    ScenePlaneAlignmentFilterInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ScenePlaneAlignmentFilterInfoMSFT as the address of a raw XrScenePlaneAlignmentFilterInfoMSFT
 * @relates ScenePlaneAlignmentFilterInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrScenePlaneAlignmentFilterInfoMSFT* put(
    ScenePlaneAlignmentFilterInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshMSFT>
 * @xrentity{XrSceneMeshMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneMeshMSFT {
public:
  //! Constructor initializing all members.
  SceneMeshMSFT(uint64_t meshBufferId_, const Bool32& supportsIndicesUint16_)
      : meshBufferId{meshBufferId_}, supportsIndicesUint16{supportsIndicesUint16_} {}

  //! Default/empty constructor
  SceneMeshMSFT()

      : meshBufferId{0}, supportsIndicesUint16{false} {}

  //! Default copy constructor
  SceneMeshMSFT(const SceneMeshMSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshMSFT& operator=(const SceneMeshMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshMSFT(const XrSceneMeshMSFT& rhs) : SceneMeshMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneMeshMSFT& operator=(const XrSceneMeshMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshMSFT&() const {
    return *reinterpret_cast<const XrSceneMeshMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshMSFT&() { return *reinterpret_cast<XrSceneMeshMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneMeshMSFT
  XrSceneMeshMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneMeshMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneMeshMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneMeshMSFT{};
    }
    return reinterpret_cast<XrSceneMeshMSFT*>(this);
  }
  uint64_t meshBufferId;
  Bool32 supportsIndicesUint16;
};
static_assert(sizeof(XrSceneMeshMSFT) == sizeof(SceneMeshMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshMSFT pointer to const from a SceneMeshMSFT
 * reference to const.
 * @relates SceneMeshMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshMSFT const* get(SceneMeshMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshMSFT as the address
 * of a raw XrSceneMeshMSFT
 * @relates SceneMeshMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshMSFT* put(SceneMeshMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshesMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshesMSFT>
 * @xrentity{XrSceneMeshesMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMeshesMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneMeshesMSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneMeshesMSFT, next_) {}

  //! Default copy constructor
  SceneMeshesMSFT(const SceneMeshesMSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshesMSFT& operator=(const SceneMeshesMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshesMSFT(const XrSceneMeshesMSFT& rhs) : SceneMeshesMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneMeshesMSFT& operator=(const XrSceneMeshesMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshesMSFT&() const {
    return *reinterpret_cast<const XrSceneMeshesMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshesMSFT&() { return *reinterpret_cast<XrSceneMeshesMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneMeshesMSFT
  XrSceneMeshesMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshesMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneMeshesMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMeshesMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMeshesMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMeshesMSFT*>(this);
  }
  uint32_t sceneMeshCount;
  SceneMeshMSFT* sceneMeshes;
};
static_assert(sizeof(XrSceneMeshesMSFT) == sizeof(SceneMeshesMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshesMSFT pointer to const from a SceneMeshesMSFT
 * reference to const.
 * @relates SceneMeshesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshesMSFT const* get(SceneMeshesMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshesMSFT as the
 * address of a raw XrSceneMeshesMSFT
 * @relates SceneMeshesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshesMSFT* put(SceneMeshesMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshBuffersGetInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshBuffersGetInfoMSFT>
 * @xrentity{XrSceneMeshBuffersGetInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMeshBuffersGetInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneMeshBuffersGetInfoMSFT(uint64_t meshBufferId_, const void* next_ = nullptr)
      : Parent(StructureType::SceneMeshBuffersGetInfoMSFT, next_), meshBufferId{meshBufferId_} {}

  //! Default/empty constructor
  SceneMeshBuffersGetInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneMeshBuffersGetInfoMSFT, next_), meshBufferId{0} {}

  //! Default copy constructor
  SceneMeshBuffersGetInfoMSFT(const SceneMeshBuffersGetInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshBuffersGetInfoMSFT& operator=(const SceneMeshBuffersGetInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshBuffersGetInfoMSFT(const XrSceneMeshBuffersGetInfoMSFT& rhs)
      : SceneMeshBuffersGetInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneMeshBuffersGetInfoMSFT& operator=(const XrSceneMeshBuffersGetInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshBuffersGetInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneMeshBuffersGetInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshBuffersGetInfoMSFT&() {
    return *reinterpret_cast<XrSceneMeshBuffersGetInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneMeshBuffersGetInfoMSFT
  XrSceneMeshBuffersGetInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshBuffersGetInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneMeshBuffersGetInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMeshBuffersGetInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMeshBuffersGetInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMeshBuffersGetInfoMSFT*>(this);
  }
  uint64_t meshBufferId;
};
static_assert(sizeof(XrSceneMeshBuffersGetInfoMSFT) == sizeof(SceneMeshBuffersGetInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshBuffersGetInfoMSFT pointer to const from a
 * SceneMeshBuffersGetInfoMSFT reference to const.
 * @relates SceneMeshBuffersGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshBuffersGetInfoMSFT const* get(
    SceneMeshBuffersGetInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshBuffersGetInfoMSFT
 * as the address of a raw XrSceneMeshBuffersGetInfoMSFT
 * @relates SceneMeshBuffersGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshBuffersGetInfoMSFT* put(SceneMeshBuffersGetInfoMSFT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshBuffersMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshBuffersMSFT>
 * @xrentity{XrSceneMeshBuffersMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMeshBuffersMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneMeshBuffersMSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneMeshBuffersMSFT, next_) {}

  //! Default copy constructor
  SceneMeshBuffersMSFT(const SceneMeshBuffersMSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshBuffersMSFT& operator=(const SceneMeshBuffersMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshBuffersMSFT(const XrSceneMeshBuffersMSFT& rhs) : SceneMeshBuffersMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneMeshBuffersMSFT& operator=(const XrSceneMeshBuffersMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshBuffersMSFT&() const {
    return *reinterpret_cast<const XrSceneMeshBuffersMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshBuffersMSFT&() { return *reinterpret_cast<XrSceneMeshBuffersMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneMeshBuffersMSFT
  XrSceneMeshBuffersMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshBuffersMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneMeshBuffersMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMeshBuffersMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMeshBuffersMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMeshBuffersMSFT*>(this);
  }
};
static_assert(sizeof(XrSceneMeshBuffersMSFT) == sizeof(SceneMeshBuffersMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshBuffersMSFT pointer to const from a
 * SceneMeshBuffersMSFT reference to const.
 * @relates SceneMeshBuffersMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshBuffersMSFT const* get(SceneMeshBuffersMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshBuffersMSFT as the
 * address of a raw XrSceneMeshBuffersMSFT
 * @relates SceneMeshBuffersMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshBuffersMSFT* put(SceneMeshBuffersMSFT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshVertexBufferMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshVertexBufferMSFT>
 * @xrentity{XrSceneMeshVertexBufferMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMeshVertexBufferMSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneMeshVertexBufferMSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneMeshVertexBufferMSFT, next_) {}

  //! Default copy constructor
  SceneMeshVertexBufferMSFT(const SceneMeshVertexBufferMSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshVertexBufferMSFT& operator=(const SceneMeshVertexBufferMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshVertexBufferMSFT(const XrSceneMeshVertexBufferMSFT& rhs) : SceneMeshVertexBufferMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneMeshVertexBufferMSFT& operator=(const XrSceneMeshVertexBufferMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshVertexBufferMSFT&() const {
    return *reinterpret_cast<const XrSceneMeshVertexBufferMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshVertexBufferMSFT&() {
    return *reinterpret_cast<XrSceneMeshVertexBufferMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneMeshVertexBufferMSFT
  XrSceneMeshVertexBufferMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshVertexBufferMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneMeshVertexBufferMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMeshVertexBufferMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMeshVertexBufferMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMeshVertexBufferMSFT*>(this);
  }
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  Vector3f* vertices;
};
static_assert(sizeof(XrSceneMeshVertexBufferMSFT) == sizeof(SceneMeshVertexBufferMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshVertexBufferMSFT pointer to const from a
 * SceneMeshVertexBufferMSFT reference to const.
 * @relates SceneMeshVertexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshVertexBufferMSFT const* get(
    SceneMeshVertexBufferMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshVertexBufferMSFT as
 * the address of a raw XrSceneMeshVertexBufferMSFT
 * @relates SceneMeshVertexBufferMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshVertexBufferMSFT* put(SceneMeshVertexBufferMSFT& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshIndicesUint32MSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshIndicesUint32MSFT>
 * @xrentity{XrSceneMeshIndicesUint32MSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMeshIndicesUint32MSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneMeshIndicesUint32MSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneMeshIndicesUint32MSFT, next_) {}

  //! Default copy constructor
  SceneMeshIndicesUint32MSFT(const SceneMeshIndicesUint32MSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshIndicesUint32MSFT& operator=(const SceneMeshIndicesUint32MSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshIndicesUint32MSFT(const XrSceneMeshIndicesUint32MSFT& rhs)
      : SceneMeshIndicesUint32MSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneMeshIndicesUint32MSFT& operator=(const XrSceneMeshIndicesUint32MSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshIndicesUint32MSFT&() const {
    return *reinterpret_cast<const XrSceneMeshIndicesUint32MSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshIndicesUint32MSFT&() {
    return *reinterpret_cast<XrSceneMeshIndicesUint32MSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneMeshIndicesUint32MSFT
  XrSceneMeshIndicesUint32MSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshIndicesUint32MSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneMeshIndicesUint32MSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMeshIndicesUint32MSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMeshIndicesUint32MSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMeshIndicesUint32MSFT*>(this);
  }
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  uint32_t* indices;
};
static_assert(sizeof(XrSceneMeshIndicesUint32MSFT) == sizeof(SceneMeshIndicesUint32MSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshIndicesUint32MSFT pointer to const from a
 * SceneMeshIndicesUint32MSFT reference to const.
 * @relates SceneMeshIndicesUint32MSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshIndicesUint32MSFT const* get(
    SceneMeshIndicesUint32MSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshIndicesUint32MSFT as
 * the address of a raw XrSceneMeshIndicesUint32MSFT
 * @relates SceneMeshIndicesUint32MSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshIndicesUint32MSFT* put(SceneMeshIndicesUint32MSFT& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding
/*!
 * C++ projection of XrSceneMeshIndicesUint16MSFT
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMeshIndicesUint16MSFT>
 * @xrentity{XrSceneMeshIndicesUint16MSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMeshIndicesUint16MSFT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneMeshIndicesUint16MSFT(void* next_ = nullptr)

      : Parent(StructureType::SceneMeshIndicesUint16MSFT, next_) {}

  //! Default copy constructor
  SceneMeshIndicesUint16MSFT(const SceneMeshIndicesUint16MSFT& rhs) = default;
  //! Default copy assignment
  SceneMeshIndicesUint16MSFT& operator=(const SceneMeshIndicesUint16MSFT& rhs) = default;
  //! Copy construct from raw
  SceneMeshIndicesUint16MSFT(const XrSceneMeshIndicesUint16MSFT& rhs)
      : SceneMeshIndicesUint16MSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneMeshIndicesUint16MSFT& operator=(const XrSceneMeshIndicesUint16MSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMeshIndicesUint16MSFT&() const {
    return *reinterpret_cast<const XrSceneMeshIndicesUint16MSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMeshIndicesUint16MSFT&() {
    return *reinterpret_cast<XrSceneMeshIndicesUint16MSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneMeshIndicesUint16MSFT
  XrSceneMeshIndicesUint16MSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMeshIndicesUint16MSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneMeshIndicesUint16MSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMeshIndicesUint16MSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMeshIndicesUint16MSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMeshIndicesUint16MSFT*>(this);
  }
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  uint16_t* indices;
};
static_assert(sizeof(XrSceneMeshIndicesUint16MSFT) == sizeof(SceneMeshIndicesUint16MSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMeshIndicesUint16MSFT pointer to const from a
 * SceneMeshIndicesUint16MSFT reference to const.
 * @relates SceneMeshIndicesUint16MSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshIndicesUint16MSFT const* get(
    SceneMeshIndicesUint16MSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMeshIndicesUint16MSFT as
 * the address of a raw XrSceneMeshIndicesUint16MSFT
 * @relates SceneMeshIndicesUint16MSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMeshIndicesUint16MSFT* put(SceneMeshIndicesUint16MSFT& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding_serialization
/*!
 * C++ projection of XrSerializedSceneFragmentDataGetInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding_serialization` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSerializedSceneFragmentDataGetInfoMSFT>
 * @xrentity{XrSerializedSceneFragmentDataGetInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SerializedSceneFragmentDataGetInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SerializedSceneFragmentDataGetInfoMSFT(const UuidMSFT& sceneFragmentId_,
                                         const void* next_ = nullptr)
      : Parent(StructureType::SerializedSceneFragmentDataGetInfoMSFT, next_),
        sceneFragmentId{sceneFragmentId_} {}

  //! Default/empty constructor
  SerializedSceneFragmentDataGetInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SerializedSceneFragmentDataGetInfoMSFT, next_), sceneFragmentId{} {}

  //! Default copy constructor
  SerializedSceneFragmentDataGetInfoMSFT(const SerializedSceneFragmentDataGetInfoMSFT& rhs) =
      default;
  //! Default copy assignment
  SerializedSceneFragmentDataGetInfoMSFT& operator=(
      const SerializedSceneFragmentDataGetInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SerializedSceneFragmentDataGetInfoMSFT(const XrSerializedSceneFragmentDataGetInfoMSFT& rhs)
      : SerializedSceneFragmentDataGetInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SerializedSceneFragmentDataGetInfoMSFT& operator=(
      const XrSerializedSceneFragmentDataGetInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSerializedSceneFragmentDataGetInfoMSFT&() const {
    return *reinterpret_cast<const XrSerializedSceneFragmentDataGetInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSerializedSceneFragmentDataGetInfoMSFT&() {
    return *reinterpret_cast<XrSerializedSceneFragmentDataGetInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSerializedSceneFragmentDataGetInfoMSFT
  XrSerializedSceneFragmentDataGetInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSerializedSceneFragmentDataGetInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSerializedSceneFragmentDataGetInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSerializedSceneFragmentDataGetInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SerializedSceneFragmentDataGetInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSerializedSceneFragmentDataGetInfoMSFT*>(this);
  }
  UuidMSFT sceneFragmentId;
};
static_assert(sizeof(XrSerializedSceneFragmentDataGetInfoMSFT) ==
                  sizeof(SerializedSceneFragmentDataGetInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSerializedSceneFragmentDataGetInfoMSFT pointer to const
 * from a SerializedSceneFragmentDataGetInfoMSFT reference to const.
 * @relates SerializedSceneFragmentDataGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSerializedSceneFragmentDataGetInfoMSFT const* get(
    SerializedSceneFragmentDataGetInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SerializedSceneFragmentDataGetInfoMSFT as the address of a raw
 * XrSerializedSceneFragmentDataGetInfoMSFT
 * @relates SerializedSceneFragmentDataGetInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSerializedSceneFragmentDataGetInfoMSFT* put(
    SerializedSceneFragmentDataGetInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding_serialization

#ifdef XR_MSFT_scene_understanding_serialization
/*!
 * C++ projection of XrDeserializeSceneFragmentMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding_serialization` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDeserializeSceneFragmentMSFT>
 * @xrentity{XrDeserializeSceneFragmentMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS DeserializeSceneFragmentMSFT {
public:
  //! Constructor initializing all members.
  DeserializeSceneFragmentMSFT(uint32_t bufferSize_, const uint8_t* buffer_)
      : bufferSize{bufferSize_}, buffer{buffer_} {}

  //! Default/empty constructor
  DeserializeSceneFragmentMSFT()

      : bufferSize{0}, buffer{nullptr} {}

  //! Default copy constructor
  DeserializeSceneFragmentMSFT(const DeserializeSceneFragmentMSFT& rhs) = default;
  //! Default copy assignment
  DeserializeSceneFragmentMSFT& operator=(const DeserializeSceneFragmentMSFT& rhs) = default;
  //! Copy construct from raw
  DeserializeSceneFragmentMSFT(const XrDeserializeSceneFragmentMSFT& rhs)
      : DeserializeSceneFragmentMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DeserializeSceneFragmentMSFT& operator=(const XrDeserializeSceneFragmentMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDeserializeSceneFragmentMSFT&() const {
    return *reinterpret_cast<const XrDeserializeSceneFragmentMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDeserializeSceneFragmentMSFT&() {
    return *reinterpret_cast<XrDeserializeSceneFragmentMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrDeserializeSceneFragmentMSFT
  XrDeserializeSceneFragmentMSFT const* get() const noexcept {
    return reinterpret_cast<XrDeserializeSceneFragmentMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDeserializeSceneFragmentMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrDeserializeSceneFragmentMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = DeserializeSceneFragmentMSFT{};
    }
    return reinterpret_cast<XrDeserializeSceneFragmentMSFT*>(this);
  }
  uint32_t bufferSize;
  const uint8_t* buffer;
};
static_assert(sizeof(XrDeserializeSceneFragmentMSFT) == sizeof(DeserializeSceneFragmentMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDeserializeSceneFragmentMSFT pointer to const from a
 * DeserializeSceneFragmentMSFT reference to const.
 * @relates DeserializeSceneFragmentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDeserializeSceneFragmentMSFT const* get(
    DeserializeSceneFragmentMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing DeserializeSceneFragmentMSFT
 * as the address of a raw XrDeserializeSceneFragmentMSFT
 * @relates DeserializeSceneFragmentMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDeserializeSceneFragmentMSFT* put(DeserializeSceneFragmentMSFT& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding_serialization

#ifdef XR_MSFT_scene_understanding_serialization
/*!
 * C++ projection of XrSceneDeserializeInfoMSFT
 *
 * Provided by the `XR_MSFT_scene_understanding_serialization` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneDeserializeInfoMSFT>
 * @xrentity{XrSceneDeserializeInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneDeserializeInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneDeserializeInfoMSFT(uint32_t fragmentCount_, const DeserializeSceneFragmentMSFT* fragments_,
                           const void* next_ = nullptr)
      : Parent(StructureType::SceneDeserializeInfoMSFT, next_),
        fragmentCount{fragmentCount_},
        fragments{fragments_} {}

  //! Default/empty constructor
  SceneDeserializeInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneDeserializeInfoMSFT, next_),
        fragmentCount{0},
        fragments{nullptr} {}

  //! Default copy constructor
  SceneDeserializeInfoMSFT(const SceneDeserializeInfoMSFT& rhs) = default;
  //! Default copy assignment
  SceneDeserializeInfoMSFT& operator=(const SceneDeserializeInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SceneDeserializeInfoMSFT(const XrSceneDeserializeInfoMSFT& rhs) : SceneDeserializeInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneDeserializeInfoMSFT& operator=(const XrSceneDeserializeInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneDeserializeInfoMSFT&() const {
    return *reinterpret_cast<const XrSceneDeserializeInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneDeserializeInfoMSFT&() {
    return *reinterpret_cast<XrSceneDeserializeInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneDeserializeInfoMSFT
  XrSceneDeserializeInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneDeserializeInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneDeserializeInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneDeserializeInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneDeserializeInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneDeserializeInfoMSFT*>(this);
  }
  uint32_t fragmentCount;
  const DeserializeSceneFragmentMSFT* fragments;
};
static_assert(sizeof(XrSceneDeserializeInfoMSFT) == sizeof(SceneDeserializeInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneDeserializeInfoMSFT pointer to const from a
 * SceneDeserializeInfoMSFT reference to const.
 * @relates SceneDeserializeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneDeserializeInfoMSFT const* get(SceneDeserializeInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneDeserializeInfoMSFT as
 * the address of a raw XrSceneDeserializeInfoMSFT
 * @relates SceneDeserializeInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneDeserializeInfoMSFT* put(SceneDeserializeInfoMSFT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_understanding_serialization

#ifdef XR_FB_display_refresh_rate
/*!
 * C++ projection of XrEventDataDisplayRefreshRateChangedFB
 *
 * Provided by the `XR_FB_display_refresh_rate` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataDisplayRefreshRateChangedFB>
 * @xrentity{XrEventDataDisplayRefreshRateChangedFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataDisplayRefreshRateChangedFB : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataDisplayRefreshRateChangedFB(void* next_ = nullptr)

      : Parent(StructureType::EventDataDisplayRefreshRateChangedFB, next_) {}

  //! Default copy constructor
  EventDataDisplayRefreshRateChangedFB(const EventDataDisplayRefreshRateChangedFB& rhs) = default;
  //! Default copy assignment
  EventDataDisplayRefreshRateChangedFB& operator=(const EventDataDisplayRefreshRateChangedFB& rhs) =
      default;
  //! Copy construct from raw
  EventDataDisplayRefreshRateChangedFB(const XrEventDataDisplayRefreshRateChangedFB& rhs)
      : EventDataDisplayRefreshRateChangedFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataDisplayRefreshRateChangedFB& operator=(
      const XrEventDataDisplayRefreshRateChangedFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataDisplayRefreshRateChangedFB&() const {
    return *reinterpret_cast<const XrEventDataDisplayRefreshRateChangedFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataDisplayRefreshRateChangedFB&() {
    return *reinterpret_cast<XrEventDataDisplayRefreshRateChangedFB*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataDisplayRefreshRateChangedFB
  XrEventDataDisplayRefreshRateChangedFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataDisplayRefreshRateChangedFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataDisplayRefreshRateChangedFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataDisplayRefreshRateChangedFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataDisplayRefreshRateChangedFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataDisplayRefreshRateChangedFB*>(this);
  }
  float fromDisplayRefreshRate;
  float toDisplayRefreshRate;
};
static_assert(sizeof(XrEventDataDisplayRefreshRateChangedFB) ==
                  sizeof(EventDataDisplayRefreshRateChangedFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataDisplayRefreshRateChangedFB pointer to const
 * from a EventDataDisplayRefreshRateChangedFB reference to const.
 * @relates EventDataDisplayRefreshRateChangedFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataDisplayRefreshRateChangedFB const* get(
    EventDataDisplayRefreshRateChangedFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataDisplayRefreshRateChangedFB as the address of a raw
 * XrEventDataDisplayRefreshRateChangedFB
 * @relates EventDataDisplayRefreshRateChangedFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataDisplayRefreshRateChangedFB* put(
    EventDataDisplayRefreshRateChangedFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataDisplayRefreshRateChangedFB as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataDisplayRefreshRateChangedFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataDisplayRefreshRateChangedFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_display_refresh_rate

#ifdef XR_HTCX_vive_tracker_interaction
/*!
 * C++ projection of XrViveTrackerPathsHTCX
 *
 * Provided by the `XR_HTCX_vive_tracker_interaction` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViveTrackerPathsHTCX>
 * @xrentity{XrViveTrackerPathsHTCX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViveTrackerPathsHTCX : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ViveTrackerPathsHTCX(void* next_ = nullptr)

      : Parent(StructureType::ViveTrackerPathsHTCX, next_) {}

  //! Default copy constructor
  ViveTrackerPathsHTCX(const ViveTrackerPathsHTCX& rhs) = default;
  //! Default copy assignment
  ViveTrackerPathsHTCX& operator=(const ViveTrackerPathsHTCX& rhs) = default;
  //! Copy construct from raw
  ViveTrackerPathsHTCX(const XrViveTrackerPathsHTCX& rhs) : ViveTrackerPathsHTCX() { *put() = rhs; }
  //! Copy assign from raw
  ViveTrackerPathsHTCX& operator=(const XrViveTrackerPathsHTCX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViveTrackerPathsHTCX&() const {
    return *reinterpret_cast<const XrViveTrackerPathsHTCX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViveTrackerPathsHTCX&() { return *reinterpret_cast<XrViveTrackerPathsHTCX*>(this); }

  //! Accessor for this as the address of a raw XrViveTrackerPathsHTCX
  XrViveTrackerPathsHTCX const* get() const noexcept {
    return reinterpret_cast<XrViveTrackerPathsHTCX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrViveTrackerPathsHTCX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViveTrackerPathsHTCX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViveTrackerPathsHTCX{};
      next = oldNext;
    }
    return reinterpret_cast<XrViveTrackerPathsHTCX*>(this);
  }
  Path persistentPath;
  Path rolePath;
};
static_assert(sizeof(XrViveTrackerPathsHTCX) == sizeof(ViveTrackerPathsHTCX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViveTrackerPathsHTCX pointer to const from a
 * ViveTrackerPathsHTCX reference to const.
 * @relates ViveTrackerPathsHTCX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViveTrackerPathsHTCX const* get(ViveTrackerPathsHTCX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ViveTrackerPathsHTCX as the
 * address of a raw XrViveTrackerPathsHTCX
 * @relates ViveTrackerPathsHTCX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViveTrackerPathsHTCX* put(ViveTrackerPathsHTCX& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTCX_vive_tracker_interaction

#ifdef XR_HTCX_vive_tracker_interaction
/*!
 * C++ projection of XrEventDataViveTrackerConnectedHTCX
 *
 * Provided by the `XR_HTCX_vive_tracker_interaction` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataViveTrackerConnectedHTCX>
 * @xrentity{XrEventDataViveTrackerConnectedHTCX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataViveTrackerConnectedHTCX : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataViveTrackerConnectedHTCX(void* next_ = nullptr)

      : Parent(StructureType::EventDataViveTrackerConnectedHTCX, next_) {}

  //! Default copy constructor
  EventDataViveTrackerConnectedHTCX(const EventDataViveTrackerConnectedHTCX& rhs) = default;
  //! Default copy assignment
  EventDataViveTrackerConnectedHTCX& operator=(const EventDataViveTrackerConnectedHTCX& rhs) =
      default;
  //! Copy construct from raw
  EventDataViveTrackerConnectedHTCX(const XrEventDataViveTrackerConnectedHTCX& rhs)
      : EventDataViveTrackerConnectedHTCX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataViveTrackerConnectedHTCX& operator=(const XrEventDataViveTrackerConnectedHTCX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataViveTrackerConnectedHTCX&() const {
    return *reinterpret_cast<const XrEventDataViveTrackerConnectedHTCX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataViveTrackerConnectedHTCX&() {
    return *reinterpret_cast<XrEventDataViveTrackerConnectedHTCX*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataViveTrackerConnectedHTCX
  XrEventDataViveTrackerConnectedHTCX const* get() const noexcept {
    return reinterpret_cast<XrEventDataViveTrackerConnectedHTCX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataViveTrackerConnectedHTCX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataViveTrackerConnectedHTCX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataViveTrackerConnectedHTCX{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataViveTrackerConnectedHTCX*>(this);
  }
  ViveTrackerPathsHTCX* paths;
};
static_assert(sizeof(XrEventDataViveTrackerConnectedHTCX) ==
                  sizeof(EventDataViveTrackerConnectedHTCX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataViveTrackerConnectedHTCX pointer to const from
 * a EventDataViveTrackerConnectedHTCX reference to const.
 * @relates EventDataViveTrackerConnectedHTCX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataViveTrackerConnectedHTCX const* get(
    EventDataViveTrackerConnectedHTCX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataViveTrackerConnectedHTCX as the address of a raw XrEventDataViveTrackerConnectedHTCX
 * @relates EventDataViveTrackerConnectedHTCX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataViveTrackerConnectedHTCX* put(
    EventDataViveTrackerConnectedHTCX& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataViveTrackerConnectedHTCX as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataViveTrackerConnectedHTCX
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataViveTrackerConnectedHTCX const& h) {
  return h.get_base();
}
#endif  // XR_HTCX_vive_tracker_interaction

#ifdef XR_HTC_facial_tracking
/*!
 * C++ projection of XrSystemFacialTrackingPropertiesHTC
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemFacialTrackingPropertiesHTC>
 * @xrentity{XrSystemFacialTrackingPropertiesHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemFacialTrackingPropertiesHTC : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemFacialTrackingPropertiesHTC(void* next_ = nullptr)

      : Parent(StructureType::SystemFacialTrackingPropertiesHTC, next_) {}

  //! Default copy constructor
  SystemFacialTrackingPropertiesHTC(const SystemFacialTrackingPropertiesHTC& rhs) = default;
  //! Default copy assignment
  SystemFacialTrackingPropertiesHTC& operator=(const SystemFacialTrackingPropertiesHTC& rhs) =
      default;
  //! Copy construct from raw
  SystemFacialTrackingPropertiesHTC(const XrSystemFacialTrackingPropertiesHTC& rhs)
      : SystemFacialTrackingPropertiesHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemFacialTrackingPropertiesHTC& operator=(const XrSystemFacialTrackingPropertiesHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemFacialTrackingPropertiesHTC&() const {
    return *reinterpret_cast<const XrSystemFacialTrackingPropertiesHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemFacialTrackingPropertiesHTC&() {
    return *reinterpret_cast<XrSystemFacialTrackingPropertiesHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemFacialTrackingPropertiesHTC
  XrSystemFacialTrackingPropertiesHTC const* get() const noexcept {
    return reinterpret_cast<XrSystemFacialTrackingPropertiesHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemFacialTrackingPropertiesHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemFacialTrackingPropertiesHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemFacialTrackingPropertiesHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemFacialTrackingPropertiesHTC*>(this);
  }
  Bool32 supportEyeFacialTracking;
  Bool32 supportLipFacialTracking;
};
static_assert(sizeof(XrSystemFacialTrackingPropertiesHTC) ==
                  sizeof(SystemFacialTrackingPropertiesHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemFacialTrackingPropertiesHTC pointer to const from
 * a SystemFacialTrackingPropertiesHTC reference to const.
 * @relates SystemFacialTrackingPropertiesHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFacialTrackingPropertiesHTC const* get(
    SystemFacialTrackingPropertiesHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemFacialTrackingPropertiesHTC as the address of a raw XrSystemFacialTrackingPropertiesHTC
 * @relates SystemFacialTrackingPropertiesHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFacialTrackingPropertiesHTC* put(
    SystemFacialTrackingPropertiesHTC& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_facial_tracking

#ifdef XR_HTC_facial_tracking
/*!
 * C++ projection of XrFacialExpressionsHTC
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialExpressionsHTC>
 * @xrentity{XrFacialExpressionsHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FacialExpressionsHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FacialExpressionsHTC(const Bool32& isActive_, const Time& sampleTime_, uint32_t expressionCount_,
                       float* expressionWeightings_, const void* next_ = nullptr)
      : Parent(StructureType::FacialExpressionsHTC, next_),
        isActive{isActive_},
        sampleTime{sampleTime_},
        expressionCount{expressionCount_},
        expressionWeightings{expressionWeightings_} {}

  //! Default/empty constructor
  FacialExpressionsHTC(const void* next_ = nullptr)

      : Parent(StructureType::FacialExpressionsHTC, next_),
        isActive{false},
        sampleTime{},
        expressionCount{0},
        expressionWeightings{nullptr} {}

  //! Default copy constructor
  FacialExpressionsHTC(const FacialExpressionsHTC& rhs) = default;
  //! Default copy assignment
  FacialExpressionsHTC& operator=(const FacialExpressionsHTC& rhs) = default;
  //! Copy construct from raw
  FacialExpressionsHTC(const XrFacialExpressionsHTC& rhs) : FacialExpressionsHTC() { *put() = rhs; }
  //! Copy assign from raw
  FacialExpressionsHTC& operator=(const XrFacialExpressionsHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFacialExpressionsHTC&() const {
    return *reinterpret_cast<const XrFacialExpressionsHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFacialExpressionsHTC&() { return *reinterpret_cast<XrFacialExpressionsHTC*>(this); }

  //! Accessor for this as the address of a raw XrFacialExpressionsHTC
  XrFacialExpressionsHTC const* get() const noexcept {
    return reinterpret_cast<XrFacialExpressionsHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFacialExpressionsHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFacialExpressionsHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FacialExpressionsHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrFacialExpressionsHTC*>(this);
  }
  Bool32 isActive;
  Time sampleTime;
  uint32_t expressionCount;
  float* expressionWeightings;
};
static_assert(sizeof(XrFacialExpressionsHTC) == sizeof(FacialExpressionsHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFacialExpressionsHTC pointer to const from a
 * FacialExpressionsHTC reference to const.
 * @relates FacialExpressionsHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialExpressionsHTC const* get(FacialExpressionsHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FacialExpressionsHTC as the
 * address of a raw XrFacialExpressionsHTC
 * @relates FacialExpressionsHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialExpressionsHTC* put(FacialExpressionsHTC& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_facial_tracking

#ifdef XR_HTC_facial_tracking
/*!
 * C++ projection of XrFacialTrackerCreateInfoHTC
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialTrackerCreateInfoHTC>
 * @xrentity{XrFacialTrackerCreateInfoHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FacialTrackerCreateInfoHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FacialTrackerCreateInfoHTC(const FacialTrackingTypeHTC& facialTrackingType_,
                             const void* next_ = nullptr)
      : Parent(StructureType::FacialTrackerCreateInfoHTC, next_),
        facialTrackingType{facialTrackingType_} {}

  //! Default/empty constructor
  FacialTrackerCreateInfoHTC(const void* next_ = nullptr)

      : Parent(StructureType::FacialTrackerCreateInfoHTC, next_), facialTrackingType{} {}

  //! Default copy constructor
  FacialTrackerCreateInfoHTC(const FacialTrackerCreateInfoHTC& rhs) = default;
  //! Default copy assignment
  FacialTrackerCreateInfoHTC& operator=(const FacialTrackerCreateInfoHTC& rhs) = default;
  //! Copy construct from raw
  FacialTrackerCreateInfoHTC(const XrFacialTrackerCreateInfoHTC& rhs)
      : FacialTrackerCreateInfoHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FacialTrackerCreateInfoHTC& operator=(const XrFacialTrackerCreateInfoHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFacialTrackerCreateInfoHTC&() const {
    return *reinterpret_cast<const XrFacialTrackerCreateInfoHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFacialTrackerCreateInfoHTC&() {
    return *reinterpret_cast<XrFacialTrackerCreateInfoHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrFacialTrackerCreateInfoHTC
  XrFacialTrackerCreateInfoHTC const* get() const noexcept {
    return reinterpret_cast<XrFacialTrackerCreateInfoHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFacialTrackerCreateInfoHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFacialTrackerCreateInfoHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FacialTrackerCreateInfoHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrFacialTrackerCreateInfoHTC*>(this);
  }
  FacialTrackingTypeHTC facialTrackingType;
};
static_assert(sizeof(XrFacialTrackerCreateInfoHTC) == sizeof(FacialTrackerCreateInfoHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFacialTrackerCreateInfoHTC pointer to const from a
 * FacialTrackerCreateInfoHTC reference to const.
 * @relates FacialTrackerCreateInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialTrackerCreateInfoHTC const* get(
    FacialTrackerCreateInfoHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FacialTrackerCreateInfoHTC as
 * the address of a raw XrFacialTrackerCreateInfoHTC
 * @relates FacialTrackerCreateInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialTrackerCreateInfoHTC* put(FacialTrackerCreateInfoHTC& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_facial_tracking

#ifdef XR_FB_color_space
/*!
 * C++ projection of XrSystemColorSpacePropertiesFB
 *
 * Provided by the `XR_FB_color_space` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemColorSpacePropertiesFB>
 * @xrentity{XrSystemColorSpacePropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemColorSpacePropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemColorSpacePropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemColorSpacePropertiesFB, next_) {}

  //! Default copy constructor
  SystemColorSpacePropertiesFB(const SystemColorSpacePropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemColorSpacePropertiesFB& operator=(const SystemColorSpacePropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemColorSpacePropertiesFB(const XrSystemColorSpacePropertiesFB& rhs)
      : SystemColorSpacePropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemColorSpacePropertiesFB& operator=(const XrSystemColorSpacePropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemColorSpacePropertiesFB&() const {
    return *reinterpret_cast<const XrSystemColorSpacePropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemColorSpacePropertiesFB&() {
    return *reinterpret_cast<XrSystemColorSpacePropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemColorSpacePropertiesFB
  XrSystemColorSpacePropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemColorSpacePropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemColorSpacePropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemColorSpacePropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemColorSpacePropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemColorSpacePropertiesFB*>(this);
  }
  ColorSpaceFB colorSpace;
};
static_assert(sizeof(XrSystemColorSpacePropertiesFB) == sizeof(SystemColorSpacePropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemColorSpacePropertiesFB pointer to const from a
 * SystemColorSpacePropertiesFB reference to const.
 * @relates SystemColorSpacePropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemColorSpacePropertiesFB const* get(
    SystemColorSpacePropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemColorSpacePropertiesFB
 * as the address of a raw XrSystemColorSpacePropertiesFB
 * @relates SystemColorSpacePropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemColorSpacePropertiesFB* put(SystemColorSpacePropertiesFB& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_color_space

#ifdef XR_FB_hand_tracking_mesh
/*!
 * C++ projection of XrVector4sFB
 *
 * Provided by the `XR_FB_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVector4sFB>
 * @xrentity{XrVector4sFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Vector4sFB {
public:
  //! Constructor initializing all members.
  Vector4sFB(int16_t x_, int16_t y_, int16_t z_, int16_t w_) : x{x_}, y{y_}, z{z_}, w{w_} {}

  //! Default/empty constructor
  Vector4sFB()

      : x{0}, y{0}, z{0}, w{0} {}

  //! Default copy constructor
  Vector4sFB(const Vector4sFB& rhs) = default;
  //! Default copy assignment
  Vector4sFB& operator=(const Vector4sFB& rhs) = default;
  //! Copy construct from raw
  Vector4sFB(const XrVector4sFB& rhs) : Vector4sFB() { *put() = rhs; }
  //! Copy assign from raw
  Vector4sFB& operator=(const XrVector4sFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVector4sFB&() const { return *reinterpret_cast<const XrVector4sFB*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVector4sFB&() { return *reinterpret_cast<XrVector4sFB*>(this); }

  //! Accessor for this as the address of a raw XrVector4sFB
  XrVector4sFB const* get() const noexcept { return reinterpret_cast<XrVector4sFB const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrVector4sFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrVector4sFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = Vector4sFB{};
    }
    return reinterpret_cast<XrVector4sFB*>(this);
  }
  int16_t x;
  int16_t y;
  int16_t z;
  int16_t w;
};
static_assert(sizeof(XrVector4sFB) == sizeof(Vector4sFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVector4sFB pointer to const from a Vector4sFB reference
 * to const.
 * @relates Vector4sFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector4sFB const* get(Vector4sFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Vector4sFB as the address of
 * a raw XrVector4sFB
 * @relates Vector4sFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVector4sFB* put(Vector4sFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_hand_tracking_mesh

#ifdef XR_FB_hand_tracking_mesh
/*!
 * C++ projection of XrHandTrackingMeshFB
 *
 * Provided by the `XR_FB_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingMeshFB>
 * @xrentity{XrHandTrackingMeshFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackingMeshFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandTrackingMeshFB(void* next_ = nullptr)

      : Parent(StructureType::HandTrackingMeshFB, next_) {}

  //! Default copy constructor
  HandTrackingMeshFB(const HandTrackingMeshFB& rhs) = default;
  //! Default copy assignment
  HandTrackingMeshFB& operator=(const HandTrackingMeshFB& rhs) = default;
  //! Copy construct from raw
  HandTrackingMeshFB(const XrHandTrackingMeshFB& rhs) : HandTrackingMeshFB() { *put() = rhs; }
  //! Copy assign from raw
  HandTrackingMeshFB& operator=(const XrHandTrackingMeshFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackingMeshFB&() const {
    return *reinterpret_cast<const XrHandTrackingMeshFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackingMeshFB&() { return *reinterpret_cast<XrHandTrackingMeshFB*>(this); }

  //! Accessor for this as the address of a raw XrHandTrackingMeshFB
  XrHandTrackingMeshFB const* get() const noexcept {
    return reinterpret_cast<XrHandTrackingMeshFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackingMeshFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackingMeshFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackingMeshFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackingMeshFB*>(this);
  }
  uint32_t jointCapacityInput;
  uint32_t jointCountOutput;
  Posef* jointBindPoses;
  float* jointRadii;
  HandJointEXT* jointParents;
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  Vector3f* vertexPositions;
  Vector3f* vertexNormals;
  Vector2f* vertexUVs;
  Vector4sFB* vertexBlendIndices;
  Vector4f* vertexBlendWeights;
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  int16_t* indices;
};
static_assert(sizeof(XrHandTrackingMeshFB) == sizeof(HandTrackingMeshFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackingMeshFB pointer to const from a
 * HandTrackingMeshFB reference to const.
 * @relates HandTrackingMeshFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingMeshFB const* get(HandTrackingMeshFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingMeshFB as the
 * address of a raw XrHandTrackingMeshFB
 * @relates HandTrackingMeshFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingMeshFB* put(HandTrackingMeshFB& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_hand_tracking_mesh

#ifdef XR_FB_hand_tracking_mesh
/*!
 * C++ projection of XrHandTrackingScaleFB
 *
 * Provided by the `XR_FB_hand_tracking_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingScaleFB>
 * @xrentity{XrHandTrackingScaleFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackingScaleFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandTrackingScaleFB(void* next_ = nullptr)

      : Parent(StructureType::HandTrackingScaleFB, next_) {}

  //! Default copy constructor
  HandTrackingScaleFB(const HandTrackingScaleFB& rhs) = default;
  //! Default copy assignment
  HandTrackingScaleFB& operator=(const HandTrackingScaleFB& rhs) = default;
  //! Copy construct from raw
  HandTrackingScaleFB(const XrHandTrackingScaleFB& rhs) : HandTrackingScaleFB() { *put() = rhs; }
  //! Copy assign from raw
  HandTrackingScaleFB& operator=(const XrHandTrackingScaleFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackingScaleFB&() const {
    return *reinterpret_cast<const XrHandTrackingScaleFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackingScaleFB&() { return *reinterpret_cast<XrHandTrackingScaleFB*>(this); }

  //! Accessor for this as the address of a raw XrHandTrackingScaleFB
  XrHandTrackingScaleFB const* get() const noexcept {
    return reinterpret_cast<XrHandTrackingScaleFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackingScaleFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackingScaleFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackingScaleFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackingScaleFB*>(this);
  }
  float sensorOutput;
  float currentOutput;
  Bool32 overrideHandScale;
  float overrideValueInput;
};
static_assert(sizeof(XrHandTrackingScaleFB) == sizeof(HandTrackingScaleFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackingScaleFB pointer to const from a
 * HandTrackingScaleFB reference to const.
 * @relates HandTrackingScaleFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingScaleFB const* get(HandTrackingScaleFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingScaleFB as the
 * address of a raw XrHandTrackingScaleFB
 * @relates HandTrackingScaleFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingScaleFB* put(HandTrackingScaleFB& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_hand_tracking_mesh

#ifdef XR_FB_hand_tracking_aim
/*!
 * C++ projection of XrHandTrackingAimStateFB
 *
 * Provided by the `XR_FB_hand_tracking_aim` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingAimStateFB>
 * @xrentity{XrHandTrackingAimStateFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackingAimStateFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandTrackingAimStateFB(void* next_ = nullptr)

      : Parent(StructureType::HandTrackingAimStateFB, next_) {}

  //! Default copy constructor
  HandTrackingAimStateFB(const HandTrackingAimStateFB& rhs) = default;
  //! Default copy assignment
  HandTrackingAimStateFB& operator=(const HandTrackingAimStateFB& rhs) = default;
  //! Copy construct from raw
  HandTrackingAimStateFB(const XrHandTrackingAimStateFB& rhs) : HandTrackingAimStateFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandTrackingAimStateFB& operator=(const XrHandTrackingAimStateFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackingAimStateFB&() const {
    return *reinterpret_cast<const XrHandTrackingAimStateFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackingAimStateFB&() {
    return *reinterpret_cast<XrHandTrackingAimStateFB*>(this);
  }

  //! Accessor for this as the address of a raw XrHandTrackingAimStateFB
  XrHandTrackingAimStateFB const* get() const noexcept {
    return reinterpret_cast<XrHandTrackingAimStateFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandTrackingAimStateFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackingAimStateFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackingAimStateFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackingAimStateFB*>(this);
  }
  HandTrackingAimFlagsFB status;
  Posef aimPose;
  float pinchStrengthIndex;
  float pinchStrengthMiddle;
  float pinchStrengthRing;
  float pinchStrengthLittle;
};
static_assert(sizeof(XrHandTrackingAimStateFB) == sizeof(HandTrackingAimStateFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackingAimStateFB pointer to const from a
 * HandTrackingAimStateFB reference to const.
 * @relates HandTrackingAimStateFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingAimStateFB const* get(HandTrackingAimStateFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingAimStateFB as the
 * address of a raw XrHandTrackingAimStateFB
 * @relates HandTrackingAimStateFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingAimStateFB* put(HandTrackingAimStateFB& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_hand_tracking_aim

#ifdef XR_FB_hand_tracking_capsules
/*!
 * C++ projection of XrHandCapsuleFB
 *
 * Provided by the `XR_FB_hand_tracking_capsules` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandCapsuleFB>
 * @xrentity{XrHandCapsuleFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS HandCapsuleFB {
public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandCapsuleFB()

  {}

  //! Default copy constructor
  HandCapsuleFB(const HandCapsuleFB& rhs) = default;
  //! Default copy assignment
  HandCapsuleFB& operator=(const HandCapsuleFB& rhs) = default;
  //! Copy construct from raw
  HandCapsuleFB(const XrHandCapsuleFB& rhs) : HandCapsuleFB() { *put() = rhs; }
  //! Copy assign from raw
  HandCapsuleFB& operator=(const XrHandCapsuleFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandCapsuleFB&() const {
    return *reinterpret_cast<const XrHandCapsuleFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandCapsuleFB&() { return *reinterpret_cast<XrHandCapsuleFB*>(this); }

  //! Accessor for this as the address of a raw XrHandCapsuleFB
  XrHandCapsuleFB const* get() const noexcept {
    return reinterpret_cast<XrHandCapsuleFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHandCapsuleFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrHandCapsuleFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = HandCapsuleFB{};
    }
    return reinterpret_cast<XrHandCapsuleFB*>(this);
  }
  Vector3f points[XR_HAND_TRACKING_CAPSULE_POINT_COUNT_FB];
  float radius;
  HandJointEXT joint;
};
static_assert(sizeof(XrHandCapsuleFB) == sizeof(HandCapsuleFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandCapsuleFB pointer to const from a HandCapsuleFB
 * reference to const.
 * @relates HandCapsuleFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandCapsuleFB const* get(HandCapsuleFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing HandCapsuleFB as the address
 * of a raw XrHandCapsuleFB
 * @relates HandCapsuleFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandCapsuleFB* put(HandCapsuleFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_hand_tracking_capsules

#ifdef XR_FB_hand_tracking_capsules
/*!
 * C++ projection of XrHandTrackingCapsulesStateFB
 *
 * Provided by the `XR_FB_hand_tracking_capsules` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingCapsulesStateFB>
 * @xrentity{XrHandTrackingCapsulesStateFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackingCapsulesStateFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandTrackingCapsulesStateFB(void* next_ = nullptr)

      : Parent(StructureType::HandTrackingCapsulesStateFB, next_) {}

  //! Default copy constructor
  HandTrackingCapsulesStateFB(const HandTrackingCapsulesStateFB& rhs) = default;
  //! Default copy assignment
  HandTrackingCapsulesStateFB& operator=(const HandTrackingCapsulesStateFB& rhs) = default;
  //! Copy construct from raw
  HandTrackingCapsulesStateFB(const XrHandTrackingCapsulesStateFB& rhs)
      : HandTrackingCapsulesStateFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandTrackingCapsulesStateFB& operator=(const XrHandTrackingCapsulesStateFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackingCapsulesStateFB&() const {
    return *reinterpret_cast<const XrHandTrackingCapsulesStateFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackingCapsulesStateFB&() {
    return *reinterpret_cast<XrHandTrackingCapsulesStateFB*>(this);
  }

  //! Accessor for this as the address of a raw XrHandTrackingCapsulesStateFB
  XrHandTrackingCapsulesStateFB const* get() const noexcept {
    return reinterpret_cast<XrHandTrackingCapsulesStateFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandTrackingCapsulesStateFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackingCapsulesStateFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackingCapsulesStateFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackingCapsulesStateFB*>(this);
  }
  HandCapsuleFB capsules[XR_HAND_TRACKING_CAPSULE_COUNT_FB];
};
static_assert(sizeof(XrHandTrackingCapsulesStateFB) == sizeof(HandTrackingCapsulesStateFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackingCapsulesStateFB pointer to const from a
 * HandTrackingCapsulesStateFB reference to const.
 * @relates HandTrackingCapsulesStateFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingCapsulesStateFB const* get(
    HandTrackingCapsulesStateFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingCapsulesStateFB
 * as the address of a raw XrHandTrackingCapsulesStateFB
 * @relates HandTrackingCapsulesStateFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingCapsulesStateFB* put(HandTrackingCapsulesStateFB& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_hand_tracking_capsules

#ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrSystemSpatialEntityPropertiesFB
 *
 * Provided by the `XR_FB_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpatialEntityPropertiesFB>
 * @xrentity{XrSystemSpatialEntityPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemSpatialEntityPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemSpatialEntityPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemSpatialEntityPropertiesFB, next_) {}

  //! Default copy constructor
  SystemSpatialEntityPropertiesFB(const SystemSpatialEntityPropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemSpatialEntityPropertiesFB& operator=(const SystemSpatialEntityPropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemSpatialEntityPropertiesFB(const XrSystemSpatialEntityPropertiesFB& rhs)
      : SystemSpatialEntityPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemSpatialEntityPropertiesFB& operator=(const XrSystemSpatialEntityPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemSpatialEntityPropertiesFB&() const {
    return *reinterpret_cast<const XrSystemSpatialEntityPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemSpatialEntityPropertiesFB&() {
    return *reinterpret_cast<XrSystemSpatialEntityPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemSpatialEntityPropertiesFB
  XrSystemSpatialEntityPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemSpatialEntityPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemSpatialEntityPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemSpatialEntityPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemSpatialEntityPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemSpatialEntityPropertiesFB*>(this);
  }
  Bool32 supportsSpatialEntity;
};
static_assert(sizeof(XrSystemSpatialEntityPropertiesFB) == sizeof(SystemSpatialEntityPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemSpatialEntityPropertiesFB pointer to const from a
 * SystemSpatialEntityPropertiesFB reference to const.
 * @relates SystemSpatialEntityPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialEntityPropertiesFB const* get(
    SystemSpatialEntityPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemSpatialEntityPropertiesFB as the address of a raw XrSystemSpatialEntityPropertiesFB
 * @relates SystemSpatialEntityPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialEntityPropertiesFB* put(SystemSpatialEntityPropertiesFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity

#ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrSpatialAnchorCreateInfoFB
 *
 * Provided by the `XR_FB_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorCreateInfoFB>
 * @xrentity{XrSpatialAnchorCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorCreateInfoFB(const Space& space_, const Posef& poseInSpace_, const Time& time_,
                            const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorCreateInfoFB, next_),
        space{space_},
        poseInSpace{poseInSpace_},
        time{time_} {}

  //! Default/empty constructor
  SpatialAnchorCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorCreateInfoFB, next_), space{}, poseInSpace{}, time{} {}

  //! Default copy constructor
  SpatialAnchorCreateInfoFB(const SpatialAnchorCreateInfoFB& rhs) = default;
  //! Default copy assignment
  SpatialAnchorCreateInfoFB& operator=(const SpatialAnchorCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorCreateInfoFB(const XrSpatialAnchorCreateInfoFB& rhs) : SpatialAnchorCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorCreateInfoFB& operator=(const XrSpatialAnchorCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorCreateInfoFB&() const {
    return *reinterpret_cast<const XrSpatialAnchorCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorCreateInfoFB&() {
    return *reinterpret_cast<XrSpatialAnchorCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorCreateInfoFB
  XrSpatialAnchorCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorCreateInfoFB*>(this);
  }
  Space space;
  Posef poseInSpace;
  Time time;
};
static_assert(sizeof(XrSpatialAnchorCreateInfoFB) == sizeof(SpatialAnchorCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorCreateInfoFB pointer to const from a
 * SpatialAnchorCreateInfoFB reference to const.
 * @relates SpatialAnchorCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoFB const* get(
    SpatialAnchorCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorCreateInfoFB as
 * the address of a raw XrSpatialAnchorCreateInfoFB
 * @relates SpatialAnchorCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoFB* put(SpatialAnchorCreateInfoFB& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity

#ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrSpaceComponentStatusSetInfoFB
 *
 * Provided by the `XR_FB_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceComponentStatusSetInfoFB>
 * @xrentity{XrSpaceComponentStatusSetInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceComponentStatusSetInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpaceComponentStatusSetInfoFB(const SpaceComponentTypeFB& componentType_, const Bool32& enabled_,
                                const Duration& timeout_, const void* next_ = nullptr)
      : Parent(StructureType::SpaceComponentStatusSetInfoFB, next_),
        componentType{componentType_},
        enabled{enabled_},
        timeout{timeout_} {}

  //! Default/empty constructor
  SpaceComponentStatusSetInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SpaceComponentStatusSetInfoFB, next_),
        componentType{},
        enabled{false},
        timeout{} {}

  //! Default copy constructor
  SpaceComponentStatusSetInfoFB(const SpaceComponentStatusSetInfoFB& rhs) = default;
  //! Default copy assignment
  SpaceComponentStatusSetInfoFB& operator=(const SpaceComponentStatusSetInfoFB& rhs) = default;
  //! Copy construct from raw
  SpaceComponentStatusSetInfoFB(const XrSpaceComponentStatusSetInfoFB& rhs)
      : SpaceComponentStatusSetInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpaceComponentStatusSetInfoFB& operator=(const XrSpaceComponentStatusSetInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceComponentStatusSetInfoFB&() const {
    return *reinterpret_cast<const XrSpaceComponentStatusSetInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceComponentStatusSetInfoFB&() {
    return *reinterpret_cast<XrSpaceComponentStatusSetInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSpaceComponentStatusSetInfoFB
  XrSpaceComponentStatusSetInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceComponentStatusSetInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpaceComponentStatusSetInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceComponentStatusSetInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceComponentStatusSetInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceComponentStatusSetInfoFB*>(this);
  }
  SpaceComponentTypeFB componentType;
  Bool32 enabled;
  Duration timeout;
};
static_assert(sizeof(XrSpaceComponentStatusSetInfoFB) == sizeof(SpaceComponentStatusSetInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceComponentStatusSetInfoFB pointer to const from a
 * SpaceComponentStatusSetInfoFB reference to const.
 * @relates SpaceComponentStatusSetInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceComponentStatusSetInfoFB const* get(
    SpaceComponentStatusSetInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceComponentStatusSetInfoFB
 * as the address of a raw XrSpaceComponentStatusSetInfoFB
 * @relates SpaceComponentStatusSetInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceComponentStatusSetInfoFB* put(SpaceComponentStatusSetInfoFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity

#ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrSpaceComponentStatusFB
 *
 * Provided by the `XR_FB_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceComponentStatusFB>
 * @xrentity{XrSpaceComponentStatusFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceComponentStatusFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceComponentStatusFB(void* next_ = nullptr)

      : Parent(StructureType::SpaceComponentStatusFB, next_) {}

  //! Default copy constructor
  SpaceComponentStatusFB(const SpaceComponentStatusFB& rhs) = default;
  //! Default copy assignment
  SpaceComponentStatusFB& operator=(const SpaceComponentStatusFB& rhs) = default;
  //! Copy construct from raw
  SpaceComponentStatusFB(const XrSpaceComponentStatusFB& rhs) : SpaceComponentStatusFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpaceComponentStatusFB& operator=(const XrSpaceComponentStatusFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceComponentStatusFB&() const {
    return *reinterpret_cast<const XrSpaceComponentStatusFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceComponentStatusFB&() {
    return *reinterpret_cast<XrSpaceComponentStatusFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSpaceComponentStatusFB
  XrSpaceComponentStatusFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceComponentStatusFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceComponentStatusFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceComponentStatusFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceComponentStatusFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceComponentStatusFB*>(this);
  }
  Bool32 enabled;
  Bool32 changePending;
};
static_assert(sizeof(XrSpaceComponentStatusFB) == sizeof(SpaceComponentStatusFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceComponentStatusFB pointer to const from a
 * SpaceComponentStatusFB reference to const.
 * @relates SpaceComponentStatusFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceComponentStatusFB const* get(SpaceComponentStatusFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceComponentStatusFB as the
 * address of a raw XrSpaceComponentStatusFB
 * @relates SpaceComponentStatusFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceComponentStatusFB* put(SpaceComponentStatusFB& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity

#ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrEventDataSpatialAnchorCreateCompleteFB
 *
 * Provided by the `XR_FB_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpatialAnchorCreateCompleteFB>
 * @xrentity{XrEventDataSpatialAnchorCreateCompleteFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSpatialAnchorCreateCompleteFB : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSpatialAnchorCreateCompleteFB(void* next_ = nullptr)

      : Parent(StructureType::EventDataSpatialAnchorCreateCompleteFB, next_) {}

  //! Default copy constructor
  EventDataSpatialAnchorCreateCompleteFB(const EventDataSpatialAnchorCreateCompleteFB& rhs) =
      default;
  //! Default copy assignment
  EventDataSpatialAnchorCreateCompleteFB& operator=(
      const EventDataSpatialAnchorCreateCompleteFB& rhs) = default;
  //! Copy construct from raw
  EventDataSpatialAnchorCreateCompleteFB(const XrEventDataSpatialAnchorCreateCompleteFB& rhs)
      : EventDataSpatialAnchorCreateCompleteFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSpatialAnchorCreateCompleteFB& operator=(
      const XrEventDataSpatialAnchorCreateCompleteFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSpatialAnchorCreateCompleteFB&() const {
    return *reinterpret_cast<const XrEventDataSpatialAnchorCreateCompleteFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSpatialAnchorCreateCompleteFB&() {
    return *reinterpret_cast<XrEventDataSpatialAnchorCreateCompleteFB*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSpatialAnchorCreateCompleteFB
  XrEventDataSpatialAnchorCreateCompleteFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataSpatialAnchorCreateCompleteFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSpatialAnchorCreateCompleteFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSpatialAnchorCreateCompleteFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSpatialAnchorCreateCompleteFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSpatialAnchorCreateCompleteFB*>(this);
  }
  AsyncRequestIdFB requestId;
  Result result;
  Space space;
  UuidEXT uuid;
};
static_assert(sizeof(XrEventDataSpatialAnchorCreateCompleteFB) ==
                  sizeof(EventDataSpatialAnchorCreateCompleteFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSpatialAnchorCreateCompleteFB pointer to const
 * from a EventDataSpatialAnchorCreateCompleteFB reference to const.
 * @relates EventDataSpatialAnchorCreateCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpatialAnchorCreateCompleteFB const* get(
    EventDataSpatialAnchorCreateCompleteFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataSpatialAnchorCreateCompleteFB as the address of a raw
 * XrEventDataSpatialAnchorCreateCompleteFB
 * @relates EventDataSpatialAnchorCreateCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpatialAnchorCreateCompleteFB* put(
    EventDataSpatialAnchorCreateCompleteFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSpatialAnchorCreateCompleteFB as
 * a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpatialAnchorCreateCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSpatialAnchorCreateCompleteFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_spatial_entity

#ifdef XR_FB_spatial_entity
/*!
 * C++ projection of XrEventDataSpaceSetStatusCompleteFB
 *
 * Provided by the `XR_FB_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceSetStatusCompleteFB>
 * @xrentity{XrEventDataSpaceSetStatusCompleteFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSpaceSetStatusCompleteFB : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSpaceSetStatusCompleteFB(void* next_ = nullptr)

      : Parent(StructureType::EventDataSpaceSetStatusCompleteFB, next_) {}

  //! Default copy constructor
  EventDataSpaceSetStatusCompleteFB(const EventDataSpaceSetStatusCompleteFB& rhs) = default;
  //! Default copy assignment
  EventDataSpaceSetStatusCompleteFB& operator=(const EventDataSpaceSetStatusCompleteFB& rhs) =
      default;
  //! Copy construct from raw
  EventDataSpaceSetStatusCompleteFB(const XrEventDataSpaceSetStatusCompleteFB& rhs)
      : EventDataSpaceSetStatusCompleteFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSpaceSetStatusCompleteFB& operator=(const XrEventDataSpaceSetStatusCompleteFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSpaceSetStatusCompleteFB&() const {
    return *reinterpret_cast<const XrEventDataSpaceSetStatusCompleteFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSpaceSetStatusCompleteFB&() {
    return *reinterpret_cast<XrEventDataSpaceSetStatusCompleteFB*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSpaceSetStatusCompleteFB
  XrEventDataSpaceSetStatusCompleteFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataSpaceSetStatusCompleteFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSpaceSetStatusCompleteFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSpaceSetStatusCompleteFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSpaceSetStatusCompleteFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSpaceSetStatusCompleteFB*>(this);
  }
  AsyncRequestIdFB requestId;
  Result result;
  Space space;
  UuidEXT uuid;
  SpaceComponentTypeFB componentType;
  Bool32 enabled;
};
static_assert(sizeof(XrEventDataSpaceSetStatusCompleteFB) ==
                  sizeof(EventDataSpaceSetStatusCompleteFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSpaceSetStatusCompleteFB pointer to const from
 * a EventDataSpaceSetStatusCompleteFB reference to const.
 * @relates EventDataSpaceSetStatusCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceSetStatusCompleteFB const* get(
    EventDataSpaceSetStatusCompleteFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataSpaceSetStatusCompleteFB as the address of a raw XrEventDataSpaceSetStatusCompleteFB
 * @relates EventDataSpaceSetStatusCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceSetStatusCompleteFB* put(
    EventDataSpaceSetStatusCompleteFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceSetStatusCompleteFB as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceSetStatusCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSpaceSetStatusCompleteFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_spatial_entity

#ifdef XR_FB_foveation
/*!
 * C++ projection of XrFoveationProfileCreateInfoFB
 *
 * Provided by the `XR_FB_foveation` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationProfileCreateInfoFB>
 * @xrentity{XrFoveationProfileCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FoveationProfileCreateInfoFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FoveationProfileCreateInfoFB(void* next_ = nullptr)

      : Parent(StructureType::FoveationProfileCreateInfoFB, next_) {}

  //! Default copy constructor
  FoveationProfileCreateInfoFB(const FoveationProfileCreateInfoFB& rhs) = default;
  //! Default copy assignment
  FoveationProfileCreateInfoFB& operator=(const FoveationProfileCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  FoveationProfileCreateInfoFB(const XrFoveationProfileCreateInfoFB& rhs)
      : FoveationProfileCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FoveationProfileCreateInfoFB& operator=(const XrFoveationProfileCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFoveationProfileCreateInfoFB&() const {
    return *reinterpret_cast<const XrFoveationProfileCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFoveationProfileCreateInfoFB&() {
    return *reinterpret_cast<XrFoveationProfileCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrFoveationProfileCreateInfoFB
  XrFoveationProfileCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrFoveationProfileCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFoveationProfileCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFoveationProfileCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FoveationProfileCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrFoveationProfileCreateInfoFB*>(this);
  }
};
static_assert(sizeof(XrFoveationProfileCreateInfoFB) == sizeof(FoveationProfileCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFoveationProfileCreateInfoFB pointer to const from a
 * FoveationProfileCreateInfoFB reference to const.
 * @relates FoveationProfileCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationProfileCreateInfoFB const* get(
    FoveationProfileCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationProfileCreateInfoFB
 * as the address of a raw XrFoveationProfileCreateInfoFB
 * @relates FoveationProfileCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationProfileCreateInfoFB* put(FoveationProfileCreateInfoFB& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_foveation

#ifdef XR_FB_foveation
/*!
 * C++ projection of XrSwapchainCreateInfoFoveationFB
 *
 * Provided by the `XR_FB_foveation` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainCreateInfoFoveationFB>
 * @xrentity{XrSwapchainCreateInfoFoveationFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainCreateInfoFoveationFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainCreateInfoFoveationFB(void* next_ = nullptr)

      : Parent(StructureType::SwapchainCreateInfoFoveationFB, next_) {}

  //! Default copy constructor
  SwapchainCreateInfoFoveationFB(const SwapchainCreateInfoFoveationFB& rhs) = default;
  //! Default copy assignment
  SwapchainCreateInfoFoveationFB& operator=(const SwapchainCreateInfoFoveationFB& rhs) = default;
  //! Copy construct from raw
  SwapchainCreateInfoFoveationFB(const XrSwapchainCreateInfoFoveationFB& rhs)
      : SwapchainCreateInfoFoveationFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainCreateInfoFoveationFB& operator=(const XrSwapchainCreateInfoFoveationFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainCreateInfoFoveationFB&() const {
    return *reinterpret_cast<const XrSwapchainCreateInfoFoveationFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainCreateInfoFoveationFB&() {
    return *reinterpret_cast<XrSwapchainCreateInfoFoveationFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainCreateInfoFoveationFB
  XrSwapchainCreateInfoFoveationFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainCreateInfoFoveationFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainCreateInfoFoveationFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainCreateInfoFoveationFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainCreateInfoFoveationFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainCreateInfoFoveationFB*>(this);
  }
  SwapchainCreateFoveationFlagsFB flags;
};
static_assert(sizeof(XrSwapchainCreateInfoFoveationFB) == sizeof(SwapchainCreateInfoFoveationFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainCreateInfoFoveationFB pointer to const from a
 * SwapchainCreateInfoFoveationFB reference to const.
 * @relates SwapchainCreateInfoFoveationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainCreateInfoFoveationFB const* get(
    SwapchainCreateInfoFoveationFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SwapchainCreateInfoFoveationFB as the address of a raw XrSwapchainCreateInfoFoveationFB
 * @relates SwapchainCreateInfoFoveationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainCreateInfoFoveationFB* put(SwapchainCreateInfoFoveationFB& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_foveation

#ifdef XR_FB_foveation
/*!
 * C++ projection of XrSwapchainStateFoveationFB
 *
 * Provided by the `XR_FB_foveation` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateFoveationFB>
 * @xrentity{XrSwapchainStateFoveationFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainStateFoveationFB : public SwapchainStateBaseHeaderFB {
private:
  using Parent = SwapchainStateBaseHeaderFB;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainStateFoveationFB(void* next_ = nullptr)

      : Parent(StructureType::SwapchainStateFoveationFB, next_) {}

  //! Default copy constructor
  SwapchainStateFoveationFB(const SwapchainStateFoveationFB& rhs) = default;
  //! Default copy assignment
  SwapchainStateFoveationFB& operator=(const SwapchainStateFoveationFB& rhs) = default;
  //! Copy construct from raw
  SwapchainStateFoveationFB(const XrSwapchainStateFoveationFB& rhs) : SwapchainStateFoveationFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainStateFoveationFB& operator=(const XrSwapchainStateFoveationFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainStateFoveationFB&() const {
    return *reinterpret_cast<const XrSwapchainStateFoveationFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainStateFoveationFB&() {
    return *reinterpret_cast<XrSwapchainStateFoveationFB*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainStateBaseHeaderFB const pointer
  XrSwapchainStateBaseHeaderFB const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainStateFoveationFB
  XrSwapchainStateFoveationFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainStateFoveationFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainStateFoveationFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainStateFoveationFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainStateFoveationFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainStateFoveationFB*>(this);
  }
  SwapchainStateFoveationFlagsFB flags;
  FoveationProfileFB profile;
};
static_assert(sizeof(XrSwapchainStateFoveationFB) == sizeof(SwapchainStateFoveationFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainStateFoveationFB pointer to const from a
 * SwapchainStateFoveationFB reference to const.
 * @relates SwapchainStateFoveationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateFoveationFB const* get(
    SwapchainStateFoveationFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainStateFoveationFB as
 * the address of a raw XrSwapchainStateFoveationFB
 * @relates SwapchainStateFoveationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateFoveationFB* put(SwapchainStateFoveationFB& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainStateFoveationFB as a raw,
 * pointer to const XrSwapchainStateBaseHeaderFB (the base type)
 * @relates SwapchainStateFoveationFB
 * @relatesalso SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get_base(
    SwapchainStateFoveationFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_foveation

#ifdef XR_FB_foveation_configuration
/*!
 * C++ projection of XrFoveationLevelProfileCreateInfoFB
 *
 * Provided by the `XR_FB_foveation_configuration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationLevelProfileCreateInfoFB>
 * @xrentity{XrFoveationLevelProfileCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FoveationLevelProfileCreateInfoFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FoveationLevelProfileCreateInfoFB(void* next_ = nullptr)

      : Parent(StructureType::FoveationLevelProfileCreateInfoFB, next_) {}

  //! Default copy constructor
  FoveationLevelProfileCreateInfoFB(const FoveationLevelProfileCreateInfoFB& rhs) = default;
  //! Default copy assignment
  FoveationLevelProfileCreateInfoFB& operator=(const FoveationLevelProfileCreateInfoFB& rhs) =
      default;
  //! Copy construct from raw
  FoveationLevelProfileCreateInfoFB(const XrFoveationLevelProfileCreateInfoFB& rhs)
      : FoveationLevelProfileCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FoveationLevelProfileCreateInfoFB& operator=(const XrFoveationLevelProfileCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFoveationLevelProfileCreateInfoFB&() const {
    return *reinterpret_cast<const XrFoveationLevelProfileCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFoveationLevelProfileCreateInfoFB&() {
    return *reinterpret_cast<XrFoveationLevelProfileCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrFoveationLevelProfileCreateInfoFB
  XrFoveationLevelProfileCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrFoveationLevelProfileCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFoveationLevelProfileCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFoveationLevelProfileCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FoveationLevelProfileCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrFoveationLevelProfileCreateInfoFB*>(this);
  }
  FoveationLevelFB level;
  float verticalOffset;
  FoveationDynamicFB dynamic;
};
static_assert(sizeof(XrFoveationLevelProfileCreateInfoFB) ==
                  sizeof(FoveationLevelProfileCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFoveationLevelProfileCreateInfoFB pointer to const from
 * a FoveationLevelProfileCreateInfoFB reference to const.
 * @relates FoveationLevelProfileCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationLevelProfileCreateInfoFB const* get(
    FoveationLevelProfileCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * FoveationLevelProfileCreateInfoFB as the address of a raw XrFoveationLevelProfileCreateInfoFB
 * @relates FoveationLevelProfileCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationLevelProfileCreateInfoFB* put(
    FoveationLevelProfileCreateInfoFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_foveation_configuration

#ifdef XR_FB_keyboard_tracking
/*!
 * C++ projection of XrSystemKeyboardTrackingPropertiesFB
 *
 * Provided by the `XR_FB_keyboard_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemKeyboardTrackingPropertiesFB>
 * @xrentity{XrSystemKeyboardTrackingPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemKeyboardTrackingPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemKeyboardTrackingPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemKeyboardTrackingPropertiesFB, next_) {}

  //! Default copy constructor
  SystemKeyboardTrackingPropertiesFB(const SystemKeyboardTrackingPropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemKeyboardTrackingPropertiesFB& operator=(const SystemKeyboardTrackingPropertiesFB& rhs) =
      default;
  //! Copy construct from raw
  SystemKeyboardTrackingPropertiesFB(const XrSystemKeyboardTrackingPropertiesFB& rhs)
      : SystemKeyboardTrackingPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemKeyboardTrackingPropertiesFB& operator=(const XrSystemKeyboardTrackingPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemKeyboardTrackingPropertiesFB&() const {
    return *reinterpret_cast<const XrSystemKeyboardTrackingPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemKeyboardTrackingPropertiesFB&() {
    return *reinterpret_cast<XrSystemKeyboardTrackingPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemKeyboardTrackingPropertiesFB
  XrSystemKeyboardTrackingPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemKeyboardTrackingPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemKeyboardTrackingPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemKeyboardTrackingPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemKeyboardTrackingPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemKeyboardTrackingPropertiesFB*>(this);
  }
  Bool32 supportsKeyboardTracking;
};
static_assert(sizeof(XrSystemKeyboardTrackingPropertiesFB) ==
                  sizeof(SystemKeyboardTrackingPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemKeyboardTrackingPropertiesFB pointer to const from
 * a SystemKeyboardTrackingPropertiesFB reference to const.
 * @relates SystemKeyboardTrackingPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemKeyboardTrackingPropertiesFB const* get(
    SystemKeyboardTrackingPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemKeyboardTrackingPropertiesFB as the address of a raw XrSystemKeyboardTrackingPropertiesFB
 * @relates SystemKeyboardTrackingPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemKeyboardTrackingPropertiesFB* put(
    SystemKeyboardTrackingPropertiesFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_keyboard_tracking
/*!
 * C++ projection of XrKeyboardTrackingDescriptionFB
 *
 * Provided by the `XR_FB_keyboard_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrKeyboardTrackingDescriptionFB>
 * @xrentity{XrKeyboardTrackingDescriptionFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS KeyboardTrackingDescriptionFB {
public:
  //! Empty constructor for a type that is marked as "returnonly"
  KeyboardTrackingDescriptionFB()

  {}

  //! Default copy constructor
  KeyboardTrackingDescriptionFB(const KeyboardTrackingDescriptionFB& rhs) = default;
  //! Default copy assignment
  KeyboardTrackingDescriptionFB& operator=(const KeyboardTrackingDescriptionFB& rhs) = default;
  //! Copy construct from raw
  KeyboardTrackingDescriptionFB(const XrKeyboardTrackingDescriptionFB& rhs)
      : KeyboardTrackingDescriptionFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  KeyboardTrackingDescriptionFB& operator=(const XrKeyboardTrackingDescriptionFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrKeyboardTrackingDescriptionFB&() const {
    return *reinterpret_cast<const XrKeyboardTrackingDescriptionFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrKeyboardTrackingDescriptionFB&() {
    return *reinterpret_cast<XrKeyboardTrackingDescriptionFB*>(this);
  }

  //! Accessor for this as the address of a raw XrKeyboardTrackingDescriptionFB
  XrKeyboardTrackingDescriptionFB const* get() const noexcept {
    return reinterpret_cast<XrKeyboardTrackingDescriptionFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrKeyboardTrackingDescriptionFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrKeyboardTrackingDescriptionFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = KeyboardTrackingDescriptionFB{};
    }
    return reinterpret_cast<XrKeyboardTrackingDescriptionFB*>(this);
  }
  uint64_t trackedKeyboardId;
  Vector3f size;
  KeyboardTrackingFlagsFB flags;
  char name[XR_MAX_KEYBOARD_TRACKING_NAME_SIZE_FB];
};
static_assert(sizeof(XrKeyboardTrackingDescriptionFB) == sizeof(KeyboardTrackingDescriptionFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrKeyboardTrackingDescriptionFB pointer to const from a
 * KeyboardTrackingDescriptionFB reference to const.
 * @relates KeyboardTrackingDescriptionFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrKeyboardTrackingDescriptionFB const* get(
    KeyboardTrackingDescriptionFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing KeyboardTrackingDescriptionFB
 * as the address of a raw XrKeyboardTrackingDescriptionFB
 * @relates KeyboardTrackingDescriptionFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrKeyboardTrackingDescriptionFB* put(KeyboardTrackingDescriptionFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_keyboard_tracking
/*!
 * C++ projection of XrKeyboardSpaceCreateInfoFB
 *
 * Provided by the `XR_FB_keyboard_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrKeyboardSpaceCreateInfoFB>
 * @xrentity{XrKeyboardSpaceCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS KeyboardSpaceCreateInfoFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  KeyboardSpaceCreateInfoFB(void* next_ = nullptr)

      : Parent(StructureType::KeyboardSpaceCreateInfoFB, next_) {}

  //! Default copy constructor
  KeyboardSpaceCreateInfoFB(const KeyboardSpaceCreateInfoFB& rhs) = default;
  //! Default copy assignment
  KeyboardSpaceCreateInfoFB& operator=(const KeyboardSpaceCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  KeyboardSpaceCreateInfoFB(const XrKeyboardSpaceCreateInfoFB& rhs) : KeyboardSpaceCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  KeyboardSpaceCreateInfoFB& operator=(const XrKeyboardSpaceCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrKeyboardSpaceCreateInfoFB&() const {
    return *reinterpret_cast<const XrKeyboardSpaceCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrKeyboardSpaceCreateInfoFB&() {
    return *reinterpret_cast<XrKeyboardSpaceCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrKeyboardSpaceCreateInfoFB
  XrKeyboardSpaceCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrKeyboardSpaceCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrKeyboardSpaceCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrKeyboardSpaceCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = KeyboardSpaceCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrKeyboardSpaceCreateInfoFB*>(this);
  }
  uint64_t trackedKeyboardId;
};
static_assert(sizeof(XrKeyboardSpaceCreateInfoFB) == sizeof(KeyboardSpaceCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrKeyboardSpaceCreateInfoFB pointer to const from a
 * KeyboardSpaceCreateInfoFB reference to const.
 * @relates KeyboardSpaceCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrKeyboardSpaceCreateInfoFB const* get(
    KeyboardSpaceCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing KeyboardSpaceCreateInfoFB as
 * the address of a raw XrKeyboardSpaceCreateInfoFB
 * @relates KeyboardSpaceCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrKeyboardSpaceCreateInfoFB* put(KeyboardSpaceCreateInfoFB& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_keyboard_tracking
/*!
 * C++ projection of XrKeyboardTrackingQueryFB
 *
 * Provided by the `XR_FB_keyboard_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrKeyboardTrackingQueryFB>
 * @xrentity{XrKeyboardTrackingQueryFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS KeyboardTrackingQueryFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  KeyboardTrackingQueryFB(void* next_ = nullptr)

      : Parent(StructureType::KeyboardTrackingQueryFB, next_) {}

  //! Default copy constructor
  KeyboardTrackingQueryFB(const KeyboardTrackingQueryFB& rhs) = default;
  //! Default copy assignment
  KeyboardTrackingQueryFB& operator=(const KeyboardTrackingQueryFB& rhs) = default;
  //! Copy construct from raw
  KeyboardTrackingQueryFB(const XrKeyboardTrackingQueryFB& rhs) : KeyboardTrackingQueryFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  KeyboardTrackingQueryFB& operator=(const XrKeyboardTrackingQueryFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrKeyboardTrackingQueryFB&() const {
    return *reinterpret_cast<const XrKeyboardTrackingQueryFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrKeyboardTrackingQueryFB&() {
    return *reinterpret_cast<XrKeyboardTrackingQueryFB*>(this);
  }

  //! Accessor for this as the address of a raw XrKeyboardTrackingQueryFB
  XrKeyboardTrackingQueryFB const* get() const noexcept {
    return reinterpret_cast<XrKeyboardTrackingQueryFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrKeyboardTrackingQueryFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrKeyboardTrackingQueryFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = KeyboardTrackingQueryFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrKeyboardTrackingQueryFB*>(this);
  }
  KeyboardTrackingQueryFlagsFB flags;
};
static_assert(sizeof(XrKeyboardTrackingQueryFB) == sizeof(KeyboardTrackingQueryFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrKeyboardTrackingQueryFB pointer to const from a
 * KeyboardTrackingQueryFB reference to const.
 * @relates KeyboardTrackingQueryFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrKeyboardTrackingQueryFB const* get(KeyboardTrackingQueryFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing KeyboardTrackingQueryFB as
 * the address of a raw XrKeyboardTrackingQueryFB
 * @relates KeyboardTrackingQueryFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrKeyboardTrackingQueryFB* put(KeyboardTrackingQueryFB& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_triangle_mesh
/*!
 * C++ projection of XrTriangleMeshCreateInfoFB
 *
 * Provided by the `XR_FB_triangle_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrTriangleMeshCreateInfoFB>
 * @xrentity{XrTriangleMeshCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS TriangleMeshCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  TriangleMeshCreateInfoFB(const TriangleMeshFlagsFB& flags_, const WindingOrderFB& windingOrder_,
                           uint32_t vertexCount_, const Vector3f* vertexBuffer_,
                           uint32_t triangleCount_, const uint32_t* indexBuffer_,
                           const void* next_ = nullptr)
      : Parent(StructureType::TriangleMeshCreateInfoFB, next_),
        flags{flags_},
        windingOrder{windingOrder_},
        vertexCount{vertexCount_},
        vertexBuffer{vertexBuffer_},
        triangleCount{triangleCount_},
        indexBuffer{indexBuffer_} {}

  //! Default/empty constructor
  TriangleMeshCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::TriangleMeshCreateInfoFB, next_),
        flags{},
        windingOrder{},
        vertexCount{0},
        vertexBuffer{nullptr},
        triangleCount{0},
        indexBuffer{nullptr} {}

  //! Default copy constructor
  TriangleMeshCreateInfoFB(const TriangleMeshCreateInfoFB& rhs) = default;
  //! Default copy assignment
  TriangleMeshCreateInfoFB& operator=(const TriangleMeshCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  TriangleMeshCreateInfoFB(const XrTriangleMeshCreateInfoFB& rhs) : TriangleMeshCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  TriangleMeshCreateInfoFB& operator=(const XrTriangleMeshCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrTriangleMeshCreateInfoFB&() const {
    return *reinterpret_cast<const XrTriangleMeshCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrTriangleMeshCreateInfoFB&() {
    return *reinterpret_cast<XrTriangleMeshCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrTriangleMeshCreateInfoFB
  XrTriangleMeshCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrTriangleMeshCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrTriangleMeshCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrTriangleMeshCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = TriangleMeshCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrTriangleMeshCreateInfoFB*>(this);
  }
  TriangleMeshFlagsFB flags;
  WindingOrderFB windingOrder;
  uint32_t vertexCount;
  const Vector3f* vertexBuffer;
  uint32_t triangleCount;
  const uint32_t* indexBuffer;
};
static_assert(sizeof(XrTriangleMeshCreateInfoFB) == sizeof(TriangleMeshCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrTriangleMeshCreateInfoFB pointer to const from a
 * TriangleMeshCreateInfoFB reference to const.
 * @relates TriangleMeshCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrTriangleMeshCreateInfoFB const* get(TriangleMeshCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing TriangleMeshCreateInfoFB as
 * the address of a raw XrTriangleMeshCreateInfoFB
 * @relates TriangleMeshCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrTriangleMeshCreateInfoFB* put(TriangleMeshCreateInfoFB& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrSystemPassthroughPropertiesFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemPassthroughPropertiesFB>
 * @xrentity{XrSystemPassthroughPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemPassthroughPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemPassthroughPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemPassthroughPropertiesFB, next_) {}

  //! Default copy constructor
  SystemPassthroughPropertiesFB(const SystemPassthroughPropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemPassthroughPropertiesFB& operator=(const SystemPassthroughPropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemPassthroughPropertiesFB(const XrSystemPassthroughPropertiesFB& rhs)
      : SystemPassthroughPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemPassthroughPropertiesFB& operator=(const XrSystemPassthroughPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemPassthroughPropertiesFB&() const {
    return *reinterpret_cast<const XrSystemPassthroughPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemPassthroughPropertiesFB&() {
    return *reinterpret_cast<XrSystemPassthroughPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemPassthroughPropertiesFB
  XrSystemPassthroughPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemPassthroughPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemPassthroughPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemPassthroughPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemPassthroughPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemPassthroughPropertiesFB*>(this);
  }
  Bool32 supportsPassthrough;
};
static_assert(sizeof(XrSystemPassthroughPropertiesFB) == sizeof(SystemPassthroughPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemPassthroughPropertiesFB pointer to const from a
 * SystemPassthroughPropertiesFB reference to const.
 * @relates SystemPassthroughPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemPassthroughPropertiesFB const* get(
    SystemPassthroughPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemPassthroughPropertiesFB
 * as the address of a raw XrSystemPassthroughPropertiesFB
 * @relates SystemPassthroughPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemPassthroughPropertiesFB* put(SystemPassthroughPropertiesFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrSystemPassthroughProperties2FB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemPassthroughProperties2FB>
 * @xrentity{XrSystemPassthroughProperties2FB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemPassthroughProperties2FB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemPassthroughProperties2FB(void* next_ = nullptr)

      : Parent(StructureType::SystemPassthroughProperties2FB, next_) {}

  //! Default copy constructor
  SystemPassthroughProperties2FB(const SystemPassthroughProperties2FB& rhs) = default;
  //! Default copy assignment
  SystemPassthroughProperties2FB& operator=(const SystemPassthroughProperties2FB& rhs) = default;
  //! Copy construct from raw
  SystemPassthroughProperties2FB(const XrSystemPassthroughProperties2FB& rhs)
      : SystemPassthroughProperties2FB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemPassthroughProperties2FB& operator=(const XrSystemPassthroughProperties2FB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemPassthroughProperties2FB&() const {
    return *reinterpret_cast<const XrSystemPassthroughProperties2FB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemPassthroughProperties2FB&() {
    return *reinterpret_cast<XrSystemPassthroughProperties2FB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemPassthroughProperties2FB
  XrSystemPassthroughProperties2FB const* get() const noexcept {
    return reinterpret_cast<XrSystemPassthroughProperties2FB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemPassthroughProperties2FB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemPassthroughProperties2FB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemPassthroughProperties2FB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemPassthroughProperties2FB*>(this);
  }
  PassthroughCapabilityFlagsFB capabilities;
};
static_assert(sizeof(XrSystemPassthroughProperties2FB) == sizeof(SystemPassthroughProperties2FB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemPassthroughProperties2FB pointer to const from a
 * SystemPassthroughProperties2FB reference to const.
 * @relates SystemPassthroughProperties2FB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemPassthroughProperties2FB const* get(
    SystemPassthroughProperties2FB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemPassthroughProperties2FB as the address of a raw XrSystemPassthroughProperties2FB
 * @relates SystemPassthroughProperties2FB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemPassthroughProperties2FB* put(SystemPassthroughProperties2FB& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughCreateInfoFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughCreateInfoFB>
 * @xrentity{XrPassthroughCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughCreateInfoFB(const PassthroughFlagsFB& flags_, const void* next_ = nullptr)
      : Parent(StructureType::PassthroughCreateInfoFB, next_), flags{flags_} {}

  //! Default/empty constructor
  PassthroughCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughCreateInfoFB, next_), flags{} {}

  //! Default copy constructor
  PassthroughCreateInfoFB(const PassthroughCreateInfoFB& rhs) = default;
  //! Default copy assignment
  PassthroughCreateInfoFB& operator=(const PassthroughCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  PassthroughCreateInfoFB(const XrPassthroughCreateInfoFB& rhs) : PassthroughCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughCreateInfoFB& operator=(const XrPassthroughCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughCreateInfoFB&() const {
    return *reinterpret_cast<const XrPassthroughCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughCreateInfoFB&() {
    return *reinterpret_cast<XrPassthroughCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughCreateInfoFB
  XrPassthroughCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrPassthroughCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughCreateInfoFB*>(this);
  }
  PassthroughFlagsFB flags;
};
static_assert(sizeof(XrPassthroughCreateInfoFB) == sizeof(PassthroughCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughCreateInfoFB pointer to const from a
 * PassthroughCreateInfoFB reference to const.
 * @relates PassthroughCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughCreateInfoFB const* get(PassthroughCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughCreateInfoFB as
 * the address of a raw XrPassthroughCreateInfoFB
 * @relates PassthroughCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughCreateInfoFB* put(PassthroughCreateInfoFB& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughLayerCreateInfoFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughLayerCreateInfoFB>
 * @xrentity{XrPassthroughLayerCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughLayerCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughLayerCreateInfoFB(const PassthroughFB& passthrough_, const PassthroughFlagsFB& flags_,
                               const PassthroughLayerPurposeFB& purpose_,
                               const void* next_ = nullptr)
      : Parent(StructureType::PassthroughLayerCreateInfoFB, next_),
        passthrough{passthrough_},
        flags{flags_},
        purpose{purpose_} {}

  //! Default/empty constructor
  PassthroughLayerCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughLayerCreateInfoFB, next_),
        passthrough{},
        flags{},
        purpose{} {}

  //! Default copy constructor
  PassthroughLayerCreateInfoFB(const PassthroughLayerCreateInfoFB& rhs) = default;
  //! Default copy assignment
  PassthroughLayerCreateInfoFB& operator=(const PassthroughLayerCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  PassthroughLayerCreateInfoFB(const XrPassthroughLayerCreateInfoFB& rhs)
      : PassthroughLayerCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughLayerCreateInfoFB& operator=(const XrPassthroughLayerCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughLayerCreateInfoFB&() const {
    return *reinterpret_cast<const XrPassthroughLayerCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughLayerCreateInfoFB&() {
    return *reinterpret_cast<XrPassthroughLayerCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughLayerCreateInfoFB
  XrPassthroughLayerCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrPassthroughLayerCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughLayerCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughLayerCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughLayerCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughLayerCreateInfoFB*>(this);
  }
  PassthroughFB passthrough;
  PassthroughFlagsFB flags;
  PassthroughLayerPurposeFB purpose;
};
static_assert(sizeof(XrPassthroughLayerCreateInfoFB) == sizeof(PassthroughLayerCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughLayerCreateInfoFB pointer to const from a
 * PassthroughLayerCreateInfoFB reference to const.
 * @relates PassthroughLayerCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughLayerCreateInfoFB const* get(
    PassthroughLayerCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughLayerCreateInfoFB
 * as the address of a raw XrPassthroughLayerCreateInfoFB
 * @relates PassthroughLayerCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughLayerCreateInfoFB* put(PassthroughLayerCreateInfoFB& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrCompositionLayerPassthroughFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerPassthroughFB>
 * @xrentity{XrCompositionLayerPassthroughFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerPassthroughFB : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerPassthroughFB(const CompositionLayerFlags& flags_, const Space& space_,
                                const PassthroughLayerFB& layerHandle_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerPassthroughFB, flags_, space_, next_),
        layerHandle{layerHandle_} {}

  //! Default/empty constructor
  CompositionLayerPassthroughFB(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerPassthroughFB, {}, {}, next_), layerHandle{} {}

  //! Default copy constructor
  CompositionLayerPassthroughFB(const CompositionLayerPassthroughFB& rhs) = default;
  //! Default copy assignment
  CompositionLayerPassthroughFB& operator=(const CompositionLayerPassthroughFB& rhs) = default;
  //! Copy construct from raw
  CompositionLayerPassthroughFB(const XrCompositionLayerPassthroughFB& rhs)
      : CompositionLayerPassthroughFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerPassthroughFB& operator=(const XrCompositionLayerPassthroughFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerPassthroughFB&() const {
    return *reinterpret_cast<const XrCompositionLayerPassthroughFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerPassthroughFB&() {
    return *reinterpret_cast<XrCompositionLayerPassthroughFB*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerPassthroughFB
  XrCompositionLayerPassthroughFB const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerPassthroughFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerPassthroughFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerPassthroughFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerPassthroughFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerPassthroughFB*>(this);
  }
  PassthroughLayerFB layerHandle;
};
static_assert(sizeof(XrCompositionLayerPassthroughFB) == sizeof(CompositionLayerPassthroughFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerPassthroughFB pointer to const from a
 * CompositionLayerPassthroughFB reference to const.
 * @relates CompositionLayerPassthroughFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerPassthroughFB const* get(
    CompositionLayerPassthroughFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerPassthroughFB
 * as the address of a raw XrCompositionLayerPassthroughFB
 * @relates CompositionLayerPassthroughFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerPassthroughFB* put(CompositionLayerPassthroughFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerPassthroughFB as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerPassthroughFB
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerPassthroughFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrGeometryInstanceCreateInfoFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGeometryInstanceCreateInfoFB>
 * @xrentity{XrGeometryInstanceCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GeometryInstanceCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GeometryInstanceCreateInfoFB(const PassthroughLayerFB& layer_, const TriangleMeshFB& mesh_,
                               const Space& baseSpace_, const Posef& pose_, const Vector3f& scale_,
                               const void* next_ = nullptr)
      : Parent(StructureType::GeometryInstanceCreateInfoFB, next_),
        layer{layer_},
        mesh{mesh_},
        baseSpace{baseSpace_},
        pose{pose_},
        scale{scale_} {}

  //! Default/empty constructor
  GeometryInstanceCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::GeometryInstanceCreateInfoFB, next_),
        layer{},
        mesh{},
        baseSpace{},
        pose{},
        scale{} {}

  //! Default copy constructor
  GeometryInstanceCreateInfoFB(const GeometryInstanceCreateInfoFB& rhs) = default;
  //! Default copy assignment
  GeometryInstanceCreateInfoFB& operator=(const GeometryInstanceCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  GeometryInstanceCreateInfoFB(const XrGeometryInstanceCreateInfoFB& rhs)
      : GeometryInstanceCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GeometryInstanceCreateInfoFB& operator=(const XrGeometryInstanceCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGeometryInstanceCreateInfoFB&() const {
    return *reinterpret_cast<const XrGeometryInstanceCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGeometryInstanceCreateInfoFB&() {
    return *reinterpret_cast<XrGeometryInstanceCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrGeometryInstanceCreateInfoFB
  XrGeometryInstanceCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrGeometryInstanceCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGeometryInstanceCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGeometryInstanceCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GeometryInstanceCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrGeometryInstanceCreateInfoFB*>(this);
  }
  PassthroughLayerFB layer;
  TriangleMeshFB mesh;
  Space baseSpace;
  Posef pose;
  Vector3f scale;
};
static_assert(sizeof(XrGeometryInstanceCreateInfoFB) == sizeof(GeometryInstanceCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGeometryInstanceCreateInfoFB pointer to const from a
 * GeometryInstanceCreateInfoFB reference to const.
 * @relates GeometryInstanceCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGeometryInstanceCreateInfoFB const* get(
    GeometryInstanceCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GeometryInstanceCreateInfoFB
 * as the address of a raw XrGeometryInstanceCreateInfoFB
 * @relates GeometryInstanceCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGeometryInstanceCreateInfoFB* put(GeometryInstanceCreateInfoFB& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrGeometryInstanceTransformFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGeometryInstanceTransformFB>
 * @xrentity{XrGeometryInstanceTransformFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GeometryInstanceTransformFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GeometryInstanceTransformFB(const Space& baseSpace_, const Time& time_, const Posef& pose_,
                              const Vector3f& scale_, const void* next_ = nullptr)
      : Parent(StructureType::GeometryInstanceTransformFB, next_),
        baseSpace{baseSpace_},
        time{time_},
        pose{pose_},
        scale{scale_} {}

  //! Default/empty constructor
  GeometryInstanceTransformFB(const void* next_ = nullptr)

      : Parent(StructureType::GeometryInstanceTransformFB, next_),
        baseSpace{},
        time{},
        pose{},
        scale{} {}

  //! Default copy constructor
  GeometryInstanceTransformFB(const GeometryInstanceTransformFB& rhs) = default;
  //! Default copy assignment
  GeometryInstanceTransformFB& operator=(const GeometryInstanceTransformFB& rhs) = default;
  //! Copy construct from raw
  GeometryInstanceTransformFB(const XrGeometryInstanceTransformFB& rhs)
      : GeometryInstanceTransformFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GeometryInstanceTransformFB& operator=(const XrGeometryInstanceTransformFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGeometryInstanceTransformFB&() const {
    return *reinterpret_cast<const XrGeometryInstanceTransformFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGeometryInstanceTransformFB&() {
    return *reinterpret_cast<XrGeometryInstanceTransformFB*>(this);
  }

  //! Accessor for this as the address of a raw XrGeometryInstanceTransformFB
  XrGeometryInstanceTransformFB const* get() const noexcept {
    return reinterpret_cast<XrGeometryInstanceTransformFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGeometryInstanceTransformFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGeometryInstanceTransformFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GeometryInstanceTransformFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrGeometryInstanceTransformFB*>(this);
  }
  Space baseSpace;
  Time time;
  Posef pose;
  Vector3f scale;
};
static_assert(sizeof(XrGeometryInstanceTransformFB) == sizeof(GeometryInstanceTransformFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGeometryInstanceTransformFB pointer to const from a
 * GeometryInstanceTransformFB reference to const.
 * @relates GeometryInstanceTransformFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGeometryInstanceTransformFB const* get(
    GeometryInstanceTransformFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GeometryInstanceTransformFB
 * as the address of a raw XrGeometryInstanceTransformFB
 * @relates GeometryInstanceTransformFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGeometryInstanceTransformFB* put(GeometryInstanceTransformFB& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughStyleFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughStyleFB>
 * @xrentity{XrPassthroughStyleFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughStyleFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughStyleFB(float textureOpacityFactor_, const Color4f& edgeColor_,
                     const void* next_ = nullptr)
      : Parent(StructureType::PassthroughStyleFB, next_),
        textureOpacityFactor{textureOpacityFactor_},
        edgeColor{edgeColor_} {}

  //! Default/empty constructor
  PassthroughStyleFB(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughStyleFB, next_), textureOpacityFactor{0.0f}, edgeColor{} {}

  //! Default copy constructor
  PassthroughStyleFB(const PassthroughStyleFB& rhs) = default;
  //! Default copy assignment
  PassthroughStyleFB& operator=(const PassthroughStyleFB& rhs) = default;
  //! Copy construct from raw
  PassthroughStyleFB(const XrPassthroughStyleFB& rhs) : PassthroughStyleFB() { *put() = rhs; }
  //! Copy assign from raw
  PassthroughStyleFB& operator=(const XrPassthroughStyleFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughStyleFB&() const {
    return *reinterpret_cast<const XrPassthroughStyleFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughStyleFB&() { return *reinterpret_cast<XrPassthroughStyleFB*>(this); }

  //! Accessor for this as the address of a raw XrPassthroughStyleFB
  XrPassthroughStyleFB const* get() const noexcept {
    return reinterpret_cast<XrPassthroughStyleFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughStyleFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughStyleFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughStyleFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughStyleFB*>(this);
  }
  float textureOpacityFactor;
  Color4f edgeColor;
};
static_assert(sizeof(XrPassthroughStyleFB) == sizeof(PassthroughStyleFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughStyleFB pointer to const from a
 * PassthroughStyleFB reference to const.
 * @relates PassthroughStyleFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughStyleFB const* get(PassthroughStyleFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughStyleFB as the
 * address of a raw XrPassthroughStyleFB
 * @relates PassthroughStyleFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughStyleFB* put(PassthroughStyleFB& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughColorMapMonoToRgbaFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorMapMonoToRgbaFB>
 * @xrentity{XrPassthroughColorMapMonoToRgbaFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughColorMapMonoToRgbaFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughColorMapMonoToRgbaFB(Color4f textureColorMap_[XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB],
                                  const void* next_ = nullptr)
      : Parent(StructureType::PassthroughColorMapMonoToRgbaFB, next_) {
    memcpy(textureColorMap, textureColorMap_, sizeof(textureColorMap));
  }

  //! Default/empty constructor
  PassthroughColorMapMonoToRgbaFB(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughColorMapMonoToRgbaFB, next_), textureColorMap{} {}

  //! Default copy constructor
  PassthroughColorMapMonoToRgbaFB(const PassthroughColorMapMonoToRgbaFB& rhs) = default;
  //! Default copy assignment
  PassthroughColorMapMonoToRgbaFB& operator=(const PassthroughColorMapMonoToRgbaFB& rhs) = default;
  //! Copy construct from raw
  PassthroughColorMapMonoToRgbaFB(const XrPassthroughColorMapMonoToRgbaFB& rhs)
      : PassthroughColorMapMonoToRgbaFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughColorMapMonoToRgbaFB& operator=(const XrPassthroughColorMapMonoToRgbaFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughColorMapMonoToRgbaFB&() const {
    return *reinterpret_cast<const XrPassthroughColorMapMonoToRgbaFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughColorMapMonoToRgbaFB&() {
    return *reinterpret_cast<XrPassthroughColorMapMonoToRgbaFB*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughColorMapMonoToRgbaFB
  XrPassthroughColorMapMonoToRgbaFB const* get() const noexcept {
    return reinterpret_cast<XrPassthroughColorMapMonoToRgbaFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughColorMapMonoToRgbaFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughColorMapMonoToRgbaFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughColorMapMonoToRgbaFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughColorMapMonoToRgbaFB*>(this);
  }
  Color4f textureColorMap[XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB];
};
static_assert(sizeof(XrPassthroughColorMapMonoToRgbaFB) == sizeof(PassthroughColorMapMonoToRgbaFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughColorMapMonoToRgbaFB pointer to const from a
 * PassthroughColorMapMonoToRgbaFB reference to const.
 * @relates PassthroughColorMapMonoToRgbaFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorMapMonoToRgbaFB const* get(
    PassthroughColorMapMonoToRgbaFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * PassthroughColorMapMonoToRgbaFB as the address of a raw XrPassthroughColorMapMonoToRgbaFB
 * @relates PassthroughColorMapMonoToRgbaFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorMapMonoToRgbaFB* put(PassthroughColorMapMonoToRgbaFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughColorMapMonoToMonoFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorMapMonoToMonoFB>
 * @xrentity{XrPassthroughColorMapMonoToMonoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughColorMapMonoToMonoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughColorMapMonoToMonoFB(uint8_t textureColorMap_[XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB],
                                  const void* next_ = nullptr)
      : Parent(StructureType::PassthroughColorMapMonoToMonoFB, next_) {
    memcpy(textureColorMap, textureColorMap_, sizeof(textureColorMap));
  }

  //! Default/empty constructor
  PassthroughColorMapMonoToMonoFB(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughColorMapMonoToMonoFB, next_), textureColorMap{0} {}

  //! Default copy constructor
  PassthroughColorMapMonoToMonoFB(const PassthroughColorMapMonoToMonoFB& rhs) = default;
  //! Default copy assignment
  PassthroughColorMapMonoToMonoFB& operator=(const PassthroughColorMapMonoToMonoFB& rhs) = default;
  //! Copy construct from raw
  PassthroughColorMapMonoToMonoFB(const XrPassthroughColorMapMonoToMonoFB& rhs)
      : PassthroughColorMapMonoToMonoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughColorMapMonoToMonoFB& operator=(const XrPassthroughColorMapMonoToMonoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughColorMapMonoToMonoFB&() const {
    return *reinterpret_cast<const XrPassthroughColorMapMonoToMonoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughColorMapMonoToMonoFB&() {
    return *reinterpret_cast<XrPassthroughColorMapMonoToMonoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughColorMapMonoToMonoFB
  XrPassthroughColorMapMonoToMonoFB const* get() const noexcept {
    return reinterpret_cast<XrPassthroughColorMapMonoToMonoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughColorMapMonoToMonoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughColorMapMonoToMonoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughColorMapMonoToMonoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughColorMapMonoToMonoFB*>(this);
  }
  uint8_t textureColorMap[XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB];
};
static_assert(sizeof(XrPassthroughColorMapMonoToMonoFB) == sizeof(PassthroughColorMapMonoToMonoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughColorMapMonoToMonoFB pointer to const from a
 * PassthroughColorMapMonoToMonoFB reference to const.
 * @relates PassthroughColorMapMonoToMonoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorMapMonoToMonoFB const* get(
    PassthroughColorMapMonoToMonoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * PassthroughColorMapMonoToMonoFB as the address of a raw XrPassthroughColorMapMonoToMonoFB
 * @relates PassthroughColorMapMonoToMonoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorMapMonoToMonoFB* put(PassthroughColorMapMonoToMonoFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrPassthroughBrightnessContrastSaturationFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughBrightnessContrastSaturationFB>
 * @xrentity{XrPassthroughBrightnessContrastSaturationFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughBrightnessContrastSaturationFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughBrightnessContrastSaturationFB(float brightness_, float contrast_, float saturation_,
                                            const void* next_ = nullptr)
      : Parent(StructureType::PassthroughBrightnessContrastSaturationFB, next_),
        brightness{brightness_},
        contrast{contrast_},
        saturation{saturation_} {}

  //! Default/empty constructor
  PassthroughBrightnessContrastSaturationFB(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughBrightnessContrastSaturationFB, next_),
        brightness{0.0f},
        contrast{0.0f},
        saturation{0.0f} {}

  //! Default copy constructor
  PassthroughBrightnessContrastSaturationFB(const PassthroughBrightnessContrastSaturationFB& rhs) =
      default;
  //! Default copy assignment
  PassthroughBrightnessContrastSaturationFB& operator=(
      const PassthroughBrightnessContrastSaturationFB& rhs) = default;
  //! Copy construct from raw
  PassthroughBrightnessContrastSaturationFB(const XrPassthroughBrightnessContrastSaturationFB& rhs)
      : PassthroughBrightnessContrastSaturationFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughBrightnessContrastSaturationFB& operator=(
      const XrPassthroughBrightnessContrastSaturationFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughBrightnessContrastSaturationFB&() const {
    return *reinterpret_cast<const XrPassthroughBrightnessContrastSaturationFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughBrightnessContrastSaturationFB&() {
    return *reinterpret_cast<XrPassthroughBrightnessContrastSaturationFB*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughBrightnessContrastSaturationFB
  XrPassthroughBrightnessContrastSaturationFB const* get() const noexcept {
    return reinterpret_cast<XrPassthroughBrightnessContrastSaturationFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughBrightnessContrastSaturationFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughBrightnessContrastSaturationFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughBrightnessContrastSaturationFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughBrightnessContrastSaturationFB*>(this);
  }
  float brightness;
  float contrast;
  float saturation;
};
static_assert(sizeof(XrPassthroughBrightnessContrastSaturationFB) ==
                  sizeof(PassthroughBrightnessContrastSaturationFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughBrightnessContrastSaturationFB pointer to
 * const from a PassthroughBrightnessContrastSaturationFB reference to const.
 * @relates PassthroughBrightnessContrastSaturationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughBrightnessContrastSaturationFB const* get(
    PassthroughBrightnessContrastSaturationFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * PassthroughBrightnessContrastSaturationFB as the address of a raw
 * XrPassthroughBrightnessContrastSaturationFB
 * @relates PassthroughBrightnessContrastSaturationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughBrightnessContrastSaturationFB* put(
    PassthroughBrightnessContrastSaturationFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough
/*!
 * C++ projection of XrEventDataPassthroughStateChangedFB
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataPassthroughStateChangedFB>
 * @xrentity{XrEventDataPassthroughStateChangedFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataPassthroughStateChangedFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataPassthroughStateChangedFB(void* next_ = nullptr)

      : Parent(StructureType::EventDataPassthroughStateChangedFB, next_) {}

  //! Default copy constructor
  EventDataPassthroughStateChangedFB(const EventDataPassthroughStateChangedFB& rhs) = default;
  //! Default copy assignment
  EventDataPassthroughStateChangedFB& operator=(const EventDataPassthroughStateChangedFB& rhs) =
      default;
  //! Copy construct from raw
  EventDataPassthroughStateChangedFB(const XrEventDataPassthroughStateChangedFB& rhs)
      : EventDataPassthroughStateChangedFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataPassthroughStateChangedFB& operator=(const XrEventDataPassthroughStateChangedFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataPassthroughStateChangedFB&() const {
    return *reinterpret_cast<const XrEventDataPassthroughStateChangedFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataPassthroughStateChangedFB&() {
    return *reinterpret_cast<XrEventDataPassthroughStateChangedFB*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataPassthroughStateChangedFB
  XrEventDataPassthroughStateChangedFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataPassthroughStateChangedFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataPassthroughStateChangedFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataPassthroughStateChangedFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataPassthroughStateChangedFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataPassthroughStateChangedFB*>(this);
  }
  PassthroughStateChangedFlagsFB flags;
};
static_assert(sizeof(XrEventDataPassthroughStateChangedFB) ==
                  sizeof(EventDataPassthroughStateChangedFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataPassthroughStateChangedFB pointer to const from
 * a EventDataPassthroughStateChangedFB reference to const.
 * @relates EventDataPassthroughStateChangedFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataPassthroughStateChangedFB const* get(
    EventDataPassthroughStateChangedFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataPassthroughStateChangedFB as the address of a raw XrEventDataPassthroughStateChangedFB
 * @relates EventDataPassthroughStateChangedFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataPassthroughStateChangedFB* put(
    EventDataPassthroughStateChangedFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelPathInfoFB
 *
 * Provided by the `XR_FB_render_model` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelPathInfoFB>
 * @xrentity{XrRenderModelPathInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelPathInfoFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelPathInfoFB(void* next_ = nullptr)

      : Parent(StructureType::RenderModelPathInfoFB, next_) {}

  //! Default copy constructor
  RenderModelPathInfoFB(const RenderModelPathInfoFB& rhs) = default;
  //! Default copy assignment
  RenderModelPathInfoFB& operator=(const RenderModelPathInfoFB& rhs) = default;
  //! Copy construct from raw
  RenderModelPathInfoFB(const XrRenderModelPathInfoFB& rhs) : RenderModelPathInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelPathInfoFB& operator=(const XrRenderModelPathInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelPathInfoFB&() const {
    return *reinterpret_cast<const XrRenderModelPathInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelPathInfoFB&() { return *reinterpret_cast<XrRenderModelPathInfoFB*>(this); }

  //! Accessor for this as the address of a raw XrRenderModelPathInfoFB
  XrRenderModelPathInfoFB const* get() const noexcept {
    return reinterpret_cast<XrRenderModelPathInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRenderModelPathInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelPathInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelPathInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelPathInfoFB*>(this);
  }
  Path path;
};
static_assert(sizeof(XrRenderModelPathInfoFB) == sizeof(RenderModelPathInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelPathInfoFB pointer to const from a
 * RenderModelPathInfoFB reference to const.
 * @relates RenderModelPathInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelPathInfoFB const* get(RenderModelPathInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelPathInfoFB as the
 * address of a raw XrRenderModelPathInfoFB
 * @relates RenderModelPathInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelPathInfoFB* put(RenderModelPathInfoFB& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_render_model

#ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelPropertiesFB
 *
 * Provided by the `XR_FB_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelPropertiesFB>
 * @xrentity{XrRenderModelPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::RenderModelPropertiesFB, next_) {}

  //! Default copy constructor
  RenderModelPropertiesFB(const RenderModelPropertiesFB& rhs) = default;
  //! Default copy assignment
  RenderModelPropertiesFB& operator=(const RenderModelPropertiesFB& rhs) = default;
  //! Copy construct from raw
  RenderModelPropertiesFB(const XrRenderModelPropertiesFB& rhs) : RenderModelPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelPropertiesFB& operator=(const XrRenderModelPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelPropertiesFB&() const {
    return *reinterpret_cast<const XrRenderModelPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelPropertiesFB&() {
    return *reinterpret_cast<XrRenderModelPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelPropertiesFB
  XrRenderModelPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrRenderModelPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelPropertiesFB*>(this);
  }
  uint32_t vendorId;
  char modelName[XR_MAX_RENDER_MODEL_NAME_SIZE_FB];
  RenderModelKeyFB modelKey;
  uint32_t modelVersion;
  RenderModelFlagsFB flags;
};
static_assert(sizeof(XrRenderModelPropertiesFB) == sizeof(RenderModelPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelPropertiesFB pointer to const from a
 * RenderModelPropertiesFB reference to const.
 * @relates RenderModelPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelPropertiesFB const* get(RenderModelPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelPropertiesFB as
 * the address of a raw XrRenderModelPropertiesFB
 * @relates RenderModelPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelPropertiesFB* put(RenderModelPropertiesFB& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_render_model

#ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelBufferFB
 *
 * Provided by the `XR_FB_render_model` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelBufferFB>
 * @xrentity{XrRenderModelBufferFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelBufferFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelBufferFB(void* next_ = nullptr)

      : Parent(StructureType::RenderModelBufferFB, next_) {}

  //! Default copy constructor
  RenderModelBufferFB(const RenderModelBufferFB& rhs) = default;
  //! Default copy assignment
  RenderModelBufferFB& operator=(const RenderModelBufferFB& rhs) = default;
  //! Copy construct from raw
  RenderModelBufferFB(const XrRenderModelBufferFB& rhs) : RenderModelBufferFB() { *put() = rhs; }
  //! Copy assign from raw
  RenderModelBufferFB& operator=(const XrRenderModelBufferFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelBufferFB&() const {
    return *reinterpret_cast<const XrRenderModelBufferFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelBufferFB&() { return *reinterpret_cast<XrRenderModelBufferFB*>(this); }

  //! Accessor for this as the address of a raw XrRenderModelBufferFB
  XrRenderModelBufferFB const* get() const noexcept {
    return reinterpret_cast<XrRenderModelBufferFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRenderModelBufferFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelBufferFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelBufferFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelBufferFB*>(this);
  }
  uint32_t bufferCapacityInput;
  uint32_t bufferCountOutput;
  uint8_t* buffer;
};
static_assert(sizeof(XrRenderModelBufferFB) == sizeof(RenderModelBufferFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelBufferFB pointer to const from a
 * RenderModelBufferFB reference to const.
 * @relates RenderModelBufferFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelBufferFB const* get(RenderModelBufferFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelBufferFB as the
 * address of a raw XrRenderModelBufferFB
 * @relates RenderModelBufferFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelBufferFB* put(RenderModelBufferFB& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_render_model

#ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelLoadInfoFB
 *
 * Provided by the `XR_FB_render_model` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelLoadInfoFB>
 * @xrentity{XrRenderModelLoadInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelLoadInfoFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelLoadInfoFB(void* next_ = nullptr)

      : Parent(StructureType::RenderModelLoadInfoFB, next_) {}

  //! Default copy constructor
  RenderModelLoadInfoFB(const RenderModelLoadInfoFB& rhs) = default;
  //! Default copy assignment
  RenderModelLoadInfoFB& operator=(const RenderModelLoadInfoFB& rhs) = default;
  //! Copy construct from raw
  RenderModelLoadInfoFB(const XrRenderModelLoadInfoFB& rhs) : RenderModelLoadInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelLoadInfoFB& operator=(const XrRenderModelLoadInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelLoadInfoFB&() const {
    return *reinterpret_cast<const XrRenderModelLoadInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelLoadInfoFB&() { return *reinterpret_cast<XrRenderModelLoadInfoFB*>(this); }

  //! Accessor for this as the address of a raw XrRenderModelLoadInfoFB
  XrRenderModelLoadInfoFB const* get() const noexcept {
    return reinterpret_cast<XrRenderModelLoadInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRenderModelLoadInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelLoadInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelLoadInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelLoadInfoFB*>(this);
  }
  RenderModelKeyFB modelKey;
};
static_assert(sizeof(XrRenderModelLoadInfoFB) == sizeof(RenderModelLoadInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelLoadInfoFB pointer to const from a
 * RenderModelLoadInfoFB reference to const.
 * @relates RenderModelLoadInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelLoadInfoFB const* get(RenderModelLoadInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelLoadInfoFB as the
 * address of a raw XrRenderModelLoadInfoFB
 * @relates RenderModelLoadInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelLoadInfoFB* put(RenderModelLoadInfoFB& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_render_model

#ifdef XR_FB_render_model
/*!
 * C++ projection of XrSystemRenderModelPropertiesFB
 *
 * Provided by the `XR_FB_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemRenderModelPropertiesFB>
 * @xrentity{XrSystemRenderModelPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemRenderModelPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemRenderModelPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemRenderModelPropertiesFB, next_) {}

  //! Default copy constructor
  SystemRenderModelPropertiesFB(const SystemRenderModelPropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemRenderModelPropertiesFB& operator=(const SystemRenderModelPropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemRenderModelPropertiesFB(const XrSystemRenderModelPropertiesFB& rhs)
      : SystemRenderModelPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemRenderModelPropertiesFB& operator=(const XrSystemRenderModelPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemRenderModelPropertiesFB&() const {
    return *reinterpret_cast<const XrSystemRenderModelPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemRenderModelPropertiesFB&() {
    return *reinterpret_cast<XrSystemRenderModelPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemRenderModelPropertiesFB
  XrSystemRenderModelPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemRenderModelPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemRenderModelPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemRenderModelPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemRenderModelPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemRenderModelPropertiesFB*>(this);
  }
  Bool32 supportsRenderModelLoading;
};
static_assert(sizeof(XrSystemRenderModelPropertiesFB) == sizeof(SystemRenderModelPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemRenderModelPropertiesFB pointer to const from a
 * SystemRenderModelPropertiesFB reference to const.
 * @relates SystemRenderModelPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemRenderModelPropertiesFB const* get(
    SystemRenderModelPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemRenderModelPropertiesFB
 * as the address of a raw XrSystemRenderModelPropertiesFB
 * @relates SystemRenderModelPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemRenderModelPropertiesFB* put(SystemRenderModelPropertiesFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_render_model

#ifdef XR_FB_render_model
/*!
 * C++ projection of XrRenderModelCapabilitiesRequestFB
 *
 * Provided by the `XR_FB_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelCapabilitiesRequestFB>
 * @xrentity{XrRenderModelCapabilitiesRequestFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelCapabilitiesRequestFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelCapabilitiesRequestFB(void* next_ = nullptr)

      : Parent(StructureType::RenderModelCapabilitiesRequestFB, next_) {}

  //! Default copy constructor
  RenderModelCapabilitiesRequestFB(const RenderModelCapabilitiesRequestFB& rhs) = default;
  //! Default copy assignment
  RenderModelCapabilitiesRequestFB& operator=(const RenderModelCapabilitiesRequestFB& rhs) =
      default;
  //! Copy construct from raw
  RenderModelCapabilitiesRequestFB(const XrRenderModelCapabilitiesRequestFB& rhs)
      : RenderModelCapabilitiesRequestFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelCapabilitiesRequestFB& operator=(const XrRenderModelCapabilitiesRequestFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelCapabilitiesRequestFB&() const {
    return *reinterpret_cast<const XrRenderModelCapabilitiesRequestFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelCapabilitiesRequestFB&() {
    return *reinterpret_cast<XrRenderModelCapabilitiesRequestFB*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelCapabilitiesRequestFB
  XrRenderModelCapabilitiesRequestFB const* get() const noexcept {
    return reinterpret_cast<XrRenderModelCapabilitiesRequestFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelCapabilitiesRequestFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelCapabilitiesRequestFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelCapabilitiesRequestFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelCapabilitiesRequestFB*>(this);
  }
  RenderModelFlagsFB flags;
};
static_assert(sizeof(XrRenderModelCapabilitiesRequestFB) ==
                  sizeof(RenderModelCapabilitiesRequestFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelCapabilitiesRequestFB pointer to const from a
 * RenderModelCapabilitiesRequestFB reference to const.
 * @relates RenderModelCapabilitiesRequestFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelCapabilitiesRequestFB const* get(
    RenderModelCapabilitiesRequestFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * RenderModelCapabilitiesRequestFB as the address of a raw XrRenderModelCapabilitiesRequestFB
 * @relates RenderModelCapabilitiesRequestFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelCapabilitiesRequestFB* put(
    RenderModelCapabilitiesRequestFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_render_model

#ifdef XR_VARJO_foveated_rendering
/*!
 * C++ projection of XrViewLocateFoveatedRenderingVARJO
 *
 * Provided by the `XR_VARJO_foveated_rendering` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrViewLocateFoveatedRenderingVARJO>
 * @xrentity{XrViewLocateFoveatedRenderingVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ViewLocateFoveatedRenderingVARJO : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ViewLocateFoveatedRenderingVARJO(const Bool32& foveatedRenderingActive_,
                                   const void* next_ = nullptr)
      : Parent(StructureType::ViewLocateFoveatedRenderingVARJO, next_),
        foveatedRenderingActive{foveatedRenderingActive_} {}

  //! Default/empty constructor
  ViewLocateFoveatedRenderingVARJO(const void* next_ = nullptr)

      : Parent(StructureType::ViewLocateFoveatedRenderingVARJO, next_),
        foveatedRenderingActive{false} {}

  //! Default copy constructor
  ViewLocateFoveatedRenderingVARJO(const ViewLocateFoveatedRenderingVARJO& rhs) = default;
  //! Default copy assignment
  ViewLocateFoveatedRenderingVARJO& operator=(const ViewLocateFoveatedRenderingVARJO& rhs) =
      default;
  //! Copy construct from raw
  ViewLocateFoveatedRenderingVARJO(const XrViewLocateFoveatedRenderingVARJO& rhs)
      : ViewLocateFoveatedRenderingVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ViewLocateFoveatedRenderingVARJO& operator=(const XrViewLocateFoveatedRenderingVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrViewLocateFoveatedRenderingVARJO&() const {
    return *reinterpret_cast<const XrViewLocateFoveatedRenderingVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrViewLocateFoveatedRenderingVARJO&() {
    return *reinterpret_cast<XrViewLocateFoveatedRenderingVARJO*>(this);
  }

  //! Accessor for this as the address of a raw XrViewLocateFoveatedRenderingVARJO
  XrViewLocateFoveatedRenderingVARJO const* get() const noexcept {
    return reinterpret_cast<XrViewLocateFoveatedRenderingVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrViewLocateFoveatedRenderingVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrViewLocateFoveatedRenderingVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ViewLocateFoveatedRenderingVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrViewLocateFoveatedRenderingVARJO*>(this);
  }
  Bool32 foveatedRenderingActive;
};
static_assert(sizeof(XrViewLocateFoveatedRenderingVARJO) ==
                  sizeof(ViewLocateFoveatedRenderingVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrViewLocateFoveatedRenderingVARJO pointer to const from a
 * ViewLocateFoveatedRenderingVARJO reference to const.
 * @relates ViewLocateFoveatedRenderingVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewLocateFoveatedRenderingVARJO const* get(
    ViewLocateFoveatedRenderingVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ViewLocateFoveatedRenderingVARJO as the address of a raw XrViewLocateFoveatedRenderingVARJO
 * @relates ViewLocateFoveatedRenderingVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrViewLocateFoveatedRenderingVARJO* put(
    ViewLocateFoveatedRenderingVARJO& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VARJO_foveated_rendering

#ifdef XR_VARJO_foveated_rendering
/*!
 * C++ projection of XrFoveatedViewConfigurationViewVARJO
 *
 * Provided by the `XR_VARJO_foveated_rendering` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveatedViewConfigurationViewVARJO>
 * @xrentity{XrFoveatedViewConfigurationViewVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FoveatedViewConfigurationViewVARJO : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FoveatedViewConfigurationViewVARJO(void* next_ = nullptr)

      : Parent(StructureType::FoveatedViewConfigurationViewVARJO, next_) {}

  //! Default copy constructor
  FoveatedViewConfigurationViewVARJO(const FoveatedViewConfigurationViewVARJO& rhs) = default;
  //! Default copy assignment
  FoveatedViewConfigurationViewVARJO& operator=(const FoveatedViewConfigurationViewVARJO& rhs) =
      default;
  //! Copy construct from raw
  FoveatedViewConfigurationViewVARJO(const XrFoveatedViewConfigurationViewVARJO& rhs)
      : FoveatedViewConfigurationViewVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FoveatedViewConfigurationViewVARJO& operator=(const XrFoveatedViewConfigurationViewVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFoveatedViewConfigurationViewVARJO&() const {
    return *reinterpret_cast<const XrFoveatedViewConfigurationViewVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFoveatedViewConfigurationViewVARJO&() {
    return *reinterpret_cast<XrFoveatedViewConfigurationViewVARJO*>(this);
  }

  //! Accessor for this as the address of a raw XrFoveatedViewConfigurationViewVARJO
  XrFoveatedViewConfigurationViewVARJO const* get() const noexcept {
    return reinterpret_cast<XrFoveatedViewConfigurationViewVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFoveatedViewConfigurationViewVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFoveatedViewConfigurationViewVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FoveatedViewConfigurationViewVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrFoveatedViewConfigurationViewVARJO*>(this);
  }
  Bool32 foveatedRenderingActive;
};
static_assert(sizeof(XrFoveatedViewConfigurationViewVARJO) ==
                  sizeof(FoveatedViewConfigurationViewVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFoveatedViewConfigurationViewVARJO pointer to const from
 * a FoveatedViewConfigurationViewVARJO reference to const.
 * @relates FoveatedViewConfigurationViewVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveatedViewConfigurationViewVARJO const* get(
    FoveatedViewConfigurationViewVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * FoveatedViewConfigurationViewVARJO as the address of a raw XrFoveatedViewConfigurationViewVARJO
 * @relates FoveatedViewConfigurationViewVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveatedViewConfigurationViewVARJO* put(
    FoveatedViewConfigurationViewVARJO& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VARJO_foveated_rendering

#ifdef XR_VARJO_foveated_rendering
/*!
 * C++ projection of XrSystemFoveatedRenderingPropertiesVARJO
 *
 * Provided by the `XR_VARJO_foveated_rendering` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemFoveatedRenderingPropertiesVARJO>
 * @xrentity{XrSystemFoveatedRenderingPropertiesVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemFoveatedRenderingPropertiesVARJO : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemFoveatedRenderingPropertiesVARJO(void* next_ = nullptr)

      : Parent(StructureType::SystemFoveatedRenderingPropertiesVARJO, next_) {}

  //! Default copy constructor
  SystemFoveatedRenderingPropertiesVARJO(const SystemFoveatedRenderingPropertiesVARJO& rhs) =
      default;
  //! Default copy assignment
  SystemFoveatedRenderingPropertiesVARJO& operator=(
      const SystemFoveatedRenderingPropertiesVARJO& rhs) = default;
  //! Copy construct from raw
  SystemFoveatedRenderingPropertiesVARJO(const XrSystemFoveatedRenderingPropertiesVARJO& rhs)
      : SystemFoveatedRenderingPropertiesVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemFoveatedRenderingPropertiesVARJO& operator=(
      const XrSystemFoveatedRenderingPropertiesVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemFoveatedRenderingPropertiesVARJO&() const {
    return *reinterpret_cast<const XrSystemFoveatedRenderingPropertiesVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemFoveatedRenderingPropertiesVARJO&() {
    return *reinterpret_cast<XrSystemFoveatedRenderingPropertiesVARJO*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemFoveatedRenderingPropertiesVARJO
  XrSystemFoveatedRenderingPropertiesVARJO const* get() const noexcept {
    return reinterpret_cast<XrSystemFoveatedRenderingPropertiesVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemFoveatedRenderingPropertiesVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemFoveatedRenderingPropertiesVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemFoveatedRenderingPropertiesVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemFoveatedRenderingPropertiesVARJO*>(this);
  }
  Bool32 supportsFoveatedRendering;
};
static_assert(sizeof(XrSystemFoveatedRenderingPropertiesVARJO) ==
                  sizeof(SystemFoveatedRenderingPropertiesVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemFoveatedRenderingPropertiesVARJO pointer to const
 * from a SystemFoveatedRenderingPropertiesVARJO reference to const.
 * @relates SystemFoveatedRenderingPropertiesVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFoveatedRenderingPropertiesVARJO const* get(
    SystemFoveatedRenderingPropertiesVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemFoveatedRenderingPropertiesVARJO as the address of a raw
 * XrSystemFoveatedRenderingPropertiesVARJO
 * @relates SystemFoveatedRenderingPropertiesVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFoveatedRenderingPropertiesVARJO* put(
    SystemFoveatedRenderingPropertiesVARJO& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VARJO_foveated_rendering

#ifdef XR_VARJO_composition_layer_depth_test
/*!
 * C++ projection of XrCompositionLayerDepthTestVARJO
 *
 * Provided by the `XR_VARJO_composition_layer_depth_test` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerDepthTestVARJO>
 * @xrentity{XrCompositionLayerDepthTestVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerDepthTestVARJO : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerDepthTestVARJO(float depthTestRangeNearZ_, float depthTestRangeFarZ_,
                                 const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerDepthTestVARJO, next_),
        depthTestRangeNearZ{depthTestRangeNearZ_},
        depthTestRangeFarZ{depthTestRangeFarZ_} {}

  //! Default/empty constructor
  CompositionLayerDepthTestVARJO(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerDepthTestVARJO, next_),
        depthTestRangeNearZ{0.0f},
        depthTestRangeFarZ{0.0f} {}

  //! Default copy constructor
  CompositionLayerDepthTestVARJO(const CompositionLayerDepthTestVARJO& rhs) = default;
  //! Default copy assignment
  CompositionLayerDepthTestVARJO& operator=(const CompositionLayerDepthTestVARJO& rhs) = default;
  //! Copy construct from raw
  CompositionLayerDepthTestVARJO(const XrCompositionLayerDepthTestVARJO& rhs)
      : CompositionLayerDepthTestVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerDepthTestVARJO& operator=(const XrCompositionLayerDepthTestVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerDepthTestVARJO&() const {
    return *reinterpret_cast<const XrCompositionLayerDepthTestVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerDepthTestVARJO&() {
    return *reinterpret_cast<XrCompositionLayerDepthTestVARJO*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerDepthTestVARJO
  XrCompositionLayerDepthTestVARJO const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerDepthTestVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerDepthTestVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerDepthTestVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerDepthTestVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerDepthTestVARJO*>(this);
  }
  float depthTestRangeNearZ;
  float depthTestRangeFarZ;
};
static_assert(sizeof(XrCompositionLayerDepthTestVARJO) == sizeof(CompositionLayerDepthTestVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerDepthTestVARJO pointer to const from a
 * CompositionLayerDepthTestVARJO reference to const.
 * @relates CompositionLayerDepthTestVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerDepthTestVARJO const* get(
    CompositionLayerDepthTestVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerDepthTestVARJO as the address of a raw XrCompositionLayerDepthTestVARJO
 * @relates CompositionLayerDepthTestVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerDepthTestVARJO* put(CompositionLayerDepthTestVARJO& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VARJO_composition_layer_depth_test

#ifdef XR_VARJO_marker_tracking
/*!
 * C++ projection of XrSystemMarkerTrackingPropertiesVARJO
 *
 * Provided by the `XR_VARJO_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemMarkerTrackingPropertiesVARJO>
 * @xrentity{XrSystemMarkerTrackingPropertiesVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemMarkerTrackingPropertiesVARJO : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemMarkerTrackingPropertiesVARJO(void* next_ = nullptr)

      : Parent(StructureType::SystemMarkerTrackingPropertiesVARJO, next_) {}

  //! Default copy constructor
  SystemMarkerTrackingPropertiesVARJO(const SystemMarkerTrackingPropertiesVARJO& rhs) = default;
  //! Default copy assignment
  SystemMarkerTrackingPropertiesVARJO& operator=(const SystemMarkerTrackingPropertiesVARJO& rhs) =
      default;
  //! Copy construct from raw
  SystemMarkerTrackingPropertiesVARJO(const XrSystemMarkerTrackingPropertiesVARJO& rhs)
      : SystemMarkerTrackingPropertiesVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemMarkerTrackingPropertiesVARJO& operator=(const XrSystemMarkerTrackingPropertiesVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemMarkerTrackingPropertiesVARJO&() const {
    return *reinterpret_cast<const XrSystemMarkerTrackingPropertiesVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemMarkerTrackingPropertiesVARJO&() {
    return *reinterpret_cast<XrSystemMarkerTrackingPropertiesVARJO*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemMarkerTrackingPropertiesVARJO
  XrSystemMarkerTrackingPropertiesVARJO const* get() const noexcept {
    return reinterpret_cast<XrSystemMarkerTrackingPropertiesVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemMarkerTrackingPropertiesVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemMarkerTrackingPropertiesVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemMarkerTrackingPropertiesVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemMarkerTrackingPropertiesVARJO*>(this);
  }
  Bool32 supportsMarkerTracking;
};
static_assert(sizeof(XrSystemMarkerTrackingPropertiesVARJO) ==
                  sizeof(SystemMarkerTrackingPropertiesVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemMarkerTrackingPropertiesVARJO pointer to const
 * from a SystemMarkerTrackingPropertiesVARJO reference to const.
 * @relates SystemMarkerTrackingPropertiesVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemMarkerTrackingPropertiesVARJO const* get(
    SystemMarkerTrackingPropertiesVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemMarkerTrackingPropertiesVARJO as the address of a raw XrSystemMarkerTrackingPropertiesVARJO
 * @relates SystemMarkerTrackingPropertiesVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemMarkerTrackingPropertiesVARJO* put(
    SystemMarkerTrackingPropertiesVARJO& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking
/*!
 * C++ projection of XrEventDataMarkerTrackingUpdateVARJO
 *
 * Provided by the `XR_VARJO_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataMarkerTrackingUpdateVARJO>
 * @xrentity{XrEventDataMarkerTrackingUpdateVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataMarkerTrackingUpdateVARJO : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataMarkerTrackingUpdateVARJO(void* next_ = nullptr)

      : Parent(StructureType::EventDataMarkerTrackingUpdateVARJO, next_) {}

  //! Default copy constructor
  EventDataMarkerTrackingUpdateVARJO(const EventDataMarkerTrackingUpdateVARJO& rhs) = default;
  //! Default copy assignment
  EventDataMarkerTrackingUpdateVARJO& operator=(const EventDataMarkerTrackingUpdateVARJO& rhs) =
      default;
  //! Copy construct from raw
  EventDataMarkerTrackingUpdateVARJO(const XrEventDataMarkerTrackingUpdateVARJO& rhs)
      : EventDataMarkerTrackingUpdateVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataMarkerTrackingUpdateVARJO& operator=(const XrEventDataMarkerTrackingUpdateVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataMarkerTrackingUpdateVARJO&() const {
    return *reinterpret_cast<const XrEventDataMarkerTrackingUpdateVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataMarkerTrackingUpdateVARJO&() {
    return *reinterpret_cast<XrEventDataMarkerTrackingUpdateVARJO*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataMarkerTrackingUpdateVARJO
  XrEventDataMarkerTrackingUpdateVARJO const* get() const noexcept {
    return reinterpret_cast<XrEventDataMarkerTrackingUpdateVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataMarkerTrackingUpdateVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataMarkerTrackingUpdateVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataMarkerTrackingUpdateVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataMarkerTrackingUpdateVARJO*>(this);
  }
  uint64_t markerId;
  Bool32 isActive;
  Bool32 isPredicted;
  Time time;
};
static_assert(sizeof(XrEventDataMarkerTrackingUpdateVARJO) ==
                  sizeof(EventDataMarkerTrackingUpdateVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataMarkerTrackingUpdateVARJO pointer to const from
 * a EventDataMarkerTrackingUpdateVARJO reference to const.
 * @relates EventDataMarkerTrackingUpdateVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataMarkerTrackingUpdateVARJO const* get(
    EventDataMarkerTrackingUpdateVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataMarkerTrackingUpdateVARJO as the address of a raw XrEventDataMarkerTrackingUpdateVARJO
 * @relates EventDataMarkerTrackingUpdateVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataMarkerTrackingUpdateVARJO* put(
    EventDataMarkerTrackingUpdateVARJO& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataMarkerTrackingUpdateVARJO as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataMarkerTrackingUpdateVARJO
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataMarkerTrackingUpdateVARJO const& h) {
  return h.get_base();
}
#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking
/*!
 * C++ projection of XrMarkerSpaceCreateInfoVARJO
 *
 * Provided by the `XR_VARJO_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerSpaceCreateInfoVARJO>
 * @xrentity{XrMarkerSpaceCreateInfoVARJO}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS MarkerSpaceCreateInfoVARJO : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  MarkerSpaceCreateInfoVARJO(uint64_t markerId_, const Posef& poseInMarkerSpace_,
                             const void* next_ = nullptr)
      : Parent(StructureType::MarkerSpaceCreateInfoVARJO, next_),
        markerId{markerId_},
        poseInMarkerSpace{poseInMarkerSpace_} {}

  //! Default/empty constructor
  MarkerSpaceCreateInfoVARJO(const void* next_ = nullptr)

      : Parent(StructureType::MarkerSpaceCreateInfoVARJO, next_),
        markerId{0},
        poseInMarkerSpace{} {}

  //! Default copy constructor
  MarkerSpaceCreateInfoVARJO(const MarkerSpaceCreateInfoVARJO& rhs) = default;
  //! Default copy assignment
  MarkerSpaceCreateInfoVARJO& operator=(const MarkerSpaceCreateInfoVARJO& rhs) = default;
  //! Copy construct from raw
  MarkerSpaceCreateInfoVARJO(const XrMarkerSpaceCreateInfoVARJO& rhs)
      : MarkerSpaceCreateInfoVARJO() {
    *put() = rhs;
  }
  //! Copy assign from raw
  MarkerSpaceCreateInfoVARJO& operator=(const XrMarkerSpaceCreateInfoVARJO& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrMarkerSpaceCreateInfoVARJO&() const {
    return *reinterpret_cast<const XrMarkerSpaceCreateInfoVARJO*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrMarkerSpaceCreateInfoVARJO&() {
    return *reinterpret_cast<XrMarkerSpaceCreateInfoVARJO*>(this);
  }

  //! Accessor for this as the address of a raw XrMarkerSpaceCreateInfoVARJO
  XrMarkerSpaceCreateInfoVARJO const* get() const noexcept {
    return reinterpret_cast<XrMarkerSpaceCreateInfoVARJO const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrMarkerSpaceCreateInfoVARJO.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrMarkerSpaceCreateInfoVARJO* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = MarkerSpaceCreateInfoVARJO{};
      next = oldNext;
    }
    return reinterpret_cast<XrMarkerSpaceCreateInfoVARJO*>(this);
  }
  uint64_t markerId;
  Posef poseInMarkerSpace;
};
static_assert(sizeof(XrMarkerSpaceCreateInfoVARJO) == sizeof(MarkerSpaceCreateInfoVARJO),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrMarkerSpaceCreateInfoVARJO pointer to const from a
 * MarkerSpaceCreateInfoVARJO reference to const.
 * @relates MarkerSpaceCreateInfoVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerSpaceCreateInfoVARJO const* get(
    MarkerSpaceCreateInfoVARJO const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing MarkerSpaceCreateInfoVARJO as
 * the address of a raw XrMarkerSpaceCreateInfoVARJO
 * @relates MarkerSpaceCreateInfoVARJO
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerSpaceCreateInfoVARJO* put(MarkerSpaceCreateInfoVARJO& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_VARJO_marker_tracking

#ifdef XR_ML_frame_end_info
/*!
 * C++ projection of XrFrameEndInfoML
 *
 * Provided by the `XR_ML_frame_end_info` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameEndInfoML>
 * @xrentity{XrFrameEndInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameEndInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FrameEndInfoML(float focusDistance_, const FrameEndInfoFlagsML& flags_,
                 const void* next_ = nullptr)
      : Parent(StructureType::FrameEndInfoML, next_),
        focusDistance{focusDistance_},
        flags{flags_} {}

  //! Default/empty constructor
  FrameEndInfoML(const void* next_ = nullptr)

      : Parent(StructureType::FrameEndInfoML, next_), focusDistance{0.0f}, flags{} {}

  //! Default copy constructor
  FrameEndInfoML(const FrameEndInfoML& rhs) = default;
  //! Default copy assignment
  FrameEndInfoML& operator=(const FrameEndInfoML& rhs) = default;
  //! Copy construct from raw
  FrameEndInfoML(const XrFrameEndInfoML& rhs) : FrameEndInfoML() { *put() = rhs; }
  //! Copy assign from raw
  FrameEndInfoML& operator=(const XrFrameEndInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameEndInfoML&() const {
    return *reinterpret_cast<const XrFrameEndInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameEndInfoML&() { return *reinterpret_cast<XrFrameEndInfoML*>(this); }

  //! Accessor for this as the address of a raw XrFrameEndInfoML
  XrFrameEndInfoML const* get() const noexcept {
    return reinterpret_cast<XrFrameEndInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameEndInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameEndInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameEndInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameEndInfoML*>(this);
  }
  float focusDistance;
  FrameEndInfoFlagsML flags;
};
static_assert(sizeof(XrFrameEndInfoML) == sizeof(FrameEndInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameEndInfoML pointer to const from a FrameEndInfoML
 * reference to const.
 * @relates FrameEndInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameEndInfoML const* get(FrameEndInfoML const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameEndInfoML as the address
 * of a raw XrFrameEndInfoML
 * @relates FrameEndInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameEndInfoML* put(FrameEndInfoML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_frame_end_info

#ifdef XR_ML_global_dimmer
/*!
 * C++ projection of XrGlobalDimmerFrameEndInfoML
 *
 * Provided by the `XR_ML_global_dimmer` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGlobalDimmerFrameEndInfoML>
 * @xrentity{XrGlobalDimmerFrameEndInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS GlobalDimmerFrameEndInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  GlobalDimmerFrameEndInfoML(float dimmerValue_, const GlobalDimmerFrameEndInfoFlagsML& flags_,
                             const void* next_ = nullptr)
      : Parent(StructureType::GlobalDimmerFrameEndInfoML, next_),
        dimmerValue{dimmerValue_},
        flags{flags_} {}

  //! Default/empty constructor
  GlobalDimmerFrameEndInfoML(const void* next_ = nullptr)

      : Parent(StructureType::GlobalDimmerFrameEndInfoML, next_), dimmerValue{0.0f}, flags{} {}

  //! Default copy constructor
  GlobalDimmerFrameEndInfoML(const GlobalDimmerFrameEndInfoML& rhs) = default;
  //! Default copy assignment
  GlobalDimmerFrameEndInfoML& operator=(const GlobalDimmerFrameEndInfoML& rhs) = default;
  //! Copy construct from raw
  GlobalDimmerFrameEndInfoML(const XrGlobalDimmerFrameEndInfoML& rhs)
      : GlobalDimmerFrameEndInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  GlobalDimmerFrameEndInfoML& operator=(const XrGlobalDimmerFrameEndInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrGlobalDimmerFrameEndInfoML&() const {
    return *reinterpret_cast<const XrGlobalDimmerFrameEndInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrGlobalDimmerFrameEndInfoML&() {
    return *reinterpret_cast<XrGlobalDimmerFrameEndInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrGlobalDimmerFrameEndInfoML
  XrGlobalDimmerFrameEndInfoML const* get() const noexcept {
    return reinterpret_cast<XrGlobalDimmerFrameEndInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrGlobalDimmerFrameEndInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrGlobalDimmerFrameEndInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = GlobalDimmerFrameEndInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrGlobalDimmerFrameEndInfoML*>(this);
  }
  float dimmerValue;
  GlobalDimmerFrameEndInfoFlagsML flags;
};
static_assert(sizeof(XrGlobalDimmerFrameEndInfoML) == sizeof(GlobalDimmerFrameEndInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrGlobalDimmerFrameEndInfoML pointer to const from a
 * GlobalDimmerFrameEndInfoML reference to const.
 * @relates GlobalDimmerFrameEndInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGlobalDimmerFrameEndInfoML const* get(
    GlobalDimmerFrameEndInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing GlobalDimmerFrameEndInfoML as
 * the address of a raw XrGlobalDimmerFrameEndInfoML
 * @relates GlobalDimmerFrameEndInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrGlobalDimmerFrameEndInfoML* put(GlobalDimmerFrameEndInfoML& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_global_dimmer

#ifdef XR_ML_compat
#if defined(XR_USE_PLATFORM_ML)
/*!
 * C++ projection of XrCoordinateSpaceCreateInfoML
 *
 * Provided by the `XR_ML_compat` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCoordinateSpaceCreateInfoML>
 * @xrentity{XrCoordinateSpaceCreateInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CoordinateSpaceCreateInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CoordinateSpaceCreateInfoML(MLCoordinateFrameUID cfuid_, const Posef& poseInCoordinateSpace_,
                              const void* next_ = nullptr)
      : Parent(StructureType::CoordinateSpaceCreateInfoML, next_),
        cfuid{cfuid_},
        poseInCoordinateSpace{poseInCoordinateSpace_} {}

  //! Default/empty constructor
  CoordinateSpaceCreateInfoML(const void* next_ = nullptr)

      : Parent(StructureType::CoordinateSpaceCreateInfoML, next_),
        cfuid{},
        poseInCoordinateSpace{} {}

  //! Default copy constructor
  CoordinateSpaceCreateInfoML(const CoordinateSpaceCreateInfoML& rhs) = default;
  //! Default copy assignment
  CoordinateSpaceCreateInfoML& operator=(const CoordinateSpaceCreateInfoML& rhs) = default;
  //! Copy construct from raw
  CoordinateSpaceCreateInfoML(const XrCoordinateSpaceCreateInfoML& rhs)
      : CoordinateSpaceCreateInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CoordinateSpaceCreateInfoML& operator=(const XrCoordinateSpaceCreateInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCoordinateSpaceCreateInfoML&() const {
    return *reinterpret_cast<const XrCoordinateSpaceCreateInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCoordinateSpaceCreateInfoML&() {
    return *reinterpret_cast<XrCoordinateSpaceCreateInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrCoordinateSpaceCreateInfoML
  XrCoordinateSpaceCreateInfoML const* get() const noexcept {
    return reinterpret_cast<XrCoordinateSpaceCreateInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCoordinateSpaceCreateInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCoordinateSpaceCreateInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CoordinateSpaceCreateInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrCoordinateSpaceCreateInfoML*>(this);
  }
  MLCoordinateFrameUID cfuid;
  Posef poseInCoordinateSpace;
};
static_assert(sizeof(XrCoordinateSpaceCreateInfoML) == sizeof(CoordinateSpaceCreateInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCoordinateSpaceCreateInfoML pointer to const from a
 * CoordinateSpaceCreateInfoML reference to const.
 * @relates CoordinateSpaceCreateInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCoordinateSpaceCreateInfoML const* get(
    CoordinateSpaceCreateInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CoordinateSpaceCreateInfoML
 * as the address of a raw XrCoordinateSpaceCreateInfoML
 * @relates CoordinateSpaceCreateInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCoordinateSpaceCreateInfoML* put(CoordinateSpaceCreateInfoML& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_PLATFORM_ML)
#endif  // XR_ML_compat

#ifdef XR_ML_marker_understanding
/*!
 * C++ projection of XrSystemMarkerUnderstandingPropertiesML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemMarkerUnderstandingPropertiesML>
 * @xrentity{XrSystemMarkerUnderstandingPropertiesML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemMarkerUnderstandingPropertiesML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemMarkerUnderstandingPropertiesML(void* next_ = nullptr)

      : Parent(StructureType::SystemMarkerUnderstandingPropertiesML, next_) {}

  //! Default copy constructor
  SystemMarkerUnderstandingPropertiesML(const SystemMarkerUnderstandingPropertiesML& rhs) = default;
  //! Default copy assignment
  SystemMarkerUnderstandingPropertiesML& operator=(
      const SystemMarkerUnderstandingPropertiesML& rhs) = default;
  //! Copy construct from raw
  SystemMarkerUnderstandingPropertiesML(const XrSystemMarkerUnderstandingPropertiesML& rhs)
      : SystemMarkerUnderstandingPropertiesML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemMarkerUnderstandingPropertiesML& operator=(
      const XrSystemMarkerUnderstandingPropertiesML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemMarkerUnderstandingPropertiesML&() const {
    return *reinterpret_cast<const XrSystemMarkerUnderstandingPropertiesML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemMarkerUnderstandingPropertiesML&() {
    return *reinterpret_cast<XrSystemMarkerUnderstandingPropertiesML*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemMarkerUnderstandingPropertiesML
  XrSystemMarkerUnderstandingPropertiesML const* get() const noexcept {
    return reinterpret_cast<XrSystemMarkerUnderstandingPropertiesML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemMarkerUnderstandingPropertiesML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemMarkerUnderstandingPropertiesML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemMarkerUnderstandingPropertiesML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemMarkerUnderstandingPropertiesML*>(this);
  }
  Bool32 supportsMarkerUnderstanding;
};
static_assert(sizeof(XrSystemMarkerUnderstandingPropertiesML) ==
                  sizeof(SystemMarkerUnderstandingPropertiesML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemMarkerUnderstandingPropertiesML pointer to const
 * from a SystemMarkerUnderstandingPropertiesML reference to const.
 * @relates SystemMarkerUnderstandingPropertiesML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemMarkerUnderstandingPropertiesML const* get(
    SystemMarkerUnderstandingPropertiesML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemMarkerUnderstandingPropertiesML as the address of a raw
 * XrSystemMarkerUnderstandingPropertiesML
 * @relates SystemMarkerUnderstandingPropertiesML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemMarkerUnderstandingPropertiesML* put(
    SystemMarkerUnderstandingPropertiesML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * C++ projection of XrMarkerDetectorCreateInfoML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorCreateInfoML>
 * @xrentity{XrMarkerDetectorCreateInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS MarkerDetectorCreateInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  MarkerDetectorCreateInfoML(const MarkerDetectorProfileML& profile_,
                             const MarkerTypeML& markerType_, const void* next_ = nullptr)
      : Parent(StructureType::MarkerDetectorCreateInfoML, next_),
        profile{profile_},
        markerType{markerType_} {}

  //! Default/empty constructor
  MarkerDetectorCreateInfoML(const void* next_ = nullptr)

      : Parent(StructureType::MarkerDetectorCreateInfoML, next_), profile{}, markerType{} {}

  //! Default copy constructor
  MarkerDetectorCreateInfoML(const MarkerDetectorCreateInfoML& rhs) = default;
  //! Default copy assignment
  MarkerDetectorCreateInfoML& operator=(const MarkerDetectorCreateInfoML& rhs) = default;
  //! Copy construct from raw
  MarkerDetectorCreateInfoML(const XrMarkerDetectorCreateInfoML& rhs)
      : MarkerDetectorCreateInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  MarkerDetectorCreateInfoML& operator=(const XrMarkerDetectorCreateInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrMarkerDetectorCreateInfoML&() const {
    return *reinterpret_cast<const XrMarkerDetectorCreateInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrMarkerDetectorCreateInfoML&() {
    return *reinterpret_cast<XrMarkerDetectorCreateInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrMarkerDetectorCreateInfoML
  XrMarkerDetectorCreateInfoML const* get() const noexcept {
    return reinterpret_cast<XrMarkerDetectorCreateInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrMarkerDetectorCreateInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrMarkerDetectorCreateInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = MarkerDetectorCreateInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrMarkerDetectorCreateInfoML*>(this);
  }
  MarkerDetectorProfileML profile;
  MarkerTypeML markerType;
};
static_assert(sizeof(XrMarkerDetectorCreateInfoML) == sizeof(MarkerDetectorCreateInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrMarkerDetectorCreateInfoML pointer to const from a
 * MarkerDetectorCreateInfoML reference to const.
 * @relates MarkerDetectorCreateInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorCreateInfoML const* get(
    MarkerDetectorCreateInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing MarkerDetectorCreateInfoML as
 * the address of a raw XrMarkerDetectorCreateInfoML
 * @relates MarkerDetectorCreateInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorCreateInfoML* put(MarkerDetectorCreateInfoML& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * C++ projection of XrMarkerDetectorArucoInfoML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorArucoInfoML>
 * @xrentity{XrMarkerDetectorArucoInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS MarkerDetectorArucoInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  MarkerDetectorArucoInfoML(const MarkerArucoDictML& arucoDict_, const void* next_ = nullptr)
      : Parent(StructureType::MarkerDetectorArucoInfoML, next_), arucoDict{arucoDict_} {}

  //! Default/empty constructor
  MarkerDetectorArucoInfoML(const void* next_ = nullptr)

      : Parent(StructureType::MarkerDetectorArucoInfoML, next_), arucoDict{} {}

  //! Default copy constructor
  MarkerDetectorArucoInfoML(const MarkerDetectorArucoInfoML& rhs) = default;
  //! Default copy assignment
  MarkerDetectorArucoInfoML& operator=(const MarkerDetectorArucoInfoML& rhs) = default;
  //! Copy construct from raw
  MarkerDetectorArucoInfoML(const XrMarkerDetectorArucoInfoML& rhs) : MarkerDetectorArucoInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  MarkerDetectorArucoInfoML& operator=(const XrMarkerDetectorArucoInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrMarkerDetectorArucoInfoML&() const {
    return *reinterpret_cast<const XrMarkerDetectorArucoInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrMarkerDetectorArucoInfoML&() {
    return *reinterpret_cast<XrMarkerDetectorArucoInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrMarkerDetectorArucoInfoML
  XrMarkerDetectorArucoInfoML const* get() const noexcept {
    return reinterpret_cast<XrMarkerDetectorArucoInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrMarkerDetectorArucoInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrMarkerDetectorArucoInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = MarkerDetectorArucoInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrMarkerDetectorArucoInfoML*>(this);
  }
  MarkerArucoDictML arucoDict;
};
static_assert(sizeof(XrMarkerDetectorArucoInfoML) == sizeof(MarkerDetectorArucoInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrMarkerDetectorArucoInfoML pointer to const from a
 * MarkerDetectorArucoInfoML reference to const.
 * @relates MarkerDetectorArucoInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorArucoInfoML const* get(
    MarkerDetectorArucoInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing MarkerDetectorArucoInfoML as
 * the address of a raw XrMarkerDetectorArucoInfoML
 * @relates MarkerDetectorArucoInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorArucoInfoML* put(MarkerDetectorArucoInfoML& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * C++ projection of XrMarkerDetectorSizeInfoML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorSizeInfoML>
 * @xrentity{XrMarkerDetectorSizeInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS MarkerDetectorSizeInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  MarkerDetectorSizeInfoML(float markerLength_, const void* next_ = nullptr)
      : Parent(StructureType::MarkerDetectorSizeInfoML, next_), markerLength{markerLength_} {}

  //! Default/empty constructor
  MarkerDetectorSizeInfoML(const void* next_ = nullptr)

      : Parent(StructureType::MarkerDetectorSizeInfoML, next_), markerLength{0.0f} {}

  //! Default copy constructor
  MarkerDetectorSizeInfoML(const MarkerDetectorSizeInfoML& rhs) = default;
  //! Default copy assignment
  MarkerDetectorSizeInfoML& operator=(const MarkerDetectorSizeInfoML& rhs) = default;
  //! Copy construct from raw
  MarkerDetectorSizeInfoML(const XrMarkerDetectorSizeInfoML& rhs) : MarkerDetectorSizeInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  MarkerDetectorSizeInfoML& operator=(const XrMarkerDetectorSizeInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrMarkerDetectorSizeInfoML&() const {
    return *reinterpret_cast<const XrMarkerDetectorSizeInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrMarkerDetectorSizeInfoML&() {
    return *reinterpret_cast<XrMarkerDetectorSizeInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrMarkerDetectorSizeInfoML
  XrMarkerDetectorSizeInfoML const* get() const noexcept {
    return reinterpret_cast<XrMarkerDetectorSizeInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrMarkerDetectorSizeInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrMarkerDetectorSizeInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = MarkerDetectorSizeInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrMarkerDetectorSizeInfoML*>(this);
  }
  float markerLength;
};
static_assert(sizeof(XrMarkerDetectorSizeInfoML) == sizeof(MarkerDetectorSizeInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrMarkerDetectorSizeInfoML pointer to const from a
 * MarkerDetectorSizeInfoML reference to const.
 * @relates MarkerDetectorSizeInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorSizeInfoML const* get(MarkerDetectorSizeInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing MarkerDetectorSizeInfoML as
 * the address of a raw XrMarkerDetectorSizeInfoML
 * @relates MarkerDetectorSizeInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorSizeInfoML* put(MarkerDetectorSizeInfoML& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * C++ projection of XrMarkerDetectorAprilTagInfoML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorAprilTagInfoML>
 * @xrentity{XrMarkerDetectorAprilTagInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS MarkerDetectorAprilTagInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  MarkerDetectorAprilTagInfoML(const MarkerAprilTagDictML& aprilTagDict_,
                               const void* next_ = nullptr)
      : Parent(StructureType::MarkerDetectorAprilTagInfoML, next_), aprilTagDict{aprilTagDict_} {}

  //! Default/empty constructor
  MarkerDetectorAprilTagInfoML(const void* next_ = nullptr)

      : Parent(StructureType::MarkerDetectorAprilTagInfoML, next_), aprilTagDict{} {}

  //! Default copy constructor
  MarkerDetectorAprilTagInfoML(const MarkerDetectorAprilTagInfoML& rhs) = default;
  //! Default copy assignment
  MarkerDetectorAprilTagInfoML& operator=(const MarkerDetectorAprilTagInfoML& rhs) = default;
  //! Copy construct from raw
  MarkerDetectorAprilTagInfoML(const XrMarkerDetectorAprilTagInfoML& rhs)
      : MarkerDetectorAprilTagInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  MarkerDetectorAprilTagInfoML& operator=(const XrMarkerDetectorAprilTagInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrMarkerDetectorAprilTagInfoML&() const {
    return *reinterpret_cast<const XrMarkerDetectorAprilTagInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrMarkerDetectorAprilTagInfoML&() {
    return *reinterpret_cast<XrMarkerDetectorAprilTagInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrMarkerDetectorAprilTagInfoML
  XrMarkerDetectorAprilTagInfoML const* get() const noexcept {
    return reinterpret_cast<XrMarkerDetectorAprilTagInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrMarkerDetectorAprilTagInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrMarkerDetectorAprilTagInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = MarkerDetectorAprilTagInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrMarkerDetectorAprilTagInfoML*>(this);
  }
  MarkerAprilTagDictML aprilTagDict;
};
static_assert(sizeof(XrMarkerDetectorAprilTagInfoML) == sizeof(MarkerDetectorAprilTagInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrMarkerDetectorAprilTagInfoML pointer to const from a
 * MarkerDetectorAprilTagInfoML reference to const.
 * @relates MarkerDetectorAprilTagInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorAprilTagInfoML const* get(
    MarkerDetectorAprilTagInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing MarkerDetectorAprilTagInfoML
 * as the address of a raw XrMarkerDetectorAprilTagInfoML
 * @relates MarkerDetectorAprilTagInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorAprilTagInfoML* put(MarkerDetectorAprilTagInfoML& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * C++ projection of XrMarkerDetectorCustomProfileInfoML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorCustomProfileInfoML>
 * @xrentity{XrMarkerDetectorCustomProfileInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS MarkerDetectorCustomProfileInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  MarkerDetectorCustomProfileInfoML(
      const MarkerDetectorFpsML& fpsHint_, const MarkerDetectorResolutionML& resolutionHint_,
      const MarkerDetectorCameraML& cameraHint_,
      const MarkerDetectorCornerRefineMethodML& cornerRefineMethod_,
      const Bool32& useEdgeRefinement_,
      const MarkerDetectorFullAnalysisIntervalML& fullAnalysisIntervalHint_,
      const void* next_ = nullptr)
      : Parent(StructureType::MarkerDetectorCustomProfileInfoML, next_),
        fpsHint{fpsHint_},
        resolutionHint{resolutionHint_},
        cameraHint{cameraHint_},
        cornerRefineMethod{cornerRefineMethod_},
        useEdgeRefinement{useEdgeRefinement_},
        fullAnalysisIntervalHint{fullAnalysisIntervalHint_} {}

  //! Default/empty constructor
  MarkerDetectorCustomProfileInfoML(const void* next_ = nullptr)

      : Parent(StructureType::MarkerDetectorCustomProfileInfoML, next_),
        fpsHint{},
        resolutionHint{},
        cameraHint{},
        cornerRefineMethod{},
        useEdgeRefinement{false},
        fullAnalysisIntervalHint{} {}

  //! Default copy constructor
  MarkerDetectorCustomProfileInfoML(const MarkerDetectorCustomProfileInfoML& rhs) = default;
  //! Default copy assignment
  MarkerDetectorCustomProfileInfoML& operator=(const MarkerDetectorCustomProfileInfoML& rhs) =
      default;
  //! Copy construct from raw
  MarkerDetectorCustomProfileInfoML(const XrMarkerDetectorCustomProfileInfoML& rhs)
      : MarkerDetectorCustomProfileInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  MarkerDetectorCustomProfileInfoML& operator=(const XrMarkerDetectorCustomProfileInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrMarkerDetectorCustomProfileInfoML&() const {
    return *reinterpret_cast<const XrMarkerDetectorCustomProfileInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrMarkerDetectorCustomProfileInfoML&() {
    return *reinterpret_cast<XrMarkerDetectorCustomProfileInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrMarkerDetectorCustomProfileInfoML
  XrMarkerDetectorCustomProfileInfoML const* get() const noexcept {
    return reinterpret_cast<XrMarkerDetectorCustomProfileInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrMarkerDetectorCustomProfileInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrMarkerDetectorCustomProfileInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = MarkerDetectorCustomProfileInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrMarkerDetectorCustomProfileInfoML*>(this);
  }
  MarkerDetectorFpsML fpsHint;
  MarkerDetectorResolutionML resolutionHint;
  MarkerDetectorCameraML cameraHint;
  MarkerDetectorCornerRefineMethodML cornerRefineMethod;
  Bool32 useEdgeRefinement;
  MarkerDetectorFullAnalysisIntervalML fullAnalysisIntervalHint;
};
static_assert(sizeof(XrMarkerDetectorCustomProfileInfoML) ==
                  sizeof(MarkerDetectorCustomProfileInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrMarkerDetectorCustomProfileInfoML pointer to const from
 * a MarkerDetectorCustomProfileInfoML reference to const.
 * @relates MarkerDetectorCustomProfileInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorCustomProfileInfoML const* get(
    MarkerDetectorCustomProfileInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * MarkerDetectorCustomProfileInfoML as the address of a raw XrMarkerDetectorCustomProfileInfoML
 * @relates MarkerDetectorCustomProfileInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorCustomProfileInfoML* put(
    MarkerDetectorCustomProfileInfoML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * C++ projection of XrMarkerDetectorSnapshotInfoML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorSnapshotInfoML>
 * @xrentity{XrMarkerDetectorSnapshotInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS MarkerDetectorSnapshotInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  MarkerDetectorSnapshotInfoML(const void* next_ = nullptr)

      : Parent(StructureType::MarkerDetectorSnapshotInfoML, next_) {}

  //! Default copy constructor
  MarkerDetectorSnapshotInfoML(const MarkerDetectorSnapshotInfoML& rhs) = default;
  //! Default copy assignment
  MarkerDetectorSnapshotInfoML& operator=(const MarkerDetectorSnapshotInfoML& rhs) = default;
  //! Copy construct from raw
  MarkerDetectorSnapshotInfoML(const XrMarkerDetectorSnapshotInfoML& rhs)
      : MarkerDetectorSnapshotInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  MarkerDetectorSnapshotInfoML& operator=(const XrMarkerDetectorSnapshotInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrMarkerDetectorSnapshotInfoML&() const {
    return *reinterpret_cast<const XrMarkerDetectorSnapshotInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrMarkerDetectorSnapshotInfoML&() {
    return *reinterpret_cast<XrMarkerDetectorSnapshotInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrMarkerDetectorSnapshotInfoML
  XrMarkerDetectorSnapshotInfoML const* get() const noexcept {
    return reinterpret_cast<XrMarkerDetectorSnapshotInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrMarkerDetectorSnapshotInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrMarkerDetectorSnapshotInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = MarkerDetectorSnapshotInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrMarkerDetectorSnapshotInfoML*>(this);
  }
};
static_assert(sizeof(XrMarkerDetectorSnapshotInfoML) == sizeof(MarkerDetectorSnapshotInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrMarkerDetectorSnapshotInfoML pointer to const from a
 * MarkerDetectorSnapshotInfoML reference to const.
 * @relates MarkerDetectorSnapshotInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorSnapshotInfoML const* get(
    MarkerDetectorSnapshotInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing MarkerDetectorSnapshotInfoML
 * as the address of a raw XrMarkerDetectorSnapshotInfoML
 * @relates MarkerDetectorSnapshotInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorSnapshotInfoML* put(MarkerDetectorSnapshotInfoML& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * C++ projection of XrMarkerDetectorStateML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorStateML>
 * @xrentity{XrMarkerDetectorStateML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS MarkerDetectorStateML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  MarkerDetectorStateML(void* next_ = nullptr)

      : Parent(StructureType::MarkerDetectorStateML, next_) {}

  //! Default copy constructor
  MarkerDetectorStateML(const MarkerDetectorStateML& rhs) = default;
  //! Default copy assignment
  MarkerDetectorStateML& operator=(const MarkerDetectorStateML& rhs) = default;
  //! Copy construct from raw
  MarkerDetectorStateML(const XrMarkerDetectorStateML& rhs) : MarkerDetectorStateML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  MarkerDetectorStateML& operator=(const XrMarkerDetectorStateML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrMarkerDetectorStateML&() const {
    return *reinterpret_cast<const XrMarkerDetectorStateML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrMarkerDetectorStateML&() { return *reinterpret_cast<XrMarkerDetectorStateML*>(this); }

  //! Accessor for this as the address of a raw XrMarkerDetectorStateML
  XrMarkerDetectorStateML const* get() const noexcept {
    return reinterpret_cast<XrMarkerDetectorStateML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrMarkerDetectorStateML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrMarkerDetectorStateML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = MarkerDetectorStateML{};
      next = oldNext;
    }
    return reinterpret_cast<XrMarkerDetectorStateML*>(this);
  }
  MarkerDetectorStatusML state;
};
static_assert(sizeof(XrMarkerDetectorStateML) == sizeof(MarkerDetectorStateML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrMarkerDetectorStateML pointer to const from a
 * MarkerDetectorStateML reference to const.
 * @relates MarkerDetectorStateML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorStateML const* get(MarkerDetectorStateML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing MarkerDetectorStateML as the
 * address of a raw XrMarkerDetectorStateML
 * @relates MarkerDetectorStateML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerDetectorStateML* put(MarkerDetectorStateML& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding
/*!
 * C++ projection of XrMarkerSpaceCreateInfoML
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerSpaceCreateInfoML>
 * @xrentity{XrMarkerSpaceCreateInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS MarkerSpaceCreateInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  MarkerSpaceCreateInfoML(const MarkerDetectorML& markerDetector_, const MarkerML& marker_,
                          const Posef& poseInMarkerSpace_, const void* next_ = nullptr)
      : Parent(StructureType::MarkerSpaceCreateInfoML, next_),
        markerDetector{markerDetector_},
        marker{marker_},
        poseInMarkerSpace{poseInMarkerSpace_} {}

  //! Default/empty constructor
  MarkerSpaceCreateInfoML(const void* next_ = nullptr)

      : Parent(StructureType::MarkerSpaceCreateInfoML, next_),
        markerDetector{},
        marker{},
        poseInMarkerSpace{} {}

  //! Default copy constructor
  MarkerSpaceCreateInfoML(const MarkerSpaceCreateInfoML& rhs) = default;
  //! Default copy assignment
  MarkerSpaceCreateInfoML& operator=(const MarkerSpaceCreateInfoML& rhs) = default;
  //! Copy construct from raw
  MarkerSpaceCreateInfoML(const XrMarkerSpaceCreateInfoML& rhs) : MarkerSpaceCreateInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  MarkerSpaceCreateInfoML& operator=(const XrMarkerSpaceCreateInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrMarkerSpaceCreateInfoML&() const {
    return *reinterpret_cast<const XrMarkerSpaceCreateInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrMarkerSpaceCreateInfoML&() {
    return *reinterpret_cast<XrMarkerSpaceCreateInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrMarkerSpaceCreateInfoML
  XrMarkerSpaceCreateInfoML const* get() const noexcept {
    return reinterpret_cast<XrMarkerSpaceCreateInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrMarkerSpaceCreateInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrMarkerSpaceCreateInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = MarkerSpaceCreateInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrMarkerSpaceCreateInfoML*>(this);
  }
  MarkerDetectorML markerDetector;
  MarkerML marker;
  Posef poseInMarkerSpace;
};
static_assert(sizeof(XrMarkerSpaceCreateInfoML) == sizeof(MarkerSpaceCreateInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrMarkerSpaceCreateInfoML pointer to const from a
 * MarkerSpaceCreateInfoML reference to const.
 * @relates MarkerSpaceCreateInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerSpaceCreateInfoML const* get(MarkerSpaceCreateInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing MarkerSpaceCreateInfoML as
 * the address of a raw XrMarkerSpaceCreateInfoML
 * @relates MarkerSpaceCreateInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMarkerSpaceCreateInfoML* put(MarkerSpaceCreateInfoML& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_marker_understanding

#ifdef XR_ML_localization_map
/*!
 * C++ projection of XrLocalizationMapML
 *
 * Provided by the `XR_ML_localization_map` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLocalizationMapML>
 * @xrentity{XrLocalizationMapML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS LocalizationMapML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  LocalizationMapML(void* next_ = nullptr)

      : Parent(StructureType::LocalizationMapML, next_) {}

  //! Default copy constructor
  LocalizationMapML(const LocalizationMapML& rhs) = default;
  //! Default copy assignment
  LocalizationMapML& operator=(const LocalizationMapML& rhs) = default;
  //! Copy construct from raw
  LocalizationMapML(const XrLocalizationMapML& rhs) : LocalizationMapML() { *put() = rhs; }
  //! Copy assign from raw
  LocalizationMapML& operator=(const XrLocalizationMapML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrLocalizationMapML&() const {
    return *reinterpret_cast<const XrLocalizationMapML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrLocalizationMapML&() { return *reinterpret_cast<XrLocalizationMapML*>(this); }

  //! Accessor for this as the address of a raw XrLocalizationMapML
  XrLocalizationMapML const* get() const noexcept {
    return reinterpret_cast<XrLocalizationMapML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrLocalizationMapML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrLocalizationMapML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = LocalizationMapML{};
      next = oldNext;
    }
    return reinterpret_cast<XrLocalizationMapML*>(this);
  }
  char name[XR_MAX_LOCALIZATION_MAP_NAME_LENGTH_ML];
  UuidEXT mapUuid;
  LocalizationMapTypeML mapType;
};
static_assert(sizeof(XrLocalizationMapML) == sizeof(LocalizationMapML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrLocalizationMapML pointer to const from a
 * LocalizationMapML reference to const.
 * @relates LocalizationMapML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLocalizationMapML const* get(LocalizationMapML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing LocalizationMapML as the
 * address of a raw XrLocalizationMapML
 * @relates LocalizationMapML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLocalizationMapML* put(LocalizationMapML& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_localization_map

#ifdef XR_ML_localization_map
/*!
 * C++ projection of XrEventDataLocalizationChangedML
 *
 * Provided by the `XR_ML_localization_map` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataLocalizationChangedML>
 * @xrentity{XrEventDataLocalizationChangedML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataLocalizationChangedML : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataLocalizationChangedML(void* next_ = nullptr)

      : Parent(StructureType::EventDataLocalizationChangedML, next_) {}

  //! Default copy constructor
  EventDataLocalizationChangedML(const EventDataLocalizationChangedML& rhs) = default;
  //! Default copy assignment
  EventDataLocalizationChangedML& operator=(const EventDataLocalizationChangedML& rhs) = default;
  //! Copy construct from raw
  EventDataLocalizationChangedML(const XrEventDataLocalizationChangedML& rhs)
      : EventDataLocalizationChangedML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataLocalizationChangedML& operator=(const XrEventDataLocalizationChangedML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataLocalizationChangedML&() const {
    return *reinterpret_cast<const XrEventDataLocalizationChangedML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataLocalizationChangedML&() {
    return *reinterpret_cast<XrEventDataLocalizationChangedML*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataLocalizationChangedML
  XrEventDataLocalizationChangedML const* get() const noexcept {
    return reinterpret_cast<XrEventDataLocalizationChangedML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataLocalizationChangedML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataLocalizationChangedML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataLocalizationChangedML{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataLocalizationChangedML*>(this);
  }
  Session session;
  LocalizationMapStateML state;
  LocalizationMapML map;
  LocalizationMapConfidenceML confidence;
  LocalizationMapErrorFlagsML errorFlags;
};
static_assert(sizeof(XrEventDataLocalizationChangedML) == sizeof(EventDataLocalizationChangedML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataLocalizationChangedML pointer to const from a
 * EventDataLocalizationChangedML reference to const.
 * @relates EventDataLocalizationChangedML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataLocalizationChangedML const* get(
    EventDataLocalizationChangedML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataLocalizationChangedML as the address of a raw XrEventDataLocalizationChangedML
 * @relates EventDataLocalizationChangedML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataLocalizationChangedML* put(EventDataLocalizationChangedML& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataLocalizationChangedML as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataLocalizationChangedML
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataLocalizationChangedML const& h) {
  return h.get_base();
}
#endif  // XR_ML_localization_map

#ifdef XR_ML_localization_map
/*!
 * C++ projection of XrLocalizationMapQueryInfoBaseHeaderML
 *
 * Provided by the `XR_ML_localization_map` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLocalizationMapQueryInfoBaseHeaderML>
 * @xrentity{XrLocalizationMapQueryInfoBaseHeaderML}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS LocalizationMapQueryInfoBaseHeaderML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  LocalizationMapQueryInfoBaseHeaderML(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrLocalizationMapQueryInfoBaseHeaderML&() const {
    return *reinterpret_cast<const XrLocalizationMapQueryInfoBaseHeaderML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrLocalizationMapQueryInfoBaseHeaderML&() {
    return *reinterpret_cast<XrLocalizationMapQueryInfoBaseHeaderML*>(this);
  }

  //! Accessor for this as the address of a raw XrLocalizationMapQueryInfoBaseHeaderML
  XrLocalizationMapQueryInfoBaseHeaderML const* get() const noexcept {
    return reinterpret_cast<XrLocalizationMapQueryInfoBaseHeaderML const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw
   * XrLocalizationMapQueryInfoBaseHeaderML.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrLocalizationMapQueryInfoBaseHeaderML* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrLocalizationMapQueryInfoBaseHeaderML*>(this);
  }
};
static_assert(sizeof(XrLocalizationMapQueryInfoBaseHeaderML) ==
                  sizeof(LocalizationMapQueryInfoBaseHeaderML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrLocalizationMapQueryInfoBaseHeaderML pointer to const
 * from a LocalizationMapQueryInfoBaseHeaderML reference to const.
 * @relates LocalizationMapQueryInfoBaseHeaderML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLocalizationMapQueryInfoBaseHeaderML const* get(
    LocalizationMapQueryInfoBaseHeaderML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * LocalizationMapQueryInfoBaseHeaderML as the address of a raw
 * XrLocalizationMapQueryInfoBaseHeaderML
 * @relates LocalizationMapQueryInfoBaseHeaderML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLocalizationMapQueryInfoBaseHeaderML* put(
    LocalizationMapQueryInfoBaseHeaderML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_localization_map

#ifdef XR_ML_localization_map
/*!
 * C++ projection of XrMapLocalizationRequestInfoML
 *
 * Provided by the `XR_ML_localization_map` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMapLocalizationRequestInfoML>
 * @xrentity{XrMapLocalizationRequestInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS MapLocalizationRequestInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  MapLocalizationRequestInfoML(const UuidEXT& mapUuid_, const void* next_ = nullptr)
      : Parent(StructureType::MapLocalizationRequestInfoML, next_), mapUuid{mapUuid_} {}

  //! Default/empty constructor
  MapLocalizationRequestInfoML(const void* next_ = nullptr)

      : Parent(StructureType::MapLocalizationRequestInfoML, next_), mapUuid{} {}

  //! Default copy constructor
  MapLocalizationRequestInfoML(const MapLocalizationRequestInfoML& rhs) = default;
  //! Default copy assignment
  MapLocalizationRequestInfoML& operator=(const MapLocalizationRequestInfoML& rhs) = default;
  //! Copy construct from raw
  MapLocalizationRequestInfoML(const XrMapLocalizationRequestInfoML& rhs)
      : MapLocalizationRequestInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  MapLocalizationRequestInfoML& operator=(const XrMapLocalizationRequestInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrMapLocalizationRequestInfoML&() const {
    return *reinterpret_cast<const XrMapLocalizationRequestInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrMapLocalizationRequestInfoML&() {
    return *reinterpret_cast<XrMapLocalizationRequestInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrMapLocalizationRequestInfoML
  XrMapLocalizationRequestInfoML const* get() const noexcept {
    return reinterpret_cast<XrMapLocalizationRequestInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrMapLocalizationRequestInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrMapLocalizationRequestInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = MapLocalizationRequestInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrMapLocalizationRequestInfoML*>(this);
  }
  UuidEXT mapUuid;
};
static_assert(sizeof(XrMapLocalizationRequestInfoML) == sizeof(MapLocalizationRequestInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrMapLocalizationRequestInfoML pointer to const from a
 * MapLocalizationRequestInfoML reference to const.
 * @relates MapLocalizationRequestInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMapLocalizationRequestInfoML const* get(
    MapLocalizationRequestInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing MapLocalizationRequestInfoML
 * as the address of a raw XrMapLocalizationRequestInfoML
 * @relates MapLocalizationRequestInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrMapLocalizationRequestInfoML* put(MapLocalizationRequestInfoML& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_localization_map

#ifdef XR_ML_localization_map
/*!
 * C++ projection of XrLocalizationMapImportInfoML
 *
 * Provided by the `XR_ML_localization_map` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLocalizationMapImportInfoML>
 * @xrentity{XrLocalizationMapImportInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS LocalizationMapImportInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  LocalizationMapImportInfoML(uint32_t size_, char* data_, const void* next_ = nullptr)
      : Parent(StructureType::LocalizationMapImportInfoML, next_), size{size_}, data{data_} {}

  //! Default/empty constructor
  LocalizationMapImportInfoML(const void* next_ = nullptr)

      : Parent(StructureType::LocalizationMapImportInfoML, next_), size{0}, data{nullptr} {}

  //! Default copy constructor
  LocalizationMapImportInfoML(const LocalizationMapImportInfoML& rhs) = default;
  //! Default copy assignment
  LocalizationMapImportInfoML& operator=(const LocalizationMapImportInfoML& rhs) = default;
  //! Copy construct from raw
  LocalizationMapImportInfoML(const XrLocalizationMapImportInfoML& rhs)
      : LocalizationMapImportInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  LocalizationMapImportInfoML& operator=(const XrLocalizationMapImportInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrLocalizationMapImportInfoML&() const {
    return *reinterpret_cast<const XrLocalizationMapImportInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrLocalizationMapImportInfoML&() {
    return *reinterpret_cast<XrLocalizationMapImportInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrLocalizationMapImportInfoML
  XrLocalizationMapImportInfoML const* get() const noexcept {
    return reinterpret_cast<XrLocalizationMapImportInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrLocalizationMapImportInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrLocalizationMapImportInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = LocalizationMapImportInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrLocalizationMapImportInfoML*>(this);
  }
  uint32_t size;
  char* data;
};
static_assert(sizeof(XrLocalizationMapImportInfoML) == sizeof(LocalizationMapImportInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrLocalizationMapImportInfoML pointer to const from a
 * LocalizationMapImportInfoML reference to const.
 * @relates LocalizationMapImportInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLocalizationMapImportInfoML const* get(
    LocalizationMapImportInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing LocalizationMapImportInfoML
 * as the address of a raw XrLocalizationMapImportInfoML
 * @relates LocalizationMapImportInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLocalizationMapImportInfoML* put(LocalizationMapImportInfoML& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_localization_map

#ifdef XR_ML_localization_map
/*!
 * C++ projection of XrLocalizationEnableEventsInfoML
 *
 * Provided by the `XR_ML_localization_map` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLocalizationEnableEventsInfoML>
 * @xrentity{XrLocalizationEnableEventsInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS LocalizationEnableEventsInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  LocalizationEnableEventsInfoML(const Bool32& enabled_, const void* next_ = nullptr)
      : Parent(StructureType::LocalizationEnableEventsInfoML, next_), enabled{enabled_} {}

  //! Default/empty constructor
  LocalizationEnableEventsInfoML(const void* next_ = nullptr)

      : Parent(StructureType::LocalizationEnableEventsInfoML, next_), enabled{false} {}

  //! Default copy constructor
  LocalizationEnableEventsInfoML(const LocalizationEnableEventsInfoML& rhs) = default;
  //! Default copy assignment
  LocalizationEnableEventsInfoML& operator=(const LocalizationEnableEventsInfoML& rhs) = default;
  //! Copy construct from raw
  LocalizationEnableEventsInfoML(const XrLocalizationEnableEventsInfoML& rhs)
      : LocalizationEnableEventsInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  LocalizationEnableEventsInfoML& operator=(const XrLocalizationEnableEventsInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrLocalizationEnableEventsInfoML&() const {
    return *reinterpret_cast<const XrLocalizationEnableEventsInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrLocalizationEnableEventsInfoML&() {
    return *reinterpret_cast<XrLocalizationEnableEventsInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrLocalizationEnableEventsInfoML
  XrLocalizationEnableEventsInfoML const* get() const noexcept {
    return reinterpret_cast<XrLocalizationEnableEventsInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrLocalizationEnableEventsInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrLocalizationEnableEventsInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = LocalizationEnableEventsInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrLocalizationEnableEventsInfoML*>(this);
  }
  Bool32 enabled;
};
static_assert(sizeof(XrLocalizationEnableEventsInfoML) == sizeof(LocalizationEnableEventsInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrLocalizationEnableEventsInfoML pointer to const from a
 * LocalizationEnableEventsInfoML reference to const.
 * @relates LocalizationEnableEventsInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLocalizationEnableEventsInfoML const* get(
    LocalizationEnableEventsInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * LocalizationEnableEventsInfoML as the address of a raw XrLocalizationEnableEventsInfoML
 * @relates LocalizationEnableEventsInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLocalizationEnableEventsInfoML* put(LocalizationEnableEventsInfoML& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_localization_map

#ifdef XR_ML_spatial_anchors
/*!
 * C++ projection of XrSpatialAnchorsCreateInfoBaseHeaderML
 *
 * Provided by the `XR_ML_spatial_anchors` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsCreateInfoBaseHeaderML>
 * @xrentity{XrSpatialAnchorsCreateInfoBaseHeaderML}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsCreateInfoBaseHeaderML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  SpatialAnchorsCreateInfoBaseHeaderML(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsCreateInfoBaseHeaderML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsCreateInfoBaseHeaderML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsCreateInfoBaseHeaderML&() {
    return *reinterpret_cast<XrSpatialAnchorsCreateInfoBaseHeaderML*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorsCreateInfoBaseHeaderML
  XrSpatialAnchorsCreateInfoBaseHeaderML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsCreateInfoBaseHeaderML const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw
   * XrSpatialAnchorsCreateInfoBaseHeaderML.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrSpatialAnchorsCreateInfoBaseHeaderML* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrSpatialAnchorsCreateInfoBaseHeaderML*>(this);
  }
};
static_assert(sizeof(XrSpatialAnchorsCreateInfoBaseHeaderML) ==
                  sizeof(SpatialAnchorsCreateInfoBaseHeaderML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsCreateInfoBaseHeaderML pointer to const
 * from a SpatialAnchorsCreateInfoBaseHeaderML reference to const.
 * @relates SpatialAnchorsCreateInfoBaseHeaderML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsCreateInfoBaseHeaderML const* get(
    SpatialAnchorsCreateInfoBaseHeaderML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsCreateInfoBaseHeaderML as the address of a raw
 * XrSpatialAnchorsCreateInfoBaseHeaderML
 * @relates SpatialAnchorsCreateInfoBaseHeaderML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsCreateInfoBaseHeaderML* put(
    SpatialAnchorsCreateInfoBaseHeaderML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_spatial_anchors

#ifdef XR_ML_spatial_anchors
/*!
 * C++ projection of XrSpatialAnchorsCreateInfoFromPoseML
 *
 * Provided by the `XR_ML_spatial_anchors` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsCreateInfoFromPoseML>
 * @xrentity{XrSpatialAnchorsCreateInfoFromPoseML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsCreateInfoFromPoseML
    : public SpatialAnchorsCreateInfoBaseHeaderML {
private:
  using Parent = SpatialAnchorsCreateInfoBaseHeaderML;

public:
  //! Constructor initializing all members.
  SpatialAnchorsCreateInfoFromPoseML(const Space& baseSpace_, const Posef& poseInBaseSpace_,
                                     const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorsCreateInfoFromPoseML, next_),
        baseSpace{baseSpace_},
        poseInBaseSpace{poseInBaseSpace_},
        time{time_} {}

  //! Default/empty constructor
  SpatialAnchorsCreateInfoFromPoseML(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsCreateInfoFromPoseML, next_),
        baseSpace{},
        poseInBaseSpace{},
        time{} {}

  //! Default copy constructor
  SpatialAnchorsCreateInfoFromPoseML(const SpatialAnchorsCreateInfoFromPoseML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorsCreateInfoFromPoseML& operator=(const SpatialAnchorsCreateInfoFromPoseML& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorsCreateInfoFromPoseML(const XrSpatialAnchorsCreateInfoFromPoseML& rhs)
      : SpatialAnchorsCreateInfoFromPoseML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsCreateInfoFromPoseML& operator=(const XrSpatialAnchorsCreateInfoFromPoseML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsCreateInfoFromPoseML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsCreateInfoFromPoseML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsCreateInfoFromPoseML&() {
    return *reinterpret_cast<XrSpatialAnchorsCreateInfoFromPoseML*>(this);
  }

  //! Accessor for this as a raw, base XrSpatialAnchorsCreateInfoBaseHeaderML const pointer
  XrSpatialAnchorsCreateInfoBaseHeaderML const* get_base() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsCreateInfoBaseHeaderML const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialAnchorsCreateInfoFromPoseML
  XrSpatialAnchorsCreateInfoFromPoseML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsCreateInfoFromPoseML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsCreateInfoFromPoseML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsCreateInfoFromPoseML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsCreateInfoFromPoseML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsCreateInfoFromPoseML*>(this);
  }
  Space baseSpace;
  Posef poseInBaseSpace;
  Time time;
};
static_assert(sizeof(XrSpatialAnchorsCreateInfoFromPoseML) ==
                  sizeof(SpatialAnchorsCreateInfoFromPoseML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsCreateInfoFromPoseML pointer to const from
 * a SpatialAnchorsCreateInfoFromPoseML reference to const.
 * @relates SpatialAnchorsCreateInfoFromPoseML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsCreateInfoFromPoseML const* get(
    SpatialAnchorsCreateInfoFromPoseML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsCreateInfoFromPoseML as the address of a raw XrSpatialAnchorsCreateInfoFromPoseML
 * @relates SpatialAnchorsCreateInfoFromPoseML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsCreateInfoFromPoseML* put(
    SpatialAnchorsCreateInfoFromPoseML& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpatialAnchorsCreateInfoFromPoseML as a
 * raw, pointer to const XrSpatialAnchorsCreateInfoBaseHeaderML (the base type)
 * @relates SpatialAnchorsCreateInfoFromPoseML
 * @relatesalso SpatialAnchorsCreateInfoBaseHeaderML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsCreateInfoBaseHeaderML const* get_base(
    SpatialAnchorsCreateInfoFromPoseML const& h) {
  return h.get_base();
}
#endif  // XR_ML_spatial_anchors

#ifdef XR_EXT_future
/*!
 * C++ projection of XrFutureCompletionBaseHeaderEXT
 *
 * Provided by the `XR_EXT_future` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFutureCompletionBaseHeaderEXT>
 * @xrentity{XrFutureCompletionBaseHeaderEXT}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS FutureCompletionBaseHeaderEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  FutureCompletionBaseHeaderEXT(StructureType type_, const Result& futureResult_,
                                void* next_ = nullptr)
      : Parent(type_, next_), futureResult{futureResult_} {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFutureCompletionBaseHeaderEXT&() const {
    return *reinterpret_cast<const XrFutureCompletionBaseHeaderEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFutureCompletionBaseHeaderEXT&() {
    return *reinterpret_cast<XrFutureCompletionBaseHeaderEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrFutureCompletionBaseHeaderEXT
  XrFutureCompletionBaseHeaderEXT const* get() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw XrFutureCompletionBaseHeaderEXT.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrFutureCompletionBaseHeaderEXT* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT*>(this);
  }
  Result futureResult;
};
static_assert(sizeof(XrFutureCompletionBaseHeaderEXT) == sizeof(FutureCompletionBaseHeaderEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFutureCompletionBaseHeaderEXT pointer to const from a
 * FutureCompletionBaseHeaderEXT reference to const.
 * @relates FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get(
    FutureCompletionBaseHeaderEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FutureCompletionBaseHeaderEXT
 * as the address of a raw XrFutureCompletionBaseHeaderEXT
 * @relates FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT* put(FutureCompletionBaseHeaderEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_future

#ifdef XR_ML_spatial_anchors
/*!
 * C++ projection of XrCreateSpatialAnchorsCompletionML
 *
 * Provided by the `XR_ML_spatial_anchors` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCreateSpatialAnchorsCompletionML>
 * @xrentity{XrCreateSpatialAnchorsCompletionML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CreateSpatialAnchorsCompletionML : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  CreateSpatialAnchorsCompletionML(void* next_ = nullptr)

      : Parent(StructureType::CreateSpatialAnchorsCompletionML, {}, next_) {}

  //! Default copy constructor
  CreateSpatialAnchorsCompletionML(const CreateSpatialAnchorsCompletionML& rhs) = default;
  //! Default copy assignment
  CreateSpatialAnchorsCompletionML& operator=(const CreateSpatialAnchorsCompletionML& rhs) =
      default;
  //! Copy construct from raw
  CreateSpatialAnchorsCompletionML(const XrCreateSpatialAnchorsCompletionML& rhs)
      : CreateSpatialAnchorsCompletionML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CreateSpatialAnchorsCompletionML& operator=(const XrCreateSpatialAnchorsCompletionML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCreateSpatialAnchorsCompletionML&() const {
    return *reinterpret_cast<const XrCreateSpatialAnchorsCompletionML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCreateSpatialAnchorsCompletionML&() {
    return *reinterpret_cast<XrCreateSpatialAnchorsCompletionML*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrCreateSpatialAnchorsCompletionML
  XrCreateSpatialAnchorsCompletionML const* get() const noexcept {
    return reinterpret_cast<XrCreateSpatialAnchorsCompletionML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCreateSpatialAnchorsCompletionML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCreateSpatialAnchorsCompletionML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CreateSpatialAnchorsCompletionML{};
      next = oldNext;
    }
    return reinterpret_cast<XrCreateSpatialAnchorsCompletionML*>(this);
  }
  uint32_t spaceCount;
  Space* spaces;
};
static_assert(sizeof(XrCreateSpatialAnchorsCompletionML) ==
                  sizeof(CreateSpatialAnchorsCompletionML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCreateSpatialAnchorsCompletionML pointer to const from a
 * CreateSpatialAnchorsCompletionML reference to const.
 * @relates CreateSpatialAnchorsCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCreateSpatialAnchorsCompletionML const* get(
    CreateSpatialAnchorsCompletionML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CreateSpatialAnchorsCompletionML as the address of a raw XrCreateSpatialAnchorsCompletionML
 * @relates CreateSpatialAnchorsCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCreateSpatialAnchorsCompletionML* put(
    CreateSpatialAnchorsCompletionML& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CreateSpatialAnchorsCompletionML as a raw,
 * pointer to const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates CreateSpatialAnchorsCompletionML
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    CreateSpatialAnchorsCompletionML const& h) {
  return h.get_base();
}
#endif  // XR_ML_spatial_anchors

#ifdef XR_ML_spatial_anchors
/*!
 * C++ projection of XrSpatialAnchorStateML
 *
 * Provided by the `XR_ML_spatial_anchors` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorStateML>
 * @xrentity{XrSpatialAnchorStateML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorStateML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialAnchorStateML(void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorStateML, next_) {}

  //! Default copy constructor
  SpatialAnchorStateML(const SpatialAnchorStateML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorStateML& operator=(const SpatialAnchorStateML& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorStateML(const XrSpatialAnchorStateML& rhs) : SpatialAnchorStateML() { *put() = rhs; }
  //! Copy assign from raw
  SpatialAnchorStateML& operator=(const XrSpatialAnchorStateML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorStateML&() const {
    return *reinterpret_cast<const XrSpatialAnchorStateML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorStateML&() { return *reinterpret_cast<XrSpatialAnchorStateML*>(this); }

  //! Accessor for this as the address of a raw XrSpatialAnchorStateML
  XrSpatialAnchorStateML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorStateML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpatialAnchorStateML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorStateML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorStateML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorStateML*>(this);
  }
  SpatialAnchorConfidenceML confidence;
};
static_assert(sizeof(XrSpatialAnchorStateML) == sizeof(SpatialAnchorStateML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorStateML pointer to const from a
 * SpatialAnchorStateML reference to const.
 * @relates SpatialAnchorStateML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorStateML const* get(SpatialAnchorStateML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorStateML as the
 * address of a raw XrSpatialAnchorStateML
 * @relates SpatialAnchorStateML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorStateML* put(SpatialAnchorStateML& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_spatial_anchors

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsCreateStorageInfoML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsCreateStorageInfoML>
 * @xrentity{XrSpatialAnchorsCreateStorageInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsCreateStorageInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SpatialAnchorsCreateStorageInfoML(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsCreateStorageInfoML, next_) {}

  //! Default copy constructor
  SpatialAnchorsCreateStorageInfoML(const SpatialAnchorsCreateStorageInfoML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorsCreateStorageInfoML& operator=(const SpatialAnchorsCreateStorageInfoML& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorsCreateStorageInfoML(const XrSpatialAnchorsCreateStorageInfoML& rhs)
      : SpatialAnchorsCreateStorageInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsCreateStorageInfoML& operator=(const XrSpatialAnchorsCreateStorageInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsCreateStorageInfoML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsCreateStorageInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsCreateStorageInfoML&() {
    return *reinterpret_cast<XrSpatialAnchorsCreateStorageInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorsCreateStorageInfoML
  XrSpatialAnchorsCreateStorageInfoML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsCreateStorageInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsCreateStorageInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsCreateStorageInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsCreateStorageInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsCreateStorageInfoML*>(this);
  }
};
static_assert(sizeof(XrSpatialAnchorsCreateStorageInfoML) ==
                  sizeof(SpatialAnchorsCreateStorageInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsCreateStorageInfoML pointer to const from
 * a SpatialAnchorsCreateStorageInfoML reference to const.
 * @relates SpatialAnchorsCreateStorageInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsCreateStorageInfoML const* get(
    SpatialAnchorsCreateStorageInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsCreateStorageInfoML as the address of a raw XrSpatialAnchorsCreateStorageInfoML
 * @relates SpatialAnchorsCreateStorageInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsCreateStorageInfoML* put(
    SpatialAnchorsCreateStorageInfoML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsQueryInfoBaseHeaderML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsQueryInfoBaseHeaderML>
 * @xrentity{XrSpatialAnchorsQueryInfoBaseHeaderML}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsQueryInfoBaseHeaderML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  SpatialAnchorsQueryInfoBaseHeaderML(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsQueryInfoBaseHeaderML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsQueryInfoBaseHeaderML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsQueryInfoBaseHeaderML&() {
    return *reinterpret_cast<XrSpatialAnchorsQueryInfoBaseHeaderML*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorsQueryInfoBaseHeaderML
  XrSpatialAnchorsQueryInfoBaseHeaderML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsQueryInfoBaseHeaderML const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw XrSpatialAnchorsQueryInfoBaseHeaderML.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrSpatialAnchorsQueryInfoBaseHeaderML* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrSpatialAnchorsQueryInfoBaseHeaderML*>(this);
  }
};
static_assert(sizeof(XrSpatialAnchorsQueryInfoBaseHeaderML) ==
                  sizeof(SpatialAnchorsQueryInfoBaseHeaderML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsQueryInfoBaseHeaderML pointer to const
 * from a SpatialAnchorsQueryInfoBaseHeaderML reference to const.
 * @relates SpatialAnchorsQueryInfoBaseHeaderML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsQueryInfoBaseHeaderML const* get(
    SpatialAnchorsQueryInfoBaseHeaderML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsQueryInfoBaseHeaderML as the address of a raw XrSpatialAnchorsQueryInfoBaseHeaderML
 * @relates SpatialAnchorsQueryInfoBaseHeaderML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsQueryInfoBaseHeaderML* put(
    SpatialAnchorsQueryInfoBaseHeaderML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsQueryInfoRadiusML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsQueryInfoRadiusML>
 * @xrentity{XrSpatialAnchorsQueryInfoRadiusML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsQueryInfoRadiusML : public SpatialAnchorsQueryInfoBaseHeaderML {
private:
  using Parent = SpatialAnchorsQueryInfoBaseHeaderML;

public:
  //! Constructor initializing all members.
  SpatialAnchorsQueryInfoRadiusML(const Space& baseSpace_, const Vector3f& center_,
                                  const Time& time_, float radius_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorsQueryInfoRadiusML, next_),
        baseSpace{baseSpace_},
        center{center_},
        time{time_},
        radius{radius_} {}

  //! Default/empty constructor
  SpatialAnchorsQueryInfoRadiusML(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsQueryInfoRadiusML, next_),
        baseSpace{},
        center{},
        time{},
        radius{0.0f} {}

  //! Default copy constructor
  SpatialAnchorsQueryInfoRadiusML(const SpatialAnchorsQueryInfoRadiusML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorsQueryInfoRadiusML& operator=(const SpatialAnchorsQueryInfoRadiusML& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorsQueryInfoRadiusML(const XrSpatialAnchorsQueryInfoRadiusML& rhs)
      : SpatialAnchorsQueryInfoRadiusML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsQueryInfoRadiusML& operator=(const XrSpatialAnchorsQueryInfoRadiusML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsQueryInfoRadiusML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsQueryInfoRadiusML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsQueryInfoRadiusML&() {
    return *reinterpret_cast<XrSpatialAnchorsQueryInfoRadiusML*>(this);
  }

  //! Accessor for this as a raw, base XrSpatialAnchorsQueryInfoBaseHeaderML const pointer
  XrSpatialAnchorsQueryInfoBaseHeaderML const* get_base() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsQueryInfoBaseHeaderML const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialAnchorsQueryInfoRadiusML
  XrSpatialAnchorsQueryInfoRadiusML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsQueryInfoRadiusML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsQueryInfoRadiusML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsQueryInfoRadiusML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsQueryInfoRadiusML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsQueryInfoRadiusML*>(this);
  }
  Space baseSpace;
  Vector3f center;
  Time time;
  float radius;
};
static_assert(sizeof(XrSpatialAnchorsQueryInfoRadiusML) == sizeof(SpatialAnchorsQueryInfoRadiusML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsQueryInfoRadiusML pointer to const from a
 * SpatialAnchorsQueryInfoRadiusML reference to const.
 * @relates SpatialAnchorsQueryInfoRadiusML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsQueryInfoRadiusML const* get(
    SpatialAnchorsQueryInfoRadiusML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsQueryInfoRadiusML as the address of a raw XrSpatialAnchorsQueryInfoRadiusML
 * @relates SpatialAnchorsQueryInfoRadiusML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsQueryInfoRadiusML* put(SpatialAnchorsQueryInfoRadiusML& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpatialAnchorsQueryInfoRadiusML as a raw,
 * pointer to const XrSpatialAnchorsQueryInfoBaseHeaderML (the base type)
 * @relates SpatialAnchorsQueryInfoRadiusML
 * @relatesalso SpatialAnchorsQueryInfoBaseHeaderML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsQueryInfoBaseHeaderML const* get_base(
    SpatialAnchorsQueryInfoRadiusML const& h) {
  return h.get_base();
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsQueryCompletionML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsQueryCompletionML>
 * @xrentity{XrSpatialAnchorsQueryCompletionML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsQueryCompletionML : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialAnchorsQueryCompletionML(void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsQueryCompletionML, {}, next_) {}

  //! Default copy constructor
  SpatialAnchorsQueryCompletionML(const SpatialAnchorsQueryCompletionML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorsQueryCompletionML& operator=(const SpatialAnchorsQueryCompletionML& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorsQueryCompletionML(const XrSpatialAnchorsQueryCompletionML& rhs)
      : SpatialAnchorsQueryCompletionML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsQueryCompletionML& operator=(const XrSpatialAnchorsQueryCompletionML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsQueryCompletionML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsQueryCompletionML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsQueryCompletionML&() {
    return *reinterpret_cast<XrSpatialAnchorsQueryCompletionML*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialAnchorsQueryCompletionML
  XrSpatialAnchorsQueryCompletionML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsQueryCompletionML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsQueryCompletionML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsQueryCompletionML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsQueryCompletionML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsQueryCompletionML*>(this);
  }
  uint32_t uuidCapacityInput;
  uint32_t uuidCountOutput;
  UuidEXT* uuids;
};
static_assert(sizeof(XrSpatialAnchorsQueryCompletionML) == sizeof(SpatialAnchorsQueryCompletionML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsQueryCompletionML pointer to const from a
 * SpatialAnchorsQueryCompletionML reference to const.
 * @relates SpatialAnchorsQueryCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsQueryCompletionML const* get(
    SpatialAnchorsQueryCompletionML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsQueryCompletionML as the address of a raw XrSpatialAnchorsQueryCompletionML
 * @relates SpatialAnchorsQueryCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsQueryCompletionML* put(SpatialAnchorsQueryCompletionML& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpatialAnchorsQueryCompletionML as a raw,
 * pointer to const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates SpatialAnchorsQueryCompletionML
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    SpatialAnchorsQueryCompletionML const& h) {
  return h.get_base();
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsCreateInfoFromUuidsML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsCreateInfoFromUuidsML>
 * @xrentity{XrSpatialAnchorsCreateInfoFromUuidsML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsCreateInfoFromUuidsML
    : public SpatialAnchorsCreateInfoBaseHeaderML {
private:
  using Parent = SpatialAnchorsCreateInfoBaseHeaderML;

public:
  //! Constructor initializing all members.
  SpatialAnchorsCreateInfoFromUuidsML(const SpatialAnchorsStorageML& storage_, uint32_t uuidCount_,
                                      const UuidEXT* uuids_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorsCreateInfoFromUuidsML, next_),
        storage{storage_},
        uuidCount{uuidCount_},
        uuids{uuids_} {}

  //! Default/empty constructor
  SpatialAnchorsCreateInfoFromUuidsML(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsCreateInfoFromUuidsML, next_),
        storage{},
        uuidCount{0},
        uuids{nullptr} {}

  //! Default copy constructor
  SpatialAnchorsCreateInfoFromUuidsML(const SpatialAnchorsCreateInfoFromUuidsML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorsCreateInfoFromUuidsML& operator=(const SpatialAnchorsCreateInfoFromUuidsML& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorsCreateInfoFromUuidsML(const XrSpatialAnchorsCreateInfoFromUuidsML& rhs)
      : SpatialAnchorsCreateInfoFromUuidsML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsCreateInfoFromUuidsML& operator=(const XrSpatialAnchorsCreateInfoFromUuidsML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsCreateInfoFromUuidsML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsCreateInfoFromUuidsML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsCreateInfoFromUuidsML&() {
    return *reinterpret_cast<XrSpatialAnchorsCreateInfoFromUuidsML*>(this);
  }

  //! Accessor for this as a raw, base XrSpatialAnchorsCreateInfoBaseHeaderML const pointer
  XrSpatialAnchorsCreateInfoBaseHeaderML const* get_base() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsCreateInfoBaseHeaderML const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialAnchorsCreateInfoFromUuidsML
  XrSpatialAnchorsCreateInfoFromUuidsML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsCreateInfoFromUuidsML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsCreateInfoFromUuidsML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsCreateInfoFromUuidsML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsCreateInfoFromUuidsML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsCreateInfoFromUuidsML*>(this);
  }
  SpatialAnchorsStorageML storage;
  uint32_t uuidCount;
  const UuidEXT* uuids;
};
static_assert(sizeof(XrSpatialAnchorsCreateInfoFromUuidsML) ==
                  sizeof(SpatialAnchorsCreateInfoFromUuidsML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsCreateInfoFromUuidsML pointer to const
 * from a SpatialAnchorsCreateInfoFromUuidsML reference to const.
 * @relates SpatialAnchorsCreateInfoFromUuidsML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsCreateInfoFromUuidsML const* get(
    SpatialAnchorsCreateInfoFromUuidsML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsCreateInfoFromUuidsML as the address of a raw XrSpatialAnchorsCreateInfoFromUuidsML
 * @relates SpatialAnchorsCreateInfoFromUuidsML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsCreateInfoFromUuidsML* put(
    SpatialAnchorsCreateInfoFromUuidsML& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpatialAnchorsCreateInfoFromUuidsML as a
 * raw, pointer to const XrSpatialAnchorsCreateInfoBaseHeaderML (the base type)
 * @relates SpatialAnchorsCreateInfoFromUuidsML
 * @relatesalso SpatialAnchorsCreateInfoBaseHeaderML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsCreateInfoBaseHeaderML const* get_base(
    SpatialAnchorsCreateInfoFromUuidsML const& h) {
  return h.get_base();
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsPublishInfoML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsPublishInfoML>
 * @xrentity{XrSpatialAnchorsPublishInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsPublishInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorsPublishInfoML(uint32_t anchorCount_, const Space* anchors_, uint64_t expiration_,
                              const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorsPublishInfoML, next_),
        anchorCount{anchorCount_},
        anchors{anchors_},
        expiration{expiration_} {}

  //! Default/empty constructor
  SpatialAnchorsPublishInfoML(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsPublishInfoML, next_),
        anchorCount{0},
        anchors{nullptr},
        expiration{0} {}

  //! Default copy constructor
  SpatialAnchorsPublishInfoML(const SpatialAnchorsPublishInfoML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorsPublishInfoML& operator=(const SpatialAnchorsPublishInfoML& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorsPublishInfoML(const XrSpatialAnchorsPublishInfoML& rhs)
      : SpatialAnchorsPublishInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsPublishInfoML& operator=(const XrSpatialAnchorsPublishInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsPublishInfoML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsPublishInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsPublishInfoML&() {
    return *reinterpret_cast<XrSpatialAnchorsPublishInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorsPublishInfoML
  XrSpatialAnchorsPublishInfoML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsPublishInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsPublishInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsPublishInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsPublishInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsPublishInfoML*>(this);
  }
  uint32_t anchorCount;
  const Space* anchors;
  uint64_t expiration;
};
static_assert(sizeof(XrSpatialAnchorsPublishInfoML) == sizeof(SpatialAnchorsPublishInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsPublishInfoML pointer to const from a
 * SpatialAnchorsPublishInfoML reference to const.
 * @relates SpatialAnchorsPublishInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsPublishInfoML const* get(
    SpatialAnchorsPublishInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorsPublishInfoML
 * as the address of a raw XrSpatialAnchorsPublishInfoML
 * @relates SpatialAnchorsPublishInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsPublishInfoML* put(SpatialAnchorsPublishInfoML& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsPublishCompletionML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsPublishCompletionML>
 * @xrentity{XrSpatialAnchorsPublishCompletionML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsPublishCompletionML : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialAnchorsPublishCompletionML(void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsPublishCompletionML, {}, next_) {}

  //! Default copy constructor
  SpatialAnchorsPublishCompletionML(const SpatialAnchorsPublishCompletionML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorsPublishCompletionML& operator=(const SpatialAnchorsPublishCompletionML& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorsPublishCompletionML(const XrSpatialAnchorsPublishCompletionML& rhs)
      : SpatialAnchorsPublishCompletionML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsPublishCompletionML& operator=(const XrSpatialAnchorsPublishCompletionML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsPublishCompletionML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsPublishCompletionML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsPublishCompletionML&() {
    return *reinterpret_cast<XrSpatialAnchorsPublishCompletionML*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialAnchorsPublishCompletionML
  XrSpatialAnchorsPublishCompletionML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsPublishCompletionML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsPublishCompletionML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsPublishCompletionML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsPublishCompletionML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsPublishCompletionML*>(this);
  }
  uint32_t uuidCount;
  UuidEXT* uuids;
};
static_assert(sizeof(XrSpatialAnchorsPublishCompletionML) ==
                  sizeof(SpatialAnchorsPublishCompletionML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsPublishCompletionML pointer to const from
 * a SpatialAnchorsPublishCompletionML reference to const.
 * @relates SpatialAnchorsPublishCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsPublishCompletionML const* get(
    SpatialAnchorsPublishCompletionML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsPublishCompletionML as the address of a raw XrSpatialAnchorsPublishCompletionML
 * @relates SpatialAnchorsPublishCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsPublishCompletionML* put(
    SpatialAnchorsPublishCompletionML& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpatialAnchorsPublishCompletionML as a
 * raw, pointer to const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates SpatialAnchorsPublishCompletionML
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    SpatialAnchorsPublishCompletionML const& h) {
  return h.get_base();
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsDeleteInfoML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsDeleteInfoML>
 * @xrentity{XrSpatialAnchorsDeleteInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsDeleteInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorsDeleteInfoML(uint32_t uuidCount_, const UuidEXT* uuids_,
                             const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorsDeleteInfoML, next_),
        uuidCount{uuidCount_},
        uuids{uuids_} {}

  //! Default/empty constructor
  SpatialAnchorsDeleteInfoML(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsDeleteInfoML, next_), uuidCount{0}, uuids{nullptr} {}

  //! Default copy constructor
  SpatialAnchorsDeleteInfoML(const SpatialAnchorsDeleteInfoML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorsDeleteInfoML& operator=(const SpatialAnchorsDeleteInfoML& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorsDeleteInfoML(const XrSpatialAnchorsDeleteInfoML& rhs)
      : SpatialAnchorsDeleteInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsDeleteInfoML& operator=(const XrSpatialAnchorsDeleteInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsDeleteInfoML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsDeleteInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsDeleteInfoML&() {
    return *reinterpret_cast<XrSpatialAnchorsDeleteInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorsDeleteInfoML
  XrSpatialAnchorsDeleteInfoML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsDeleteInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsDeleteInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsDeleteInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsDeleteInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsDeleteInfoML*>(this);
  }
  uint32_t uuidCount;
  const UuidEXT* uuids;
};
static_assert(sizeof(XrSpatialAnchorsDeleteInfoML) == sizeof(SpatialAnchorsDeleteInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsDeleteInfoML pointer to const from a
 * SpatialAnchorsDeleteInfoML reference to const.
 * @relates SpatialAnchorsDeleteInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsDeleteInfoML const* get(
    SpatialAnchorsDeleteInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorsDeleteInfoML as
 * the address of a raw XrSpatialAnchorsDeleteInfoML
 * @relates SpatialAnchorsDeleteInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsDeleteInfoML* put(SpatialAnchorsDeleteInfoML& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsDeleteCompletionML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsDeleteCompletionML>
 * @xrentity{XrSpatialAnchorsDeleteCompletionML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsDeleteCompletionML : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialAnchorsDeleteCompletionML(void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsDeleteCompletionML, {}, next_) {}

  //! Default copy constructor
  SpatialAnchorsDeleteCompletionML(const SpatialAnchorsDeleteCompletionML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorsDeleteCompletionML& operator=(const SpatialAnchorsDeleteCompletionML& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorsDeleteCompletionML(const XrSpatialAnchorsDeleteCompletionML& rhs)
      : SpatialAnchorsDeleteCompletionML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsDeleteCompletionML& operator=(const XrSpatialAnchorsDeleteCompletionML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsDeleteCompletionML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsDeleteCompletionML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsDeleteCompletionML&() {
    return *reinterpret_cast<XrSpatialAnchorsDeleteCompletionML*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialAnchorsDeleteCompletionML
  XrSpatialAnchorsDeleteCompletionML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsDeleteCompletionML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsDeleteCompletionML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsDeleteCompletionML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsDeleteCompletionML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsDeleteCompletionML*>(this);
  }
};
static_assert(sizeof(XrSpatialAnchorsDeleteCompletionML) ==
                  sizeof(SpatialAnchorsDeleteCompletionML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsDeleteCompletionML pointer to const from a
 * SpatialAnchorsDeleteCompletionML reference to const.
 * @relates SpatialAnchorsDeleteCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsDeleteCompletionML const* get(
    SpatialAnchorsDeleteCompletionML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsDeleteCompletionML as the address of a raw XrSpatialAnchorsDeleteCompletionML
 * @relates SpatialAnchorsDeleteCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsDeleteCompletionML* put(
    SpatialAnchorsDeleteCompletionML& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpatialAnchorsDeleteCompletionML as a raw,
 * pointer to const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates SpatialAnchorsDeleteCompletionML
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    SpatialAnchorsDeleteCompletionML const& h) {
  return h.get_base();
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsUpdateExpirationInfoML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsUpdateExpirationInfoML>
 * @xrentity{XrSpatialAnchorsUpdateExpirationInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsUpdateExpirationInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorsUpdateExpirationInfoML(uint32_t uuidCount_, const UuidEXT* uuids_,
                                       uint64_t expiration_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorsUpdateExpirationInfoML, next_),
        uuidCount{uuidCount_},
        uuids{uuids_},
        expiration{expiration_} {}

  //! Default/empty constructor
  SpatialAnchorsUpdateExpirationInfoML(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsUpdateExpirationInfoML, next_),
        uuidCount{0},
        uuids{nullptr},
        expiration{0} {}

  //! Default copy constructor
  SpatialAnchorsUpdateExpirationInfoML(const SpatialAnchorsUpdateExpirationInfoML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorsUpdateExpirationInfoML& operator=(const SpatialAnchorsUpdateExpirationInfoML& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorsUpdateExpirationInfoML(const XrSpatialAnchorsUpdateExpirationInfoML& rhs)
      : SpatialAnchorsUpdateExpirationInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsUpdateExpirationInfoML& operator=(
      const XrSpatialAnchorsUpdateExpirationInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsUpdateExpirationInfoML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsUpdateExpirationInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsUpdateExpirationInfoML&() {
    return *reinterpret_cast<XrSpatialAnchorsUpdateExpirationInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorsUpdateExpirationInfoML
  XrSpatialAnchorsUpdateExpirationInfoML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsUpdateExpirationInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsUpdateExpirationInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsUpdateExpirationInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsUpdateExpirationInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsUpdateExpirationInfoML*>(this);
  }
  uint32_t uuidCount;
  const UuidEXT* uuids;
  uint64_t expiration;
};
static_assert(sizeof(XrSpatialAnchorsUpdateExpirationInfoML) ==
                  sizeof(SpatialAnchorsUpdateExpirationInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsUpdateExpirationInfoML pointer to const
 * from a SpatialAnchorsUpdateExpirationInfoML reference to const.
 * @relates SpatialAnchorsUpdateExpirationInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsUpdateExpirationInfoML const* get(
    SpatialAnchorsUpdateExpirationInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsUpdateExpirationInfoML as the address of a raw
 * XrSpatialAnchorsUpdateExpirationInfoML
 * @relates SpatialAnchorsUpdateExpirationInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsUpdateExpirationInfoML* put(
    SpatialAnchorsUpdateExpirationInfoML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsUpdateExpirationCompletionML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsUpdateExpirationCompletionML>
 * @xrentity{XrSpatialAnchorsUpdateExpirationCompletionML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsUpdateExpirationCompletionML
    : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialAnchorsUpdateExpirationCompletionML(void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsUpdateExpirationCompletionML, {}, next_) {}

  //! Default copy constructor
  SpatialAnchorsUpdateExpirationCompletionML(
      const SpatialAnchorsUpdateExpirationCompletionML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorsUpdateExpirationCompletionML& operator=(
      const SpatialAnchorsUpdateExpirationCompletionML& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorsUpdateExpirationCompletionML(
      const XrSpatialAnchorsUpdateExpirationCompletionML& rhs)
      : SpatialAnchorsUpdateExpirationCompletionML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsUpdateExpirationCompletionML& operator=(
      const XrSpatialAnchorsUpdateExpirationCompletionML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsUpdateExpirationCompletionML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsUpdateExpirationCompletionML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsUpdateExpirationCompletionML&() {
    return *reinterpret_cast<XrSpatialAnchorsUpdateExpirationCompletionML*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialAnchorsUpdateExpirationCompletionML
  XrSpatialAnchorsUpdateExpirationCompletionML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsUpdateExpirationCompletionML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsUpdateExpirationCompletionML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsUpdateExpirationCompletionML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsUpdateExpirationCompletionML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsUpdateExpirationCompletionML*>(this);
  }
};
static_assert(sizeof(XrSpatialAnchorsUpdateExpirationCompletionML) ==
                  sizeof(SpatialAnchorsUpdateExpirationCompletionML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsUpdateExpirationCompletionML pointer to
 * const from a SpatialAnchorsUpdateExpirationCompletionML reference to const.
 * @relates SpatialAnchorsUpdateExpirationCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsUpdateExpirationCompletionML const* get(
    SpatialAnchorsUpdateExpirationCompletionML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsUpdateExpirationCompletionML as the address of a raw
 * XrSpatialAnchorsUpdateExpirationCompletionML
 * @relates SpatialAnchorsUpdateExpirationCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsUpdateExpirationCompletionML* put(
    SpatialAnchorsUpdateExpirationCompletionML& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpatialAnchorsUpdateExpirationCompletionML
 * as a raw, pointer to const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates SpatialAnchorsUpdateExpirationCompletionML
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    SpatialAnchorsUpdateExpirationCompletionML const& h) {
  return h.get_base();
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorCompletionResultML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorCompletionResultML>
 * @xrentity{XrSpatialAnchorCompletionResultML}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpatialAnchorCompletionResultML {
public:
  //! Constructor initializing all members.
  SpatialAnchorCompletionResultML(const UuidEXT& uuid_, const Result& result_)
      : uuid{uuid_}, result{result_} {}

  //! Default/empty constructor
  SpatialAnchorCompletionResultML()

      : uuid{}, result{} {}

  //! Default copy constructor
  SpatialAnchorCompletionResultML(const SpatialAnchorCompletionResultML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorCompletionResultML& operator=(const SpatialAnchorCompletionResultML& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorCompletionResultML(const XrSpatialAnchorCompletionResultML& rhs)
      : SpatialAnchorCompletionResultML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorCompletionResultML& operator=(const XrSpatialAnchorCompletionResultML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorCompletionResultML&() const {
    return *reinterpret_cast<const XrSpatialAnchorCompletionResultML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorCompletionResultML&() {
    return *reinterpret_cast<XrSpatialAnchorCompletionResultML*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorCompletionResultML
  XrSpatialAnchorCompletionResultML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorCompletionResultML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorCompletionResultML.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpatialAnchorCompletionResultML* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpatialAnchorCompletionResultML{};
    }
    return reinterpret_cast<XrSpatialAnchorCompletionResultML*>(this);
  }
  UuidEXT uuid;
  Result result;
};
static_assert(sizeof(XrSpatialAnchorCompletionResultML) == sizeof(SpatialAnchorCompletionResultML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorCompletionResultML pointer to const from a
 * SpatialAnchorCompletionResultML reference to const.
 * @relates SpatialAnchorCompletionResultML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCompletionResultML const* get(
    SpatialAnchorCompletionResultML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorCompletionResultML as the address of a raw XrSpatialAnchorCompletionResultML
 * @relates SpatialAnchorCompletionResultML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCompletionResultML* put(SpatialAnchorCompletionResultML& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsPublishCompletionDetailsML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsPublishCompletionDetailsML>
 * @xrentity{XrSpatialAnchorsPublishCompletionDetailsML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsPublishCompletionDetailsML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialAnchorsPublishCompletionDetailsML(void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsPublishCompletionDetailsML, next_) {}

  //! Default copy constructor
  SpatialAnchorsPublishCompletionDetailsML(const SpatialAnchorsPublishCompletionDetailsML& rhs) =
      default;
  //! Default copy assignment
  SpatialAnchorsPublishCompletionDetailsML& operator=(
      const SpatialAnchorsPublishCompletionDetailsML& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorsPublishCompletionDetailsML(const XrSpatialAnchorsPublishCompletionDetailsML& rhs)
      : SpatialAnchorsPublishCompletionDetailsML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsPublishCompletionDetailsML& operator=(
      const XrSpatialAnchorsPublishCompletionDetailsML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsPublishCompletionDetailsML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsPublishCompletionDetailsML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsPublishCompletionDetailsML&() {
    return *reinterpret_cast<XrSpatialAnchorsPublishCompletionDetailsML*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorsPublishCompletionDetailsML
  XrSpatialAnchorsPublishCompletionDetailsML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsPublishCompletionDetailsML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsPublishCompletionDetailsML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsPublishCompletionDetailsML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsPublishCompletionDetailsML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsPublishCompletionDetailsML*>(this);
  }
  uint32_t resultCount;
  SpatialAnchorCompletionResultML* results;
};
static_assert(sizeof(XrSpatialAnchorsPublishCompletionDetailsML) ==
                  sizeof(SpatialAnchorsPublishCompletionDetailsML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsPublishCompletionDetailsML pointer to
 * const from a SpatialAnchorsPublishCompletionDetailsML reference to const.
 * @relates SpatialAnchorsPublishCompletionDetailsML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsPublishCompletionDetailsML const* get(
    SpatialAnchorsPublishCompletionDetailsML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsPublishCompletionDetailsML as the address of a raw
 * XrSpatialAnchorsPublishCompletionDetailsML
 * @relates SpatialAnchorsPublishCompletionDetailsML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsPublishCompletionDetailsML* put(
    SpatialAnchorsPublishCompletionDetailsML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsDeleteCompletionDetailsML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsDeleteCompletionDetailsML>
 * @xrentity{XrSpatialAnchorsDeleteCompletionDetailsML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsDeleteCompletionDetailsML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialAnchorsDeleteCompletionDetailsML(void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsDeleteCompletionDetailsML, next_) {}

  //! Default copy constructor
  SpatialAnchorsDeleteCompletionDetailsML(const SpatialAnchorsDeleteCompletionDetailsML& rhs) =
      default;
  //! Default copy assignment
  SpatialAnchorsDeleteCompletionDetailsML& operator=(
      const SpatialAnchorsDeleteCompletionDetailsML& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorsDeleteCompletionDetailsML(const XrSpatialAnchorsDeleteCompletionDetailsML& rhs)
      : SpatialAnchorsDeleteCompletionDetailsML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsDeleteCompletionDetailsML& operator=(
      const XrSpatialAnchorsDeleteCompletionDetailsML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsDeleteCompletionDetailsML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsDeleteCompletionDetailsML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsDeleteCompletionDetailsML&() {
    return *reinterpret_cast<XrSpatialAnchorsDeleteCompletionDetailsML*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorsDeleteCompletionDetailsML
  XrSpatialAnchorsDeleteCompletionDetailsML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsDeleteCompletionDetailsML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsDeleteCompletionDetailsML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsDeleteCompletionDetailsML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsDeleteCompletionDetailsML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsDeleteCompletionDetailsML*>(this);
  }
  uint32_t resultCount;
  SpatialAnchorCompletionResultML* results;
};
static_assert(sizeof(XrSpatialAnchorsDeleteCompletionDetailsML) ==
                  sizeof(SpatialAnchorsDeleteCompletionDetailsML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsDeleteCompletionDetailsML pointer to const
 * from a SpatialAnchorsDeleteCompletionDetailsML reference to const.
 * @relates SpatialAnchorsDeleteCompletionDetailsML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsDeleteCompletionDetailsML const* get(
    SpatialAnchorsDeleteCompletionDetailsML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsDeleteCompletionDetailsML as the address of a raw
 * XrSpatialAnchorsDeleteCompletionDetailsML
 * @relates SpatialAnchorsDeleteCompletionDetailsML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsDeleteCompletionDetailsML* put(
    SpatialAnchorsDeleteCompletionDetailsML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_ML_spatial_anchors_storage
/*!
 * C++ projection of XrSpatialAnchorsUpdateExpirationCompletionDetailsML
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsUpdateExpirationCompletionDetailsML>
 * @xrentity{XrSpatialAnchorsUpdateExpirationCompletionDetailsML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorsUpdateExpirationCompletionDetailsML
    : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialAnchorsUpdateExpirationCompletionDetailsML(void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorsUpdateExpirationCompletionDetailsML, next_) {}

  //! Default copy constructor
  SpatialAnchorsUpdateExpirationCompletionDetailsML(
      const SpatialAnchorsUpdateExpirationCompletionDetailsML& rhs) = default;
  //! Default copy assignment
  SpatialAnchorsUpdateExpirationCompletionDetailsML& operator=(
      const SpatialAnchorsUpdateExpirationCompletionDetailsML& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorsUpdateExpirationCompletionDetailsML(
      const XrSpatialAnchorsUpdateExpirationCompletionDetailsML& rhs)
      : SpatialAnchorsUpdateExpirationCompletionDetailsML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorsUpdateExpirationCompletionDetailsML& operator=(
      const XrSpatialAnchorsUpdateExpirationCompletionDetailsML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorsUpdateExpirationCompletionDetailsML&() const {
    return *reinterpret_cast<const XrSpatialAnchorsUpdateExpirationCompletionDetailsML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorsUpdateExpirationCompletionDetailsML&() {
    return *reinterpret_cast<XrSpatialAnchorsUpdateExpirationCompletionDetailsML*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorsUpdateExpirationCompletionDetailsML
  XrSpatialAnchorsUpdateExpirationCompletionDetailsML const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorsUpdateExpirationCompletionDetailsML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorsUpdateExpirationCompletionDetailsML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorsUpdateExpirationCompletionDetailsML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorsUpdateExpirationCompletionDetailsML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorsUpdateExpirationCompletionDetailsML*>(this);
  }
  uint32_t resultCount;
  SpatialAnchorCompletionResultML* results;
};
static_assert(sizeof(XrSpatialAnchorsUpdateExpirationCompletionDetailsML) ==
                  sizeof(SpatialAnchorsUpdateExpirationCompletionDetailsML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorsUpdateExpirationCompletionDetailsML
 * pointer to const from a SpatialAnchorsUpdateExpirationCompletionDetailsML reference to const.
 * @relates SpatialAnchorsUpdateExpirationCompletionDetailsML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsUpdateExpirationCompletionDetailsML const* get(
    SpatialAnchorsUpdateExpirationCompletionDetailsML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorsUpdateExpirationCompletionDetailsML as the address of a raw
 * XrSpatialAnchorsUpdateExpirationCompletionDetailsML
 * @relates SpatialAnchorsUpdateExpirationCompletionDetailsML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsUpdateExpirationCompletionDetailsML* put(
    SpatialAnchorsUpdateExpirationCompletionDetailsML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_MSFT_spatial_anchor_persistence
/*!
 * C++ projection of XrSpatialAnchorPersistenceNameMSFT
 *
 * Provided by the `XR_MSFT_spatial_anchor_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorPersistenceNameMSFT>
 * @xrentity{XrSpatialAnchorPersistenceNameMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpatialAnchorPersistenceNameMSFT {
public:
  //! Constructor initializing all members.
  SpatialAnchorPersistenceNameMSFT(const char* name_) {
    if (nullptr != name_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(name, XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT, name_,
                XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT);
#else
      strncpy(name, name_, XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT - 1);
      name[XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  SpatialAnchorPersistenceNameMSFT()

  {}

  //! Default copy constructor
  SpatialAnchorPersistenceNameMSFT(const SpatialAnchorPersistenceNameMSFT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorPersistenceNameMSFT& operator=(const SpatialAnchorPersistenceNameMSFT& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorPersistenceNameMSFT(const XrSpatialAnchorPersistenceNameMSFT& rhs)
      : SpatialAnchorPersistenceNameMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorPersistenceNameMSFT& operator=(const XrSpatialAnchorPersistenceNameMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorPersistenceNameMSFT&() const {
    return *reinterpret_cast<const XrSpatialAnchorPersistenceNameMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorPersistenceNameMSFT&() {
    return *reinterpret_cast<XrSpatialAnchorPersistenceNameMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorPersistenceNameMSFT
  XrSpatialAnchorPersistenceNameMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorPersistenceNameMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorPersistenceNameMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpatialAnchorPersistenceNameMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpatialAnchorPersistenceNameMSFT{};
    }
    return reinterpret_cast<XrSpatialAnchorPersistenceNameMSFT*>(this);
  }
  char name[XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT];
};
static_assert(sizeof(XrSpatialAnchorPersistenceNameMSFT) ==
                  sizeof(SpatialAnchorPersistenceNameMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorPersistenceNameMSFT pointer to const from a
 * SpatialAnchorPersistenceNameMSFT reference to const.
 * @relates SpatialAnchorPersistenceNameMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorPersistenceNameMSFT const* get(
    SpatialAnchorPersistenceNameMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorPersistenceNameMSFT as the address of a raw XrSpatialAnchorPersistenceNameMSFT
 * @relates SpatialAnchorPersistenceNameMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorPersistenceNameMSFT* put(
    SpatialAnchorPersistenceNameMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_spatial_anchor_persistence
/*!
 * C++ projection of XrSpatialAnchorPersistenceInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_anchor_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorPersistenceInfoMSFT>
 * @xrentity{XrSpatialAnchorPersistenceInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorPersistenceInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorPersistenceInfoMSFT(
      const SpatialAnchorPersistenceNameMSFT& spatialAnchorPersistenceName_,
      const SpatialAnchorMSFT& spatialAnchor_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorPersistenceInfoMSFT, next_),
        spatialAnchorPersistenceName{spatialAnchorPersistenceName_},
        spatialAnchor{spatialAnchor_} {}

  //! Default/empty constructor
  SpatialAnchorPersistenceInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorPersistenceInfoMSFT, next_),
        spatialAnchorPersistenceName{},
        spatialAnchor{} {}

  //! Default copy constructor
  SpatialAnchorPersistenceInfoMSFT(const SpatialAnchorPersistenceInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorPersistenceInfoMSFT& operator=(const SpatialAnchorPersistenceInfoMSFT& rhs) =
      default;
  //! Copy construct from raw
  SpatialAnchorPersistenceInfoMSFT(const XrSpatialAnchorPersistenceInfoMSFT& rhs)
      : SpatialAnchorPersistenceInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorPersistenceInfoMSFT& operator=(const XrSpatialAnchorPersistenceInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorPersistenceInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialAnchorPersistenceInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorPersistenceInfoMSFT&() {
    return *reinterpret_cast<XrSpatialAnchorPersistenceInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorPersistenceInfoMSFT
  XrSpatialAnchorPersistenceInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorPersistenceInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorPersistenceInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorPersistenceInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorPersistenceInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorPersistenceInfoMSFT*>(this);
  }
  SpatialAnchorPersistenceNameMSFT spatialAnchorPersistenceName;
  SpatialAnchorMSFT spatialAnchor;
};
static_assert(sizeof(XrSpatialAnchorPersistenceInfoMSFT) ==
                  sizeof(SpatialAnchorPersistenceInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorPersistenceInfoMSFT pointer to const from a
 * SpatialAnchorPersistenceInfoMSFT reference to const.
 * @relates SpatialAnchorPersistenceInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorPersistenceInfoMSFT const* get(
    SpatialAnchorPersistenceInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorPersistenceInfoMSFT as the address of a raw XrSpatialAnchorPersistenceInfoMSFT
 * @relates SpatialAnchorPersistenceInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorPersistenceInfoMSFT* put(
    SpatialAnchorPersistenceInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_spatial_anchor_persistence
/*!
 * C++ projection of XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT
 *
 * Provided by the `XR_MSFT_spatial_anchor_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT>
 * @xrentity{XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorFromPersistedAnchorCreateInfoMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT(
      const SpatialAnchorStoreConnectionMSFT& spatialAnchorStore_,
      const SpatialAnchorPersistenceNameMSFT& spatialAnchorPersistenceName_,
      const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorFromPersistedAnchorCreateInfoMSFT, next_),
        spatialAnchorStore{spatialAnchorStore_},
        spatialAnchorPersistenceName{spatialAnchorPersistenceName_} {}

  //! Default/empty constructor
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorFromPersistedAnchorCreateInfoMSFT, next_),
        spatialAnchorStore{},
        spatialAnchorPersistenceName{} {}

  //! Default copy constructor
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT& operator=(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT(
      const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT& rhs)
      : SpatialAnchorFromPersistedAnchorCreateInfoMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorFromPersistedAnchorCreateInfoMSFT& operator=(
      const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT&() const {
    return *reinterpret_cast<const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT&() {
    return *reinterpret_cast<XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT
  XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorFromPersistedAnchorCreateInfoMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT*>(this);
  }
  SpatialAnchorStoreConnectionMSFT spatialAnchorStore;
  SpatialAnchorPersistenceNameMSFT spatialAnchorPersistenceName;
};
static_assert(sizeof(XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT) ==
                  sizeof(SpatialAnchorFromPersistedAnchorCreateInfoMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT pointer
 * to const from a SpatialAnchorFromPersistedAnchorCreateInfoMSFT reference to const.
 * @relates SpatialAnchorFromPersistedAnchorCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT const* get(
    SpatialAnchorFromPersistedAnchorCreateInfoMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorFromPersistedAnchorCreateInfoMSFT as the address of a raw
 * XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT
 * @relates SpatialAnchorFromPersistedAnchorCreateInfoMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* put(
    SpatialAnchorFromPersistedAnchorCreateInfoMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_scene_marker
/*!
 * C++ projection of XrSceneMarkerMSFT
 *
 * Provided by the `XR_MSFT_scene_marker` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkerMSFT>
 * @xrentity{XrSceneMarkerMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneMarkerMSFT {
public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneMarkerMSFT()

  {}

  //! Default copy constructor
  SceneMarkerMSFT(const SceneMarkerMSFT& rhs) = default;
  //! Default copy assignment
  SceneMarkerMSFT& operator=(const SceneMarkerMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMarkerMSFT(const XrSceneMarkerMSFT& rhs) : SceneMarkerMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneMarkerMSFT& operator=(const XrSceneMarkerMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMarkerMSFT&() const {
    return *reinterpret_cast<const XrSceneMarkerMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMarkerMSFT&() { return *reinterpret_cast<XrSceneMarkerMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneMarkerMSFT
  XrSceneMarkerMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMarkerMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneMarkerMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneMarkerMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneMarkerMSFT{};
    }
    return reinterpret_cast<XrSceneMarkerMSFT*>(this);
  }
  SceneMarkerTypeMSFT markerType;
  Time lastSeenTime;
  Offset2Df center;
  Extent2Df size;
};
static_assert(sizeof(XrSceneMarkerMSFT) == sizeof(SceneMarkerMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMarkerMSFT pointer to const from a SceneMarkerMSFT
 * reference to const.
 * @relates SceneMarkerMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMarkerMSFT const* get(SceneMarkerMSFT const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMarkerMSFT as the
 * address of a raw XrSceneMarkerMSFT
 * @relates SceneMarkerMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMarkerMSFT* put(SceneMarkerMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_marker

#ifdef XR_MSFT_scene_marker
/*!
 * C++ projection of XrSceneMarkersMSFT
 *
 * Provided by the `XR_MSFT_scene_marker` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkersMSFT>
 * @xrentity{XrSceneMarkersMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMarkersMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneMarkersMSFT(uint32_t sceneMarkerCapacityInput_, SceneMarkerMSFT* sceneMarkers_,
                   const void* next_ = nullptr)
      : Parent(StructureType::SceneMarkersMSFT, next_),
        sceneMarkerCapacityInput{sceneMarkerCapacityInput_},
        sceneMarkers{sceneMarkers_} {}

  //! Default/empty constructor
  SceneMarkersMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneMarkersMSFT, next_),
        sceneMarkerCapacityInput{0},
        sceneMarkers{nullptr} {}

  //! Default copy constructor
  SceneMarkersMSFT(const SceneMarkersMSFT& rhs) = default;
  //! Default copy assignment
  SceneMarkersMSFT& operator=(const SceneMarkersMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMarkersMSFT(const XrSceneMarkersMSFT& rhs) : SceneMarkersMSFT() { *put() = rhs; }
  //! Copy assign from raw
  SceneMarkersMSFT& operator=(const XrSceneMarkersMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMarkersMSFT&() const {
    return *reinterpret_cast<const XrSceneMarkersMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMarkersMSFT&() { return *reinterpret_cast<XrSceneMarkersMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneMarkersMSFT
  XrSceneMarkersMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMarkersMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneMarkersMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMarkersMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMarkersMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMarkersMSFT*>(this);
  }
  uint32_t sceneMarkerCapacityInput;
  SceneMarkerMSFT* sceneMarkers;
};
static_assert(sizeof(XrSceneMarkersMSFT) == sizeof(SceneMarkersMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMarkersMSFT pointer to const from a
 * SceneMarkersMSFT reference to const.
 * @relates SceneMarkersMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMarkersMSFT const* get(SceneMarkersMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMarkersMSFT as the
 * address of a raw XrSceneMarkersMSFT
 * @relates SceneMarkersMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMarkersMSFT* put(SceneMarkersMSFT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_marker

#ifdef XR_MSFT_scene_marker
/*!
 * C++ projection of XrSceneMarkerTypeFilterMSFT
 *
 * Provided by the `XR_MSFT_scene_marker` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkerTypeFilterMSFT>
 * @xrentity{XrSceneMarkerTypeFilterMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMarkerTypeFilterMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneMarkerTypeFilterMSFT(uint32_t markerTypeCount_, SceneMarkerTypeMSFT* markerTypes_,
                            const void* next_ = nullptr)
      : Parent(StructureType::SceneMarkerTypeFilterMSFT, next_),
        markerTypeCount{markerTypeCount_},
        markerTypes{markerTypes_} {}

  //! Default/empty constructor
  SceneMarkerTypeFilterMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneMarkerTypeFilterMSFT, next_),
        markerTypeCount{0},
        markerTypes{nullptr} {}

  //! Default copy constructor
  SceneMarkerTypeFilterMSFT(const SceneMarkerTypeFilterMSFT& rhs) = default;
  //! Default copy assignment
  SceneMarkerTypeFilterMSFT& operator=(const SceneMarkerTypeFilterMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMarkerTypeFilterMSFT(const XrSceneMarkerTypeFilterMSFT& rhs) : SceneMarkerTypeFilterMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneMarkerTypeFilterMSFT& operator=(const XrSceneMarkerTypeFilterMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMarkerTypeFilterMSFT&() const {
    return *reinterpret_cast<const XrSceneMarkerTypeFilterMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMarkerTypeFilterMSFT&() {
    return *reinterpret_cast<XrSceneMarkerTypeFilterMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneMarkerTypeFilterMSFT
  XrSceneMarkerTypeFilterMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMarkerTypeFilterMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneMarkerTypeFilterMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMarkerTypeFilterMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMarkerTypeFilterMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMarkerTypeFilterMSFT*>(this);
  }
  uint32_t markerTypeCount;
  SceneMarkerTypeMSFT* markerTypes;
};
static_assert(sizeof(XrSceneMarkerTypeFilterMSFT) == sizeof(SceneMarkerTypeFilterMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMarkerTypeFilterMSFT pointer to const from a
 * SceneMarkerTypeFilterMSFT reference to const.
 * @relates SceneMarkerTypeFilterMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMarkerTypeFilterMSFT const* get(
    SceneMarkerTypeFilterMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMarkerTypeFilterMSFT as
 * the address of a raw XrSceneMarkerTypeFilterMSFT
 * @relates SceneMarkerTypeFilterMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMarkerTypeFilterMSFT* put(SceneMarkerTypeFilterMSFT& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_marker

#ifdef XR_MSFT_scene_marker
/*!
 * C++ projection of XrSceneMarkerQRCodeMSFT
 *
 * Provided by the `XR_MSFT_scene_marker` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkerQRCodeMSFT>
 * @xrentity{XrSceneMarkerQRCodeMSFT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SceneMarkerQRCodeMSFT {
public:
  //! Empty constructor for a type that is marked as "returnonly"
  SceneMarkerQRCodeMSFT()

  {}

  //! Default copy constructor
  SceneMarkerQRCodeMSFT(const SceneMarkerQRCodeMSFT& rhs) = default;
  //! Default copy assignment
  SceneMarkerQRCodeMSFT& operator=(const SceneMarkerQRCodeMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMarkerQRCodeMSFT(const XrSceneMarkerQRCodeMSFT& rhs) : SceneMarkerQRCodeMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneMarkerQRCodeMSFT& operator=(const XrSceneMarkerQRCodeMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMarkerQRCodeMSFT&() const {
    return *reinterpret_cast<const XrSceneMarkerQRCodeMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMarkerQRCodeMSFT&() { return *reinterpret_cast<XrSceneMarkerQRCodeMSFT*>(this); }

  //! Accessor for this as the address of a raw XrSceneMarkerQRCodeMSFT
  XrSceneMarkerQRCodeMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMarkerQRCodeMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneMarkerQRCodeMSFT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSceneMarkerQRCodeMSFT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SceneMarkerQRCodeMSFT{};
    }
    return reinterpret_cast<XrSceneMarkerQRCodeMSFT*>(this);
  }
  SceneMarkerQRCodeSymbolTypeMSFT symbolType;
  uint8_t version;
};
static_assert(sizeof(XrSceneMarkerQRCodeMSFT) == sizeof(SceneMarkerQRCodeMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMarkerQRCodeMSFT pointer to const from a
 * SceneMarkerQRCodeMSFT reference to const.
 * @relates SceneMarkerQRCodeMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMarkerQRCodeMSFT const* get(SceneMarkerQRCodeMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMarkerQRCodeMSFT as the
 * address of a raw XrSceneMarkerQRCodeMSFT
 * @relates SceneMarkerQRCodeMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMarkerQRCodeMSFT* put(SceneMarkerQRCodeMSFT& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_marker

#ifdef XR_MSFT_scene_marker
/*!
 * C++ projection of XrSceneMarkerQRCodesMSFT
 *
 * Provided by the `XR_MSFT_scene_marker` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMarkerQRCodesMSFT>
 * @xrentity{XrSceneMarkerQRCodesMSFT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneMarkerQRCodesMSFT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneMarkerQRCodesMSFT(uint32_t qrCodeCapacityInput_, SceneMarkerQRCodeMSFT* qrCodes_,
                         const void* next_ = nullptr)
      : Parent(StructureType::SceneMarkerQrCodesMSFT, next_),
        qrCodeCapacityInput{qrCodeCapacityInput_},
        qrCodes{qrCodes_} {}

  //! Default/empty constructor
  SceneMarkerQRCodesMSFT(const void* next_ = nullptr)

      : Parent(StructureType::SceneMarkerQrCodesMSFT, next_),
        qrCodeCapacityInput{0},
        qrCodes{nullptr} {}

  //! Default copy constructor
  SceneMarkerQRCodesMSFT(const SceneMarkerQRCodesMSFT& rhs) = default;
  //! Default copy assignment
  SceneMarkerQRCodesMSFT& operator=(const SceneMarkerQRCodesMSFT& rhs) = default;
  //! Copy construct from raw
  SceneMarkerQRCodesMSFT(const XrSceneMarkerQRCodesMSFT& rhs) : SceneMarkerQRCodesMSFT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneMarkerQRCodesMSFT& operator=(const XrSceneMarkerQRCodesMSFT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneMarkerQRCodesMSFT&() const {
    return *reinterpret_cast<const XrSceneMarkerQRCodesMSFT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneMarkerQRCodesMSFT&() {
    return *reinterpret_cast<XrSceneMarkerQRCodesMSFT*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneMarkerQRCodesMSFT
  XrSceneMarkerQRCodesMSFT const* get() const noexcept {
    return reinterpret_cast<XrSceneMarkerQRCodesMSFT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneMarkerQRCodesMSFT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneMarkerQRCodesMSFT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneMarkerQRCodesMSFT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneMarkerQRCodesMSFT*>(this);
  }
  uint32_t qrCodeCapacityInput;
  SceneMarkerQRCodeMSFT* qrCodes;
};
static_assert(sizeof(XrSceneMarkerQRCodesMSFT) == sizeof(SceneMarkerQRCodesMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneMarkerQRCodesMSFT pointer to const from a
 * SceneMarkerQRCodesMSFT reference to const.
 * @relates SceneMarkerQRCodesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMarkerQRCodesMSFT const* get(SceneMarkerQRCodesMSFT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneMarkerQRCodesMSFT as the
 * address of a raw XrSceneMarkerQRCodesMSFT
 * @relates SceneMarkerQRCodesMSFT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneMarkerQRCodesMSFT* put(SceneMarkerQRCodesMSFT& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MSFT_scene_marker

#ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceQueryInfoBaseHeaderFB
 *
 * Provided by the `XR_FB_spatial_entity_query` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceQueryInfoBaseHeaderFB>
 * @xrentity{XrSpaceQueryInfoBaseHeaderFB}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS SpaceQueryInfoBaseHeaderFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  SpaceQueryInfoBaseHeaderFB(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceQueryInfoBaseHeaderFB&() const {
    return *reinterpret_cast<const XrSpaceQueryInfoBaseHeaderFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceQueryInfoBaseHeaderFB&() {
    return *reinterpret_cast<XrSpaceQueryInfoBaseHeaderFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSpaceQueryInfoBaseHeaderFB
  XrSpaceQueryInfoBaseHeaderFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceQueryInfoBaseHeaderFB const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw XrSpaceQueryInfoBaseHeaderFB.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrSpaceQueryInfoBaseHeaderFB* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrSpaceQueryInfoBaseHeaderFB*>(this);
  }
};
static_assert(sizeof(XrSpaceQueryInfoBaseHeaderFB) == sizeof(SpaceQueryInfoBaseHeaderFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceQueryInfoBaseHeaderFB pointer to const from a
 * SpaceQueryInfoBaseHeaderFB reference to const.
 * @relates SpaceQueryInfoBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceQueryInfoBaseHeaderFB const* get(
    SpaceQueryInfoBaseHeaderFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceQueryInfoBaseHeaderFB as
 * the address of a raw XrSpaceQueryInfoBaseHeaderFB
 * @relates SpaceQueryInfoBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceQueryInfoBaseHeaderFB* put(SpaceQueryInfoBaseHeaderFB& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceFilterInfoBaseHeaderFB
 *
 * Provided by the `XR_FB_spatial_entity_query` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceFilterInfoBaseHeaderFB>
 * @xrentity{XrSpaceFilterInfoBaseHeaderFB}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS SpaceFilterInfoBaseHeaderFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  SpaceFilterInfoBaseHeaderFB(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceFilterInfoBaseHeaderFB&() const {
    return *reinterpret_cast<const XrSpaceFilterInfoBaseHeaderFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceFilterInfoBaseHeaderFB&() {
    return *reinterpret_cast<XrSpaceFilterInfoBaseHeaderFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSpaceFilterInfoBaseHeaderFB
  XrSpaceFilterInfoBaseHeaderFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceFilterInfoBaseHeaderFB const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw XrSpaceFilterInfoBaseHeaderFB.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrSpaceFilterInfoBaseHeaderFB* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrSpaceFilterInfoBaseHeaderFB*>(this);
  }
};
static_assert(sizeof(XrSpaceFilterInfoBaseHeaderFB) == sizeof(SpaceFilterInfoBaseHeaderFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceFilterInfoBaseHeaderFB pointer to const from a
 * SpaceFilterInfoBaseHeaderFB reference to const.
 * @relates SpaceFilterInfoBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceFilterInfoBaseHeaderFB const* get(
    SpaceFilterInfoBaseHeaderFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceFilterInfoBaseHeaderFB
 * as the address of a raw XrSpaceFilterInfoBaseHeaderFB
 * @relates SpaceFilterInfoBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceFilterInfoBaseHeaderFB* put(SpaceFilterInfoBaseHeaderFB& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceQueryInfoFB
 *
 * Provided by the `XR_FB_spatial_entity_query` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceQueryInfoFB>
 * @xrentity{XrSpaceQueryInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceQueryInfoFB : public SpaceQueryInfoBaseHeaderFB {
private:
  using Parent = SpaceQueryInfoBaseHeaderFB;

public:
  //! Constructor initializing all members.
  SpaceQueryInfoFB(const SpaceQueryActionFB& queryAction_, uint32_t maxResultCount_,
                   const Duration& timeout_, const SpaceFilterInfoBaseHeaderFB* filter_,
                   const SpaceFilterInfoBaseHeaderFB* excludeFilter_, const void* next_ = nullptr)
      : Parent(StructureType::SpaceQueryInfoFB, next_),
        queryAction{queryAction_},
        maxResultCount{maxResultCount_},
        timeout{timeout_},
        filter{filter_},
        excludeFilter{excludeFilter_} {}

  //! Default/empty constructor
  SpaceQueryInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SpaceQueryInfoFB, next_),
        queryAction{},
        maxResultCount{0},
        timeout{},
        filter{nullptr},
        excludeFilter{nullptr} {}

  //! Default copy constructor
  SpaceQueryInfoFB(const SpaceQueryInfoFB& rhs) = default;
  //! Default copy assignment
  SpaceQueryInfoFB& operator=(const SpaceQueryInfoFB& rhs) = default;
  //! Copy construct from raw
  SpaceQueryInfoFB(const XrSpaceQueryInfoFB& rhs) : SpaceQueryInfoFB() { *put() = rhs; }
  //! Copy assign from raw
  SpaceQueryInfoFB& operator=(const XrSpaceQueryInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceQueryInfoFB&() const {
    return *reinterpret_cast<const XrSpaceQueryInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceQueryInfoFB&() { return *reinterpret_cast<XrSpaceQueryInfoFB*>(this); }

  //! Accessor for this as a raw, base XrSpaceQueryInfoBaseHeaderFB const pointer
  XrSpaceQueryInfoBaseHeaderFB const* get_base() const noexcept {
    return reinterpret_cast<XrSpaceQueryInfoBaseHeaderFB const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpaceQueryInfoFB
  XrSpaceQueryInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceQueryInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceQueryInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceQueryInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceQueryInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceQueryInfoFB*>(this);
  }
  SpaceQueryActionFB queryAction;
  uint32_t maxResultCount;
  Duration timeout;
  const SpaceFilterInfoBaseHeaderFB* filter;
  const SpaceFilterInfoBaseHeaderFB* excludeFilter;
};
static_assert(sizeof(XrSpaceQueryInfoFB) == sizeof(SpaceQueryInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceQueryInfoFB pointer to const from a
 * SpaceQueryInfoFB reference to const.
 * @relates SpaceQueryInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceQueryInfoFB const* get(SpaceQueryInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceQueryInfoFB as the
 * address of a raw XrSpaceQueryInfoFB
 * @relates SpaceQueryInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceQueryInfoFB* put(SpaceQueryInfoFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpaceQueryInfoFB as a raw, pointer to
 * const XrSpaceQueryInfoBaseHeaderFB (the base type)
 * @relates SpaceQueryInfoFB
 * @relatesalso SpaceQueryInfoBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceQueryInfoBaseHeaderFB const* get_base(SpaceQueryInfoFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceStorageLocationFilterInfoFB
 *
 * Provided by the `XR_FB_spatial_entity_query` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceStorageLocationFilterInfoFB>
 * @xrentity{XrSpaceStorageLocationFilterInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceStorageLocationFilterInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpaceStorageLocationFilterInfoFB(const SpaceStorageLocationFB& location_,
                                   const void* next_ = nullptr)
      : Parent(StructureType::SpaceStorageLocationFilterInfoFB, next_), location{location_} {}

  //! Default/empty constructor
  SpaceStorageLocationFilterInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SpaceStorageLocationFilterInfoFB, next_), location{} {}

  //! Default copy constructor
  SpaceStorageLocationFilterInfoFB(const SpaceStorageLocationFilterInfoFB& rhs) = default;
  //! Default copy assignment
  SpaceStorageLocationFilterInfoFB& operator=(const SpaceStorageLocationFilterInfoFB& rhs) =
      default;
  //! Copy construct from raw
  SpaceStorageLocationFilterInfoFB(const XrSpaceStorageLocationFilterInfoFB& rhs)
      : SpaceStorageLocationFilterInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpaceStorageLocationFilterInfoFB& operator=(const XrSpaceStorageLocationFilterInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceStorageLocationFilterInfoFB&() const {
    return *reinterpret_cast<const XrSpaceStorageLocationFilterInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceStorageLocationFilterInfoFB&() {
    return *reinterpret_cast<XrSpaceStorageLocationFilterInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSpaceStorageLocationFilterInfoFB
  XrSpaceStorageLocationFilterInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceStorageLocationFilterInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpaceStorageLocationFilterInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceStorageLocationFilterInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceStorageLocationFilterInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceStorageLocationFilterInfoFB*>(this);
  }
  SpaceStorageLocationFB location;
};
static_assert(sizeof(XrSpaceStorageLocationFilterInfoFB) ==
                  sizeof(SpaceStorageLocationFilterInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceStorageLocationFilterInfoFB pointer to const from a
 * SpaceStorageLocationFilterInfoFB reference to const.
 * @relates SpaceStorageLocationFilterInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceStorageLocationFilterInfoFB const* get(
    SpaceStorageLocationFilterInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpaceStorageLocationFilterInfoFB as the address of a raw XrSpaceStorageLocationFilterInfoFB
 * @relates SpaceStorageLocationFilterInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceStorageLocationFilterInfoFB* put(
    SpaceStorageLocationFilterInfoFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceUuidFilterInfoFB
 *
 * Provided by the `XR_FB_spatial_entity_query` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceUuidFilterInfoFB>
 * @xrentity{XrSpaceUuidFilterInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceUuidFilterInfoFB : public SpaceFilterInfoBaseHeaderFB {
private:
  using Parent = SpaceFilterInfoBaseHeaderFB;

public:
  //! Constructor initializing all members.
  SpaceUuidFilterInfoFB(uint32_t uuidCount_, UuidEXT* uuids_, const void* next_ = nullptr)
      : Parent(StructureType::SpaceUuidFilterInfoFB, next_), uuidCount{uuidCount_}, uuids{uuids_} {}

  //! Default/empty constructor
  SpaceUuidFilterInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SpaceUuidFilterInfoFB, next_), uuidCount{0}, uuids{nullptr} {}

  //! Default copy constructor
  SpaceUuidFilterInfoFB(const SpaceUuidFilterInfoFB& rhs) = default;
  //! Default copy assignment
  SpaceUuidFilterInfoFB& operator=(const SpaceUuidFilterInfoFB& rhs) = default;
  //! Copy construct from raw
  SpaceUuidFilterInfoFB(const XrSpaceUuidFilterInfoFB& rhs) : SpaceUuidFilterInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpaceUuidFilterInfoFB& operator=(const XrSpaceUuidFilterInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceUuidFilterInfoFB&() const {
    return *reinterpret_cast<const XrSpaceUuidFilterInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceUuidFilterInfoFB&() { return *reinterpret_cast<XrSpaceUuidFilterInfoFB*>(this); }

  //! Accessor for this as a raw, base XrSpaceFilterInfoBaseHeaderFB const pointer
  XrSpaceFilterInfoBaseHeaderFB const* get_base() const noexcept {
    return reinterpret_cast<XrSpaceFilterInfoBaseHeaderFB const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpaceUuidFilterInfoFB
  XrSpaceUuidFilterInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceUuidFilterInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceUuidFilterInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceUuidFilterInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceUuidFilterInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceUuidFilterInfoFB*>(this);
  }
  uint32_t uuidCount;
  UuidEXT* uuids;
};
static_assert(sizeof(XrSpaceUuidFilterInfoFB) == sizeof(SpaceUuidFilterInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceUuidFilterInfoFB pointer to const from a
 * SpaceUuidFilterInfoFB reference to const.
 * @relates SpaceUuidFilterInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceUuidFilterInfoFB const* get(SpaceUuidFilterInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceUuidFilterInfoFB as the
 * address of a raw XrSpaceUuidFilterInfoFB
 * @relates SpaceUuidFilterInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceUuidFilterInfoFB* put(SpaceUuidFilterInfoFB& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpaceUuidFilterInfoFB as a raw, pointer to
 * const XrSpaceFilterInfoBaseHeaderFB (the base type)
 * @relates SpaceUuidFilterInfoFB
 * @relatesalso SpaceFilterInfoBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceFilterInfoBaseHeaderFB const* get_base(
    SpaceUuidFilterInfoFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceComponentFilterInfoFB
 *
 * Provided by the `XR_FB_spatial_entity_query` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceComponentFilterInfoFB>
 * @xrentity{XrSpaceComponentFilterInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceComponentFilterInfoFB : public SpaceFilterInfoBaseHeaderFB {
private:
  using Parent = SpaceFilterInfoBaseHeaderFB;

public:
  //! Constructor initializing all members.
  SpaceComponentFilterInfoFB(const SpaceComponentTypeFB& componentType_,
                             const void* next_ = nullptr)
      : Parent(StructureType::SpaceComponentFilterInfoFB, next_), componentType{componentType_} {}

  //! Default/empty constructor
  SpaceComponentFilterInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SpaceComponentFilterInfoFB, next_), componentType{} {}

  //! Default copy constructor
  SpaceComponentFilterInfoFB(const SpaceComponentFilterInfoFB& rhs) = default;
  //! Default copy assignment
  SpaceComponentFilterInfoFB& operator=(const SpaceComponentFilterInfoFB& rhs) = default;
  //! Copy construct from raw
  SpaceComponentFilterInfoFB(const XrSpaceComponentFilterInfoFB& rhs)
      : SpaceComponentFilterInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpaceComponentFilterInfoFB& operator=(const XrSpaceComponentFilterInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceComponentFilterInfoFB&() const {
    return *reinterpret_cast<const XrSpaceComponentFilterInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceComponentFilterInfoFB&() {
    return *reinterpret_cast<XrSpaceComponentFilterInfoFB*>(this);
  }

  //! Accessor for this as a raw, base XrSpaceFilterInfoBaseHeaderFB const pointer
  XrSpaceFilterInfoBaseHeaderFB const* get_base() const noexcept {
    return reinterpret_cast<XrSpaceFilterInfoBaseHeaderFB const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpaceComponentFilterInfoFB
  XrSpaceComponentFilterInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceComponentFilterInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpaceComponentFilterInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceComponentFilterInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceComponentFilterInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceComponentFilterInfoFB*>(this);
  }
  SpaceComponentTypeFB componentType;
};
static_assert(sizeof(XrSpaceComponentFilterInfoFB) == sizeof(SpaceComponentFilterInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceComponentFilterInfoFB pointer to const from a
 * SpaceComponentFilterInfoFB reference to const.
 * @relates SpaceComponentFilterInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceComponentFilterInfoFB const* get(
    SpaceComponentFilterInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceComponentFilterInfoFB as
 * the address of a raw XrSpaceComponentFilterInfoFB
 * @relates SpaceComponentFilterInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceComponentFilterInfoFB* put(SpaceComponentFilterInfoFB& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpaceComponentFilterInfoFB as a raw,
 * pointer to const XrSpaceFilterInfoBaseHeaderFB (the base type)
 * @relates SpaceComponentFilterInfoFB
 * @relatesalso SpaceFilterInfoBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceFilterInfoBaseHeaderFB const* get_base(
    SpaceComponentFilterInfoFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceQueryResultFB
 *
 * Provided by the `XR_FB_spatial_entity_query` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceQueryResultFB>
 * @xrentity{XrSpaceQueryResultFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpaceQueryResultFB {
public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceQueryResultFB()

  {}

  //! Default copy constructor
  SpaceQueryResultFB(const SpaceQueryResultFB& rhs) = default;
  //! Default copy assignment
  SpaceQueryResultFB& operator=(const SpaceQueryResultFB& rhs) = default;
  //! Copy construct from raw
  SpaceQueryResultFB(const XrSpaceQueryResultFB& rhs) : SpaceQueryResultFB() { *put() = rhs; }
  //! Copy assign from raw
  SpaceQueryResultFB& operator=(const XrSpaceQueryResultFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceQueryResultFB&() const {
    return *reinterpret_cast<const XrSpaceQueryResultFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceQueryResultFB&() { return *reinterpret_cast<XrSpaceQueryResultFB*>(this); }

  //! Accessor for this as the address of a raw XrSpaceQueryResultFB
  XrSpaceQueryResultFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceQueryResultFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceQueryResultFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpaceQueryResultFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpaceQueryResultFB{};
    }
    return reinterpret_cast<XrSpaceQueryResultFB*>(this);
  }
  Space space;
  UuidEXT uuid;
};
static_assert(sizeof(XrSpaceQueryResultFB) == sizeof(SpaceQueryResultFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceQueryResultFB pointer to const from a
 * SpaceQueryResultFB reference to const.
 * @relates SpaceQueryResultFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceQueryResultFB const* get(SpaceQueryResultFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceQueryResultFB as the
 * address of a raw XrSpaceQueryResultFB
 * @relates SpaceQueryResultFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceQueryResultFB* put(SpaceQueryResultFB& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrSpaceQueryResultsFB
 *
 * Provided by the `XR_FB_spatial_entity_query` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceQueryResultsFB>
 * @xrentity{XrSpaceQueryResultsFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceQueryResultsFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceQueryResultsFB(void* next_ = nullptr)

      : Parent(StructureType::SpaceQueryResultsFB, next_) {}

  //! Default copy constructor
  SpaceQueryResultsFB(const SpaceQueryResultsFB& rhs) = default;
  //! Default copy assignment
  SpaceQueryResultsFB& operator=(const SpaceQueryResultsFB& rhs) = default;
  //! Copy construct from raw
  SpaceQueryResultsFB(const XrSpaceQueryResultsFB& rhs) : SpaceQueryResultsFB() { *put() = rhs; }
  //! Copy assign from raw
  SpaceQueryResultsFB& operator=(const XrSpaceQueryResultsFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceQueryResultsFB&() const {
    return *reinterpret_cast<const XrSpaceQueryResultsFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceQueryResultsFB&() { return *reinterpret_cast<XrSpaceQueryResultsFB*>(this); }

  //! Accessor for this as the address of a raw XrSpaceQueryResultsFB
  XrSpaceQueryResultsFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceQueryResultsFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceQueryResultsFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceQueryResultsFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceQueryResultsFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceQueryResultsFB*>(this);
  }
  uint32_t resultCapacityInput;
  uint32_t resultCountOutput;
  SpaceQueryResultFB* results;
};
static_assert(sizeof(XrSpaceQueryResultsFB) == sizeof(SpaceQueryResultsFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceQueryResultsFB pointer to const from a
 * SpaceQueryResultsFB reference to const.
 * @relates SpaceQueryResultsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceQueryResultsFB const* get(SpaceQueryResultsFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceQueryResultsFB as the
 * address of a raw XrSpaceQueryResultsFB
 * @relates SpaceQueryResultsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceQueryResultsFB* put(SpaceQueryResultsFB& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrEventDataSpaceQueryResultsAvailableFB
 *
 * Provided by the `XR_FB_spatial_entity_query` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceQueryResultsAvailableFB>
 * @xrentity{XrEventDataSpaceQueryResultsAvailableFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSpaceQueryResultsAvailableFB : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSpaceQueryResultsAvailableFB(void* next_ = nullptr)

      : Parent(StructureType::EventDataSpaceQueryResultsAvailableFB, next_) {}

  //! Default copy constructor
  EventDataSpaceQueryResultsAvailableFB(const EventDataSpaceQueryResultsAvailableFB& rhs) = default;
  //! Default copy assignment
  EventDataSpaceQueryResultsAvailableFB& operator=(
      const EventDataSpaceQueryResultsAvailableFB& rhs) = default;
  //! Copy construct from raw
  EventDataSpaceQueryResultsAvailableFB(const XrEventDataSpaceQueryResultsAvailableFB& rhs)
      : EventDataSpaceQueryResultsAvailableFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSpaceQueryResultsAvailableFB& operator=(
      const XrEventDataSpaceQueryResultsAvailableFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSpaceQueryResultsAvailableFB&() const {
    return *reinterpret_cast<const XrEventDataSpaceQueryResultsAvailableFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSpaceQueryResultsAvailableFB&() {
    return *reinterpret_cast<XrEventDataSpaceQueryResultsAvailableFB*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSpaceQueryResultsAvailableFB
  XrEventDataSpaceQueryResultsAvailableFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataSpaceQueryResultsAvailableFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSpaceQueryResultsAvailableFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSpaceQueryResultsAvailableFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSpaceQueryResultsAvailableFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSpaceQueryResultsAvailableFB*>(this);
  }
  AsyncRequestIdFB requestId;
};
static_assert(sizeof(XrEventDataSpaceQueryResultsAvailableFB) ==
                  sizeof(EventDataSpaceQueryResultsAvailableFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSpaceQueryResultsAvailableFB pointer to const
 * from a EventDataSpaceQueryResultsAvailableFB reference to const.
 * @relates EventDataSpaceQueryResultsAvailableFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceQueryResultsAvailableFB const* get(
    EventDataSpaceQueryResultsAvailableFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataSpaceQueryResultsAvailableFB as the address of a raw
 * XrEventDataSpaceQueryResultsAvailableFB
 * @relates EventDataSpaceQueryResultsAvailableFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceQueryResultsAvailableFB* put(
    EventDataSpaceQueryResultsAvailableFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceQueryResultsAvailableFB as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceQueryResultsAvailableFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSpaceQueryResultsAvailableFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_query
/*!
 * C++ projection of XrEventDataSpaceQueryCompleteFB
 *
 * Provided by the `XR_FB_spatial_entity_query` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceQueryCompleteFB>
 * @xrentity{XrEventDataSpaceQueryCompleteFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSpaceQueryCompleteFB : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSpaceQueryCompleteFB(void* next_ = nullptr)

      : Parent(StructureType::EventDataSpaceQueryCompleteFB, next_) {}

  //! Default copy constructor
  EventDataSpaceQueryCompleteFB(const EventDataSpaceQueryCompleteFB& rhs) = default;
  //! Default copy assignment
  EventDataSpaceQueryCompleteFB& operator=(const EventDataSpaceQueryCompleteFB& rhs) = default;
  //! Copy construct from raw
  EventDataSpaceQueryCompleteFB(const XrEventDataSpaceQueryCompleteFB& rhs)
      : EventDataSpaceQueryCompleteFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSpaceQueryCompleteFB& operator=(const XrEventDataSpaceQueryCompleteFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSpaceQueryCompleteFB&() const {
    return *reinterpret_cast<const XrEventDataSpaceQueryCompleteFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSpaceQueryCompleteFB&() {
    return *reinterpret_cast<XrEventDataSpaceQueryCompleteFB*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSpaceQueryCompleteFB
  XrEventDataSpaceQueryCompleteFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataSpaceQueryCompleteFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSpaceQueryCompleteFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSpaceQueryCompleteFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSpaceQueryCompleteFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSpaceQueryCompleteFB*>(this);
  }
  AsyncRequestIdFB requestId;
  Result result;
};
static_assert(sizeof(XrEventDataSpaceQueryCompleteFB) == sizeof(EventDataSpaceQueryCompleteFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSpaceQueryCompleteFB pointer to const from a
 * EventDataSpaceQueryCompleteFB reference to const.
 * @relates EventDataSpaceQueryCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceQueryCompleteFB const* get(
    EventDataSpaceQueryCompleteFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSpaceQueryCompleteFB
 * as the address of a raw XrEventDataSpaceQueryCompleteFB
 * @relates EventDataSpaceQueryCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceQueryCompleteFB* put(EventDataSpaceQueryCompleteFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceQueryCompleteFB as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceQueryCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSpaceQueryCompleteFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_storage
/*!
 * C++ projection of XrSpaceSaveInfoFB
 *
 * Provided by the `XR_FB_spatial_entity_storage` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceSaveInfoFB>
 * @xrentity{XrSpaceSaveInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceSaveInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpaceSaveInfoFB(const Space& space_, const SpaceStorageLocationFB& location_,
                  const SpacePersistenceModeFB& persistenceMode_, const void* next_ = nullptr)
      : Parent(StructureType::SpaceSaveInfoFB, next_),
        space{space_},
        location{location_},
        persistenceMode{persistenceMode_} {}

  //! Default/empty constructor
  SpaceSaveInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SpaceSaveInfoFB, next_), space{}, location{}, persistenceMode{} {}

  //! Default copy constructor
  SpaceSaveInfoFB(const SpaceSaveInfoFB& rhs) = default;
  //! Default copy assignment
  SpaceSaveInfoFB& operator=(const SpaceSaveInfoFB& rhs) = default;
  //! Copy construct from raw
  SpaceSaveInfoFB(const XrSpaceSaveInfoFB& rhs) : SpaceSaveInfoFB() { *put() = rhs; }
  //! Copy assign from raw
  SpaceSaveInfoFB& operator=(const XrSpaceSaveInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceSaveInfoFB&() const {
    return *reinterpret_cast<const XrSpaceSaveInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceSaveInfoFB&() { return *reinterpret_cast<XrSpaceSaveInfoFB*>(this); }

  //! Accessor for this as the address of a raw XrSpaceSaveInfoFB
  XrSpaceSaveInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceSaveInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceSaveInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceSaveInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceSaveInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceSaveInfoFB*>(this);
  }
  Space space;
  SpaceStorageLocationFB location;
  SpacePersistenceModeFB persistenceMode;
};
static_assert(sizeof(XrSpaceSaveInfoFB) == sizeof(SpaceSaveInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceSaveInfoFB pointer to const from a SpaceSaveInfoFB
 * reference to const.
 * @relates SpaceSaveInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceSaveInfoFB const* get(SpaceSaveInfoFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceSaveInfoFB as the
 * address of a raw XrSpaceSaveInfoFB
 * @relates SpaceSaveInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceSaveInfoFB* put(SpaceSaveInfoFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity_storage

#ifdef XR_FB_spatial_entity_storage
/*!
 * C++ projection of XrSpaceEraseInfoFB
 *
 * Provided by the `XR_FB_spatial_entity_storage` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceEraseInfoFB>
 * @xrentity{XrSpaceEraseInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceEraseInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpaceEraseInfoFB(const Space& space_, const SpaceStorageLocationFB& location_,
                   const void* next_ = nullptr)
      : Parent(StructureType::SpaceEraseInfoFB, next_), space{space_}, location{location_} {}

  //! Default/empty constructor
  SpaceEraseInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SpaceEraseInfoFB, next_), space{}, location{} {}

  //! Default copy constructor
  SpaceEraseInfoFB(const SpaceEraseInfoFB& rhs) = default;
  //! Default copy assignment
  SpaceEraseInfoFB& operator=(const SpaceEraseInfoFB& rhs) = default;
  //! Copy construct from raw
  SpaceEraseInfoFB(const XrSpaceEraseInfoFB& rhs) : SpaceEraseInfoFB() { *put() = rhs; }
  //! Copy assign from raw
  SpaceEraseInfoFB& operator=(const XrSpaceEraseInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceEraseInfoFB&() const {
    return *reinterpret_cast<const XrSpaceEraseInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceEraseInfoFB&() { return *reinterpret_cast<XrSpaceEraseInfoFB*>(this); }

  //! Accessor for this as the address of a raw XrSpaceEraseInfoFB
  XrSpaceEraseInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceEraseInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceEraseInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceEraseInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceEraseInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceEraseInfoFB*>(this);
  }
  Space space;
  SpaceStorageLocationFB location;
};
static_assert(sizeof(XrSpaceEraseInfoFB) == sizeof(SpaceEraseInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceEraseInfoFB pointer to const from a
 * SpaceEraseInfoFB reference to const.
 * @relates SpaceEraseInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceEraseInfoFB const* get(SpaceEraseInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceEraseInfoFB as the
 * address of a raw XrSpaceEraseInfoFB
 * @relates SpaceEraseInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceEraseInfoFB* put(SpaceEraseInfoFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity_storage

#ifdef XR_FB_spatial_entity_storage
/*!
 * C++ projection of XrEventDataSpaceSaveCompleteFB
 *
 * Provided by the `XR_FB_spatial_entity_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceSaveCompleteFB>
 * @xrentity{XrEventDataSpaceSaveCompleteFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSpaceSaveCompleteFB : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSpaceSaveCompleteFB(void* next_ = nullptr)

      : Parent(StructureType::EventDataSpaceSaveCompleteFB, next_) {}

  //! Default copy constructor
  EventDataSpaceSaveCompleteFB(const EventDataSpaceSaveCompleteFB& rhs) = default;
  //! Default copy assignment
  EventDataSpaceSaveCompleteFB& operator=(const EventDataSpaceSaveCompleteFB& rhs) = default;
  //! Copy construct from raw
  EventDataSpaceSaveCompleteFB(const XrEventDataSpaceSaveCompleteFB& rhs)
      : EventDataSpaceSaveCompleteFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSpaceSaveCompleteFB& operator=(const XrEventDataSpaceSaveCompleteFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSpaceSaveCompleteFB&() const {
    return *reinterpret_cast<const XrEventDataSpaceSaveCompleteFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSpaceSaveCompleteFB&() {
    return *reinterpret_cast<XrEventDataSpaceSaveCompleteFB*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSpaceSaveCompleteFB
  XrEventDataSpaceSaveCompleteFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataSpaceSaveCompleteFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSpaceSaveCompleteFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSpaceSaveCompleteFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSpaceSaveCompleteFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSpaceSaveCompleteFB*>(this);
  }
  AsyncRequestIdFB requestId;
  Result result;
  Space space;
  UuidEXT uuid;
  SpaceStorageLocationFB location;
};
static_assert(sizeof(XrEventDataSpaceSaveCompleteFB) == sizeof(EventDataSpaceSaveCompleteFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSpaceSaveCompleteFB pointer to const from a
 * EventDataSpaceSaveCompleteFB reference to const.
 * @relates EventDataSpaceSaveCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceSaveCompleteFB const* get(
    EventDataSpaceSaveCompleteFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSpaceSaveCompleteFB
 * as the address of a raw XrEventDataSpaceSaveCompleteFB
 * @relates EventDataSpaceSaveCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceSaveCompleteFB* put(EventDataSpaceSaveCompleteFB& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceSaveCompleteFB as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceSaveCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSpaceSaveCompleteFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_spatial_entity_storage

#ifdef XR_FB_spatial_entity_storage
/*!
 * C++ projection of XrEventDataSpaceEraseCompleteFB
 *
 * Provided by the `XR_FB_spatial_entity_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceEraseCompleteFB>
 * @xrentity{XrEventDataSpaceEraseCompleteFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSpaceEraseCompleteFB : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSpaceEraseCompleteFB(void* next_ = nullptr)

      : Parent(StructureType::EventDataSpaceEraseCompleteFB, next_) {}

  //! Default copy constructor
  EventDataSpaceEraseCompleteFB(const EventDataSpaceEraseCompleteFB& rhs) = default;
  //! Default copy assignment
  EventDataSpaceEraseCompleteFB& operator=(const EventDataSpaceEraseCompleteFB& rhs) = default;
  //! Copy construct from raw
  EventDataSpaceEraseCompleteFB(const XrEventDataSpaceEraseCompleteFB& rhs)
      : EventDataSpaceEraseCompleteFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSpaceEraseCompleteFB& operator=(const XrEventDataSpaceEraseCompleteFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSpaceEraseCompleteFB&() const {
    return *reinterpret_cast<const XrEventDataSpaceEraseCompleteFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSpaceEraseCompleteFB&() {
    return *reinterpret_cast<XrEventDataSpaceEraseCompleteFB*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSpaceEraseCompleteFB
  XrEventDataSpaceEraseCompleteFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataSpaceEraseCompleteFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSpaceEraseCompleteFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSpaceEraseCompleteFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSpaceEraseCompleteFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSpaceEraseCompleteFB*>(this);
  }
  AsyncRequestIdFB requestId;
  Result result;
  Space space;
  UuidEXT uuid;
  SpaceStorageLocationFB location;
};
static_assert(sizeof(XrEventDataSpaceEraseCompleteFB) == sizeof(EventDataSpaceEraseCompleteFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSpaceEraseCompleteFB pointer to const from a
 * EventDataSpaceEraseCompleteFB reference to const.
 * @relates EventDataSpaceEraseCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceEraseCompleteFB const* get(
    EventDataSpaceEraseCompleteFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSpaceEraseCompleteFB
 * as the address of a raw XrEventDataSpaceEraseCompleteFB
 * @relates EventDataSpaceEraseCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceEraseCompleteFB* put(EventDataSpaceEraseCompleteFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceEraseCompleteFB as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceEraseCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSpaceEraseCompleteFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_spatial_entity_storage

#ifdef XR_FB_foveation_vulkan
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrSwapchainImageFoveationVulkanFB
 *
 * Provided by the `XR_FB_foveation_vulkan` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainImageFoveationVulkanFB>
 * @xrentity{XrSwapchainImageFoveationVulkanFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainImageFoveationVulkanFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainImageFoveationVulkanFB(void* next_ = nullptr)

      : Parent(StructureType::SwapchainImageFoveationVulkanFB, next_) {}

  //! Default copy constructor
  SwapchainImageFoveationVulkanFB(const SwapchainImageFoveationVulkanFB& rhs) = default;
  //! Default copy assignment
  SwapchainImageFoveationVulkanFB& operator=(const SwapchainImageFoveationVulkanFB& rhs) = default;
  //! Copy construct from raw
  SwapchainImageFoveationVulkanFB(const XrSwapchainImageFoveationVulkanFB& rhs)
      : SwapchainImageFoveationVulkanFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainImageFoveationVulkanFB& operator=(const XrSwapchainImageFoveationVulkanFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainImageFoveationVulkanFB&() const {
    return *reinterpret_cast<const XrSwapchainImageFoveationVulkanFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainImageFoveationVulkanFB&() {
    return *reinterpret_cast<XrSwapchainImageFoveationVulkanFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSwapchainImageFoveationVulkanFB
  XrSwapchainImageFoveationVulkanFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainImageFoveationVulkanFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainImageFoveationVulkanFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainImageFoveationVulkanFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainImageFoveationVulkanFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainImageFoveationVulkanFB*>(this);
  }
  VkImage image;
  uint32_t width;
  uint32_t height;
};
static_assert(sizeof(XrSwapchainImageFoveationVulkanFB) == sizeof(SwapchainImageFoveationVulkanFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainImageFoveationVulkanFB pointer to const from a
 * SwapchainImageFoveationVulkanFB reference to const.
 * @relates SwapchainImageFoveationVulkanFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageFoveationVulkanFB const* get(
    SwapchainImageFoveationVulkanFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SwapchainImageFoveationVulkanFB as the address of a raw XrSwapchainImageFoveationVulkanFB
 * @relates SwapchainImageFoveationVulkanFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainImageFoveationVulkanFB* put(SwapchainImageFoveationVulkanFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_FB_foveation_vulkan

#ifdef XR_FB_swapchain_update_state_android_surface
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
/*!
 * C++ projection of XrSwapchainStateAndroidSurfaceDimensionsFB
 *
 * Provided by the `XR_FB_swapchain_update_state_android_surface` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateAndroidSurfaceDimensionsFB>
 * @xrentity{XrSwapchainStateAndroidSurfaceDimensionsFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainStateAndroidSurfaceDimensionsFB : public SwapchainStateBaseHeaderFB {
private:
  using Parent = SwapchainStateBaseHeaderFB;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainStateAndroidSurfaceDimensionsFB(void* next_ = nullptr)

      : Parent(StructureType::SwapchainStateAndroidSurfaceDimensionsFB, next_) {}

  //! Default copy constructor
  SwapchainStateAndroidSurfaceDimensionsFB(const SwapchainStateAndroidSurfaceDimensionsFB& rhs) =
      default;
  //! Default copy assignment
  SwapchainStateAndroidSurfaceDimensionsFB& operator=(
      const SwapchainStateAndroidSurfaceDimensionsFB& rhs) = default;
  //! Copy construct from raw
  SwapchainStateAndroidSurfaceDimensionsFB(const XrSwapchainStateAndroidSurfaceDimensionsFB& rhs)
      : SwapchainStateAndroidSurfaceDimensionsFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainStateAndroidSurfaceDimensionsFB& operator=(
      const XrSwapchainStateAndroidSurfaceDimensionsFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainStateAndroidSurfaceDimensionsFB&() const {
    return *reinterpret_cast<const XrSwapchainStateAndroidSurfaceDimensionsFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainStateAndroidSurfaceDimensionsFB&() {
    return *reinterpret_cast<XrSwapchainStateAndroidSurfaceDimensionsFB*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainStateBaseHeaderFB const pointer
  XrSwapchainStateBaseHeaderFB const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainStateAndroidSurfaceDimensionsFB
  XrSwapchainStateAndroidSurfaceDimensionsFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainStateAndroidSurfaceDimensionsFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainStateAndroidSurfaceDimensionsFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainStateAndroidSurfaceDimensionsFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainStateAndroidSurfaceDimensionsFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainStateAndroidSurfaceDimensionsFB*>(this);
  }
  uint32_t width;
  uint32_t height;
};
static_assert(sizeof(XrSwapchainStateAndroidSurfaceDimensionsFB) ==
                  sizeof(SwapchainStateAndroidSurfaceDimensionsFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainStateAndroidSurfaceDimensionsFB pointer to
 * const from a SwapchainStateAndroidSurfaceDimensionsFB reference to const.
 * @relates SwapchainStateAndroidSurfaceDimensionsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateAndroidSurfaceDimensionsFB const* get(
    SwapchainStateAndroidSurfaceDimensionsFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SwapchainStateAndroidSurfaceDimensionsFB as the address of a raw
 * XrSwapchainStateAndroidSurfaceDimensionsFB
 * @relates SwapchainStateAndroidSurfaceDimensionsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateAndroidSurfaceDimensionsFB* put(
    SwapchainStateAndroidSurfaceDimensionsFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainStateAndroidSurfaceDimensionsFB
 * as a raw, pointer to const XrSwapchainStateBaseHeaderFB (the base type)
 * @relates SwapchainStateAndroidSurfaceDimensionsFB
 * @relatesalso SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get_base(
    SwapchainStateAndroidSurfaceDimensionsFB const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_FB_swapchain_update_state_android_surface

#ifdef XR_FB_swapchain_update_state_opengl_es
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
/*!
 * C++ projection of XrSwapchainStateSamplerOpenGLESFB
 *
 * Provided by the `XR_FB_swapchain_update_state_opengl_es` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateSamplerOpenGLESFB>
 * @xrentity{XrSwapchainStateSamplerOpenGLESFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainStateSamplerOpenGLESFB : public SwapchainStateBaseHeaderFB {
private:
  using Parent = SwapchainStateBaseHeaderFB;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainStateSamplerOpenGLESFB(void* next_ = nullptr)

      : Parent(StructureType::SwapchainStateSamplerOpenGLESFB, next_) {}

  //! Default copy constructor
  SwapchainStateSamplerOpenGLESFB(const SwapchainStateSamplerOpenGLESFB& rhs) = default;
  //! Default copy assignment
  SwapchainStateSamplerOpenGLESFB& operator=(const SwapchainStateSamplerOpenGLESFB& rhs) = default;
  //! Copy construct from raw
  SwapchainStateSamplerOpenGLESFB(const XrSwapchainStateSamplerOpenGLESFB& rhs)
      : SwapchainStateSamplerOpenGLESFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainStateSamplerOpenGLESFB& operator=(const XrSwapchainStateSamplerOpenGLESFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainStateSamplerOpenGLESFB&() const {
    return *reinterpret_cast<const XrSwapchainStateSamplerOpenGLESFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainStateSamplerOpenGLESFB&() {
    return *reinterpret_cast<XrSwapchainStateSamplerOpenGLESFB*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainStateBaseHeaderFB const pointer
  XrSwapchainStateBaseHeaderFB const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainStateSamplerOpenGLESFB
  XrSwapchainStateSamplerOpenGLESFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainStateSamplerOpenGLESFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainStateSamplerOpenGLESFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainStateSamplerOpenGLESFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainStateSamplerOpenGLESFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainStateSamplerOpenGLESFB*>(this);
  }
  EGLenum minFilter;
  EGLenum magFilter;
  EGLenum wrapModeS;
  EGLenum wrapModeT;
  EGLenum swizzleRed;
  EGLenum swizzleGreen;
  EGLenum swizzleBlue;
  EGLenum swizzleAlpha;
  float maxAnisotropy;
  Color4f borderColor;
};
static_assert(sizeof(XrSwapchainStateSamplerOpenGLESFB) == sizeof(SwapchainStateSamplerOpenGLESFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainStateSamplerOpenGLESFB pointer to const from a
 * SwapchainStateSamplerOpenGLESFB reference to const.
 * @relates SwapchainStateSamplerOpenGLESFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateSamplerOpenGLESFB const* get(
    SwapchainStateSamplerOpenGLESFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SwapchainStateSamplerOpenGLESFB as the address of a raw XrSwapchainStateSamplerOpenGLESFB
 * @relates SwapchainStateSamplerOpenGLESFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateSamplerOpenGLESFB* put(SwapchainStateSamplerOpenGLESFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainStateSamplerOpenGLESFB as a raw,
 * pointer to const XrSwapchainStateBaseHeaderFB (the base type)
 * @relates SwapchainStateSamplerOpenGLESFB
 * @relatesalso SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get_base(
    SwapchainStateSamplerOpenGLESFB const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_FB_swapchain_update_state_opengl_es

#ifdef XR_FB_swapchain_update_state_vulkan
#if defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrSwapchainStateSamplerVulkanFB
 *
 * Provided by the `XR_FB_swapchain_update_state_vulkan` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchainStateSamplerVulkanFB>
 * @xrentity{XrSwapchainStateSamplerVulkanFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SwapchainStateSamplerVulkanFB : public SwapchainStateBaseHeaderFB {
private:
  using Parent = SwapchainStateBaseHeaderFB;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SwapchainStateSamplerVulkanFB(void* next_ = nullptr)

      : Parent(StructureType::SwapchainStateSamplerVulkanFB, next_) {}

  //! Default copy constructor
  SwapchainStateSamplerVulkanFB(const SwapchainStateSamplerVulkanFB& rhs) = default;
  //! Default copy assignment
  SwapchainStateSamplerVulkanFB& operator=(const SwapchainStateSamplerVulkanFB& rhs) = default;
  //! Copy construct from raw
  SwapchainStateSamplerVulkanFB(const XrSwapchainStateSamplerVulkanFB& rhs)
      : SwapchainStateSamplerVulkanFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SwapchainStateSamplerVulkanFB& operator=(const XrSwapchainStateSamplerVulkanFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSwapchainStateSamplerVulkanFB&() const {
    return *reinterpret_cast<const XrSwapchainStateSamplerVulkanFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSwapchainStateSamplerVulkanFB&() {
    return *reinterpret_cast<XrSwapchainStateSamplerVulkanFB*>(this);
  }

  //! Accessor for this as a raw, base XrSwapchainStateBaseHeaderFB const pointer
  XrSwapchainStateBaseHeaderFB const* get_base() const noexcept {
    return reinterpret_cast<XrSwapchainStateBaseHeaderFB const*>(this);
  }
  //! Accessor for this as the address of a raw XrSwapchainStateSamplerVulkanFB
  XrSwapchainStateSamplerVulkanFB const* get() const noexcept {
    return reinterpret_cast<XrSwapchainStateSamplerVulkanFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSwapchainStateSamplerVulkanFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSwapchainStateSamplerVulkanFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SwapchainStateSamplerVulkanFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSwapchainStateSamplerVulkanFB*>(this);
  }
  VkFilter minFilter;
  VkFilter magFilter;
  VkSamplerMipmapMode mipmapMode;
  VkSamplerAddressMode wrapModeS;
  VkSamplerAddressMode wrapModeT;
  VkComponentSwizzle swizzleRed;
  VkComponentSwizzle swizzleGreen;
  VkComponentSwizzle swizzleBlue;
  VkComponentSwizzle swizzleAlpha;
  float maxAnisotropy;
  Color4f borderColor;
};
static_assert(sizeof(XrSwapchainStateSamplerVulkanFB) == sizeof(SwapchainStateSamplerVulkanFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSwapchainStateSamplerVulkanFB pointer to const from a
 * SwapchainStateSamplerVulkanFB reference to const.
 * @relates SwapchainStateSamplerVulkanFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateSamplerVulkanFB const* get(
    SwapchainStateSamplerVulkanFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SwapchainStateSamplerVulkanFB
 * as the address of a raw XrSwapchainStateSamplerVulkanFB
 * @relates SwapchainStateSamplerVulkanFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateSamplerVulkanFB* put(SwapchainStateSamplerVulkanFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SwapchainStateSamplerVulkanFB as a raw,
 * pointer to const XrSwapchainStateBaseHeaderFB (the base type)
 * @relates SwapchainStateSamplerVulkanFB
 * @relatesalso SwapchainStateBaseHeaderFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSwapchainStateBaseHeaderFB const* get_base(
    SwapchainStateSamplerVulkanFB const& h) {
  return h.get_base();
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_FB_swapchain_update_state_vulkan

#ifdef XR_FB_spatial_entity_sharing
/*!
 * C++ projection of XrSpaceShareInfoFB
 *
 * Provided by the `XR_FB_spatial_entity_sharing` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceShareInfoFB>
 * @xrentity{XrSpaceShareInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceShareInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpaceShareInfoFB(uint32_t spaceCount_, Space* spaces_, uint32_t userCount_, SpaceUserFB* users_,
                   const void* next_ = nullptr)
      : Parent(StructureType::SpaceShareInfoFB, next_),
        spaceCount{spaceCount_},
        spaces{spaces_},
        userCount{userCount_},
        users{users_} {}

  //! Default/empty constructor
  SpaceShareInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SpaceShareInfoFB, next_),
        spaceCount{0},
        spaces{nullptr},
        userCount{0},
        users{nullptr} {}

  //! Default copy constructor
  SpaceShareInfoFB(const SpaceShareInfoFB& rhs) = default;
  //! Default copy assignment
  SpaceShareInfoFB& operator=(const SpaceShareInfoFB& rhs) = default;
  //! Copy construct from raw
  SpaceShareInfoFB(const XrSpaceShareInfoFB& rhs) : SpaceShareInfoFB() { *put() = rhs; }
  //! Copy assign from raw
  SpaceShareInfoFB& operator=(const XrSpaceShareInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceShareInfoFB&() const {
    return *reinterpret_cast<const XrSpaceShareInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceShareInfoFB&() { return *reinterpret_cast<XrSpaceShareInfoFB*>(this); }

  //! Accessor for this as the address of a raw XrSpaceShareInfoFB
  XrSpaceShareInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceShareInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceShareInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceShareInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceShareInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceShareInfoFB*>(this);
  }
  uint32_t spaceCount;
  Space* spaces;
  uint32_t userCount;
  SpaceUserFB* users;
};
static_assert(sizeof(XrSpaceShareInfoFB) == sizeof(SpaceShareInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceShareInfoFB pointer to const from a
 * SpaceShareInfoFB reference to const.
 * @relates SpaceShareInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceShareInfoFB const* get(SpaceShareInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceShareInfoFB as the
 * address of a raw XrSpaceShareInfoFB
 * @relates SpaceShareInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceShareInfoFB* put(SpaceShareInfoFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity_sharing

#ifdef XR_FB_spatial_entity_sharing
/*!
 * C++ projection of XrEventDataSpaceShareCompleteFB
 *
 * Provided by the `XR_FB_spatial_entity_sharing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceShareCompleteFB>
 * @xrentity{XrEventDataSpaceShareCompleteFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSpaceShareCompleteFB : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSpaceShareCompleteFB(void* next_ = nullptr)

      : Parent(StructureType::EventDataSpaceShareCompleteFB, next_) {}

  //! Default copy constructor
  EventDataSpaceShareCompleteFB(const EventDataSpaceShareCompleteFB& rhs) = default;
  //! Default copy assignment
  EventDataSpaceShareCompleteFB& operator=(const EventDataSpaceShareCompleteFB& rhs) = default;
  //! Copy construct from raw
  EventDataSpaceShareCompleteFB(const XrEventDataSpaceShareCompleteFB& rhs)
      : EventDataSpaceShareCompleteFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSpaceShareCompleteFB& operator=(const XrEventDataSpaceShareCompleteFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSpaceShareCompleteFB&() const {
    return *reinterpret_cast<const XrEventDataSpaceShareCompleteFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSpaceShareCompleteFB&() {
    return *reinterpret_cast<XrEventDataSpaceShareCompleteFB*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSpaceShareCompleteFB
  XrEventDataSpaceShareCompleteFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataSpaceShareCompleteFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSpaceShareCompleteFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSpaceShareCompleteFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSpaceShareCompleteFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSpaceShareCompleteFB*>(this);
  }
  AsyncRequestIdFB requestId;
  Result result;
};
static_assert(sizeof(XrEventDataSpaceShareCompleteFB) == sizeof(EventDataSpaceShareCompleteFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSpaceShareCompleteFB pointer to const from a
 * EventDataSpaceShareCompleteFB reference to const.
 * @relates EventDataSpaceShareCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceShareCompleteFB const* get(
    EventDataSpaceShareCompleteFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSpaceShareCompleteFB
 * as the address of a raw XrEventDataSpaceShareCompleteFB
 * @relates EventDataSpaceShareCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceShareCompleteFB* put(EventDataSpaceShareCompleteFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceShareCompleteFB as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceShareCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSpaceShareCompleteFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_spatial_entity_sharing

#ifdef XR_FB_space_warp
/*!
 * C++ projection of XrCompositionLayerSpaceWarpInfoFB
 *
 * Provided by the `XR_FB_space_warp` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerSpaceWarpInfoFB>
 * @xrentity{XrCompositionLayerSpaceWarpInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerSpaceWarpInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerSpaceWarpInfoFB(const CompositionLayerSpaceWarpInfoFlagsFB& layerFlags_,
                                  const SwapchainSubImage& motionVectorSubImage_,
                                  const Posef& appSpaceDeltaPose_,
                                  const SwapchainSubImage& depthSubImage_, float minDepth_,
                                  float maxDepth_, float nearZ_, float farZ_,
                                  const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerSpaceWarpInfoFB, next_),
        layerFlags{layerFlags_},
        motionVectorSubImage{motionVectorSubImage_},
        appSpaceDeltaPose{appSpaceDeltaPose_},
        depthSubImage{depthSubImage_},
        minDepth{minDepth_},
        maxDepth{maxDepth_},
        nearZ{nearZ_},
        farZ{farZ_} {}

  //! Default/empty constructor
  CompositionLayerSpaceWarpInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerSpaceWarpInfoFB, next_),
        layerFlags{},
        motionVectorSubImage{},
        appSpaceDeltaPose{},
        depthSubImage{},
        minDepth{0.0f},
        maxDepth{0.0f},
        nearZ{0.0f},
        farZ{0.0f} {}

  //! Default copy constructor
  CompositionLayerSpaceWarpInfoFB(const CompositionLayerSpaceWarpInfoFB& rhs) = default;
  //! Default copy assignment
  CompositionLayerSpaceWarpInfoFB& operator=(const CompositionLayerSpaceWarpInfoFB& rhs) = default;
  //! Copy construct from raw
  CompositionLayerSpaceWarpInfoFB(const XrCompositionLayerSpaceWarpInfoFB& rhs)
      : CompositionLayerSpaceWarpInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerSpaceWarpInfoFB& operator=(const XrCompositionLayerSpaceWarpInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerSpaceWarpInfoFB&() const {
    return *reinterpret_cast<const XrCompositionLayerSpaceWarpInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerSpaceWarpInfoFB&() {
    return *reinterpret_cast<XrCompositionLayerSpaceWarpInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerSpaceWarpInfoFB
  XrCompositionLayerSpaceWarpInfoFB const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerSpaceWarpInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerSpaceWarpInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerSpaceWarpInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerSpaceWarpInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerSpaceWarpInfoFB*>(this);
  }
  CompositionLayerSpaceWarpInfoFlagsFB layerFlags;
  SwapchainSubImage motionVectorSubImage;
  Posef appSpaceDeltaPose;
  SwapchainSubImage depthSubImage;
  float minDepth;
  float maxDepth;
  float nearZ;
  float farZ;
};
static_assert(sizeof(XrCompositionLayerSpaceWarpInfoFB) == sizeof(CompositionLayerSpaceWarpInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerSpaceWarpInfoFB pointer to const from a
 * CompositionLayerSpaceWarpInfoFB reference to const.
 * @relates CompositionLayerSpaceWarpInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerSpaceWarpInfoFB const* get(
    CompositionLayerSpaceWarpInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerSpaceWarpInfoFB as the address of a raw XrCompositionLayerSpaceWarpInfoFB
 * @relates CompositionLayerSpaceWarpInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerSpaceWarpInfoFB* put(CompositionLayerSpaceWarpInfoFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_space_warp

#ifdef XR_FB_space_warp
/*!
 * C++ projection of XrSystemSpaceWarpPropertiesFB
 *
 * Provided by the `XR_FB_space_warp` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpaceWarpPropertiesFB>
 * @xrentity{XrSystemSpaceWarpPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemSpaceWarpPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemSpaceWarpPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemSpaceWarpPropertiesFB, next_) {}

  //! Default copy constructor
  SystemSpaceWarpPropertiesFB(const SystemSpaceWarpPropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemSpaceWarpPropertiesFB& operator=(const SystemSpaceWarpPropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemSpaceWarpPropertiesFB(const XrSystemSpaceWarpPropertiesFB& rhs)
      : SystemSpaceWarpPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemSpaceWarpPropertiesFB& operator=(const XrSystemSpaceWarpPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemSpaceWarpPropertiesFB&() const {
    return *reinterpret_cast<const XrSystemSpaceWarpPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemSpaceWarpPropertiesFB&() {
    return *reinterpret_cast<XrSystemSpaceWarpPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemSpaceWarpPropertiesFB
  XrSystemSpaceWarpPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemSpaceWarpPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemSpaceWarpPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemSpaceWarpPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemSpaceWarpPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemSpaceWarpPropertiesFB*>(this);
  }
  uint32_t recommendedMotionVectorImageRectWidth;
  uint32_t recommendedMotionVectorImageRectHeight;
};
static_assert(sizeof(XrSystemSpaceWarpPropertiesFB) == sizeof(SystemSpaceWarpPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemSpaceWarpPropertiesFB pointer to const from a
 * SystemSpaceWarpPropertiesFB reference to const.
 * @relates SystemSpaceWarpPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpaceWarpPropertiesFB const* get(
    SystemSpaceWarpPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemSpaceWarpPropertiesFB
 * as the address of a raw XrSystemSpaceWarpPropertiesFB
 * @relates SystemSpaceWarpPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpaceWarpPropertiesFB* put(SystemSpaceWarpPropertiesFB& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_space_warp

#ifdef XR_FB_haptic_amplitude_envelope
/*!
 * C++ projection of XrHapticAmplitudeEnvelopeVibrationFB
 *
 * Provided by the `XR_FB_haptic_amplitude_envelope` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticAmplitudeEnvelopeVibrationFB>
 * @xrentity{XrHapticAmplitudeEnvelopeVibrationFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HapticAmplitudeEnvelopeVibrationFB : public HapticBaseHeader {
private:
  using Parent = HapticBaseHeader;

public:
  //! Constructor initializing all members.
  HapticAmplitudeEnvelopeVibrationFB(const Duration& duration_, uint32_t amplitudeCount_,
                                     const float* amplitudes_, const void* next_ = nullptr)
      : Parent(StructureType::HapticAmplitudeEnvelopeVibrationFB, next_),
        duration{duration_},
        amplitudeCount{amplitudeCount_},
        amplitudes{amplitudes_} {}

  //! Default/empty constructor
  HapticAmplitudeEnvelopeVibrationFB(const void* next_ = nullptr)

      : Parent(StructureType::HapticAmplitudeEnvelopeVibrationFB, next_),
        duration{},
        amplitudeCount{0},
        amplitudes{nullptr} {}

  //! Default copy constructor
  HapticAmplitudeEnvelopeVibrationFB(const HapticAmplitudeEnvelopeVibrationFB& rhs) = default;
  //! Default copy assignment
  HapticAmplitudeEnvelopeVibrationFB& operator=(const HapticAmplitudeEnvelopeVibrationFB& rhs) =
      default;
  //! Copy construct from raw
  HapticAmplitudeEnvelopeVibrationFB(const XrHapticAmplitudeEnvelopeVibrationFB& rhs)
      : HapticAmplitudeEnvelopeVibrationFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HapticAmplitudeEnvelopeVibrationFB& operator=(const XrHapticAmplitudeEnvelopeVibrationFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHapticAmplitudeEnvelopeVibrationFB&() const {
    return *reinterpret_cast<const XrHapticAmplitudeEnvelopeVibrationFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHapticAmplitudeEnvelopeVibrationFB&() {
    return *reinterpret_cast<XrHapticAmplitudeEnvelopeVibrationFB*>(this);
  }

  //! Accessor for this as a raw, base XrHapticBaseHeader const pointer
  XrHapticBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrHapticBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrHapticAmplitudeEnvelopeVibrationFB
  XrHapticAmplitudeEnvelopeVibrationFB const* get() const noexcept {
    return reinterpret_cast<XrHapticAmplitudeEnvelopeVibrationFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHapticAmplitudeEnvelopeVibrationFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHapticAmplitudeEnvelopeVibrationFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HapticAmplitudeEnvelopeVibrationFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrHapticAmplitudeEnvelopeVibrationFB*>(this);
  }
  Duration duration;
  uint32_t amplitudeCount;
  const float* amplitudes;
};
static_assert(sizeof(XrHapticAmplitudeEnvelopeVibrationFB) ==
                  sizeof(HapticAmplitudeEnvelopeVibrationFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHapticAmplitudeEnvelopeVibrationFB pointer to const from
 * a HapticAmplitudeEnvelopeVibrationFB reference to const.
 * @relates HapticAmplitudeEnvelopeVibrationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticAmplitudeEnvelopeVibrationFB const* get(
    HapticAmplitudeEnvelopeVibrationFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * HapticAmplitudeEnvelopeVibrationFB as the address of a raw XrHapticAmplitudeEnvelopeVibrationFB
 * @relates HapticAmplitudeEnvelopeVibrationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticAmplitudeEnvelopeVibrationFB* put(
    HapticAmplitudeEnvelopeVibrationFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const HapticAmplitudeEnvelopeVibrationFB as a
 * raw, pointer to const XrHapticBaseHeader (the base type)
 * @relates HapticAmplitudeEnvelopeVibrationFB
 * @relatesalso HapticBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticBaseHeader const* get_base(
    HapticAmplitudeEnvelopeVibrationFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_haptic_amplitude_envelope

#ifdef XR_FB_scene
/*!
 * C++ projection of XrOffset3DfFB
 *
 * Provided by the `XR_FB_scene` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrOffset3DfFB>
 * @xrentity{XrOffset3DfFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Offset3DfFB {
public:
  //! Constructor initializing all members.
  Offset3DfFB(float x_, float y_, float z_) : x{x_}, y{y_}, z{z_} {}

  //! Default/empty constructor
  Offset3DfFB()

      : x{0.0f}, y{0.0f}, z{0.0f} {}

  //! Default copy constructor
  Offset3DfFB(const Offset3DfFB& rhs) = default;
  //! Default copy assignment
  Offset3DfFB& operator=(const Offset3DfFB& rhs) = default;
  //! Copy construct from raw
  Offset3DfFB(const XrOffset3DfFB& rhs) : Offset3DfFB() { *put() = rhs; }
  //! Copy assign from raw
  Offset3DfFB& operator=(const XrOffset3DfFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrOffset3DfFB&() const { return *reinterpret_cast<const XrOffset3DfFB*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrOffset3DfFB&() { return *reinterpret_cast<XrOffset3DfFB*>(this); }

  //! Accessor for this as the address of a raw XrOffset3DfFB
  XrOffset3DfFB const* get() const noexcept { return reinterpret_cast<XrOffset3DfFB const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrOffset3DfFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrOffset3DfFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = Offset3DfFB{};
    }
    return reinterpret_cast<XrOffset3DfFB*>(this);
  }
  float x;
  float y;
  float z;
};
static_assert(sizeof(XrOffset3DfFB) == sizeof(Offset3DfFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrOffset3DfFB pointer to const from a Offset3DfFB
 * reference to const.
 * @relates Offset3DfFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset3DfFB const* get(Offset3DfFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Offset3DfFB as the address of
 * a raw XrOffset3DfFB
 * @relates Offset3DfFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrOffset3DfFB* put(Offset3DfFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_scene

#ifdef XR_FB_scene
/*!
 * C++ projection of XrRect3DfFB
 *
 * Provided by the `XR_FB_scene` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRect3DfFB>
 * @xrentity{XrRect3DfFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS Rect3DfFB {
public:
  //! Constructor initializing all members.
  Rect3DfFB(const Offset3DfFB& offset_, const Extent3DfFB& extent_)
      : offset{offset_}, extent{extent_} {}

  //! Default/empty constructor
  Rect3DfFB()

      : offset{}, extent{} {}

  //! Default copy constructor
  Rect3DfFB(const Rect3DfFB& rhs) = default;
  //! Default copy assignment
  Rect3DfFB& operator=(const Rect3DfFB& rhs) = default;
  //! Copy construct from raw
  Rect3DfFB(const XrRect3DfFB& rhs) : Rect3DfFB() { *put() = rhs; }
  //! Copy assign from raw
  Rect3DfFB& operator=(const XrRect3DfFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRect3DfFB&() const { return *reinterpret_cast<const XrRect3DfFB*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRect3DfFB&() { return *reinterpret_cast<XrRect3DfFB*>(this); }

  //! Accessor for this as the address of a raw XrRect3DfFB
  XrRect3DfFB const* get() const noexcept { return reinterpret_cast<XrRect3DfFB const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRect3DfFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrRect3DfFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = Rect3DfFB{};
    }
    return reinterpret_cast<XrRect3DfFB*>(this);
  }
  Offset3DfFB offset;
  Extent3DfFB extent;
};
static_assert(sizeof(XrRect3DfFB) == sizeof(Rect3DfFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRect3DfFB pointer to const from a Rect3DfFB reference to
 * const.
 * @relates Rect3DfFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect3DfFB const* get(Rect3DfFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Rect3DfFB as the address of a
 * raw XrRect3DfFB
 * @relates Rect3DfFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRect3DfFB* put(Rect3DfFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_scene

#ifdef XR_FB_scene
/*!
 * C++ projection of XrSemanticLabelsFB
 *
 * Provided by the `XR_FB_scene` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSemanticLabelsFB>
 * @xrentity{XrSemanticLabelsFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SemanticLabelsFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SemanticLabelsFB(uint32_t bufferCapacityInput_, uint32_t bufferCountOutput_, char* buffer_,
                   const void* next_ = nullptr)
      : Parent(StructureType::SemanticLabelsFB, next_),
        bufferCapacityInput{bufferCapacityInput_},
        bufferCountOutput{bufferCountOutput_},
        buffer{buffer_} {}

  //! Default/empty constructor
  SemanticLabelsFB(const void* next_ = nullptr)

      : Parent(StructureType::SemanticLabelsFB, next_),
        bufferCapacityInput{0},
        bufferCountOutput{0},
        buffer{nullptr} {}

  //! Default copy constructor
  SemanticLabelsFB(const SemanticLabelsFB& rhs) = default;
  //! Default copy assignment
  SemanticLabelsFB& operator=(const SemanticLabelsFB& rhs) = default;
  //! Copy construct from raw
  SemanticLabelsFB(const XrSemanticLabelsFB& rhs) : SemanticLabelsFB() { *put() = rhs; }
  //! Copy assign from raw
  SemanticLabelsFB& operator=(const XrSemanticLabelsFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSemanticLabelsFB&() const {
    return *reinterpret_cast<const XrSemanticLabelsFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSemanticLabelsFB&() { return *reinterpret_cast<XrSemanticLabelsFB*>(this); }

  //! Accessor for this as the address of a raw XrSemanticLabelsFB
  XrSemanticLabelsFB const* get() const noexcept {
    return reinterpret_cast<XrSemanticLabelsFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSemanticLabelsFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSemanticLabelsFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SemanticLabelsFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSemanticLabelsFB*>(this);
  }
  uint32_t bufferCapacityInput;
  uint32_t bufferCountOutput;
  char* buffer;
};
static_assert(sizeof(XrSemanticLabelsFB) == sizeof(SemanticLabelsFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSemanticLabelsFB pointer to const from a
 * SemanticLabelsFB reference to const.
 * @relates SemanticLabelsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSemanticLabelsFB const* get(SemanticLabelsFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SemanticLabelsFB as the
 * address of a raw XrSemanticLabelsFB
 * @relates SemanticLabelsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSemanticLabelsFB* put(SemanticLabelsFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_scene

#ifdef XR_FB_scene
/*!
 * C++ projection of XrRoomLayoutFB
 *
 * Provided by the `XR_FB_scene` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRoomLayoutFB>
 * @xrentity{XrRoomLayoutFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RoomLayoutFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  RoomLayoutFB(const UuidEXT& floorUuid_, const UuidEXT& ceilingUuid_,
               uint32_t wallUuidCapacityInput_, uint32_t wallUuidCountOutput_, UuidEXT* wallUuids_,
               const void* next_ = nullptr)
      : Parent(StructureType::RoomLayoutFB, next_),
        floorUuid{floorUuid_},
        ceilingUuid{ceilingUuid_},
        wallUuidCapacityInput{wallUuidCapacityInput_},
        wallUuidCountOutput{wallUuidCountOutput_},
        wallUuids{wallUuids_} {}

  //! Default/empty constructor
  RoomLayoutFB(const void* next_ = nullptr)

      : Parent(StructureType::RoomLayoutFB, next_),
        floorUuid{},
        ceilingUuid{},
        wallUuidCapacityInput{0},
        wallUuidCountOutput{0},
        wallUuids{nullptr} {}

  //! Default copy constructor
  RoomLayoutFB(const RoomLayoutFB& rhs) = default;
  //! Default copy assignment
  RoomLayoutFB& operator=(const RoomLayoutFB& rhs) = default;
  //! Copy construct from raw
  RoomLayoutFB(const XrRoomLayoutFB& rhs) : RoomLayoutFB() { *put() = rhs; }
  //! Copy assign from raw
  RoomLayoutFB& operator=(const XrRoomLayoutFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRoomLayoutFB&() const { return *reinterpret_cast<const XrRoomLayoutFB*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRoomLayoutFB&() { return *reinterpret_cast<XrRoomLayoutFB*>(this); }

  //! Accessor for this as the address of a raw XrRoomLayoutFB
  XrRoomLayoutFB const* get() const noexcept {
    return reinterpret_cast<XrRoomLayoutFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRoomLayoutFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRoomLayoutFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RoomLayoutFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrRoomLayoutFB*>(this);
  }
  UuidEXT floorUuid;
  UuidEXT ceilingUuid;
  uint32_t wallUuidCapacityInput;
  uint32_t wallUuidCountOutput;
  UuidEXT* wallUuids;
};
static_assert(sizeof(XrRoomLayoutFB) == sizeof(RoomLayoutFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRoomLayoutFB pointer to const from a RoomLayoutFB
 * reference to const.
 * @relates RoomLayoutFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRoomLayoutFB const* get(RoomLayoutFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing RoomLayoutFB as the address
 * of a raw XrRoomLayoutFB
 * @relates RoomLayoutFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRoomLayoutFB* put(RoomLayoutFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_scene

#ifdef XR_FB_scene
/*!
 * C++ projection of XrBoundary2DFB
 *
 * Provided by the `XR_FB_scene` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBoundary2DFB>
 * @xrentity{XrBoundary2DFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS Boundary2DFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  Boundary2DFB(uint32_t vertexCapacityInput_, uint32_t vertexCountOutput_, Vector2f* vertices_,
               const void* next_ = nullptr)
      : Parent(StructureType::Boundary2DFB, next_),
        vertexCapacityInput{vertexCapacityInput_},
        vertexCountOutput{vertexCountOutput_},
        vertices{vertices_} {}

  //! Default/empty constructor
  Boundary2DFB(const void* next_ = nullptr)

      : Parent(StructureType::Boundary2DFB, next_),
        vertexCapacityInput{0},
        vertexCountOutput{0},
        vertices{nullptr} {}

  //! Default copy constructor
  Boundary2DFB(const Boundary2DFB& rhs) = default;
  //! Default copy assignment
  Boundary2DFB& operator=(const Boundary2DFB& rhs) = default;
  //! Copy construct from raw
  Boundary2DFB(const XrBoundary2DFB& rhs) : Boundary2DFB() { *put() = rhs; }
  //! Copy assign from raw
  Boundary2DFB& operator=(const XrBoundary2DFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBoundary2DFB&() const { return *reinterpret_cast<const XrBoundary2DFB*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBoundary2DFB&() { return *reinterpret_cast<XrBoundary2DFB*>(this); }

  //! Accessor for this as the address of a raw XrBoundary2DFB
  XrBoundary2DFB const* get() const noexcept {
    return reinterpret_cast<XrBoundary2DFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBoundary2DFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBoundary2DFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = Boundary2DFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrBoundary2DFB*>(this);
  }
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  Vector2f* vertices;
};
static_assert(sizeof(XrBoundary2DFB) == sizeof(Boundary2DFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBoundary2DFB pointer to const from a Boundary2DFB
 * reference to const.
 * @relates Boundary2DFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBoundary2DFB const* get(Boundary2DFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing Boundary2DFB as the address
 * of a raw XrBoundary2DFB
 * @relates Boundary2DFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBoundary2DFB* put(Boundary2DFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_scene

#ifdef XR_FB_scene
/*!
 * C++ projection of XrSemanticLabelsSupportInfoFB
 *
 * Provided by the `XR_FB_scene` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSemanticLabelsSupportInfoFB>
 * @xrentity{XrSemanticLabelsSupportInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SemanticLabelsSupportInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SemanticLabelsSupportInfoFB(const SemanticLabelsSupportFlagsFB& flags_,
                              const char* recognizedLabels_, const void* next_ = nullptr)
      : Parent(StructureType::SemanticLabelsSupportInfoFB, next_),
        flags{flags_},
        recognizedLabels{recognizedLabels_} {}

  //! Default/empty constructor
  SemanticLabelsSupportInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SemanticLabelsSupportInfoFB, next_),
        flags{},
        recognizedLabels{nullptr} {}

  //! Default copy constructor
  SemanticLabelsSupportInfoFB(const SemanticLabelsSupportInfoFB& rhs) = default;
  //! Default copy assignment
  SemanticLabelsSupportInfoFB& operator=(const SemanticLabelsSupportInfoFB& rhs) = default;
  //! Copy construct from raw
  SemanticLabelsSupportInfoFB(const XrSemanticLabelsSupportInfoFB& rhs)
      : SemanticLabelsSupportInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SemanticLabelsSupportInfoFB& operator=(const XrSemanticLabelsSupportInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSemanticLabelsSupportInfoFB&() const {
    return *reinterpret_cast<const XrSemanticLabelsSupportInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSemanticLabelsSupportInfoFB&() {
    return *reinterpret_cast<XrSemanticLabelsSupportInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSemanticLabelsSupportInfoFB
  XrSemanticLabelsSupportInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSemanticLabelsSupportInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSemanticLabelsSupportInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSemanticLabelsSupportInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SemanticLabelsSupportInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSemanticLabelsSupportInfoFB*>(this);
  }
  SemanticLabelsSupportFlagsFB flags;
  const char* recognizedLabels;
};
static_assert(sizeof(XrSemanticLabelsSupportInfoFB) == sizeof(SemanticLabelsSupportInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSemanticLabelsSupportInfoFB pointer to const from a
 * SemanticLabelsSupportInfoFB reference to const.
 * @relates SemanticLabelsSupportInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSemanticLabelsSupportInfoFB const* get(
    SemanticLabelsSupportInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SemanticLabelsSupportInfoFB
 * as the address of a raw XrSemanticLabelsSupportInfoFB
 * @relates SemanticLabelsSupportInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSemanticLabelsSupportInfoFB* put(SemanticLabelsSupportInfoFB& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_scene

#ifdef XR_ALMALENCE_digital_lens_control
/*!
 * C++ projection of XrDigitalLensControlALMALENCE
 *
 * Provided by the `XR_ALMALENCE_digital_lens_control` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDigitalLensControlALMALENCE>
 * @xrentity{XrDigitalLensControlALMALENCE}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DigitalLensControlALMALENCE : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  DigitalLensControlALMALENCE(const DigitalLensControlFlagsALMALENCE& flags_,
                              const void* next_ = nullptr)
      : Parent(StructureType::DigitalLensControlALMALENCE, next_), flags{flags_} {}

  //! Default/empty constructor
  DigitalLensControlALMALENCE(const void* next_ = nullptr)

      : Parent(StructureType::DigitalLensControlALMALENCE, next_), flags{} {}

  //! Default copy constructor
  DigitalLensControlALMALENCE(const DigitalLensControlALMALENCE& rhs) = default;
  //! Default copy assignment
  DigitalLensControlALMALENCE& operator=(const DigitalLensControlALMALENCE& rhs) = default;
  //! Copy construct from raw
  DigitalLensControlALMALENCE(const XrDigitalLensControlALMALENCE& rhs)
      : DigitalLensControlALMALENCE() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DigitalLensControlALMALENCE& operator=(const XrDigitalLensControlALMALENCE& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDigitalLensControlALMALENCE&() const {
    return *reinterpret_cast<const XrDigitalLensControlALMALENCE*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDigitalLensControlALMALENCE&() {
    return *reinterpret_cast<XrDigitalLensControlALMALENCE*>(this);
  }

  //! Accessor for this as the address of a raw XrDigitalLensControlALMALENCE
  XrDigitalLensControlALMALENCE const* get() const noexcept {
    return reinterpret_cast<XrDigitalLensControlALMALENCE const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDigitalLensControlALMALENCE.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDigitalLensControlALMALENCE* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DigitalLensControlALMALENCE{};
      next = oldNext;
    }
    return reinterpret_cast<XrDigitalLensControlALMALENCE*>(this);
  }
  DigitalLensControlFlagsALMALENCE flags;
};
static_assert(sizeof(XrDigitalLensControlALMALENCE) == sizeof(DigitalLensControlALMALENCE),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDigitalLensControlALMALENCE pointer to const from a
 * DigitalLensControlALMALENCE reference to const.
 * @relates DigitalLensControlALMALENCE
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDigitalLensControlALMALENCE const* get(
    DigitalLensControlALMALENCE const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing DigitalLensControlALMALENCE
 * as the address of a raw XrDigitalLensControlALMALENCE
 * @relates DigitalLensControlALMALENCE
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDigitalLensControlALMALENCE* put(DigitalLensControlALMALENCE& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ALMALENCE_digital_lens_control

#ifdef XR_FB_scene_capture
/*!
 * C++ projection of XrEventDataSceneCaptureCompleteFB
 *
 * Provided by the `XR_FB_scene_capture` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSceneCaptureCompleteFB>
 * @xrentity{XrEventDataSceneCaptureCompleteFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSceneCaptureCompleteFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSceneCaptureCompleteFB(void* next_ = nullptr)

      : Parent(StructureType::EventDataSceneCaptureCompleteFB, next_) {}

  //! Default copy constructor
  EventDataSceneCaptureCompleteFB(const EventDataSceneCaptureCompleteFB& rhs) = default;
  //! Default copy assignment
  EventDataSceneCaptureCompleteFB& operator=(const EventDataSceneCaptureCompleteFB& rhs) = default;
  //! Copy construct from raw
  EventDataSceneCaptureCompleteFB(const XrEventDataSceneCaptureCompleteFB& rhs)
      : EventDataSceneCaptureCompleteFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSceneCaptureCompleteFB& operator=(const XrEventDataSceneCaptureCompleteFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSceneCaptureCompleteFB&() const {
    return *reinterpret_cast<const XrEventDataSceneCaptureCompleteFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSceneCaptureCompleteFB&() {
    return *reinterpret_cast<XrEventDataSceneCaptureCompleteFB*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataSceneCaptureCompleteFB
  XrEventDataSceneCaptureCompleteFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataSceneCaptureCompleteFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSceneCaptureCompleteFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSceneCaptureCompleteFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSceneCaptureCompleteFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSceneCaptureCompleteFB*>(this);
  }
  AsyncRequestIdFB requestId;
  Result result;
};
static_assert(sizeof(XrEventDataSceneCaptureCompleteFB) == sizeof(EventDataSceneCaptureCompleteFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSceneCaptureCompleteFB pointer to const from a
 * EventDataSceneCaptureCompleteFB reference to const.
 * @relates EventDataSceneCaptureCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSceneCaptureCompleteFB const* get(
    EventDataSceneCaptureCompleteFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataSceneCaptureCompleteFB as the address of a raw XrEventDataSceneCaptureCompleteFB
 * @relates EventDataSceneCaptureCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSceneCaptureCompleteFB* put(EventDataSceneCaptureCompleteFB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_scene_capture

#ifdef XR_FB_scene_capture
/*!
 * C++ projection of XrSceneCaptureRequestInfoFB
 *
 * Provided by the `XR_FB_scene_capture` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneCaptureRequestInfoFB>
 * @xrentity{XrSceneCaptureRequestInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneCaptureRequestInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SceneCaptureRequestInfoFB(uint32_t requestByteCount_, const char* request_,
                            const void* next_ = nullptr)
      : Parent(StructureType::SceneCaptureRequestInfoFB, next_),
        requestByteCount{requestByteCount_},
        request{request_} {}

  //! Default/empty constructor
  SceneCaptureRequestInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SceneCaptureRequestInfoFB, next_),
        requestByteCount{0},
        request{nullptr} {}

  //! Default copy constructor
  SceneCaptureRequestInfoFB(const SceneCaptureRequestInfoFB& rhs) = default;
  //! Default copy assignment
  SceneCaptureRequestInfoFB& operator=(const SceneCaptureRequestInfoFB& rhs) = default;
  //! Copy construct from raw
  SceneCaptureRequestInfoFB(const XrSceneCaptureRequestInfoFB& rhs) : SceneCaptureRequestInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SceneCaptureRequestInfoFB& operator=(const XrSceneCaptureRequestInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneCaptureRequestInfoFB&() const {
    return *reinterpret_cast<const XrSceneCaptureRequestInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneCaptureRequestInfoFB&() {
    return *reinterpret_cast<XrSceneCaptureRequestInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSceneCaptureRequestInfoFB
  XrSceneCaptureRequestInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSceneCaptureRequestInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSceneCaptureRequestInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneCaptureRequestInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneCaptureRequestInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneCaptureRequestInfoFB*>(this);
  }
  uint32_t requestByteCount;
  const char* request;
};
static_assert(sizeof(XrSceneCaptureRequestInfoFB) == sizeof(SceneCaptureRequestInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneCaptureRequestInfoFB pointer to const from a
 * SceneCaptureRequestInfoFB reference to const.
 * @relates SceneCaptureRequestInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneCaptureRequestInfoFB const* get(
    SceneCaptureRequestInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneCaptureRequestInfoFB as
 * the address of a raw XrSceneCaptureRequestInfoFB
 * @relates SceneCaptureRequestInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneCaptureRequestInfoFB* put(SceneCaptureRequestInfoFB& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_scene_capture

#ifdef XR_FB_spatial_entity_container
/*!
 * C++ projection of XrSpaceContainerFB
 *
 * Provided by the `XR_FB_spatial_entity_container` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceContainerFB>
 * @xrentity{XrSpaceContainerFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceContainerFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpaceContainerFB(uint32_t uuidCapacityInput_, uint32_t uuidCountOutput_, UuidEXT* uuids_,
                   const void* next_ = nullptr)
      : Parent(StructureType::SpaceContainerFB, next_),
        uuidCapacityInput{uuidCapacityInput_},
        uuidCountOutput{uuidCountOutput_},
        uuids{uuids_} {}

  //! Default/empty constructor
  SpaceContainerFB(const void* next_ = nullptr)

      : Parent(StructureType::SpaceContainerFB, next_),
        uuidCapacityInput{0},
        uuidCountOutput{0},
        uuids{nullptr} {}

  //! Default copy constructor
  SpaceContainerFB(const SpaceContainerFB& rhs) = default;
  //! Default copy assignment
  SpaceContainerFB& operator=(const SpaceContainerFB& rhs) = default;
  //! Copy construct from raw
  SpaceContainerFB(const XrSpaceContainerFB& rhs) : SpaceContainerFB() { *put() = rhs; }
  //! Copy assign from raw
  SpaceContainerFB& operator=(const XrSpaceContainerFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceContainerFB&() const {
    return *reinterpret_cast<const XrSpaceContainerFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceContainerFB&() { return *reinterpret_cast<XrSpaceContainerFB*>(this); }

  //! Accessor for this as the address of a raw XrSpaceContainerFB
  XrSpaceContainerFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceContainerFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceContainerFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceContainerFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceContainerFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceContainerFB*>(this);
  }
  uint32_t uuidCapacityInput;
  uint32_t uuidCountOutput;
  UuidEXT* uuids;
};
static_assert(sizeof(XrSpaceContainerFB) == sizeof(SpaceContainerFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceContainerFB pointer to const from a
 * SpaceContainerFB reference to const.
 * @relates SpaceContainerFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceContainerFB const* get(SpaceContainerFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceContainerFB as the
 * address of a raw XrSpaceContainerFB
 * @relates SpaceContainerFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceContainerFB* put(SpaceContainerFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity_container

#ifdef XR_META_foveation_eye_tracked
/*!
 * C++ projection of XrFoveationEyeTrackedProfileCreateInfoMETA
 *
 * Provided by the `XR_META_foveation_eye_tracked` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationEyeTrackedProfileCreateInfoMETA>
 * @xrentity{XrFoveationEyeTrackedProfileCreateInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FoveationEyeTrackedProfileCreateInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FoveationEyeTrackedProfileCreateInfoMETA(const FoveationEyeTrackedProfileCreateFlagsMETA& flags_,
                                           const void* next_ = nullptr)
      : Parent(StructureType::FoveationEyeTrackedProfileCreateInfoMETA, next_), flags{flags_} {}

  //! Default/empty constructor
  FoveationEyeTrackedProfileCreateInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::FoveationEyeTrackedProfileCreateInfoMETA, next_), flags{} {}

  //! Default copy constructor
  FoveationEyeTrackedProfileCreateInfoMETA(const FoveationEyeTrackedProfileCreateInfoMETA& rhs) =
      default;
  //! Default copy assignment
  FoveationEyeTrackedProfileCreateInfoMETA& operator=(
      const FoveationEyeTrackedProfileCreateInfoMETA& rhs) = default;
  //! Copy construct from raw
  FoveationEyeTrackedProfileCreateInfoMETA(const XrFoveationEyeTrackedProfileCreateInfoMETA& rhs)
      : FoveationEyeTrackedProfileCreateInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FoveationEyeTrackedProfileCreateInfoMETA& operator=(
      const XrFoveationEyeTrackedProfileCreateInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFoveationEyeTrackedProfileCreateInfoMETA&() const {
    return *reinterpret_cast<const XrFoveationEyeTrackedProfileCreateInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFoveationEyeTrackedProfileCreateInfoMETA&() {
    return *reinterpret_cast<XrFoveationEyeTrackedProfileCreateInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrFoveationEyeTrackedProfileCreateInfoMETA
  XrFoveationEyeTrackedProfileCreateInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrFoveationEyeTrackedProfileCreateInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFoveationEyeTrackedProfileCreateInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFoveationEyeTrackedProfileCreateInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FoveationEyeTrackedProfileCreateInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrFoveationEyeTrackedProfileCreateInfoMETA*>(this);
  }
  FoveationEyeTrackedProfileCreateFlagsMETA flags;
};
static_assert(sizeof(XrFoveationEyeTrackedProfileCreateInfoMETA) ==
                  sizeof(FoveationEyeTrackedProfileCreateInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFoveationEyeTrackedProfileCreateInfoMETA pointer to
 * const from a FoveationEyeTrackedProfileCreateInfoMETA reference to const.
 * @relates FoveationEyeTrackedProfileCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationEyeTrackedProfileCreateInfoMETA const* get(
    FoveationEyeTrackedProfileCreateInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * FoveationEyeTrackedProfileCreateInfoMETA as the address of a raw
 * XrFoveationEyeTrackedProfileCreateInfoMETA
 * @relates FoveationEyeTrackedProfileCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationEyeTrackedProfileCreateInfoMETA* put(
    FoveationEyeTrackedProfileCreateInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_foveation_eye_tracked

#ifdef XR_META_foveation_eye_tracked
/*!
 * C++ projection of XrFoveationEyeTrackedStateMETA
 *
 * Provided by the `XR_META_foveation_eye_tracked` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationEyeTrackedStateMETA>
 * @xrentity{XrFoveationEyeTrackedStateMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FoveationEyeTrackedStateMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FoveationEyeTrackedStateMETA(void* next_ = nullptr)

      : Parent(StructureType::FoveationEyeTrackedStateMETA, next_) {}

  //! Default copy constructor
  FoveationEyeTrackedStateMETA(const FoveationEyeTrackedStateMETA& rhs) = default;
  //! Default copy assignment
  FoveationEyeTrackedStateMETA& operator=(const FoveationEyeTrackedStateMETA& rhs) = default;
  //! Copy construct from raw
  FoveationEyeTrackedStateMETA(const XrFoveationEyeTrackedStateMETA& rhs)
      : FoveationEyeTrackedStateMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FoveationEyeTrackedStateMETA& operator=(const XrFoveationEyeTrackedStateMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFoveationEyeTrackedStateMETA&() const {
    return *reinterpret_cast<const XrFoveationEyeTrackedStateMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFoveationEyeTrackedStateMETA&() {
    return *reinterpret_cast<XrFoveationEyeTrackedStateMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrFoveationEyeTrackedStateMETA
  XrFoveationEyeTrackedStateMETA const* get() const noexcept {
    return reinterpret_cast<XrFoveationEyeTrackedStateMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFoveationEyeTrackedStateMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFoveationEyeTrackedStateMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FoveationEyeTrackedStateMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrFoveationEyeTrackedStateMETA*>(this);
  }
  Vector2f foveationCenter[XR_FOVEATION_CENTER_SIZE_META];
  FoveationEyeTrackedStateFlagsMETA flags;
};
static_assert(sizeof(XrFoveationEyeTrackedStateMETA) == sizeof(FoveationEyeTrackedStateMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFoveationEyeTrackedStateMETA pointer to const from a
 * FoveationEyeTrackedStateMETA reference to const.
 * @relates FoveationEyeTrackedStateMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationEyeTrackedStateMETA const* get(
    FoveationEyeTrackedStateMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationEyeTrackedStateMETA
 * as the address of a raw XrFoveationEyeTrackedStateMETA
 * @relates FoveationEyeTrackedStateMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationEyeTrackedStateMETA* put(FoveationEyeTrackedStateMETA& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_foveation_eye_tracked

#ifdef XR_META_foveation_eye_tracked
/*!
 * C++ projection of XrSystemFoveationEyeTrackedPropertiesMETA
 *
 * Provided by the `XR_META_foveation_eye_tracked` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemFoveationEyeTrackedPropertiesMETA>
 * @xrentity{XrSystemFoveationEyeTrackedPropertiesMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemFoveationEyeTrackedPropertiesMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemFoveationEyeTrackedPropertiesMETA(void* next_ = nullptr)

      : Parent(StructureType::SystemFoveationEyeTrackedPropertiesMETA, next_) {}

  //! Default copy constructor
  SystemFoveationEyeTrackedPropertiesMETA(const SystemFoveationEyeTrackedPropertiesMETA& rhs) =
      default;
  //! Default copy assignment
  SystemFoveationEyeTrackedPropertiesMETA& operator=(
      const SystemFoveationEyeTrackedPropertiesMETA& rhs) = default;
  //! Copy construct from raw
  SystemFoveationEyeTrackedPropertiesMETA(const XrSystemFoveationEyeTrackedPropertiesMETA& rhs)
      : SystemFoveationEyeTrackedPropertiesMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemFoveationEyeTrackedPropertiesMETA& operator=(
      const XrSystemFoveationEyeTrackedPropertiesMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemFoveationEyeTrackedPropertiesMETA&() const {
    return *reinterpret_cast<const XrSystemFoveationEyeTrackedPropertiesMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemFoveationEyeTrackedPropertiesMETA&() {
    return *reinterpret_cast<XrSystemFoveationEyeTrackedPropertiesMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemFoveationEyeTrackedPropertiesMETA
  XrSystemFoveationEyeTrackedPropertiesMETA const* get() const noexcept {
    return reinterpret_cast<XrSystemFoveationEyeTrackedPropertiesMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemFoveationEyeTrackedPropertiesMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemFoveationEyeTrackedPropertiesMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemFoveationEyeTrackedPropertiesMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemFoveationEyeTrackedPropertiesMETA*>(this);
  }
  Bool32 supportsFoveationEyeTracked;
};
static_assert(sizeof(XrSystemFoveationEyeTrackedPropertiesMETA) ==
                  sizeof(SystemFoveationEyeTrackedPropertiesMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemFoveationEyeTrackedPropertiesMETA pointer to const
 * from a SystemFoveationEyeTrackedPropertiesMETA reference to const.
 * @relates SystemFoveationEyeTrackedPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFoveationEyeTrackedPropertiesMETA const* get(
    SystemFoveationEyeTrackedPropertiesMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemFoveationEyeTrackedPropertiesMETA as the address of a raw
 * XrSystemFoveationEyeTrackedPropertiesMETA
 * @relates SystemFoveationEyeTrackedPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFoveationEyeTrackedPropertiesMETA* put(
    SystemFoveationEyeTrackedPropertiesMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_foveation_eye_tracked

#ifdef XR_FB_face_tracking
/*!
 * C++ projection of XrSystemFaceTrackingPropertiesFB
 *
 * Provided by the `XR_FB_face_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemFaceTrackingPropertiesFB>
 * @xrentity{XrSystemFaceTrackingPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemFaceTrackingPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemFaceTrackingPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemFaceTrackingPropertiesFB, next_) {}

  //! Default copy constructor
  SystemFaceTrackingPropertiesFB(const SystemFaceTrackingPropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemFaceTrackingPropertiesFB& operator=(const SystemFaceTrackingPropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemFaceTrackingPropertiesFB(const XrSystemFaceTrackingPropertiesFB& rhs)
      : SystemFaceTrackingPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemFaceTrackingPropertiesFB& operator=(const XrSystemFaceTrackingPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemFaceTrackingPropertiesFB&() const {
    return *reinterpret_cast<const XrSystemFaceTrackingPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemFaceTrackingPropertiesFB&() {
    return *reinterpret_cast<XrSystemFaceTrackingPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemFaceTrackingPropertiesFB
  XrSystemFaceTrackingPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemFaceTrackingPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemFaceTrackingPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemFaceTrackingPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemFaceTrackingPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemFaceTrackingPropertiesFB*>(this);
  }
  Bool32 supportsFaceTracking;
};
static_assert(sizeof(XrSystemFaceTrackingPropertiesFB) == sizeof(SystemFaceTrackingPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemFaceTrackingPropertiesFB pointer to const from a
 * SystemFaceTrackingPropertiesFB reference to const.
 * @relates SystemFaceTrackingPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFaceTrackingPropertiesFB const* get(
    SystemFaceTrackingPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemFaceTrackingPropertiesFB as the address of a raw XrSystemFaceTrackingPropertiesFB
 * @relates SystemFaceTrackingPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFaceTrackingPropertiesFB* put(SystemFaceTrackingPropertiesFB& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_face_tracking

#ifdef XR_FB_face_tracking
/*!
 * C++ projection of XrFaceTrackerCreateInfoFB
 *
 * Provided by the `XR_FB_face_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceTrackerCreateInfoFB>
 * @xrentity{XrFaceTrackerCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FaceTrackerCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FaceTrackerCreateInfoFB(const FaceExpressionSetFB& faceExpressionSet_,
                          const void* next_ = nullptr)
      : Parent(StructureType::FaceTrackerCreateInfoFB, next_),
        faceExpressionSet{faceExpressionSet_} {}

  //! Default/empty constructor
  FaceTrackerCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::FaceTrackerCreateInfoFB, next_), faceExpressionSet{} {}

  //! Default copy constructor
  FaceTrackerCreateInfoFB(const FaceTrackerCreateInfoFB& rhs) = default;
  //! Default copy assignment
  FaceTrackerCreateInfoFB& operator=(const FaceTrackerCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  FaceTrackerCreateInfoFB(const XrFaceTrackerCreateInfoFB& rhs) : FaceTrackerCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FaceTrackerCreateInfoFB& operator=(const XrFaceTrackerCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFaceTrackerCreateInfoFB&() const {
    return *reinterpret_cast<const XrFaceTrackerCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFaceTrackerCreateInfoFB&() {
    return *reinterpret_cast<XrFaceTrackerCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrFaceTrackerCreateInfoFB
  XrFaceTrackerCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrFaceTrackerCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFaceTrackerCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFaceTrackerCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FaceTrackerCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrFaceTrackerCreateInfoFB*>(this);
  }
  FaceExpressionSetFB faceExpressionSet;
};
static_assert(sizeof(XrFaceTrackerCreateInfoFB) == sizeof(FaceTrackerCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFaceTrackerCreateInfoFB pointer to const from a
 * FaceTrackerCreateInfoFB reference to const.
 * @relates FaceTrackerCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceTrackerCreateInfoFB const* get(FaceTrackerCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FaceTrackerCreateInfoFB as
 * the address of a raw XrFaceTrackerCreateInfoFB
 * @relates FaceTrackerCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceTrackerCreateInfoFB* put(FaceTrackerCreateInfoFB& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_face_tracking

#ifdef XR_FB_face_tracking
/*!
 * C++ projection of XrFaceExpressionInfoFB
 *
 * Provided by the `XR_FB_face_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionInfoFB>
 * @xrentity{XrFaceExpressionInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FaceExpressionInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FaceExpressionInfoFB(const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::FaceExpressionInfoFB, next_), time{time_} {}

  //! Default/empty constructor
  FaceExpressionInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::FaceExpressionInfoFB, next_), time{} {}

  //! Default copy constructor
  FaceExpressionInfoFB(const FaceExpressionInfoFB& rhs) = default;
  //! Default copy assignment
  FaceExpressionInfoFB& operator=(const FaceExpressionInfoFB& rhs) = default;
  //! Copy construct from raw
  FaceExpressionInfoFB(const XrFaceExpressionInfoFB& rhs) : FaceExpressionInfoFB() { *put() = rhs; }
  //! Copy assign from raw
  FaceExpressionInfoFB& operator=(const XrFaceExpressionInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFaceExpressionInfoFB&() const {
    return *reinterpret_cast<const XrFaceExpressionInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFaceExpressionInfoFB&() { return *reinterpret_cast<XrFaceExpressionInfoFB*>(this); }

  //! Accessor for this as the address of a raw XrFaceExpressionInfoFB
  XrFaceExpressionInfoFB const* get() const noexcept {
    return reinterpret_cast<XrFaceExpressionInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFaceExpressionInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFaceExpressionInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FaceExpressionInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrFaceExpressionInfoFB*>(this);
  }
  Time time;
};
static_assert(sizeof(XrFaceExpressionInfoFB) == sizeof(FaceExpressionInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFaceExpressionInfoFB pointer to const from a
 * FaceExpressionInfoFB reference to const.
 * @relates FaceExpressionInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceExpressionInfoFB const* get(FaceExpressionInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FaceExpressionInfoFB as the
 * address of a raw XrFaceExpressionInfoFB
 * @relates FaceExpressionInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceExpressionInfoFB* put(FaceExpressionInfoFB& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_face_tracking

#ifdef XR_FB_face_tracking
/*!
 * C++ projection of XrFaceExpressionStatusFB
 *
 * Provided by the `XR_FB_face_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionStatusFB>
 * @xrentity{XrFaceExpressionStatusFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS FaceExpressionStatusFB {
public:
  //! Constructor initializing all members.
  FaceExpressionStatusFB(const Bool32& isValid_, const Bool32& isEyeFollowingBlendshapesValid_)
      : isValid{isValid_}, isEyeFollowingBlendshapesValid{isEyeFollowingBlendshapesValid_} {}

  //! Default/empty constructor
  FaceExpressionStatusFB()

      : isValid{false}, isEyeFollowingBlendshapesValid{false} {}

  //! Default copy constructor
  FaceExpressionStatusFB(const FaceExpressionStatusFB& rhs) = default;
  //! Default copy assignment
  FaceExpressionStatusFB& operator=(const FaceExpressionStatusFB& rhs) = default;
  //! Copy construct from raw
  FaceExpressionStatusFB(const XrFaceExpressionStatusFB& rhs) : FaceExpressionStatusFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FaceExpressionStatusFB& operator=(const XrFaceExpressionStatusFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFaceExpressionStatusFB&() const {
    return *reinterpret_cast<const XrFaceExpressionStatusFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFaceExpressionStatusFB&() {
    return *reinterpret_cast<XrFaceExpressionStatusFB*>(this);
  }

  //! Accessor for this as the address of a raw XrFaceExpressionStatusFB
  XrFaceExpressionStatusFB const* get() const noexcept {
    return reinterpret_cast<XrFaceExpressionStatusFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFaceExpressionStatusFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrFaceExpressionStatusFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = FaceExpressionStatusFB{};
    }
    return reinterpret_cast<XrFaceExpressionStatusFB*>(this);
  }
  Bool32 isValid;
  Bool32 isEyeFollowingBlendshapesValid;
};
static_assert(sizeof(XrFaceExpressionStatusFB) == sizeof(FaceExpressionStatusFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFaceExpressionStatusFB pointer to const from a
 * FaceExpressionStatusFB reference to const.
 * @relates FaceExpressionStatusFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceExpressionStatusFB const* get(FaceExpressionStatusFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FaceExpressionStatusFB as the
 * address of a raw XrFaceExpressionStatusFB
 * @relates FaceExpressionStatusFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceExpressionStatusFB* put(FaceExpressionStatusFB& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_face_tracking

#ifdef XR_FB_face_tracking
/*!
 * C++ projection of XrFaceExpressionWeightsFB
 *
 * Provided by the `XR_FB_face_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionWeightsFB>
 * @xrentity{XrFaceExpressionWeightsFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FaceExpressionWeightsFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FaceExpressionWeightsFB(void* next_ = nullptr)

      : Parent(StructureType::FaceExpressionWeightsFB, next_) {}

  //! Default copy constructor
  FaceExpressionWeightsFB(const FaceExpressionWeightsFB& rhs) = default;
  //! Default copy assignment
  FaceExpressionWeightsFB& operator=(const FaceExpressionWeightsFB& rhs) = default;
  //! Copy construct from raw
  FaceExpressionWeightsFB(const XrFaceExpressionWeightsFB& rhs) : FaceExpressionWeightsFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FaceExpressionWeightsFB& operator=(const XrFaceExpressionWeightsFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFaceExpressionWeightsFB&() const {
    return *reinterpret_cast<const XrFaceExpressionWeightsFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFaceExpressionWeightsFB&() {
    return *reinterpret_cast<XrFaceExpressionWeightsFB*>(this);
  }

  //! Accessor for this as the address of a raw XrFaceExpressionWeightsFB
  XrFaceExpressionWeightsFB const* get() const noexcept {
    return reinterpret_cast<XrFaceExpressionWeightsFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFaceExpressionWeightsFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFaceExpressionWeightsFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FaceExpressionWeightsFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrFaceExpressionWeightsFB*>(this);
  }
  uint32_t weightCount;
  float* weights;
  uint32_t confidenceCount;
  float* confidences;
  FaceExpressionStatusFB status;
  Time time;
};
static_assert(sizeof(XrFaceExpressionWeightsFB) == sizeof(FaceExpressionWeightsFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFaceExpressionWeightsFB pointer to const from a
 * FaceExpressionWeightsFB reference to const.
 * @relates FaceExpressionWeightsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceExpressionWeightsFB const* get(FaceExpressionWeightsFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FaceExpressionWeightsFB as
 * the address of a raw XrFaceExpressionWeightsFB
 * @relates FaceExpressionWeightsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceExpressionWeightsFB* put(FaceExpressionWeightsFB& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_face_tracking

#ifdef XR_FB_eye_tracking_social
/*!
 * C++ projection of XrEyeGazeFB
 *
 * Provided by the `XR_FB_eye_tracking_social` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeGazeFB>
 * @xrentity{XrEyeGazeFB}
 * @ingroup structs
 */
struct XR_MAY_ALIAS EyeGazeFB {
public:
  //! Constructor initializing all members.
  EyeGazeFB(const Bool32& isValid_, const Posef& gazePose_, float gazeConfidence_)
      : isValid{isValid_}, gazePose{gazePose_}, gazeConfidence{gazeConfidence_} {}

  //! Default/empty constructor
  EyeGazeFB()

      : isValid{false}, gazePose{}, gazeConfidence{0.0f} {}

  //! Default copy constructor
  EyeGazeFB(const EyeGazeFB& rhs) = default;
  //! Default copy assignment
  EyeGazeFB& operator=(const EyeGazeFB& rhs) = default;
  //! Copy construct from raw
  EyeGazeFB(const XrEyeGazeFB& rhs) : EyeGazeFB() { *put() = rhs; }
  //! Copy assign from raw
  EyeGazeFB& operator=(const XrEyeGazeFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEyeGazeFB&() const { return *reinterpret_cast<const XrEyeGazeFB*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEyeGazeFB&() { return *reinterpret_cast<XrEyeGazeFB*>(this); }

  //! Accessor for this as the address of a raw XrEyeGazeFB
  XrEyeGazeFB const* get() const noexcept { return reinterpret_cast<XrEyeGazeFB const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrEyeGazeFB.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrEyeGazeFB* put(bool clear = true) noexcept {
    if (clear) {
      *this = EyeGazeFB{};
    }
    return reinterpret_cast<XrEyeGazeFB*>(this);
  }
  Bool32 isValid;
  Posef gazePose;
  float gazeConfidence;
};
static_assert(sizeof(XrEyeGazeFB) == sizeof(EyeGazeFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEyeGazeFB pointer to const from a EyeGazeFB reference to
 * const.
 * @relates EyeGazeFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeGazeFB const* get(EyeGazeFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing EyeGazeFB as the address of a
 * raw XrEyeGazeFB
 * @relates EyeGazeFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeGazeFB* put(EyeGazeFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_eye_tracking_social

#ifdef XR_FB_eye_tracking_social
/*!
 * C++ projection of XrEyeTrackerCreateInfoFB
 *
 * Provided by the `XR_FB_eye_tracking_social` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeTrackerCreateInfoFB>
 * @xrentity{XrEyeTrackerCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EyeTrackerCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  EyeTrackerCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::EyeTrackerCreateInfoFB, next_) {}

  //! Default copy constructor
  EyeTrackerCreateInfoFB(const EyeTrackerCreateInfoFB& rhs) = default;
  //! Default copy assignment
  EyeTrackerCreateInfoFB& operator=(const EyeTrackerCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  EyeTrackerCreateInfoFB(const XrEyeTrackerCreateInfoFB& rhs) : EyeTrackerCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EyeTrackerCreateInfoFB& operator=(const XrEyeTrackerCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEyeTrackerCreateInfoFB&() const {
    return *reinterpret_cast<const XrEyeTrackerCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEyeTrackerCreateInfoFB&() {
    return *reinterpret_cast<XrEyeTrackerCreateInfoFB*>(this);
  }

  //! Accessor for this as the address of a raw XrEyeTrackerCreateInfoFB
  XrEyeTrackerCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrEyeTrackerCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrEyeTrackerCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEyeTrackerCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EyeTrackerCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEyeTrackerCreateInfoFB*>(this);
  }
};
static_assert(sizeof(XrEyeTrackerCreateInfoFB) == sizeof(EyeTrackerCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEyeTrackerCreateInfoFB pointer to const from a
 * EyeTrackerCreateInfoFB reference to const.
 * @relates EyeTrackerCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeTrackerCreateInfoFB const* get(EyeTrackerCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EyeTrackerCreateInfoFB as the
 * address of a raw XrEyeTrackerCreateInfoFB
 * @relates EyeTrackerCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeTrackerCreateInfoFB* put(EyeTrackerCreateInfoFB& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_eye_tracking_social

#ifdef XR_FB_eye_tracking_social
/*!
 * C++ projection of XrEyeGazesInfoFB
 *
 * Provided by the `XR_FB_eye_tracking_social` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeGazesInfoFB>
 * @xrentity{XrEyeGazesInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EyeGazesInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  EyeGazesInfoFB(const Space& baseSpace_, const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::EyeGazesInfoFB, next_), baseSpace{baseSpace_}, time{time_} {}

  //! Default/empty constructor
  EyeGazesInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::EyeGazesInfoFB, next_), baseSpace{}, time{} {}

  //! Default copy constructor
  EyeGazesInfoFB(const EyeGazesInfoFB& rhs) = default;
  //! Default copy assignment
  EyeGazesInfoFB& operator=(const EyeGazesInfoFB& rhs) = default;
  //! Copy construct from raw
  EyeGazesInfoFB(const XrEyeGazesInfoFB& rhs) : EyeGazesInfoFB() { *put() = rhs; }
  //! Copy assign from raw
  EyeGazesInfoFB& operator=(const XrEyeGazesInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEyeGazesInfoFB&() const {
    return *reinterpret_cast<const XrEyeGazesInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEyeGazesInfoFB&() { return *reinterpret_cast<XrEyeGazesInfoFB*>(this); }

  //! Accessor for this as the address of a raw XrEyeGazesInfoFB
  XrEyeGazesInfoFB const* get() const noexcept {
    return reinterpret_cast<XrEyeGazesInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrEyeGazesInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEyeGazesInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EyeGazesInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEyeGazesInfoFB*>(this);
  }
  Space baseSpace;
  Time time;
};
static_assert(sizeof(XrEyeGazesInfoFB) == sizeof(EyeGazesInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEyeGazesInfoFB pointer to const from a EyeGazesInfoFB
 * reference to const.
 * @relates EyeGazesInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeGazesInfoFB const* get(EyeGazesInfoFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing EyeGazesInfoFB as the address
 * of a raw XrEyeGazesInfoFB
 * @relates EyeGazesInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeGazesInfoFB* put(EyeGazesInfoFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_eye_tracking_social

#ifdef XR_FB_eye_tracking_social
/*!
 * C++ projection of XrSystemEyeTrackingPropertiesFB
 *
 * Provided by the `XR_FB_eye_tracking_social` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemEyeTrackingPropertiesFB>
 * @xrentity{XrSystemEyeTrackingPropertiesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemEyeTrackingPropertiesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemEyeTrackingPropertiesFB(void* next_ = nullptr)

      : Parent(StructureType::SystemEyeTrackingPropertiesFB, next_) {}

  //! Default copy constructor
  SystemEyeTrackingPropertiesFB(const SystemEyeTrackingPropertiesFB& rhs) = default;
  //! Default copy assignment
  SystemEyeTrackingPropertiesFB& operator=(const SystemEyeTrackingPropertiesFB& rhs) = default;
  //! Copy construct from raw
  SystemEyeTrackingPropertiesFB(const XrSystemEyeTrackingPropertiesFB& rhs)
      : SystemEyeTrackingPropertiesFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemEyeTrackingPropertiesFB& operator=(const XrSystemEyeTrackingPropertiesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemEyeTrackingPropertiesFB&() const {
    return *reinterpret_cast<const XrSystemEyeTrackingPropertiesFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemEyeTrackingPropertiesFB&() {
    return *reinterpret_cast<XrSystemEyeTrackingPropertiesFB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemEyeTrackingPropertiesFB
  XrSystemEyeTrackingPropertiesFB const* get() const noexcept {
    return reinterpret_cast<XrSystemEyeTrackingPropertiesFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemEyeTrackingPropertiesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemEyeTrackingPropertiesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemEyeTrackingPropertiesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemEyeTrackingPropertiesFB*>(this);
  }
  Bool32 supportsEyeTracking;
};
static_assert(sizeof(XrSystemEyeTrackingPropertiesFB) == sizeof(SystemEyeTrackingPropertiesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemEyeTrackingPropertiesFB pointer to const from a
 * SystemEyeTrackingPropertiesFB reference to const.
 * @relates SystemEyeTrackingPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemEyeTrackingPropertiesFB const* get(
    SystemEyeTrackingPropertiesFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemEyeTrackingPropertiesFB
 * as the address of a raw XrSystemEyeTrackingPropertiesFB
 * @relates SystemEyeTrackingPropertiesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemEyeTrackingPropertiesFB* put(SystemEyeTrackingPropertiesFB& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_eye_tracking_social

#ifdef XR_FB_eye_tracking_social
/*!
 * C++ projection of XrEyeGazesFB
 *
 * Provided by the `XR_FB_eye_tracking_social` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeGazesFB>
 * @xrentity{XrEyeGazesFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EyeGazesFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EyeGazesFB(void* next_ = nullptr)

      : Parent(StructureType::EyeGazesFB, next_) {}

  //! Default copy constructor
  EyeGazesFB(const EyeGazesFB& rhs) = default;
  //! Default copy assignment
  EyeGazesFB& operator=(const EyeGazesFB& rhs) = default;
  //! Copy construct from raw
  EyeGazesFB(const XrEyeGazesFB& rhs) : EyeGazesFB() { *put() = rhs; }
  //! Copy assign from raw
  EyeGazesFB& operator=(const XrEyeGazesFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEyeGazesFB&() const { return *reinterpret_cast<const XrEyeGazesFB*>(this); }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEyeGazesFB&() { return *reinterpret_cast<XrEyeGazesFB*>(this); }

  //! Accessor for this as the address of a raw XrEyeGazesFB
  XrEyeGazesFB const* get() const noexcept { return reinterpret_cast<XrEyeGazesFB const*>(this); }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrEyeGazesFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEyeGazesFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EyeGazesFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEyeGazesFB*>(this);
  }
  EyeGazeFB gaze[XR_EYE_POSITION_COUNT_FB];
  Time time;
};
static_assert(sizeof(XrEyeGazesFB) == sizeof(EyeGazesFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEyeGazesFB pointer to const from a EyeGazesFB reference
 * to const.
 * @relates EyeGazesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeGazesFB const* get(EyeGazesFB const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing EyeGazesFB as the address of
 * a raw XrEyeGazesFB
 * @relates EyeGazesFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEyeGazesFB* put(EyeGazesFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_eye_tracking_social

#ifdef XR_FB_passthrough_keyboard_hands
/*!
 * C++ projection of XrPassthroughKeyboardHandsIntensityFB
 *
 * Provided by the `XR_FB_passthrough_keyboard_hands` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughKeyboardHandsIntensityFB>
 * @xrentity{XrPassthroughKeyboardHandsIntensityFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughKeyboardHandsIntensityFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughKeyboardHandsIntensityFB(float leftHandIntensity_, float rightHandIntensity_,
                                      const void* next_ = nullptr)
      : Parent(StructureType::PassthroughKeyboardHandsIntensityFB, next_),
        leftHandIntensity{leftHandIntensity_},
        rightHandIntensity{rightHandIntensity_} {}

  //! Default/empty constructor
  PassthroughKeyboardHandsIntensityFB(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughKeyboardHandsIntensityFB, next_),
        leftHandIntensity{0.0f},
        rightHandIntensity{0.0f} {}

  //! Default copy constructor
  PassthroughKeyboardHandsIntensityFB(const PassthroughKeyboardHandsIntensityFB& rhs) = default;
  //! Default copy assignment
  PassthroughKeyboardHandsIntensityFB& operator=(const PassthroughKeyboardHandsIntensityFB& rhs) =
      default;
  //! Copy construct from raw
  PassthroughKeyboardHandsIntensityFB(const XrPassthroughKeyboardHandsIntensityFB& rhs)
      : PassthroughKeyboardHandsIntensityFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughKeyboardHandsIntensityFB& operator=(const XrPassthroughKeyboardHandsIntensityFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughKeyboardHandsIntensityFB&() const {
    return *reinterpret_cast<const XrPassthroughKeyboardHandsIntensityFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughKeyboardHandsIntensityFB&() {
    return *reinterpret_cast<XrPassthroughKeyboardHandsIntensityFB*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughKeyboardHandsIntensityFB
  XrPassthroughKeyboardHandsIntensityFB const* get() const noexcept {
    return reinterpret_cast<XrPassthroughKeyboardHandsIntensityFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughKeyboardHandsIntensityFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughKeyboardHandsIntensityFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughKeyboardHandsIntensityFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughKeyboardHandsIntensityFB*>(this);
  }
  float leftHandIntensity;
  float rightHandIntensity;
};
static_assert(sizeof(XrPassthroughKeyboardHandsIntensityFB) ==
                  sizeof(PassthroughKeyboardHandsIntensityFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughKeyboardHandsIntensityFB pointer to const
 * from a PassthroughKeyboardHandsIntensityFB reference to const.
 * @relates PassthroughKeyboardHandsIntensityFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughKeyboardHandsIntensityFB const* get(
    PassthroughKeyboardHandsIntensityFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * PassthroughKeyboardHandsIntensityFB as the address of a raw XrPassthroughKeyboardHandsIntensityFB
 * @relates PassthroughKeyboardHandsIntensityFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughKeyboardHandsIntensityFB* put(
    PassthroughKeyboardHandsIntensityFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_passthrough_keyboard_hands

#ifdef XR_FB_composition_layer_settings
/*!
 * C++ projection of XrCompositionLayerSettingsFB
 *
 * Provided by the `XR_FB_composition_layer_settings` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerSettingsFB>
 * @xrentity{XrCompositionLayerSettingsFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerSettingsFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerSettingsFB(const CompositionLayerSettingsFlagsFB& layerFlags_,
                             const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerSettingsFB, next_), layerFlags{layerFlags_} {}

  //! Default/empty constructor
  CompositionLayerSettingsFB(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerSettingsFB, next_), layerFlags{} {}

  //! Default copy constructor
  CompositionLayerSettingsFB(const CompositionLayerSettingsFB& rhs) = default;
  //! Default copy assignment
  CompositionLayerSettingsFB& operator=(const CompositionLayerSettingsFB& rhs) = default;
  //! Copy construct from raw
  CompositionLayerSettingsFB(const XrCompositionLayerSettingsFB& rhs)
      : CompositionLayerSettingsFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerSettingsFB& operator=(const XrCompositionLayerSettingsFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerSettingsFB&() const {
    return *reinterpret_cast<const XrCompositionLayerSettingsFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerSettingsFB&() {
    return *reinterpret_cast<XrCompositionLayerSettingsFB*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerSettingsFB
  XrCompositionLayerSettingsFB const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerSettingsFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerSettingsFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerSettingsFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerSettingsFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerSettingsFB*>(this);
  }
  CompositionLayerSettingsFlagsFB layerFlags;
};
static_assert(sizeof(XrCompositionLayerSettingsFB) == sizeof(CompositionLayerSettingsFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerSettingsFB pointer to const from a
 * CompositionLayerSettingsFB reference to const.
 * @relates CompositionLayerSettingsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerSettingsFB const* get(
    CompositionLayerSettingsFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerSettingsFB as
 * the address of a raw XrCompositionLayerSettingsFB
 * @relates CompositionLayerSettingsFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerSettingsFB* put(CompositionLayerSettingsFB& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_composition_layer_settings

#ifdef XR_FB_haptic_pcm
/*!
 * C++ projection of XrHapticPcmVibrationFB
 *
 * Provided by the `XR_FB_haptic_pcm` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHapticPcmVibrationFB>
 * @xrentity{XrHapticPcmVibrationFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HapticPcmVibrationFB : public HapticBaseHeader {
private:
  using Parent = HapticBaseHeader;

public:
  //! Constructor initializing all members.
  HapticPcmVibrationFB(uint32_t bufferSize_, const float* buffer_, float sampleRate_,
                       const Bool32& append_, uint32_t* samplesConsumed_,
                       const void* next_ = nullptr)
      : Parent(StructureType::HapticPcmVibrationFB, next_),
        bufferSize{bufferSize_},
        buffer{buffer_},
        sampleRate{sampleRate_},
        append{append_},
        samplesConsumed{samplesConsumed_} {}

  //! Default/empty constructor
  HapticPcmVibrationFB(const void* next_ = nullptr)

      : Parent(StructureType::HapticPcmVibrationFB, next_),
        bufferSize{0},
        buffer{nullptr},
        sampleRate{0.0f},
        append{false},
        samplesConsumed{nullptr} {}

  //! Default copy constructor
  HapticPcmVibrationFB(const HapticPcmVibrationFB& rhs) = default;
  //! Default copy assignment
  HapticPcmVibrationFB& operator=(const HapticPcmVibrationFB& rhs) = default;
  //! Copy construct from raw
  HapticPcmVibrationFB(const XrHapticPcmVibrationFB& rhs) : HapticPcmVibrationFB() { *put() = rhs; }
  //! Copy assign from raw
  HapticPcmVibrationFB& operator=(const XrHapticPcmVibrationFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHapticPcmVibrationFB&() const {
    return *reinterpret_cast<const XrHapticPcmVibrationFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHapticPcmVibrationFB&() { return *reinterpret_cast<XrHapticPcmVibrationFB*>(this); }

  //! Accessor for this as a raw, base XrHapticBaseHeader const pointer
  XrHapticBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrHapticBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrHapticPcmVibrationFB
  XrHapticPcmVibrationFB const* get() const noexcept {
    return reinterpret_cast<XrHapticPcmVibrationFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrHapticPcmVibrationFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHapticPcmVibrationFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HapticPcmVibrationFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrHapticPcmVibrationFB*>(this);
  }
  uint32_t bufferSize;
  const float* buffer;
  float sampleRate;
  Bool32 append;
  uint32_t* samplesConsumed;
};
static_assert(sizeof(XrHapticPcmVibrationFB) == sizeof(HapticPcmVibrationFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHapticPcmVibrationFB pointer to const from a
 * HapticPcmVibrationFB reference to const.
 * @relates HapticPcmVibrationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticPcmVibrationFB const* get(HapticPcmVibrationFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HapticPcmVibrationFB as the
 * address of a raw XrHapticPcmVibrationFB
 * @relates HapticPcmVibrationFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticPcmVibrationFB* put(HapticPcmVibrationFB& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const HapticPcmVibrationFB as a raw, pointer to
 * const XrHapticBaseHeader (the base type)
 * @relates HapticPcmVibrationFB
 * @relatesalso HapticBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHapticBaseHeader const* get_base(HapticPcmVibrationFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_haptic_pcm

#ifdef XR_FB_haptic_pcm
/*!
 * C++ projection of XrDevicePcmSampleRateStateFB
 *
 * Provided by the `XR_FB_haptic_pcm` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDevicePcmSampleRateStateFB>
 * @xrentity{XrDevicePcmSampleRateStateFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS DevicePcmSampleRateStateFB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  DevicePcmSampleRateStateFB(void* next_ = nullptr)

      : Parent(StructureType::DevicePcmSampleRateStateFB, next_) {}

  //! Default copy constructor
  DevicePcmSampleRateStateFB(const DevicePcmSampleRateStateFB& rhs) = default;
  //! Default copy assignment
  DevicePcmSampleRateStateFB& operator=(const DevicePcmSampleRateStateFB& rhs) = default;
  //! Copy construct from raw
  DevicePcmSampleRateStateFB(const XrDevicePcmSampleRateStateFB& rhs)
      : DevicePcmSampleRateStateFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  DevicePcmSampleRateStateFB& operator=(const XrDevicePcmSampleRateStateFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrDevicePcmSampleRateStateFB&() const {
    return *reinterpret_cast<const XrDevicePcmSampleRateStateFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrDevicePcmSampleRateStateFB&() {
    return *reinterpret_cast<XrDevicePcmSampleRateStateFB*>(this);
  }

  //! Accessor for this as the address of a raw XrDevicePcmSampleRateStateFB
  XrDevicePcmSampleRateStateFB const* get() const noexcept {
    return reinterpret_cast<XrDevicePcmSampleRateStateFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrDevicePcmSampleRateStateFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrDevicePcmSampleRateStateFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = DevicePcmSampleRateStateFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrDevicePcmSampleRateStateFB*>(this);
  }
  float sampleRate;
};
static_assert(sizeof(XrDevicePcmSampleRateStateFB) == sizeof(DevicePcmSampleRateStateFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrDevicePcmSampleRateStateFB pointer to const from a
 * DevicePcmSampleRateStateFB reference to const.
 * @relates DevicePcmSampleRateStateFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDevicePcmSampleRateStateFB const* get(
    DevicePcmSampleRateStateFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing DevicePcmSampleRateStateFB as
 * the address of a raw XrDevicePcmSampleRateStateFB
 * @relates DevicePcmSampleRateStateFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrDevicePcmSampleRateStateFB* put(DevicePcmSampleRateStateFB& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_haptic_pcm

#ifdef XR_EXT_frame_synthesis
/*!
 * C++ projection of XrFrameSynthesisInfoEXT
 *
 * Provided by the `XR_EXT_frame_synthesis` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameSynthesisInfoEXT>
 * @xrentity{XrFrameSynthesisInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameSynthesisInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FrameSynthesisInfoEXT(const FrameSynthesisInfoFlagsEXT& layerFlags_,
                        const SwapchainSubImage& motionVectorSubImage_,
                        const Vector4f& motionVectorScale_, const Vector4f& motionVectorOffset_,
                        const Posef& appSpaceDeltaPose_, const SwapchainSubImage& depthSubImage_,
                        float minDepth_, float maxDepth_, float nearZ_, float farZ_,
                        const void* next_ = nullptr)
      : Parent(StructureType::FrameSynthesisInfoEXT, next_),
        layerFlags{layerFlags_},
        motionVectorSubImage{motionVectorSubImage_},
        motionVectorScale{motionVectorScale_},
        motionVectorOffset{motionVectorOffset_},
        appSpaceDeltaPose{appSpaceDeltaPose_},
        depthSubImage{depthSubImage_},
        minDepth{minDepth_},
        maxDepth{maxDepth_},
        nearZ{nearZ_},
        farZ{farZ_} {}

  //! Default/empty constructor
  FrameSynthesisInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::FrameSynthesisInfoEXT, next_),
        layerFlags{},
        motionVectorSubImage{},
        motionVectorScale{},
        motionVectorOffset{},
        appSpaceDeltaPose{},
        depthSubImage{},
        minDepth{0.0f},
        maxDepth{0.0f},
        nearZ{0.0f},
        farZ{0.0f} {}

  //! Default copy constructor
  FrameSynthesisInfoEXT(const FrameSynthesisInfoEXT& rhs) = default;
  //! Default copy assignment
  FrameSynthesisInfoEXT& operator=(const FrameSynthesisInfoEXT& rhs) = default;
  //! Copy construct from raw
  FrameSynthesisInfoEXT(const XrFrameSynthesisInfoEXT& rhs) : FrameSynthesisInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FrameSynthesisInfoEXT& operator=(const XrFrameSynthesisInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameSynthesisInfoEXT&() const {
    return *reinterpret_cast<const XrFrameSynthesisInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameSynthesisInfoEXT&() { return *reinterpret_cast<XrFrameSynthesisInfoEXT*>(this); }

  //! Accessor for this as the address of a raw XrFrameSynthesisInfoEXT
  XrFrameSynthesisInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrFrameSynthesisInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFrameSynthesisInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameSynthesisInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameSynthesisInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameSynthesisInfoEXT*>(this);
  }
  FrameSynthesisInfoFlagsEXT layerFlags;
  SwapchainSubImage motionVectorSubImage;
  Vector4f motionVectorScale;
  Vector4f motionVectorOffset;
  Posef appSpaceDeltaPose;
  SwapchainSubImage depthSubImage;
  float minDepth;
  float maxDepth;
  float nearZ;
  float farZ;
};
static_assert(sizeof(XrFrameSynthesisInfoEXT) == sizeof(FrameSynthesisInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameSynthesisInfoEXT pointer to const from a
 * FrameSynthesisInfoEXT reference to const.
 * @relates FrameSynthesisInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameSynthesisInfoEXT const* get(FrameSynthesisInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameSynthesisInfoEXT as the
 * address of a raw XrFrameSynthesisInfoEXT
 * @relates FrameSynthesisInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameSynthesisInfoEXT* put(FrameSynthesisInfoEXT& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_frame_synthesis

#ifdef XR_EXT_frame_synthesis
/*!
 * C++ projection of XrFrameSynthesisConfigViewEXT
 *
 * Provided by the `XR_EXT_frame_synthesis` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFrameSynthesisConfigViewEXT>
 * @xrentity{XrFrameSynthesisConfigViewEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FrameSynthesisConfigViewEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FrameSynthesisConfigViewEXT(void* next_ = nullptr)

      : Parent(StructureType::FrameSynthesisConfigViewEXT, next_) {}

  //! Default copy constructor
  FrameSynthesisConfigViewEXT(const FrameSynthesisConfigViewEXT& rhs) = default;
  //! Default copy assignment
  FrameSynthesisConfigViewEXT& operator=(const FrameSynthesisConfigViewEXT& rhs) = default;
  //! Copy construct from raw
  FrameSynthesisConfigViewEXT(const XrFrameSynthesisConfigViewEXT& rhs)
      : FrameSynthesisConfigViewEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FrameSynthesisConfigViewEXT& operator=(const XrFrameSynthesisConfigViewEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFrameSynthesisConfigViewEXT&() const {
    return *reinterpret_cast<const XrFrameSynthesisConfigViewEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFrameSynthesisConfigViewEXT&() {
    return *reinterpret_cast<XrFrameSynthesisConfigViewEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrFrameSynthesisConfigViewEXT
  XrFrameSynthesisConfigViewEXT const* get() const noexcept {
    return reinterpret_cast<XrFrameSynthesisConfigViewEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFrameSynthesisConfigViewEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFrameSynthesisConfigViewEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FrameSynthesisConfigViewEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrFrameSynthesisConfigViewEXT*>(this);
  }
  uint32_t recommendedMotionVectorImageRectWidth;
  uint32_t recommendedMotionVectorImageRectHeight;
};
static_assert(sizeof(XrFrameSynthesisConfigViewEXT) == sizeof(FrameSynthesisConfigViewEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFrameSynthesisConfigViewEXT pointer to const from a
 * FrameSynthesisConfigViewEXT reference to const.
 * @relates FrameSynthesisConfigViewEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameSynthesisConfigViewEXT const* get(
    FrameSynthesisConfigViewEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FrameSynthesisConfigViewEXT
 * as the address of a raw XrFrameSynthesisConfigViewEXT
 * @relates FrameSynthesisConfigViewEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFrameSynthesisConfigViewEXT* put(FrameSynthesisConfigViewEXT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_frame_synthesis

#ifdef XR_FB_composition_layer_depth_test
/*!
 * C++ projection of XrCompositionLayerDepthTestFB
 *
 * Provided by the `XR_FB_composition_layer_depth_test` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerDepthTestFB>
 * @xrentity{XrCompositionLayerDepthTestFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerDepthTestFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CompositionLayerDepthTestFB(const Bool32& depthMask_, const CompareOpFB& compareOp_,
                              const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerDepthTestFB, next_),
        depthMask{depthMask_},
        compareOp{compareOp_} {}

  //! Default/empty constructor
  CompositionLayerDepthTestFB(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerDepthTestFB, next_), depthMask{false}, compareOp{} {}

  //! Default copy constructor
  CompositionLayerDepthTestFB(const CompositionLayerDepthTestFB& rhs) = default;
  //! Default copy assignment
  CompositionLayerDepthTestFB& operator=(const CompositionLayerDepthTestFB& rhs) = default;
  //! Copy construct from raw
  CompositionLayerDepthTestFB(const XrCompositionLayerDepthTestFB& rhs)
      : CompositionLayerDepthTestFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerDepthTestFB& operator=(const XrCompositionLayerDepthTestFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerDepthTestFB&() const {
    return *reinterpret_cast<const XrCompositionLayerDepthTestFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerDepthTestFB&() {
    return *reinterpret_cast<XrCompositionLayerDepthTestFB*>(this);
  }

  //! Accessor for this as the address of a raw XrCompositionLayerDepthTestFB
  XrCompositionLayerDepthTestFB const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerDepthTestFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerDepthTestFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerDepthTestFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerDepthTestFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerDepthTestFB*>(this);
  }
  Bool32 depthMask;
  CompareOpFB compareOp;
};
static_assert(sizeof(XrCompositionLayerDepthTestFB) == sizeof(CompositionLayerDepthTestFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerDepthTestFB pointer to const from a
 * CompositionLayerDepthTestFB reference to const.
 * @relates CompositionLayerDepthTestFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerDepthTestFB const* get(
    CompositionLayerDepthTestFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing CompositionLayerDepthTestFB
 * as the address of a raw XrCompositionLayerDepthTestFB
 * @relates CompositionLayerDepthTestFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerDepthTestFB* put(CompositionLayerDepthTestFB& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_composition_layer_depth_test

#ifdef XR_META_local_dimming
/*!
 * C++ projection of XrLocalDimmingFrameEndInfoMETA
 *
 * Provided by the `XR_META_local_dimming` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrLocalDimmingFrameEndInfoMETA>
 * @xrentity{XrLocalDimmingFrameEndInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS LocalDimmingFrameEndInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  LocalDimmingFrameEndInfoMETA(const LocalDimmingModeMETA& localDimmingMode_,
                               const void* next_ = nullptr)
      : Parent(StructureType::LocalDimmingFrameEndInfoMETA, next_),
        localDimmingMode{localDimmingMode_} {}

  //! Default/empty constructor
  LocalDimmingFrameEndInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::LocalDimmingFrameEndInfoMETA, next_), localDimmingMode{} {}

  //! Default copy constructor
  LocalDimmingFrameEndInfoMETA(const LocalDimmingFrameEndInfoMETA& rhs) = default;
  //! Default copy assignment
  LocalDimmingFrameEndInfoMETA& operator=(const LocalDimmingFrameEndInfoMETA& rhs) = default;
  //! Copy construct from raw
  LocalDimmingFrameEndInfoMETA(const XrLocalDimmingFrameEndInfoMETA& rhs)
      : LocalDimmingFrameEndInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  LocalDimmingFrameEndInfoMETA& operator=(const XrLocalDimmingFrameEndInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrLocalDimmingFrameEndInfoMETA&() const {
    return *reinterpret_cast<const XrLocalDimmingFrameEndInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrLocalDimmingFrameEndInfoMETA&() {
    return *reinterpret_cast<XrLocalDimmingFrameEndInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrLocalDimmingFrameEndInfoMETA
  XrLocalDimmingFrameEndInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrLocalDimmingFrameEndInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrLocalDimmingFrameEndInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrLocalDimmingFrameEndInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = LocalDimmingFrameEndInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrLocalDimmingFrameEndInfoMETA*>(this);
  }
  LocalDimmingModeMETA localDimmingMode;
};
static_assert(sizeof(XrLocalDimmingFrameEndInfoMETA) == sizeof(LocalDimmingFrameEndInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrLocalDimmingFrameEndInfoMETA pointer to const from a
 * LocalDimmingFrameEndInfoMETA reference to const.
 * @relates LocalDimmingFrameEndInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLocalDimmingFrameEndInfoMETA const* get(
    LocalDimmingFrameEndInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing LocalDimmingFrameEndInfoMETA
 * as the address of a raw XrLocalDimmingFrameEndInfoMETA
 * @relates LocalDimmingFrameEndInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrLocalDimmingFrameEndInfoMETA* put(LocalDimmingFrameEndInfoMETA& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_local_dimming

#ifdef XR_META_passthrough_preferences
/*!
 * C++ projection of XrPassthroughPreferencesMETA
 *
 * Provided by the `XR_META_passthrough_preferences` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughPreferencesMETA>
 * @xrentity{XrPassthroughPreferencesMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughPreferencesMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  PassthroughPreferencesMETA(void* next_ = nullptr)

      : Parent(StructureType::PassthroughPreferencesMETA, next_) {}

  //! Default copy constructor
  PassthroughPreferencesMETA(const PassthroughPreferencesMETA& rhs) = default;
  //! Default copy assignment
  PassthroughPreferencesMETA& operator=(const PassthroughPreferencesMETA& rhs) = default;
  //! Copy construct from raw
  PassthroughPreferencesMETA(const XrPassthroughPreferencesMETA& rhs)
      : PassthroughPreferencesMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughPreferencesMETA& operator=(const XrPassthroughPreferencesMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughPreferencesMETA&() const {
    return *reinterpret_cast<const XrPassthroughPreferencesMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughPreferencesMETA&() {
    return *reinterpret_cast<XrPassthroughPreferencesMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughPreferencesMETA
  XrPassthroughPreferencesMETA const* get() const noexcept {
    return reinterpret_cast<XrPassthroughPreferencesMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughPreferencesMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughPreferencesMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughPreferencesMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughPreferencesMETA*>(this);
  }
  PassthroughPreferenceFlagsMETA flags;
};
static_assert(sizeof(XrPassthroughPreferencesMETA) == sizeof(PassthroughPreferencesMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughPreferencesMETA pointer to const from a
 * PassthroughPreferencesMETA reference to const.
 * @relates PassthroughPreferencesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughPreferencesMETA const* get(
    PassthroughPreferencesMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughPreferencesMETA as
 * the address of a raw XrPassthroughPreferencesMETA
 * @relates PassthroughPreferencesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughPreferencesMETA* put(PassthroughPreferencesMETA& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_passthrough_preferences

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrSystemVirtualKeyboardPropertiesMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemVirtualKeyboardPropertiesMETA>
 * @xrentity{XrSystemVirtualKeyboardPropertiesMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemVirtualKeyboardPropertiesMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemVirtualKeyboardPropertiesMETA(void* next_ = nullptr)

      : Parent(StructureType::SystemVirtualKeyboardPropertiesMETA, next_) {}

  //! Default copy constructor
  SystemVirtualKeyboardPropertiesMETA(const SystemVirtualKeyboardPropertiesMETA& rhs) = default;
  //! Default copy assignment
  SystemVirtualKeyboardPropertiesMETA& operator=(const SystemVirtualKeyboardPropertiesMETA& rhs) =
      default;
  //! Copy construct from raw
  SystemVirtualKeyboardPropertiesMETA(const XrSystemVirtualKeyboardPropertiesMETA& rhs)
      : SystemVirtualKeyboardPropertiesMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemVirtualKeyboardPropertiesMETA& operator=(const XrSystemVirtualKeyboardPropertiesMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemVirtualKeyboardPropertiesMETA&() const {
    return *reinterpret_cast<const XrSystemVirtualKeyboardPropertiesMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemVirtualKeyboardPropertiesMETA&() {
    return *reinterpret_cast<XrSystemVirtualKeyboardPropertiesMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemVirtualKeyboardPropertiesMETA
  XrSystemVirtualKeyboardPropertiesMETA const* get() const noexcept {
    return reinterpret_cast<XrSystemVirtualKeyboardPropertiesMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemVirtualKeyboardPropertiesMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemVirtualKeyboardPropertiesMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemVirtualKeyboardPropertiesMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemVirtualKeyboardPropertiesMETA*>(this);
  }
  Bool32 supportsVirtualKeyboard;
};
static_assert(sizeof(XrSystemVirtualKeyboardPropertiesMETA) ==
                  sizeof(SystemVirtualKeyboardPropertiesMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemVirtualKeyboardPropertiesMETA pointer to const
 * from a SystemVirtualKeyboardPropertiesMETA reference to const.
 * @relates SystemVirtualKeyboardPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemVirtualKeyboardPropertiesMETA const* get(
    SystemVirtualKeyboardPropertiesMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemVirtualKeyboardPropertiesMETA as the address of a raw XrSystemVirtualKeyboardPropertiesMETA
 * @relates SystemVirtualKeyboardPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemVirtualKeyboardPropertiesMETA* put(
    SystemVirtualKeyboardPropertiesMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardCreateInfoMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardCreateInfoMETA>
 * @xrentity{XrVirtualKeyboardCreateInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VirtualKeyboardCreateInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  VirtualKeyboardCreateInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::VirtualKeyboardCreateInfoMETA, next_) {}

  //! Default copy constructor
  VirtualKeyboardCreateInfoMETA(const VirtualKeyboardCreateInfoMETA& rhs) = default;
  //! Default copy assignment
  VirtualKeyboardCreateInfoMETA& operator=(const VirtualKeyboardCreateInfoMETA& rhs) = default;
  //! Copy construct from raw
  VirtualKeyboardCreateInfoMETA(const XrVirtualKeyboardCreateInfoMETA& rhs)
      : VirtualKeyboardCreateInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VirtualKeyboardCreateInfoMETA& operator=(const XrVirtualKeyboardCreateInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVirtualKeyboardCreateInfoMETA&() const {
    return *reinterpret_cast<const XrVirtualKeyboardCreateInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVirtualKeyboardCreateInfoMETA&() {
    return *reinterpret_cast<XrVirtualKeyboardCreateInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrVirtualKeyboardCreateInfoMETA
  XrVirtualKeyboardCreateInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrVirtualKeyboardCreateInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVirtualKeyboardCreateInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVirtualKeyboardCreateInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VirtualKeyboardCreateInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrVirtualKeyboardCreateInfoMETA*>(this);
  }
};
static_assert(sizeof(XrVirtualKeyboardCreateInfoMETA) == sizeof(VirtualKeyboardCreateInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardCreateInfoMETA pointer to const from a
 * VirtualKeyboardCreateInfoMETA reference to const.
 * @relates VirtualKeyboardCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardCreateInfoMETA const* get(
    VirtualKeyboardCreateInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VirtualKeyboardCreateInfoMETA
 * as the address of a raw XrVirtualKeyboardCreateInfoMETA
 * @relates VirtualKeyboardCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardCreateInfoMETA* put(VirtualKeyboardCreateInfoMETA& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardSpaceCreateInfoMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardSpaceCreateInfoMETA>
 * @xrentity{XrVirtualKeyboardSpaceCreateInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VirtualKeyboardSpaceCreateInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VirtualKeyboardSpaceCreateInfoMETA(const VirtualKeyboardLocationTypeMETA& locationType_,
                                     const Space& space_, const Posef& poseInSpace_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::VirtualKeyboardSpaceCreateInfoMETA, next_),
        locationType{locationType_},
        space{space_},
        poseInSpace{poseInSpace_} {}

  //! Default/empty constructor
  VirtualKeyboardSpaceCreateInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::VirtualKeyboardSpaceCreateInfoMETA, next_),
        locationType{},
        space{},
        poseInSpace{} {}

  //! Default copy constructor
  VirtualKeyboardSpaceCreateInfoMETA(const VirtualKeyboardSpaceCreateInfoMETA& rhs) = default;
  //! Default copy assignment
  VirtualKeyboardSpaceCreateInfoMETA& operator=(const VirtualKeyboardSpaceCreateInfoMETA& rhs) =
      default;
  //! Copy construct from raw
  VirtualKeyboardSpaceCreateInfoMETA(const XrVirtualKeyboardSpaceCreateInfoMETA& rhs)
      : VirtualKeyboardSpaceCreateInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VirtualKeyboardSpaceCreateInfoMETA& operator=(const XrVirtualKeyboardSpaceCreateInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVirtualKeyboardSpaceCreateInfoMETA&() const {
    return *reinterpret_cast<const XrVirtualKeyboardSpaceCreateInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVirtualKeyboardSpaceCreateInfoMETA&() {
    return *reinterpret_cast<XrVirtualKeyboardSpaceCreateInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrVirtualKeyboardSpaceCreateInfoMETA
  XrVirtualKeyboardSpaceCreateInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrVirtualKeyboardSpaceCreateInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVirtualKeyboardSpaceCreateInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVirtualKeyboardSpaceCreateInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VirtualKeyboardSpaceCreateInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrVirtualKeyboardSpaceCreateInfoMETA*>(this);
  }
  VirtualKeyboardLocationTypeMETA locationType;
  Space space;
  Posef poseInSpace;
};
static_assert(sizeof(XrVirtualKeyboardSpaceCreateInfoMETA) ==
                  sizeof(VirtualKeyboardSpaceCreateInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardSpaceCreateInfoMETA pointer to const from
 * a VirtualKeyboardSpaceCreateInfoMETA reference to const.
 * @relates VirtualKeyboardSpaceCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardSpaceCreateInfoMETA const* get(
    VirtualKeyboardSpaceCreateInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VirtualKeyboardSpaceCreateInfoMETA as the address of a raw XrVirtualKeyboardSpaceCreateInfoMETA
 * @relates VirtualKeyboardSpaceCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardSpaceCreateInfoMETA* put(
    VirtualKeyboardSpaceCreateInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardLocationInfoMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardLocationInfoMETA>
 * @xrentity{XrVirtualKeyboardLocationInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VirtualKeyboardLocationInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VirtualKeyboardLocationInfoMETA(const VirtualKeyboardLocationTypeMETA& locationType_,
                                  const Space& space_, const Posef& poseInSpace_, float scale_,
                                  const void* next_ = nullptr)
      : Parent(StructureType::VirtualKeyboardLocationInfoMETA, next_),
        locationType{locationType_},
        space{space_},
        poseInSpace{poseInSpace_},
        scale{scale_} {}

  //! Default/empty constructor
  VirtualKeyboardLocationInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::VirtualKeyboardLocationInfoMETA, next_),
        locationType{},
        space{},
        poseInSpace{},
        scale{0.0f} {}

  //! Default copy constructor
  VirtualKeyboardLocationInfoMETA(const VirtualKeyboardLocationInfoMETA& rhs) = default;
  //! Default copy assignment
  VirtualKeyboardLocationInfoMETA& operator=(const VirtualKeyboardLocationInfoMETA& rhs) = default;
  //! Copy construct from raw
  VirtualKeyboardLocationInfoMETA(const XrVirtualKeyboardLocationInfoMETA& rhs)
      : VirtualKeyboardLocationInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VirtualKeyboardLocationInfoMETA& operator=(const XrVirtualKeyboardLocationInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVirtualKeyboardLocationInfoMETA&() const {
    return *reinterpret_cast<const XrVirtualKeyboardLocationInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVirtualKeyboardLocationInfoMETA&() {
    return *reinterpret_cast<XrVirtualKeyboardLocationInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrVirtualKeyboardLocationInfoMETA
  XrVirtualKeyboardLocationInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrVirtualKeyboardLocationInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVirtualKeyboardLocationInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVirtualKeyboardLocationInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VirtualKeyboardLocationInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrVirtualKeyboardLocationInfoMETA*>(this);
  }
  VirtualKeyboardLocationTypeMETA locationType;
  Space space;
  Posef poseInSpace;
  float scale;
};
static_assert(sizeof(XrVirtualKeyboardLocationInfoMETA) == sizeof(VirtualKeyboardLocationInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardLocationInfoMETA pointer to const from a
 * VirtualKeyboardLocationInfoMETA reference to const.
 * @relates VirtualKeyboardLocationInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardLocationInfoMETA const* get(
    VirtualKeyboardLocationInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VirtualKeyboardLocationInfoMETA as the address of a raw XrVirtualKeyboardLocationInfoMETA
 * @relates VirtualKeyboardLocationInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardLocationInfoMETA* put(VirtualKeyboardLocationInfoMETA& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardModelVisibilitySetInfoMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardModelVisibilitySetInfoMETA>
 * @xrentity{XrVirtualKeyboardModelVisibilitySetInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VirtualKeyboardModelVisibilitySetInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VirtualKeyboardModelVisibilitySetInfoMETA(const Bool32& visible_, const void* next_ = nullptr)
      : Parent(StructureType::VirtualKeyboardModelVisibilitySetInfoMETA, next_),
        visible{visible_} {}

  //! Default/empty constructor
  VirtualKeyboardModelVisibilitySetInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::VirtualKeyboardModelVisibilitySetInfoMETA, next_), visible{false} {}

  //! Default copy constructor
  VirtualKeyboardModelVisibilitySetInfoMETA(const VirtualKeyboardModelVisibilitySetInfoMETA& rhs) =
      default;
  //! Default copy assignment
  VirtualKeyboardModelVisibilitySetInfoMETA& operator=(
      const VirtualKeyboardModelVisibilitySetInfoMETA& rhs) = default;
  //! Copy construct from raw
  VirtualKeyboardModelVisibilitySetInfoMETA(const XrVirtualKeyboardModelVisibilitySetInfoMETA& rhs)
      : VirtualKeyboardModelVisibilitySetInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VirtualKeyboardModelVisibilitySetInfoMETA& operator=(
      const XrVirtualKeyboardModelVisibilitySetInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVirtualKeyboardModelVisibilitySetInfoMETA&() const {
    return *reinterpret_cast<const XrVirtualKeyboardModelVisibilitySetInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVirtualKeyboardModelVisibilitySetInfoMETA&() {
    return *reinterpret_cast<XrVirtualKeyboardModelVisibilitySetInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrVirtualKeyboardModelVisibilitySetInfoMETA
  XrVirtualKeyboardModelVisibilitySetInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrVirtualKeyboardModelVisibilitySetInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVirtualKeyboardModelVisibilitySetInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVirtualKeyboardModelVisibilitySetInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VirtualKeyboardModelVisibilitySetInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrVirtualKeyboardModelVisibilitySetInfoMETA*>(this);
  }
  Bool32 visible;
};
static_assert(sizeof(XrVirtualKeyboardModelVisibilitySetInfoMETA) ==
                  sizeof(VirtualKeyboardModelVisibilitySetInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardModelVisibilitySetInfoMETA pointer to
 * const from a VirtualKeyboardModelVisibilitySetInfoMETA reference to const.
 * @relates VirtualKeyboardModelVisibilitySetInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardModelVisibilitySetInfoMETA const* get(
    VirtualKeyboardModelVisibilitySetInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VirtualKeyboardModelVisibilitySetInfoMETA as the address of a raw
 * XrVirtualKeyboardModelVisibilitySetInfoMETA
 * @relates VirtualKeyboardModelVisibilitySetInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardModelVisibilitySetInfoMETA* put(
    VirtualKeyboardModelVisibilitySetInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardAnimationStateMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardAnimationStateMETA>
 * @xrentity{XrVirtualKeyboardAnimationStateMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VirtualKeyboardAnimationStateMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  VirtualKeyboardAnimationStateMETA(void* next_ = nullptr)

      : Parent(StructureType::VirtualKeyboardAnimationStateMETA, next_) {}

  //! Default copy constructor
  VirtualKeyboardAnimationStateMETA(const VirtualKeyboardAnimationStateMETA& rhs) = default;
  //! Default copy assignment
  VirtualKeyboardAnimationStateMETA& operator=(const VirtualKeyboardAnimationStateMETA& rhs) =
      default;
  //! Copy construct from raw
  VirtualKeyboardAnimationStateMETA(const XrVirtualKeyboardAnimationStateMETA& rhs)
      : VirtualKeyboardAnimationStateMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VirtualKeyboardAnimationStateMETA& operator=(const XrVirtualKeyboardAnimationStateMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVirtualKeyboardAnimationStateMETA&() const {
    return *reinterpret_cast<const XrVirtualKeyboardAnimationStateMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVirtualKeyboardAnimationStateMETA&() {
    return *reinterpret_cast<XrVirtualKeyboardAnimationStateMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrVirtualKeyboardAnimationStateMETA
  XrVirtualKeyboardAnimationStateMETA const* get() const noexcept {
    return reinterpret_cast<XrVirtualKeyboardAnimationStateMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVirtualKeyboardAnimationStateMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVirtualKeyboardAnimationStateMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VirtualKeyboardAnimationStateMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrVirtualKeyboardAnimationStateMETA*>(this);
  }
  int32_t animationIndex;
  float fraction;
};
static_assert(sizeof(XrVirtualKeyboardAnimationStateMETA) ==
                  sizeof(VirtualKeyboardAnimationStateMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardAnimationStateMETA pointer to const from
 * a VirtualKeyboardAnimationStateMETA reference to const.
 * @relates VirtualKeyboardAnimationStateMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardAnimationStateMETA const* get(
    VirtualKeyboardAnimationStateMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VirtualKeyboardAnimationStateMETA as the address of a raw XrVirtualKeyboardAnimationStateMETA
 * @relates VirtualKeyboardAnimationStateMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardAnimationStateMETA* put(
    VirtualKeyboardAnimationStateMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardModelAnimationStatesMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardModelAnimationStatesMETA>
 * @xrentity{XrVirtualKeyboardModelAnimationStatesMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VirtualKeyboardModelAnimationStatesMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  VirtualKeyboardModelAnimationStatesMETA(void* next_ = nullptr)

      : Parent(StructureType::VirtualKeyboardModelAnimationStatesMETA, next_) {}

  //! Default copy constructor
  VirtualKeyboardModelAnimationStatesMETA(const VirtualKeyboardModelAnimationStatesMETA& rhs) =
      default;
  //! Default copy assignment
  VirtualKeyboardModelAnimationStatesMETA& operator=(
      const VirtualKeyboardModelAnimationStatesMETA& rhs) = default;
  //! Copy construct from raw
  VirtualKeyboardModelAnimationStatesMETA(const XrVirtualKeyboardModelAnimationStatesMETA& rhs)
      : VirtualKeyboardModelAnimationStatesMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VirtualKeyboardModelAnimationStatesMETA& operator=(
      const XrVirtualKeyboardModelAnimationStatesMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVirtualKeyboardModelAnimationStatesMETA&() const {
    return *reinterpret_cast<const XrVirtualKeyboardModelAnimationStatesMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVirtualKeyboardModelAnimationStatesMETA&() {
    return *reinterpret_cast<XrVirtualKeyboardModelAnimationStatesMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrVirtualKeyboardModelAnimationStatesMETA
  XrVirtualKeyboardModelAnimationStatesMETA const* get() const noexcept {
    return reinterpret_cast<XrVirtualKeyboardModelAnimationStatesMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVirtualKeyboardModelAnimationStatesMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVirtualKeyboardModelAnimationStatesMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VirtualKeyboardModelAnimationStatesMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrVirtualKeyboardModelAnimationStatesMETA*>(this);
  }
  uint32_t stateCapacityInput;
  uint32_t stateCountOutput;
  VirtualKeyboardAnimationStateMETA* states;
};
static_assert(sizeof(XrVirtualKeyboardModelAnimationStatesMETA) ==
                  sizeof(VirtualKeyboardModelAnimationStatesMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardModelAnimationStatesMETA pointer to const
 * from a VirtualKeyboardModelAnimationStatesMETA reference to const.
 * @relates VirtualKeyboardModelAnimationStatesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardModelAnimationStatesMETA const* get(
    VirtualKeyboardModelAnimationStatesMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VirtualKeyboardModelAnimationStatesMETA as the address of a raw
 * XrVirtualKeyboardModelAnimationStatesMETA
 * @relates VirtualKeyboardModelAnimationStatesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardModelAnimationStatesMETA* put(
    VirtualKeyboardModelAnimationStatesMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardTextureDataMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardTextureDataMETA>
 * @xrentity{XrVirtualKeyboardTextureDataMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VirtualKeyboardTextureDataMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  VirtualKeyboardTextureDataMETA(void* next_ = nullptr)

      : Parent(StructureType::VirtualKeyboardTextureDataMETA, next_) {}

  //! Default copy constructor
  VirtualKeyboardTextureDataMETA(const VirtualKeyboardTextureDataMETA& rhs) = default;
  //! Default copy assignment
  VirtualKeyboardTextureDataMETA& operator=(const VirtualKeyboardTextureDataMETA& rhs) = default;
  //! Copy construct from raw
  VirtualKeyboardTextureDataMETA(const XrVirtualKeyboardTextureDataMETA& rhs)
      : VirtualKeyboardTextureDataMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VirtualKeyboardTextureDataMETA& operator=(const XrVirtualKeyboardTextureDataMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVirtualKeyboardTextureDataMETA&() const {
    return *reinterpret_cast<const XrVirtualKeyboardTextureDataMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVirtualKeyboardTextureDataMETA&() {
    return *reinterpret_cast<XrVirtualKeyboardTextureDataMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrVirtualKeyboardTextureDataMETA
  XrVirtualKeyboardTextureDataMETA const* get() const noexcept {
    return reinterpret_cast<XrVirtualKeyboardTextureDataMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVirtualKeyboardTextureDataMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVirtualKeyboardTextureDataMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VirtualKeyboardTextureDataMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrVirtualKeyboardTextureDataMETA*>(this);
  }
  uint32_t textureWidth;
  uint32_t textureHeight;
  uint32_t bufferCapacityInput;
  uint32_t bufferCountOutput;
  uint8_t* buffer;
};
static_assert(sizeof(XrVirtualKeyboardTextureDataMETA) == sizeof(VirtualKeyboardTextureDataMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardTextureDataMETA pointer to const from a
 * VirtualKeyboardTextureDataMETA reference to const.
 * @relates VirtualKeyboardTextureDataMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardTextureDataMETA const* get(
    VirtualKeyboardTextureDataMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VirtualKeyboardTextureDataMETA as the address of a raw XrVirtualKeyboardTextureDataMETA
 * @relates VirtualKeyboardTextureDataMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardTextureDataMETA* put(VirtualKeyboardTextureDataMETA& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardInputInfoMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardInputInfoMETA>
 * @xrentity{XrVirtualKeyboardInputInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VirtualKeyboardInputInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VirtualKeyboardInputInfoMETA(const VirtualKeyboardInputSourceMETA& inputSource_,
                               const Space& inputSpace_, const Posef& inputPoseInSpace_,
                               const VirtualKeyboardInputStateFlagsMETA& inputState_,
                               const void* next_ = nullptr)
      : Parent(StructureType::VirtualKeyboardInputInfoMETA, next_),
        inputSource{inputSource_},
        inputSpace{inputSpace_},
        inputPoseInSpace{inputPoseInSpace_},
        inputState{inputState_} {}

  //! Default/empty constructor
  VirtualKeyboardInputInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::VirtualKeyboardInputInfoMETA, next_),
        inputSource{},
        inputSpace{},
        inputPoseInSpace{},
        inputState{} {}

  //! Default copy constructor
  VirtualKeyboardInputInfoMETA(const VirtualKeyboardInputInfoMETA& rhs) = default;
  //! Default copy assignment
  VirtualKeyboardInputInfoMETA& operator=(const VirtualKeyboardInputInfoMETA& rhs) = default;
  //! Copy construct from raw
  VirtualKeyboardInputInfoMETA(const XrVirtualKeyboardInputInfoMETA& rhs)
      : VirtualKeyboardInputInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VirtualKeyboardInputInfoMETA& operator=(const XrVirtualKeyboardInputInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVirtualKeyboardInputInfoMETA&() const {
    return *reinterpret_cast<const XrVirtualKeyboardInputInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVirtualKeyboardInputInfoMETA&() {
    return *reinterpret_cast<XrVirtualKeyboardInputInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrVirtualKeyboardInputInfoMETA
  XrVirtualKeyboardInputInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrVirtualKeyboardInputInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVirtualKeyboardInputInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVirtualKeyboardInputInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VirtualKeyboardInputInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrVirtualKeyboardInputInfoMETA*>(this);
  }
  VirtualKeyboardInputSourceMETA inputSource;
  Space inputSpace;
  Posef inputPoseInSpace;
  VirtualKeyboardInputStateFlagsMETA inputState;
};
static_assert(sizeof(XrVirtualKeyboardInputInfoMETA) == sizeof(VirtualKeyboardInputInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardInputInfoMETA pointer to const from a
 * VirtualKeyboardInputInfoMETA reference to const.
 * @relates VirtualKeyboardInputInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardInputInfoMETA const* get(
    VirtualKeyboardInputInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VirtualKeyboardInputInfoMETA
 * as the address of a raw XrVirtualKeyboardInputInfoMETA
 * @relates VirtualKeyboardInputInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardInputInfoMETA* put(VirtualKeyboardInputInfoMETA& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrVirtualKeyboardTextContextChangeInfoMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardTextContextChangeInfoMETA>
 * @xrentity{XrVirtualKeyboardTextContextChangeInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VirtualKeyboardTextContextChangeInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VirtualKeyboardTextContextChangeInfoMETA(const char* textContext_, const void* next_ = nullptr)
      : Parent(StructureType::VirtualKeyboardTextContextChangeInfoMETA, next_),
        textContext{textContext_} {}

  //! Default/empty constructor
  VirtualKeyboardTextContextChangeInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::VirtualKeyboardTextContextChangeInfoMETA, next_),
        textContext{nullptr} {}

  //! Default copy constructor
  VirtualKeyboardTextContextChangeInfoMETA(const VirtualKeyboardTextContextChangeInfoMETA& rhs) =
      default;
  //! Default copy assignment
  VirtualKeyboardTextContextChangeInfoMETA& operator=(
      const VirtualKeyboardTextContextChangeInfoMETA& rhs) = default;
  //! Copy construct from raw
  VirtualKeyboardTextContextChangeInfoMETA(const XrVirtualKeyboardTextContextChangeInfoMETA& rhs)
      : VirtualKeyboardTextContextChangeInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VirtualKeyboardTextContextChangeInfoMETA& operator=(
      const XrVirtualKeyboardTextContextChangeInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVirtualKeyboardTextContextChangeInfoMETA&() const {
    return *reinterpret_cast<const XrVirtualKeyboardTextContextChangeInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVirtualKeyboardTextContextChangeInfoMETA&() {
    return *reinterpret_cast<XrVirtualKeyboardTextContextChangeInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrVirtualKeyboardTextContextChangeInfoMETA
  XrVirtualKeyboardTextContextChangeInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrVirtualKeyboardTextContextChangeInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVirtualKeyboardTextContextChangeInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVirtualKeyboardTextContextChangeInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VirtualKeyboardTextContextChangeInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrVirtualKeyboardTextContextChangeInfoMETA*>(this);
  }
  const char* textContext;
};
static_assert(sizeof(XrVirtualKeyboardTextContextChangeInfoMETA) ==
                  sizeof(VirtualKeyboardTextContextChangeInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVirtualKeyboardTextContextChangeInfoMETA pointer to
 * const from a VirtualKeyboardTextContextChangeInfoMETA reference to const.
 * @relates VirtualKeyboardTextContextChangeInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardTextContextChangeInfoMETA const* get(
    VirtualKeyboardTextContextChangeInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * VirtualKeyboardTextContextChangeInfoMETA as the address of a raw
 * XrVirtualKeyboardTextContextChangeInfoMETA
 * @relates VirtualKeyboardTextContextChangeInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardTextContextChangeInfoMETA* put(
    VirtualKeyboardTextContextChangeInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrEventDataVirtualKeyboardCommitTextMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVirtualKeyboardCommitTextMETA>
 * @xrentity{XrEventDataVirtualKeyboardCommitTextMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataVirtualKeyboardCommitTextMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataVirtualKeyboardCommitTextMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataVirtualKeyboardCommitTextMETA, next_) {}

  //! Default copy constructor
  EventDataVirtualKeyboardCommitTextMETA(const EventDataVirtualKeyboardCommitTextMETA& rhs) =
      default;
  //! Default copy assignment
  EventDataVirtualKeyboardCommitTextMETA& operator=(
      const EventDataVirtualKeyboardCommitTextMETA& rhs) = default;
  //! Copy construct from raw
  EventDataVirtualKeyboardCommitTextMETA(const XrEventDataVirtualKeyboardCommitTextMETA& rhs)
      : EventDataVirtualKeyboardCommitTextMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataVirtualKeyboardCommitTextMETA& operator=(
      const XrEventDataVirtualKeyboardCommitTextMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataVirtualKeyboardCommitTextMETA&() const {
    return *reinterpret_cast<const XrEventDataVirtualKeyboardCommitTextMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataVirtualKeyboardCommitTextMETA&() {
    return *reinterpret_cast<XrEventDataVirtualKeyboardCommitTextMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataVirtualKeyboardCommitTextMETA
  XrEventDataVirtualKeyboardCommitTextMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataVirtualKeyboardCommitTextMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataVirtualKeyboardCommitTextMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataVirtualKeyboardCommitTextMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataVirtualKeyboardCommitTextMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataVirtualKeyboardCommitTextMETA*>(this);
  }
  VirtualKeyboardMETA keyboard;
  char text[XR_MAX_VIRTUAL_KEYBOARD_COMMIT_TEXT_SIZE_META];
};
static_assert(sizeof(XrEventDataVirtualKeyboardCommitTextMETA) ==
                  sizeof(EventDataVirtualKeyboardCommitTextMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataVirtualKeyboardCommitTextMETA pointer to const
 * from a EventDataVirtualKeyboardCommitTextMETA reference to const.
 * @relates EventDataVirtualKeyboardCommitTextMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardCommitTextMETA const* get(
    EventDataVirtualKeyboardCommitTextMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataVirtualKeyboardCommitTextMETA as the address of a raw
 * XrEventDataVirtualKeyboardCommitTextMETA
 * @relates EventDataVirtualKeyboardCommitTextMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardCommitTextMETA* put(
    EventDataVirtualKeyboardCommitTextMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrEventDataVirtualKeyboardBackspaceMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVirtualKeyboardBackspaceMETA>
 * @xrentity{XrEventDataVirtualKeyboardBackspaceMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataVirtualKeyboardBackspaceMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataVirtualKeyboardBackspaceMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataVirtualKeyboardBackspaceMETA, next_) {}

  //! Default copy constructor
  EventDataVirtualKeyboardBackspaceMETA(const EventDataVirtualKeyboardBackspaceMETA& rhs) = default;
  //! Default copy assignment
  EventDataVirtualKeyboardBackspaceMETA& operator=(
      const EventDataVirtualKeyboardBackspaceMETA& rhs) = default;
  //! Copy construct from raw
  EventDataVirtualKeyboardBackspaceMETA(const XrEventDataVirtualKeyboardBackspaceMETA& rhs)
      : EventDataVirtualKeyboardBackspaceMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataVirtualKeyboardBackspaceMETA& operator=(
      const XrEventDataVirtualKeyboardBackspaceMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataVirtualKeyboardBackspaceMETA&() const {
    return *reinterpret_cast<const XrEventDataVirtualKeyboardBackspaceMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataVirtualKeyboardBackspaceMETA&() {
    return *reinterpret_cast<XrEventDataVirtualKeyboardBackspaceMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataVirtualKeyboardBackspaceMETA
  XrEventDataVirtualKeyboardBackspaceMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataVirtualKeyboardBackspaceMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataVirtualKeyboardBackspaceMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataVirtualKeyboardBackspaceMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataVirtualKeyboardBackspaceMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataVirtualKeyboardBackspaceMETA*>(this);
  }
  VirtualKeyboardMETA keyboard;
};
static_assert(sizeof(XrEventDataVirtualKeyboardBackspaceMETA) ==
                  sizeof(EventDataVirtualKeyboardBackspaceMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataVirtualKeyboardBackspaceMETA pointer to const
 * from a EventDataVirtualKeyboardBackspaceMETA reference to const.
 * @relates EventDataVirtualKeyboardBackspaceMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardBackspaceMETA const* get(
    EventDataVirtualKeyboardBackspaceMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataVirtualKeyboardBackspaceMETA as the address of a raw
 * XrEventDataVirtualKeyboardBackspaceMETA
 * @relates EventDataVirtualKeyboardBackspaceMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardBackspaceMETA* put(
    EventDataVirtualKeyboardBackspaceMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrEventDataVirtualKeyboardEnterMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVirtualKeyboardEnterMETA>
 * @xrentity{XrEventDataVirtualKeyboardEnterMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataVirtualKeyboardEnterMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataVirtualKeyboardEnterMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataVirtualKeyboardEnterMETA, next_) {}

  //! Default copy constructor
  EventDataVirtualKeyboardEnterMETA(const EventDataVirtualKeyboardEnterMETA& rhs) = default;
  //! Default copy assignment
  EventDataVirtualKeyboardEnterMETA& operator=(const EventDataVirtualKeyboardEnterMETA& rhs) =
      default;
  //! Copy construct from raw
  EventDataVirtualKeyboardEnterMETA(const XrEventDataVirtualKeyboardEnterMETA& rhs)
      : EventDataVirtualKeyboardEnterMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataVirtualKeyboardEnterMETA& operator=(const XrEventDataVirtualKeyboardEnterMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataVirtualKeyboardEnterMETA&() const {
    return *reinterpret_cast<const XrEventDataVirtualKeyboardEnterMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataVirtualKeyboardEnterMETA&() {
    return *reinterpret_cast<XrEventDataVirtualKeyboardEnterMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataVirtualKeyboardEnterMETA
  XrEventDataVirtualKeyboardEnterMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataVirtualKeyboardEnterMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataVirtualKeyboardEnterMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataVirtualKeyboardEnterMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataVirtualKeyboardEnterMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataVirtualKeyboardEnterMETA*>(this);
  }
  VirtualKeyboardMETA keyboard;
};
static_assert(sizeof(XrEventDataVirtualKeyboardEnterMETA) ==
                  sizeof(EventDataVirtualKeyboardEnterMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataVirtualKeyboardEnterMETA pointer to const from
 * a EventDataVirtualKeyboardEnterMETA reference to const.
 * @relates EventDataVirtualKeyboardEnterMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardEnterMETA const* get(
    EventDataVirtualKeyboardEnterMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataVirtualKeyboardEnterMETA as the address of a raw XrEventDataVirtualKeyboardEnterMETA
 * @relates EventDataVirtualKeyboardEnterMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardEnterMETA* put(
    EventDataVirtualKeyboardEnterMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrEventDataVirtualKeyboardShownMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVirtualKeyboardShownMETA>
 * @xrentity{XrEventDataVirtualKeyboardShownMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataVirtualKeyboardShownMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataVirtualKeyboardShownMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataVirtualKeyboardShownMETA, next_) {}

  //! Default copy constructor
  EventDataVirtualKeyboardShownMETA(const EventDataVirtualKeyboardShownMETA& rhs) = default;
  //! Default copy assignment
  EventDataVirtualKeyboardShownMETA& operator=(const EventDataVirtualKeyboardShownMETA& rhs) =
      default;
  //! Copy construct from raw
  EventDataVirtualKeyboardShownMETA(const XrEventDataVirtualKeyboardShownMETA& rhs)
      : EventDataVirtualKeyboardShownMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataVirtualKeyboardShownMETA& operator=(const XrEventDataVirtualKeyboardShownMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataVirtualKeyboardShownMETA&() const {
    return *reinterpret_cast<const XrEventDataVirtualKeyboardShownMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataVirtualKeyboardShownMETA&() {
    return *reinterpret_cast<XrEventDataVirtualKeyboardShownMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataVirtualKeyboardShownMETA
  XrEventDataVirtualKeyboardShownMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataVirtualKeyboardShownMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataVirtualKeyboardShownMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataVirtualKeyboardShownMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataVirtualKeyboardShownMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataVirtualKeyboardShownMETA*>(this);
  }
  VirtualKeyboardMETA keyboard;
};
static_assert(sizeof(XrEventDataVirtualKeyboardShownMETA) ==
                  sizeof(EventDataVirtualKeyboardShownMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataVirtualKeyboardShownMETA pointer to const from
 * a EventDataVirtualKeyboardShownMETA reference to const.
 * @relates EventDataVirtualKeyboardShownMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardShownMETA const* get(
    EventDataVirtualKeyboardShownMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataVirtualKeyboardShownMETA as the address of a raw XrEventDataVirtualKeyboardShownMETA
 * @relates EventDataVirtualKeyboardShownMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardShownMETA* put(
    EventDataVirtualKeyboardShownMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard
/*!
 * C++ projection of XrEventDataVirtualKeyboardHiddenMETA
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataVirtualKeyboardHiddenMETA>
 * @xrentity{XrEventDataVirtualKeyboardHiddenMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataVirtualKeyboardHiddenMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataVirtualKeyboardHiddenMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataVirtualKeyboardHiddenMETA, next_) {}

  //! Default copy constructor
  EventDataVirtualKeyboardHiddenMETA(const EventDataVirtualKeyboardHiddenMETA& rhs) = default;
  //! Default copy assignment
  EventDataVirtualKeyboardHiddenMETA& operator=(const EventDataVirtualKeyboardHiddenMETA& rhs) =
      default;
  //! Copy construct from raw
  EventDataVirtualKeyboardHiddenMETA(const XrEventDataVirtualKeyboardHiddenMETA& rhs)
      : EventDataVirtualKeyboardHiddenMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataVirtualKeyboardHiddenMETA& operator=(const XrEventDataVirtualKeyboardHiddenMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataVirtualKeyboardHiddenMETA&() const {
    return *reinterpret_cast<const XrEventDataVirtualKeyboardHiddenMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataVirtualKeyboardHiddenMETA&() {
    return *reinterpret_cast<XrEventDataVirtualKeyboardHiddenMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataVirtualKeyboardHiddenMETA
  XrEventDataVirtualKeyboardHiddenMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataVirtualKeyboardHiddenMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataVirtualKeyboardHiddenMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataVirtualKeyboardHiddenMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataVirtualKeyboardHiddenMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataVirtualKeyboardHiddenMETA*>(this);
  }
  VirtualKeyboardMETA keyboard;
};
static_assert(sizeof(XrEventDataVirtualKeyboardHiddenMETA) ==
                  sizeof(EventDataVirtualKeyboardHiddenMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataVirtualKeyboardHiddenMETA pointer to const from
 * a EventDataVirtualKeyboardHiddenMETA reference to const.
 * @relates EventDataVirtualKeyboardHiddenMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardHiddenMETA const* get(
    EventDataVirtualKeyboardHiddenMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataVirtualKeyboardHiddenMETA as the address of a raw XrEventDataVirtualKeyboardHiddenMETA
 * @relates EventDataVirtualKeyboardHiddenMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataVirtualKeyboardHiddenMETA* put(
    EventDataVirtualKeyboardHiddenMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_OCULUS_external_camera
/*!
 * C++ projection of XrExternalCameraIntrinsicsOCULUS
 *
 * Provided by the `XR_OCULUS_external_camera` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExternalCameraIntrinsicsOCULUS>
 * @xrentity{XrExternalCameraIntrinsicsOCULUS}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ExternalCameraIntrinsicsOCULUS {
public:
  //! Constructor initializing all members.
  ExternalCameraIntrinsicsOCULUS(const Time& lastChangeTime_, const Fovf& fov_,
                                 float virtualNearPlaneDistance_, float virtualFarPlaneDistance_,
                                 const Extent2Di& imageSensorPixelResolution_)
      : lastChangeTime{lastChangeTime_},
        fov{fov_},
        virtualNearPlaneDistance{virtualNearPlaneDistance_},
        virtualFarPlaneDistance{virtualFarPlaneDistance_},
        imageSensorPixelResolution{imageSensorPixelResolution_} {}

  //! Default/empty constructor
  ExternalCameraIntrinsicsOCULUS()

      : lastChangeTime{},
        fov{},
        virtualNearPlaneDistance{0.0f},
        virtualFarPlaneDistance{0.0f},
        imageSensorPixelResolution{} {}

  //! Default copy constructor
  ExternalCameraIntrinsicsOCULUS(const ExternalCameraIntrinsicsOCULUS& rhs) = default;
  //! Default copy assignment
  ExternalCameraIntrinsicsOCULUS& operator=(const ExternalCameraIntrinsicsOCULUS& rhs) = default;
  //! Copy construct from raw
  ExternalCameraIntrinsicsOCULUS(const XrExternalCameraIntrinsicsOCULUS& rhs)
      : ExternalCameraIntrinsicsOCULUS() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ExternalCameraIntrinsicsOCULUS& operator=(const XrExternalCameraIntrinsicsOCULUS& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExternalCameraIntrinsicsOCULUS&() const {
    return *reinterpret_cast<const XrExternalCameraIntrinsicsOCULUS*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExternalCameraIntrinsicsOCULUS&() {
    return *reinterpret_cast<XrExternalCameraIntrinsicsOCULUS*>(this);
  }

  //! Accessor for this as the address of a raw XrExternalCameraIntrinsicsOCULUS
  XrExternalCameraIntrinsicsOCULUS const* get() const noexcept {
    return reinterpret_cast<XrExternalCameraIntrinsicsOCULUS const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrExternalCameraIntrinsicsOCULUS.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrExternalCameraIntrinsicsOCULUS* put(bool clear = true) noexcept {
    if (clear) {
      *this = ExternalCameraIntrinsicsOCULUS{};
    }
    return reinterpret_cast<XrExternalCameraIntrinsicsOCULUS*>(this);
  }
  Time lastChangeTime;
  Fovf fov;
  float virtualNearPlaneDistance;
  float virtualFarPlaneDistance;
  Extent2Di imageSensorPixelResolution;
};
static_assert(sizeof(XrExternalCameraIntrinsicsOCULUS) == sizeof(ExternalCameraIntrinsicsOCULUS),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExternalCameraIntrinsicsOCULUS pointer to const from a
 * ExternalCameraIntrinsicsOCULUS reference to const.
 * @relates ExternalCameraIntrinsicsOCULUS
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExternalCameraIntrinsicsOCULUS const* get(
    ExternalCameraIntrinsicsOCULUS const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ExternalCameraIntrinsicsOCULUS as the address of a raw XrExternalCameraIntrinsicsOCULUS
 * @relates ExternalCameraIntrinsicsOCULUS
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExternalCameraIntrinsicsOCULUS* put(ExternalCameraIntrinsicsOCULUS& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_OCULUS_external_camera

#ifdef XR_OCULUS_external_camera
/*!
 * C++ projection of XrExternalCameraExtrinsicsOCULUS
 *
 * Provided by the `XR_OCULUS_external_camera` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExternalCameraExtrinsicsOCULUS>
 * @xrentity{XrExternalCameraExtrinsicsOCULUS}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ExternalCameraExtrinsicsOCULUS {
public:
  //! Constructor initializing all members.
  ExternalCameraExtrinsicsOCULUS(const Time& lastChangeTime_,
                                 const ExternalCameraStatusFlagsOCULUS& cameraStatusFlags_,
                                 const ExternalCameraAttachedToDeviceOCULUS& attachedToDevice_,
                                 const Posef& relativePose_)
      : lastChangeTime{lastChangeTime_},
        cameraStatusFlags{cameraStatusFlags_},
        attachedToDevice{attachedToDevice_},
        relativePose{relativePose_} {}

  //! Default/empty constructor
  ExternalCameraExtrinsicsOCULUS()

      : lastChangeTime{}, cameraStatusFlags{}, attachedToDevice{}, relativePose{} {}

  //! Default copy constructor
  ExternalCameraExtrinsicsOCULUS(const ExternalCameraExtrinsicsOCULUS& rhs) = default;
  //! Default copy assignment
  ExternalCameraExtrinsicsOCULUS& operator=(const ExternalCameraExtrinsicsOCULUS& rhs) = default;
  //! Copy construct from raw
  ExternalCameraExtrinsicsOCULUS(const XrExternalCameraExtrinsicsOCULUS& rhs)
      : ExternalCameraExtrinsicsOCULUS() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ExternalCameraExtrinsicsOCULUS& operator=(const XrExternalCameraExtrinsicsOCULUS& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExternalCameraExtrinsicsOCULUS&() const {
    return *reinterpret_cast<const XrExternalCameraExtrinsicsOCULUS*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExternalCameraExtrinsicsOCULUS&() {
    return *reinterpret_cast<XrExternalCameraExtrinsicsOCULUS*>(this);
  }

  //! Accessor for this as the address of a raw XrExternalCameraExtrinsicsOCULUS
  XrExternalCameraExtrinsicsOCULUS const* get() const noexcept {
    return reinterpret_cast<XrExternalCameraExtrinsicsOCULUS const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrExternalCameraExtrinsicsOCULUS.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrExternalCameraExtrinsicsOCULUS* put(bool clear = true) noexcept {
    if (clear) {
      *this = ExternalCameraExtrinsicsOCULUS{};
    }
    return reinterpret_cast<XrExternalCameraExtrinsicsOCULUS*>(this);
  }
  Time lastChangeTime;
  ExternalCameraStatusFlagsOCULUS cameraStatusFlags;
  ExternalCameraAttachedToDeviceOCULUS attachedToDevice;
  Posef relativePose;
};
static_assert(sizeof(XrExternalCameraExtrinsicsOCULUS) == sizeof(ExternalCameraExtrinsicsOCULUS),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExternalCameraExtrinsicsOCULUS pointer to const from a
 * ExternalCameraExtrinsicsOCULUS reference to const.
 * @relates ExternalCameraExtrinsicsOCULUS
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExternalCameraExtrinsicsOCULUS const* get(
    ExternalCameraExtrinsicsOCULUS const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ExternalCameraExtrinsicsOCULUS as the address of a raw XrExternalCameraExtrinsicsOCULUS
 * @relates ExternalCameraExtrinsicsOCULUS
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExternalCameraExtrinsicsOCULUS* put(ExternalCameraExtrinsicsOCULUS& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_OCULUS_external_camera

#ifdef XR_OCULUS_external_camera
/*!
 * C++ projection of XrExternalCameraOCULUS
 *
 * Provided by the `XR_OCULUS_external_camera` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExternalCameraOCULUS>
 * @xrentity{XrExternalCameraOCULUS}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ExternalCameraOCULUS : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  ExternalCameraOCULUS(void* next_ = nullptr)

      : Parent(StructureType::ExternalCameraOCULUS, next_) {}

  //! Default copy constructor
  ExternalCameraOCULUS(const ExternalCameraOCULUS& rhs) = default;
  //! Default copy assignment
  ExternalCameraOCULUS& operator=(const ExternalCameraOCULUS& rhs) = default;
  //! Copy construct from raw
  ExternalCameraOCULUS(const XrExternalCameraOCULUS& rhs) : ExternalCameraOCULUS() { *put() = rhs; }
  //! Copy assign from raw
  ExternalCameraOCULUS& operator=(const XrExternalCameraOCULUS& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrExternalCameraOCULUS&() const {
    return *reinterpret_cast<const XrExternalCameraOCULUS*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrExternalCameraOCULUS&() { return *reinterpret_cast<XrExternalCameraOCULUS*>(this); }

  //! Accessor for this as the address of a raw XrExternalCameraOCULUS
  XrExternalCameraOCULUS const* get() const noexcept {
    return reinterpret_cast<XrExternalCameraOCULUS const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrExternalCameraOCULUS.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrExternalCameraOCULUS* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ExternalCameraOCULUS{};
      next = oldNext;
    }
    return reinterpret_cast<XrExternalCameraOCULUS*>(this);
  }
  char name[XR_MAX_EXTERNAL_CAMERA_NAME_SIZE_OCULUS];
  ExternalCameraIntrinsicsOCULUS intrinsics;
  ExternalCameraExtrinsicsOCULUS extrinsics;
};
static_assert(sizeof(XrExternalCameraOCULUS) == sizeof(ExternalCameraOCULUS),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrExternalCameraOCULUS pointer to const from a
 * ExternalCameraOCULUS reference to const.
 * @relates ExternalCameraOCULUS
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExternalCameraOCULUS const* get(ExternalCameraOCULUS const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ExternalCameraOCULUS as the
 * address of a raw XrExternalCameraOCULUS
 * @relates ExternalCameraOCULUS
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrExternalCameraOCULUS* put(ExternalCameraOCULUS& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_OCULUS_external_camera

#ifdef XR_META_vulkan_swapchain_create_info
#if defined(XR_USE_GRAPHICS_API_VULKAN)
/*!
 * C++ projection of XrVulkanSwapchainCreateInfoMETA
 *
 * Provided by the `XR_META_vulkan_swapchain_create_info` extension.
 * Be sure to include `<openxr_platform.h>` before including this header to use it.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVulkanSwapchainCreateInfoMETA>
 * @xrentity{XrVulkanSwapchainCreateInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS VulkanSwapchainCreateInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  VulkanSwapchainCreateInfoMETA(VkImageCreateFlags additionalCreateFlags_,
                                VkImageUsageFlags additionalUsageFlags_,
                                const void* next_ = nullptr)
      : Parent(StructureType::VulkanSwapchainCreateInfoMETA, next_),
        additionalCreateFlags{additionalCreateFlags_},
        additionalUsageFlags{additionalUsageFlags_} {}

  //! Default/empty constructor
  VulkanSwapchainCreateInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::VulkanSwapchainCreateInfoMETA, next_),
        additionalCreateFlags{},
        additionalUsageFlags{} {}

  //! Default copy constructor
  VulkanSwapchainCreateInfoMETA(const VulkanSwapchainCreateInfoMETA& rhs) = default;
  //! Default copy assignment
  VulkanSwapchainCreateInfoMETA& operator=(const VulkanSwapchainCreateInfoMETA& rhs) = default;
  //! Copy construct from raw
  VulkanSwapchainCreateInfoMETA(const XrVulkanSwapchainCreateInfoMETA& rhs)
      : VulkanSwapchainCreateInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  VulkanSwapchainCreateInfoMETA& operator=(const XrVulkanSwapchainCreateInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrVulkanSwapchainCreateInfoMETA&() const {
    return *reinterpret_cast<const XrVulkanSwapchainCreateInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrVulkanSwapchainCreateInfoMETA&() {
    return *reinterpret_cast<XrVulkanSwapchainCreateInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrVulkanSwapchainCreateInfoMETA
  XrVulkanSwapchainCreateInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrVulkanSwapchainCreateInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrVulkanSwapchainCreateInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrVulkanSwapchainCreateInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = VulkanSwapchainCreateInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrVulkanSwapchainCreateInfoMETA*>(this);
  }
  VkImageCreateFlags additionalCreateFlags;
  VkImageUsageFlags additionalUsageFlags;
};
static_assert(sizeof(XrVulkanSwapchainCreateInfoMETA) == sizeof(VulkanSwapchainCreateInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrVulkanSwapchainCreateInfoMETA pointer to const from a
 * VulkanSwapchainCreateInfoMETA reference to const.
 * @relates VulkanSwapchainCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanSwapchainCreateInfoMETA const* get(
    VulkanSwapchainCreateInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing VulkanSwapchainCreateInfoMETA
 * as the address of a raw XrVulkanSwapchainCreateInfoMETA
 * @relates VulkanSwapchainCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrVulkanSwapchainCreateInfoMETA* put(VulkanSwapchainCreateInfoMETA& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_META_vulkan_swapchain_create_info

#ifdef XR_META_performance_metrics
/*!
 * C++ projection of XrPerformanceMetricsStateMETA
 *
 * Provided by the `XR_META_performance_metrics` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerformanceMetricsStateMETA>
 * @xrentity{XrPerformanceMetricsStateMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PerformanceMetricsStateMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PerformanceMetricsStateMETA(const Bool32& enabled_, const void* next_ = nullptr)
      : Parent(StructureType::PerformanceMetricsStateMETA, next_), enabled{enabled_} {}

  //! Default/empty constructor
  PerformanceMetricsStateMETA(const void* next_ = nullptr)

      : Parent(StructureType::PerformanceMetricsStateMETA, next_), enabled{false} {}

  //! Default copy constructor
  PerformanceMetricsStateMETA(const PerformanceMetricsStateMETA& rhs) = default;
  //! Default copy assignment
  PerformanceMetricsStateMETA& operator=(const PerformanceMetricsStateMETA& rhs) = default;
  //! Copy construct from raw
  PerformanceMetricsStateMETA(const XrPerformanceMetricsStateMETA& rhs)
      : PerformanceMetricsStateMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PerformanceMetricsStateMETA& operator=(const XrPerformanceMetricsStateMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPerformanceMetricsStateMETA&() const {
    return *reinterpret_cast<const XrPerformanceMetricsStateMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPerformanceMetricsStateMETA&() {
    return *reinterpret_cast<XrPerformanceMetricsStateMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrPerformanceMetricsStateMETA
  XrPerformanceMetricsStateMETA const* get() const noexcept {
    return reinterpret_cast<XrPerformanceMetricsStateMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPerformanceMetricsStateMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPerformanceMetricsStateMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PerformanceMetricsStateMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrPerformanceMetricsStateMETA*>(this);
  }
  Bool32 enabled;
};
static_assert(sizeof(XrPerformanceMetricsStateMETA) == sizeof(PerformanceMetricsStateMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPerformanceMetricsStateMETA pointer to const from a
 * PerformanceMetricsStateMETA reference to const.
 * @relates PerformanceMetricsStateMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPerformanceMetricsStateMETA const* get(
    PerformanceMetricsStateMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PerformanceMetricsStateMETA
 * as the address of a raw XrPerformanceMetricsStateMETA
 * @relates PerformanceMetricsStateMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPerformanceMetricsStateMETA* put(PerformanceMetricsStateMETA& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_performance_metrics

#ifdef XR_META_performance_metrics
/*!
 * C++ projection of XrPerformanceMetricsCounterMETA
 *
 * Provided by the `XR_META_performance_metrics` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPerformanceMetricsCounterMETA>
 * @xrentity{XrPerformanceMetricsCounterMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PerformanceMetricsCounterMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PerformanceMetricsCounterMETA(const PerformanceMetricsCounterFlagsMETA& counterFlags_,
                                const PerformanceMetricsCounterUnitMETA& counterUnit_,
                                uint32_t uintValue_, float floatValue_, const void* next_ = nullptr)
      : Parent(StructureType::PerformanceMetricsCounterMETA, next_),
        counterFlags{counterFlags_},
        counterUnit{counterUnit_},
        uintValue{uintValue_},
        floatValue{floatValue_} {}

  //! Default/empty constructor
  PerformanceMetricsCounterMETA(const void* next_ = nullptr)

      : Parent(StructureType::PerformanceMetricsCounterMETA, next_),
        counterFlags{},
        counterUnit{},
        uintValue{0},
        floatValue{0.0f} {}

  //! Default copy constructor
  PerformanceMetricsCounterMETA(const PerformanceMetricsCounterMETA& rhs) = default;
  //! Default copy assignment
  PerformanceMetricsCounterMETA& operator=(const PerformanceMetricsCounterMETA& rhs) = default;
  //! Copy construct from raw
  PerformanceMetricsCounterMETA(const XrPerformanceMetricsCounterMETA& rhs)
      : PerformanceMetricsCounterMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PerformanceMetricsCounterMETA& operator=(const XrPerformanceMetricsCounterMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPerformanceMetricsCounterMETA&() const {
    return *reinterpret_cast<const XrPerformanceMetricsCounterMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPerformanceMetricsCounterMETA&() {
    return *reinterpret_cast<XrPerformanceMetricsCounterMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrPerformanceMetricsCounterMETA
  XrPerformanceMetricsCounterMETA const* get() const noexcept {
    return reinterpret_cast<XrPerformanceMetricsCounterMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPerformanceMetricsCounterMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPerformanceMetricsCounterMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PerformanceMetricsCounterMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrPerformanceMetricsCounterMETA*>(this);
  }
  PerformanceMetricsCounterFlagsMETA counterFlags;
  PerformanceMetricsCounterUnitMETA counterUnit;
  uint32_t uintValue;
  float floatValue;
};
static_assert(sizeof(XrPerformanceMetricsCounterMETA) == sizeof(PerformanceMetricsCounterMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPerformanceMetricsCounterMETA pointer to const from a
 * PerformanceMetricsCounterMETA reference to const.
 * @relates PerformanceMetricsCounterMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPerformanceMetricsCounterMETA const* get(
    PerformanceMetricsCounterMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PerformanceMetricsCounterMETA
 * as the address of a raw XrPerformanceMetricsCounterMETA
 * @relates PerformanceMetricsCounterMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPerformanceMetricsCounterMETA* put(PerformanceMetricsCounterMETA& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_performance_metrics

#ifdef XR_FB_spatial_entity_storage_batch
/*!
 * C++ projection of XrSpaceListSaveInfoFB
 *
 * Provided by the `XR_FB_spatial_entity_storage_batch` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceListSaveInfoFB>
 * @xrentity{XrSpaceListSaveInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceListSaveInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpaceListSaveInfoFB(uint32_t spaceCount_, Space* spaces_, const SpaceStorageLocationFB& location_,
                      const void* next_ = nullptr)
      : Parent(StructureType::SpaceListSaveInfoFB, next_),
        spaceCount{spaceCount_},
        spaces{spaces_},
        location{location_} {}

  //! Default/empty constructor
  SpaceListSaveInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SpaceListSaveInfoFB, next_),
        spaceCount{0},
        spaces{nullptr},
        location{} {}

  //! Default copy constructor
  SpaceListSaveInfoFB(const SpaceListSaveInfoFB& rhs) = default;
  //! Default copy assignment
  SpaceListSaveInfoFB& operator=(const SpaceListSaveInfoFB& rhs) = default;
  //! Copy construct from raw
  SpaceListSaveInfoFB(const XrSpaceListSaveInfoFB& rhs) : SpaceListSaveInfoFB() { *put() = rhs; }
  //! Copy assign from raw
  SpaceListSaveInfoFB& operator=(const XrSpaceListSaveInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceListSaveInfoFB&() const {
    return *reinterpret_cast<const XrSpaceListSaveInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceListSaveInfoFB&() { return *reinterpret_cast<XrSpaceListSaveInfoFB*>(this); }

  //! Accessor for this as the address of a raw XrSpaceListSaveInfoFB
  XrSpaceListSaveInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceListSaveInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceListSaveInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceListSaveInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceListSaveInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceListSaveInfoFB*>(this);
  }
  uint32_t spaceCount;
  Space* spaces;
  SpaceStorageLocationFB location;
};
static_assert(sizeof(XrSpaceListSaveInfoFB) == sizeof(SpaceListSaveInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceListSaveInfoFB pointer to const from a
 * SpaceListSaveInfoFB reference to const.
 * @relates SpaceListSaveInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceListSaveInfoFB const* get(SpaceListSaveInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceListSaveInfoFB as the
 * address of a raw XrSpaceListSaveInfoFB
 * @relates SpaceListSaveInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceListSaveInfoFB* put(SpaceListSaveInfoFB& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity_storage_batch

#ifdef XR_FB_spatial_entity_storage_batch
/*!
 * C++ projection of XrEventDataSpaceListSaveCompleteFB
 *
 * Provided by the `XR_FB_spatial_entity_storage_batch` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpaceListSaveCompleteFB>
 * @xrentity{XrEventDataSpaceListSaveCompleteFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSpaceListSaveCompleteFB : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSpaceListSaveCompleteFB(void* next_ = nullptr)

      : Parent(StructureType::EventDataSpaceListSaveCompleteFB, next_) {}

  //! Default copy constructor
  EventDataSpaceListSaveCompleteFB(const EventDataSpaceListSaveCompleteFB& rhs) = default;
  //! Default copy assignment
  EventDataSpaceListSaveCompleteFB& operator=(const EventDataSpaceListSaveCompleteFB& rhs) =
      default;
  //! Copy construct from raw
  EventDataSpaceListSaveCompleteFB(const XrEventDataSpaceListSaveCompleteFB& rhs)
      : EventDataSpaceListSaveCompleteFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSpaceListSaveCompleteFB& operator=(const XrEventDataSpaceListSaveCompleteFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSpaceListSaveCompleteFB&() const {
    return *reinterpret_cast<const XrEventDataSpaceListSaveCompleteFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSpaceListSaveCompleteFB&() {
    return *reinterpret_cast<XrEventDataSpaceListSaveCompleteFB*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSpaceListSaveCompleteFB
  XrEventDataSpaceListSaveCompleteFB const* get() const noexcept {
    return reinterpret_cast<XrEventDataSpaceListSaveCompleteFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSpaceListSaveCompleteFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSpaceListSaveCompleteFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSpaceListSaveCompleteFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSpaceListSaveCompleteFB*>(this);
  }
  AsyncRequestIdFB requestId;
  Result result;
};
static_assert(sizeof(XrEventDataSpaceListSaveCompleteFB) ==
                  sizeof(EventDataSpaceListSaveCompleteFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSpaceListSaveCompleteFB pointer to const from a
 * EventDataSpaceListSaveCompleteFB reference to const.
 * @relates EventDataSpaceListSaveCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceListSaveCompleteFB const* get(
    EventDataSpaceListSaveCompleteFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataSpaceListSaveCompleteFB as the address of a raw XrEventDataSpaceListSaveCompleteFB
 * @relates EventDataSpaceListSaveCompleteFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpaceListSaveCompleteFB* put(
    EventDataSpaceListSaveCompleteFB& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSpaceListSaveCompleteFB as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpaceListSaveCompleteFB
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSpaceListSaveCompleteFB const& h) {
  return h.get_base();
}
#endif  // XR_FB_spatial_entity_storage_batch

#ifdef XR_FB_spatial_entity_user
/*!
 * C++ projection of XrSpaceUserCreateInfoFB
 *
 * Provided by the `XR_FB_spatial_entity_user` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceUserCreateInfoFB>
 * @xrentity{XrSpaceUserCreateInfoFB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceUserCreateInfoFB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpaceUserCreateInfoFB(const SpaceUserIdFB& userId_, const void* next_ = nullptr)
      : Parent(StructureType::SpaceUserCreateInfoFB, next_), userId{userId_} {}

  //! Default/empty constructor
  SpaceUserCreateInfoFB(const void* next_ = nullptr)

      : Parent(StructureType::SpaceUserCreateInfoFB, next_), userId{} {}

  //! Default copy constructor
  SpaceUserCreateInfoFB(const SpaceUserCreateInfoFB& rhs) = default;
  //! Default copy assignment
  SpaceUserCreateInfoFB& operator=(const SpaceUserCreateInfoFB& rhs) = default;
  //! Copy construct from raw
  SpaceUserCreateInfoFB(const XrSpaceUserCreateInfoFB& rhs) : SpaceUserCreateInfoFB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpaceUserCreateInfoFB& operator=(const XrSpaceUserCreateInfoFB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceUserCreateInfoFB&() const {
    return *reinterpret_cast<const XrSpaceUserCreateInfoFB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceUserCreateInfoFB&() { return *reinterpret_cast<XrSpaceUserCreateInfoFB*>(this); }

  //! Accessor for this as the address of a raw XrSpaceUserCreateInfoFB
  XrSpaceUserCreateInfoFB const* get() const noexcept {
    return reinterpret_cast<XrSpaceUserCreateInfoFB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceUserCreateInfoFB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceUserCreateInfoFB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceUserCreateInfoFB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceUserCreateInfoFB*>(this);
  }
  SpaceUserIdFB userId;
};
static_assert(sizeof(XrSpaceUserCreateInfoFB) == sizeof(SpaceUserCreateInfoFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceUserCreateInfoFB pointer to const from a
 * SpaceUserCreateInfoFB reference to const.
 * @relates SpaceUserCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceUserCreateInfoFB const* get(SpaceUserCreateInfoFB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceUserCreateInfoFB as the
 * address of a raw XrSpaceUserCreateInfoFB
 * @relates SpaceUserCreateInfoFB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceUserCreateInfoFB* put(SpaceUserCreateInfoFB& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_spatial_entity_user

#ifdef XR_META_headset_id
/*!
 * C++ projection of XrSystemHeadsetIdPropertiesMETA
 *
 * Provided by the `XR_META_headset_id` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemHeadsetIdPropertiesMETA>
 * @xrentity{XrSystemHeadsetIdPropertiesMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemHeadsetIdPropertiesMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemHeadsetIdPropertiesMETA(void* next_ = nullptr)

      : Parent(StructureType::SystemHeadsetIdPropertiesMETA, next_) {}

  //! Default copy constructor
  SystemHeadsetIdPropertiesMETA(const SystemHeadsetIdPropertiesMETA& rhs) = default;
  //! Default copy assignment
  SystemHeadsetIdPropertiesMETA& operator=(const SystemHeadsetIdPropertiesMETA& rhs) = default;
  //! Copy construct from raw
  SystemHeadsetIdPropertiesMETA(const XrSystemHeadsetIdPropertiesMETA& rhs)
      : SystemHeadsetIdPropertiesMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemHeadsetIdPropertiesMETA& operator=(const XrSystemHeadsetIdPropertiesMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemHeadsetIdPropertiesMETA&() const {
    return *reinterpret_cast<const XrSystemHeadsetIdPropertiesMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemHeadsetIdPropertiesMETA&() {
    return *reinterpret_cast<XrSystemHeadsetIdPropertiesMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemHeadsetIdPropertiesMETA
  XrSystemHeadsetIdPropertiesMETA const* get() const noexcept {
    return reinterpret_cast<XrSystemHeadsetIdPropertiesMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemHeadsetIdPropertiesMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemHeadsetIdPropertiesMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemHeadsetIdPropertiesMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemHeadsetIdPropertiesMETA*>(this);
  }
  UuidEXT id;
};
static_assert(sizeof(XrSystemHeadsetIdPropertiesMETA) == sizeof(SystemHeadsetIdPropertiesMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemHeadsetIdPropertiesMETA pointer to const from a
 * SystemHeadsetIdPropertiesMETA reference to const.
 * @relates SystemHeadsetIdPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHeadsetIdPropertiesMETA const* get(
    SystemHeadsetIdPropertiesMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemHeadsetIdPropertiesMETA
 * as the address of a raw XrSystemHeadsetIdPropertiesMETA
 * @relates SystemHeadsetIdPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemHeadsetIdPropertiesMETA* put(SystemHeadsetIdPropertiesMETA& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_headset_id

#ifdef XR_META_recommended_layer_resolution
/*!
 * C++ projection of XrRecommendedLayerResolutionMETA
 *
 * Provided by the `XR_META_recommended_layer_resolution` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRecommendedLayerResolutionMETA>
 * @xrentity{XrRecommendedLayerResolutionMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RecommendedLayerResolutionMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RecommendedLayerResolutionMETA(void* next_ = nullptr)

      : Parent(StructureType::RecommendedLayerResolutionMETA, next_) {}

  //! Default copy constructor
  RecommendedLayerResolutionMETA(const RecommendedLayerResolutionMETA& rhs) = default;
  //! Default copy assignment
  RecommendedLayerResolutionMETA& operator=(const RecommendedLayerResolutionMETA& rhs) = default;
  //! Copy construct from raw
  RecommendedLayerResolutionMETA(const XrRecommendedLayerResolutionMETA& rhs)
      : RecommendedLayerResolutionMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RecommendedLayerResolutionMETA& operator=(const XrRecommendedLayerResolutionMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRecommendedLayerResolutionMETA&() const {
    return *reinterpret_cast<const XrRecommendedLayerResolutionMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRecommendedLayerResolutionMETA&() {
    return *reinterpret_cast<XrRecommendedLayerResolutionMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrRecommendedLayerResolutionMETA
  XrRecommendedLayerResolutionMETA const* get() const noexcept {
    return reinterpret_cast<XrRecommendedLayerResolutionMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRecommendedLayerResolutionMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRecommendedLayerResolutionMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RecommendedLayerResolutionMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrRecommendedLayerResolutionMETA*>(this);
  }
  Extent2Di recommendedImageDimensions;
  Bool32 isValid;
};
static_assert(sizeof(XrRecommendedLayerResolutionMETA) == sizeof(RecommendedLayerResolutionMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRecommendedLayerResolutionMETA pointer to const from a
 * RecommendedLayerResolutionMETA reference to const.
 * @relates RecommendedLayerResolutionMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRecommendedLayerResolutionMETA const* get(
    RecommendedLayerResolutionMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * RecommendedLayerResolutionMETA as the address of a raw XrRecommendedLayerResolutionMETA
 * @relates RecommendedLayerResolutionMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRecommendedLayerResolutionMETA* put(RecommendedLayerResolutionMETA& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_recommended_layer_resolution

#ifdef XR_META_recommended_layer_resolution
/*!
 * C++ projection of XrRecommendedLayerResolutionGetInfoMETA
 *
 * Provided by the `XR_META_recommended_layer_resolution` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRecommendedLayerResolutionGetInfoMETA>
 * @xrentity{XrRecommendedLayerResolutionGetInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RecommendedLayerResolutionGetInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  RecommendedLayerResolutionGetInfoMETA(const CompositionLayerBaseHeader* layer_,
                                        const Time& predictedDisplayTime_,
                                        const void* next_ = nullptr)
      : Parent(StructureType::RecommendedLayerResolutionGetInfoMETA, next_),
        layer{layer_},
        predictedDisplayTime{predictedDisplayTime_} {}

  //! Default/empty constructor
  RecommendedLayerResolutionGetInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::RecommendedLayerResolutionGetInfoMETA, next_),
        layer{nullptr},
        predictedDisplayTime{} {}

  //! Default copy constructor
  RecommendedLayerResolutionGetInfoMETA(const RecommendedLayerResolutionGetInfoMETA& rhs) = default;
  //! Default copy assignment
  RecommendedLayerResolutionGetInfoMETA& operator=(
      const RecommendedLayerResolutionGetInfoMETA& rhs) = default;
  //! Copy construct from raw
  RecommendedLayerResolutionGetInfoMETA(const XrRecommendedLayerResolutionGetInfoMETA& rhs)
      : RecommendedLayerResolutionGetInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RecommendedLayerResolutionGetInfoMETA& operator=(
      const XrRecommendedLayerResolutionGetInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRecommendedLayerResolutionGetInfoMETA&() const {
    return *reinterpret_cast<const XrRecommendedLayerResolutionGetInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRecommendedLayerResolutionGetInfoMETA&() {
    return *reinterpret_cast<XrRecommendedLayerResolutionGetInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrRecommendedLayerResolutionGetInfoMETA
  XrRecommendedLayerResolutionGetInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrRecommendedLayerResolutionGetInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRecommendedLayerResolutionGetInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRecommendedLayerResolutionGetInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RecommendedLayerResolutionGetInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrRecommendedLayerResolutionGetInfoMETA*>(this);
  }
  const CompositionLayerBaseHeader* layer;
  Time predictedDisplayTime;
};
static_assert(sizeof(XrRecommendedLayerResolutionGetInfoMETA) ==
                  sizeof(RecommendedLayerResolutionGetInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRecommendedLayerResolutionGetInfoMETA pointer to const
 * from a RecommendedLayerResolutionGetInfoMETA reference to const.
 * @relates RecommendedLayerResolutionGetInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRecommendedLayerResolutionGetInfoMETA const* get(
    RecommendedLayerResolutionGetInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * RecommendedLayerResolutionGetInfoMETA as the address of a raw
 * XrRecommendedLayerResolutionGetInfoMETA
 * @relates RecommendedLayerResolutionGetInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRecommendedLayerResolutionGetInfoMETA* put(
    RecommendedLayerResolutionGetInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_recommended_layer_resolution

#ifdef XR_META_passthrough_color_lut
/*!
 * C++ projection of XrPassthroughColorLutDataMETA
 *
 * Provided by the `XR_META_passthrough_color_lut` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorLutDataMETA>
 * @xrentity{XrPassthroughColorLutDataMETA}
 * @ingroup structs
 */
struct XR_MAY_ALIAS PassthroughColorLutDataMETA {
public:
  //! Constructor initializing all members.
  PassthroughColorLutDataMETA(uint32_t bufferSize_, const uint8_t* buffer_)
      : bufferSize{bufferSize_}, buffer{buffer_} {}

  //! Default/empty constructor
  PassthroughColorLutDataMETA()

      : bufferSize{0}, buffer{nullptr} {}

  //! Default copy constructor
  PassthroughColorLutDataMETA(const PassthroughColorLutDataMETA& rhs) = default;
  //! Default copy assignment
  PassthroughColorLutDataMETA& operator=(const PassthroughColorLutDataMETA& rhs) = default;
  //! Copy construct from raw
  PassthroughColorLutDataMETA(const XrPassthroughColorLutDataMETA& rhs)
      : PassthroughColorLutDataMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughColorLutDataMETA& operator=(const XrPassthroughColorLutDataMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughColorLutDataMETA&() const {
    return *reinterpret_cast<const XrPassthroughColorLutDataMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughColorLutDataMETA&() {
    return *reinterpret_cast<XrPassthroughColorLutDataMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughColorLutDataMETA
  XrPassthroughColorLutDataMETA const* get() const noexcept {
    return reinterpret_cast<XrPassthroughColorLutDataMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughColorLutDataMETA.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrPassthroughColorLutDataMETA* put(bool clear = true) noexcept {
    if (clear) {
      *this = PassthroughColorLutDataMETA{};
    }
    return reinterpret_cast<XrPassthroughColorLutDataMETA*>(this);
  }
  uint32_t bufferSize;
  const uint8_t* buffer;
};
static_assert(sizeof(XrPassthroughColorLutDataMETA) == sizeof(PassthroughColorLutDataMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughColorLutDataMETA pointer to const from a
 * PassthroughColorLutDataMETA reference to const.
 * @relates PassthroughColorLutDataMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorLutDataMETA const* get(
    PassthroughColorLutDataMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughColorLutDataMETA
 * as the address of a raw XrPassthroughColorLutDataMETA
 * @relates PassthroughColorLutDataMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorLutDataMETA* put(PassthroughColorLutDataMETA& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_passthrough_color_lut

#ifdef XR_META_passthrough_color_lut
/*!
 * C++ projection of XrPassthroughColorLutCreateInfoMETA
 *
 * Provided by the `XR_META_passthrough_color_lut` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorLutCreateInfoMETA>
 * @xrentity{XrPassthroughColorLutCreateInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughColorLutCreateInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughColorLutCreateInfoMETA(const PassthroughColorLutChannelsMETA& channels_,
                                    uint32_t resolution_, const PassthroughColorLutDataMETA& data_,
                                    const void* next_ = nullptr)
      : Parent(StructureType::PassthroughColorLutCreateInfoMETA, next_),
        channels{channels_},
        resolution{resolution_},
        data{data_} {}

  //! Default/empty constructor
  PassthroughColorLutCreateInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughColorLutCreateInfoMETA, next_),
        channels{},
        resolution{0},
        data{} {}

  //! Default copy constructor
  PassthroughColorLutCreateInfoMETA(const PassthroughColorLutCreateInfoMETA& rhs) = default;
  //! Default copy assignment
  PassthroughColorLutCreateInfoMETA& operator=(const PassthroughColorLutCreateInfoMETA& rhs) =
      default;
  //! Copy construct from raw
  PassthroughColorLutCreateInfoMETA(const XrPassthroughColorLutCreateInfoMETA& rhs)
      : PassthroughColorLutCreateInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughColorLutCreateInfoMETA& operator=(const XrPassthroughColorLutCreateInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughColorLutCreateInfoMETA&() const {
    return *reinterpret_cast<const XrPassthroughColorLutCreateInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughColorLutCreateInfoMETA&() {
    return *reinterpret_cast<XrPassthroughColorLutCreateInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughColorLutCreateInfoMETA
  XrPassthroughColorLutCreateInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrPassthroughColorLutCreateInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughColorLutCreateInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughColorLutCreateInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughColorLutCreateInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughColorLutCreateInfoMETA*>(this);
  }
  PassthroughColorLutChannelsMETA channels;
  uint32_t resolution;
  PassthroughColorLutDataMETA data;
};
static_assert(sizeof(XrPassthroughColorLutCreateInfoMETA) ==
                  sizeof(PassthroughColorLutCreateInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughColorLutCreateInfoMETA pointer to const from
 * a PassthroughColorLutCreateInfoMETA reference to const.
 * @relates PassthroughColorLutCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorLutCreateInfoMETA const* get(
    PassthroughColorLutCreateInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * PassthroughColorLutCreateInfoMETA as the address of a raw XrPassthroughColorLutCreateInfoMETA
 * @relates PassthroughColorLutCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorLutCreateInfoMETA* put(
    PassthroughColorLutCreateInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_passthrough_color_lut

#ifdef XR_META_passthrough_color_lut
/*!
 * C++ projection of XrPassthroughColorLutUpdateInfoMETA
 *
 * Provided by the `XR_META_passthrough_color_lut` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorLutUpdateInfoMETA>
 * @xrentity{XrPassthroughColorLutUpdateInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughColorLutUpdateInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughColorLutUpdateInfoMETA(const PassthroughColorLutDataMETA& data_,
                                    const void* next_ = nullptr)
      : Parent(StructureType::PassthroughColorLutUpdateInfoMETA, next_), data{data_} {}

  //! Default/empty constructor
  PassthroughColorLutUpdateInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughColorLutUpdateInfoMETA, next_), data{} {}

  //! Default copy constructor
  PassthroughColorLutUpdateInfoMETA(const PassthroughColorLutUpdateInfoMETA& rhs) = default;
  //! Default copy assignment
  PassthroughColorLutUpdateInfoMETA& operator=(const PassthroughColorLutUpdateInfoMETA& rhs) =
      default;
  //! Copy construct from raw
  PassthroughColorLutUpdateInfoMETA(const XrPassthroughColorLutUpdateInfoMETA& rhs)
      : PassthroughColorLutUpdateInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughColorLutUpdateInfoMETA& operator=(const XrPassthroughColorLutUpdateInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughColorLutUpdateInfoMETA&() const {
    return *reinterpret_cast<const XrPassthroughColorLutUpdateInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughColorLutUpdateInfoMETA&() {
    return *reinterpret_cast<XrPassthroughColorLutUpdateInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughColorLutUpdateInfoMETA
  XrPassthroughColorLutUpdateInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrPassthroughColorLutUpdateInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughColorLutUpdateInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughColorLutUpdateInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughColorLutUpdateInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughColorLutUpdateInfoMETA*>(this);
  }
  PassthroughColorLutDataMETA data;
};
static_assert(sizeof(XrPassthroughColorLutUpdateInfoMETA) ==
                  sizeof(PassthroughColorLutUpdateInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughColorLutUpdateInfoMETA pointer to const from
 * a PassthroughColorLutUpdateInfoMETA reference to const.
 * @relates PassthroughColorLutUpdateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorLutUpdateInfoMETA const* get(
    PassthroughColorLutUpdateInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * PassthroughColorLutUpdateInfoMETA as the address of a raw XrPassthroughColorLutUpdateInfoMETA
 * @relates PassthroughColorLutUpdateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorLutUpdateInfoMETA* put(
    PassthroughColorLutUpdateInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_passthrough_color_lut

#ifdef XR_META_passthrough_color_lut
/*!
 * C++ projection of XrPassthroughColorMapLutMETA
 *
 * Provided by the `XR_META_passthrough_color_lut` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorMapLutMETA>
 * @xrentity{XrPassthroughColorMapLutMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughColorMapLutMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughColorMapLutMETA(const PassthroughColorLutMETA& colorLut_, float weight_,
                             const void* next_ = nullptr)
      : Parent(StructureType::PassthroughColorMapLutMETA, next_),
        colorLut{colorLut_},
        weight{weight_} {}

  //! Default/empty constructor
  PassthroughColorMapLutMETA(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughColorMapLutMETA, next_), colorLut{}, weight{0.0f} {}

  //! Default copy constructor
  PassthroughColorMapLutMETA(const PassthroughColorMapLutMETA& rhs) = default;
  //! Default copy assignment
  PassthroughColorMapLutMETA& operator=(const PassthroughColorMapLutMETA& rhs) = default;
  //! Copy construct from raw
  PassthroughColorMapLutMETA(const XrPassthroughColorMapLutMETA& rhs)
      : PassthroughColorMapLutMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughColorMapLutMETA& operator=(const XrPassthroughColorMapLutMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughColorMapLutMETA&() const {
    return *reinterpret_cast<const XrPassthroughColorMapLutMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughColorMapLutMETA&() {
    return *reinterpret_cast<XrPassthroughColorMapLutMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughColorMapLutMETA
  XrPassthroughColorMapLutMETA const* get() const noexcept {
    return reinterpret_cast<XrPassthroughColorMapLutMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughColorMapLutMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughColorMapLutMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughColorMapLutMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughColorMapLutMETA*>(this);
  }
  PassthroughColorLutMETA colorLut;
  float weight;
};
static_assert(sizeof(XrPassthroughColorMapLutMETA) == sizeof(PassthroughColorMapLutMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughColorMapLutMETA pointer to const from a
 * PassthroughColorMapLutMETA reference to const.
 * @relates PassthroughColorMapLutMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorMapLutMETA const* get(
    PassthroughColorMapLutMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughColorMapLutMETA as
 * the address of a raw XrPassthroughColorMapLutMETA
 * @relates PassthroughColorMapLutMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorMapLutMETA* put(PassthroughColorMapLutMETA& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_passthrough_color_lut

#ifdef XR_META_passthrough_color_lut
/*!
 * C++ projection of XrPassthroughColorMapInterpolatedLutMETA
 *
 * Provided by the `XR_META_passthrough_color_lut` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorMapInterpolatedLutMETA>
 * @xrentity{XrPassthroughColorMapInterpolatedLutMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughColorMapInterpolatedLutMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughColorMapInterpolatedLutMETA(const PassthroughColorLutMETA& sourceColorLut_,
                                         const PassthroughColorLutMETA& targetColorLut_,
                                         float weight_, const void* next_ = nullptr)
      : Parent(StructureType::PassthroughColorMapInterpolatedLutMETA, next_),
        sourceColorLut{sourceColorLut_},
        targetColorLut{targetColorLut_},
        weight{weight_} {}

  //! Default/empty constructor
  PassthroughColorMapInterpolatedLutMETA(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughColorMapInterpolatedLutMETA, next_),
        sourceColorLut{},
        targetColorLut{},
        weight{0.0f} {}

  //! Default copy constructor
  PassthroughColorMapInterpolatedLutMETA(const PassthroughColorMapInterpolatedLutMETA& rhs) =
      default;
  //! Default copy assignment
  PassthroughColorMapInterpolatedLutMETA& operator=(
      const PassthroughColorMapInterpolatedLutMETA& rhs) = default;
  //! Copy construct from raw
  PassthroughColorMapInterpolatedLutMETA(const XrPassthroughColorMapInterpolatedLutMETA& rhs)
      : PassthroughColorMapInterpolatedLutMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughColorMapInterpolatedLutMETA& operator=(
      const XrPassthroughColorMapInterpolatedLutMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughColorMapInterpolatedLutMETA&() const {
    return *reinterpret_cast<const XrPassthroughColorMapInterpolatedLutMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughColorMapInterpolatedLutMETA&() {
    return *reinterpret_cast<XrPassthroughColorMapInterpolatedLutMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughColorMapInterpolatedLutMETA
  XrPassthroughColorMapInterpolatedLutMETA const* get() const noexcept {
    return reinterpret_cast<XrPassthroughColorMapInterpolatedLutMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughColorMapInterpolatedLutMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughColorMapInterpolatedLutMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughColorMapInterpolatedLutMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughColorMapInterpolatedLutMETA*>(this);
  }
  PassthroughColorLutMETA sourceColorLut;
  PassthroughColorLutMETA targetColorLut;
  float weight;
};
static_assert(sizeof(XrPassthroughColorMapInterpolatedLutMETA) ==
                  sizeof(PassthroughColorMapInterpolatedLutMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughColorMapInterpolatedLutMETA pointer to const
 * from a PassthroughColorMapInterpolatedLutMETA reference to const.
 * @relates PassthroughColorMapInterpolatedLutMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorMapInterpolatedLutMETA const* get(
    PassthroughColorMapInterpolatedLutMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * PassthroughColorMapInterpolatedLutMETA as the address of a raw
 * XrPassthroughColorMapInterpolatedLutMETA
 * @relates PassthroughColorMapInterpolatedLutMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorMapInterpolatedLutMETA* put(
    PassthroughColorMapInterpolatedLutMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_passthrough_color_lut

#ifdef XR_META_passthrough_color_lut
/*!
 * C++ projection of XrSystemPassthroughColorLutPropertiesMETA
 *
 * Provided by the `XR_META_passthrough_color_lut` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemPassthroughColorLutPropertiesMETA>
 * @xrentity{XrSystemPassthroughColorLutPropertiesMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemPassthroughColorLutPropertiesMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemPassthroughColorLutPropertiesMETA(void* next_ = nullptr)

      : Parent(StructureType::SystemPassthroughColorLutPropertiesMETA, next_) {}

  //! Default copy constructor
  SystemPassthroughColorLutPropertiesMETA(const SystemPassthroughColorLutPropertiesMETA& rhs) =
      default;
  //! Default copy assignment
  SystemPassthroughColorLutPropertiesMETA& operator=(
      const SystemPassthroughColorLutPropertiesMETA& rhs) = default;
  //! Copy construct from raw
  SystemPassthroughColorLutPropertiesMETA(const XrSystemPassthroughColorLutPropertiesMETA& rhs)
      : SystemPassthroughColorLutPropertiesMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemPassthroughColorLutPropertiesMETA& operator=(
      const XrSystemPassthroughColorLutPropertiesMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemPassthroughColorLutPropertiesMETA&() const {
    return *reinterpret_cast<const XrSystemPassthroughColorLutPropertiesMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemPassthroughColorLutPropertiesMETA&() {
    return *reinterpret_cast<XrSystemPassthroughColorLutPropertiesMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemPassthroughColorLutPropertiesMETA
  XrSystemPassthroughColorLutPropertiesMETA const* get() const noexcept {
    return reinterpret_cast<XrSystemPassthroughColorLutPropertiesMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemPassthroughColorLutPropertiesMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemPassthroughColorLutPropertiesMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemPassthroughColorLutPropertiesMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemPassthroughColorLutPropertiesMETA*>(this);
  }
  uint32_t maxColorLutResolution;
};
static_assert(sizeof(XrSystemPassthroughColorLutPropertiesMETA) ==
                  sizeof(SystemPassthroughColorLutPropertiesMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemPassthroughColorLutPropertiesMETA pointer to const
 * from a SystemPassthroughColorLutPropertiesMETA reference to const.
 * @relates SystemPassthroughColorLutPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemPassthroughColorLutPropertiesMETA const* get(
    SystemPassthroughColorLutPropertiesMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemPassthroughColorLutPropertiesMETA as the address of a raw
 * XrSystemPassthroughColorLutPropertiesMETA
 * @relates SystemPassthroughColorLutPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemPassthroughColorLutPropertiesMETA* put(
    SystemPassthroughColorLutPropertiesMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_passthrough_color_lut

#ifdef XR_META_spatial_entity_mesh
/*!
 * C++ projection of XrSpaceTriangleMeshGetInfoMETA
 *
 * Provided by the `XR_META_spatial_entity_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceTriangleMeshGetInfoMETA>
 * @xrentity{XrSpaceTriangleMeshGetInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceTriangleMeshGetInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SpaceTriangleMeshGetInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::SpaceTriangleMeshGetInfoMETA, next_) {}

  //! Default copy constructor
  SpaceTriangleMeshGetInfoMETA(const SpaceTriangleMeshGetInfoMETA& rhs) = default;
  //! Default copy assignment
  SpaceTriangleMeshGetInfoMETA& operator=(const SpaceTriangleMeshGetInfoMETA& rhs) = default;
  //! Copy construct from raw
  SpaceTriangleMeshGetInfoMETA(const XrSpaceTriangleMeshGetInfoMETA& rhs)
      : SpaceTriangleMeshGetInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpaceTriangleMeshGetInfoMETA& operator=(const XrSpaceTriangleMeshGetInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceTriangleMeshGetInfoMETA&() const {
    return *reinterpret_cast<const XrSpaceTriangleMeshGetInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceTriangleMeshGetInfoMETA&() {
    return *reinterpret_cast<XrSpaceTriangleMeshGetInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrSpaceTriangleMeshGetInfoMETA
  XrSpaceTriangleMeshGetInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrSpaceTriangleMeshGetInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpaceTriangleMeshGetInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceTriangleMeshGetInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceTriangleMeshGetInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceTriangleMeshGetInfoMETA*>(this);
  }
};
static_assert(sizeof(XrSpaceTriangleMeshGetInfoMETA) == sizeof(SpaceTriangleMeshGetInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceTriangleMeshGetInfoMETA pointer to const from a
 * SpaceTriangleMeshGetInfoMETA reference to const.
 * @relates SpaceTriangleMeshGetInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceTriangleMeshGetInfoMETA const* get(
    SpaceTriangleMeshGetInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceTriangleMeshGetInfoMETA
 * as the address of a raw XrSpaceTriangleMeshGetInfoMETA
 * @relates SpaceTriangleMeshGetInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceTriangleMeshGetInfoMETA* put(SpaceTriangleMeshGetInfoMETA& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_spatial_entity_mesh

#ifdef XR_META_spatial_entity_mesh
/*!
 * C++ projection of XrSpaceTriangleMeshMETA
 *
 * Provided by the `XR_META_spatial_entity_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceTriangleMeshMETA>
 * @xrentity{XrSpaceTriangleMeshMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceTriangleMeshMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpaceTriangleMeshMETA(void* next_ = nullptr)

      : Parent(StructureType::SpaceTriangleMeshMETA, next_) {}

  //! Default copy constructor
  SpaceTriangleMeshMETA(const SpaceTriangleMeshMETA& rhs) = default;
  //! Default copy assignment
  SpaceTriangleMeshMETA& operator=(const SpaceTriangleMeshMETA& rhs) = default;
  //! Copy construct from raw
  SpaceTriangleMeshMETA(const XrSpaceTriangleMeshMETA& rhs) : SpaceTriangleMeshMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpaceTriangleMeshMETA& operator=(const XrSpaceTriangleMeshMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceTriangleMeshMETA&() const {
    return *reinterpret_cast<const XrSpaceTriangleMeshMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceTriangleMeshMETA&() { return *reinterpret_cast<XrSpaceTriangleMeshMETA*>(this); }

  //! Accessor for this as the address of a raw XrSpaceTriangleMeshMETA
  XrSpaceTriangleMeshMETA const* get() const noexcept {
    return reinterpret_cast<XrSpaceTriangleMeshMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpaceTriangleMeshMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceTriangleMeshMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceTriangleMeshMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceTriangleMeshMETA*>(this);
  }
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  Vector3f* vertices;
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  uint32_t* indices;
};
static_assert(sizeof(XrSpaceTriangleMeshMETA) == sizeof(SpaceTriangleMeshMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceTriangleMeshMETA pointer to const from a
 * SpaceTriangleMeshMETA reference to const.
 * @relates SpaceTriangleMeshMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceTriangleMeshMETA const* get(SpaceTriangleMeshMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceTriangleMeshMETA as the
 * address of a raw XrSpaceTriangleMeshMETA
 * @relates SpaceTriangleMeshMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceTriangleMeshMETA* put(SpaceTriangleMeshMETA& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_spatial_entity_mesh

#ifdef XR_META_body_tracking_full_body
/*!
 * C++ projection of XrSystemPropertiesBodyTrackingFullBodyMETA
 *
 * Provided by the `XR_META_body_tracking_full_body` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemPropertiesBodyTrackingFullBodyMETA>
 * @xrentity{XrSystemPropertiesBodyTrackingFullBodyMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemPropertiesBodyTrackingFullBodyMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemPropertiesBodyTrackingFullBodyMETA(void* next_ = nullptr)

      : Parent(StructureType::SystemPropertiesBodyTrackingFullBodyMETA, next_) {}

  //! Default copy constructor
  SystemPropertiesBodyTrackingFullBodyMETA(const SystemPropertiesBodyTrackingFullBodyMETA& rhs) =
      default;
  //! Default copy assignment
  SystemPropertiesBodyTrackingFullBodyMETA& operator=(
      const SystemPropertiesBodyTrackingFullBodyMETA& rhs) = default;
  //! Copy construct from raw
  SystemPropertiesBodyTrackingFullBodyMETA(const XrSystemPropertiesBodyTrackingFullBodyMETA& rhs)
      : SystemPropertiesBodyTrackingFullBodyMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemPropertiesBodyTrackingFullBodyMETA& operator=(
      const XrSystemPropertiesBodyTrackingFullBodyMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemPropertiesBodyTrackingFullBodyMETA&() const {
    return *reinterpret_cast<const XrSystemPropertiesBodyTrackingFullBodyMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemPropertiesBodyTrackingFullBodyMETA&() {
    return *reinterpret_cast<XrSystemPropertiesBodyTrackingFullBodyMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemPropertiesBodyTrackingFullBodyMETA
  XrSystemPropertiesBodyTrackingFullBodyMETA const* get() const noexcept {
    return reinterpret_cast<XrSystemPropertiesBodyTrackingFullBodyMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemPropertiesBodyTrackingFullBodyMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemPropertiesBodyTrackingFullBodyMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemPropertiesBodyTrackingFullBodyMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemPropertiesBodyTrackingFullBodyMETA*>(this);
  }
  Bool32 supportsFullBodyTracking;
};
static_assert(sizeof(XrSystemPropertiesBodyTrackingFullBodyMETA) ==
                  sizeof(SystemPropertiesBodyTrackingFullBodyMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemPropertiesBodyTrackingFullBodyMETA pointer to
 * const from a SystemPropertiesBodyTrackingFullBodyMETA reference to const.
 * @relates SystemPropertiesBodyTrackingFullBodyMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemPropertiesBodyTrackingFullBodyMETA const* get(
    SystemPropertiesBodyTrackingFullBodyMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemPropertiesBodyTrackingFullBodyMETA as the address of a raw
 * XrSystemPropertiesBodyTrackingFullBodyMETA
 * @relates SystemPropertiesBodyTrackingFullBodyMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemPropertiesBodyTrackingFullBodyMETA* put(
    SystemPropertiesBodyTrackingFullBodyMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_body_tracking_full_body

#ifdef XR_META_passthrough_layer_resumed_event
/*!
 * C++ projection of XrEventDataPassthroughLayerResumedMETA
 *
 * Provided by the `XR_META_passthrough_layer_resumed_event` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataPassthroughLayerResumedMETA>
 * @xrentity{XrEventDataPassthroughLayerResumedMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataPassthroughLayerResumedMETA : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataPassthroughLayerResumedMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataPassthroughLayerResumedMETA, next_) {}

  //! Default copy constructor
  EventDataPassthroughLayerResumedMETA(const EventDataPassthroughLayerResumedMETA& rhs) = default;
  //! Default copy assignment
  EventDataPassthroughLayerResumedMETA& operator=(const EventDataPassthroughLayerResumedMETA& rhs) =
      default;
  //! Copy construct from raw
  EventDataPassthroughLayerResumedMETA(const XrEventDataPassthroughLayerResumedMETA& rhs)
      : EventDataPassthroughLayerResumedMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataPassthroughLayerResumedMETA& operator=(
      const XrEventDataPassthroughLayerResumedMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataPassthroughLayerResumedMETA&() const {
    return *reinterpret_cast<const XrEventDataPassthroughLayerResumedMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataPassthroughLayerResumedMETA&() {
    return *reinterpret_cast<XrEventDataPassthroughLayerResumedMETA*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataPassthroughLayerResumedMETA
  XrEventDataPassthroughLayerResumedMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataPassthroughLayerResumedMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataPassthroughLayerResumedMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataPassthroughLayerResumedMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataPassthroughLayerResumedMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataPassthroughLayerResumedMETA*>(this);
  }
  PassthroughLayerFB layer;
};
static_assert(sizeof(XrEventDataPassthroughLayerResumedMETA) ==
                  sizeof(EventDataPassthroughLayerResumedMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataPassthroughLayerResumedMETA pointer to const
 * from a EventDataPassthroughLayerResumedMETA reference to const.
 * @relates EventDataPassthroughLayerResumedMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataPassthroughLayerResumedMETA const* get(
    EventDataPassthroughLayerResumedMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataPassthroughLayerResumedMETA as the address of a raw
 * XrEventDataPassthroughLayerResumedMETA
 * @relates EventDataPassthroughLayerResumedMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataPassthroughLayerResumedMETA* put(
    EventDataPassthroughLayerResumedMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataPassthroughLayerResumedMETA as a
 * raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataPassthroughLayerResumedMETA
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataPassthroughLayerResumedMETA const& h) {
  return h.get_base();
}
#endif  // XR_META_passthrough_layer_resumed_event

#ifdef XR_FB_face_tracking2
/*!
 * C++ projection of XrSystemFaceTrackingProperties2FB
 *
 * Provided by the `XR_FB_face_tracking2` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemFaceTrackingProperties2FB>
 * @xrentity{XrSystemFaceTrackingProperties2FB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemFaceTrackingProperties2FB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemFaceTrackingProperties2FB(void* next_ = nullptr)

      : Parent(StructureType::SystemFaceTrackingProperties2FB, next_) {}

  //! Default copy constructor
  SystemFaceTrackingProperties2FB(const SystemFaceTrackingProperties2FB& rhs) = default;
  //! Default copy assignment
  SystemFaceTrackingProperties2FB& operator=(const SystemFaceTrackingProperties2FB& rhs) = default;
  //! Copy construct from raw
  SystemFaceTrackingProperties2FB(const XrSystemFaceTrackingProperties2FB& rhs)
      : SystemFaceTrackingProperties2FB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemFaceTrackingProperties2FB& operator=(const XrSystemFaceTrackingProperties2FB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemFaceTrackingProperties2FB&() const {
    return *reinterpret_cast<const XrSystemFaceTrackingProperties2FB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemFaceTrackingProperties2FB&() {
    return *reinterpret_cast<XrSystemFaceTrackingProperties2FB*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemFaceTrackingProperties2FB
  XrSystemFaceTrackingProperties2FB const* get() const noexcept {
    return reinterpret_cast<XrSystemFaceTrackingProperties2FB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemFaceTrackingProperties2FB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemFaceTrackingProperties2FB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemFaceTrackingProperties2FB{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemFaceTrackingProperties2FB*>(this);
  }
  Bool32 supportsVisualFaceTracking;
  Bool32 supportsAudioFaceTracking;
};
static_assert(sizeof(XrSystemFaceTrackingProperties2FB) == sizeof(SystemFaceTrackingProperties2FB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemFaceTrackingProperties2FB pointer to const from a
 * SystemFaceTrackingProperties2FB reference to const.
 * @relates SystemFaceTrackingProperties2FB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFaceTrackingProperties2FB const* get(
    SystemFaceTrackingProperties2FB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemFaceTrackingProperties2FB as the address of a raw XrSystemFaceTrackingProperties2FB
 * @relates SystemFaceTrackingProperties2FB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFaceTrackingProperties2FB* put(SystemFaceTrackingProperties2FB& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_face_tracking2

#ifdef XR_FB_face_tracking2
/*!
 * C++ projection of XrFaceTrackerCreateInfo2FB
 *
 * Provided by the `XR_FB_face_tracking2` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceTrackerCreateInfo2FB>
 * @xrentity{XrFaceTrackerCreateInfo2FB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FaceTrackerCreateInfo2FB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FaceTrackerCreateInfo2FB(const FaceExpressionSet2FB& faceExpressionSet_,
                           uint32_t requestedDataSourceCount_,
                           FaceTrackingDataSource2FB* requestedDataSources_,
                           const void* next_ = nullptr)
      : Parent(StructureType::FaceTrackerCreateInfo2FB, next_),
        faceExpressionSet{faceExpressionSet_},
        requestedDataSourceCount{requestedDataSourceCount_},
        requestedDataSources{requestedDataSources_} {}

  //! Default/empty constructor
  FaceTrackerCreateInfo2FB(const void* next_ = nullptr)

      : Parent(StructureType::FaceTrackerCreateInfo2FB, next_),
        faceExpressionSet{},
        requestedDataSourceCount{0},
        requestedDataSources{nullptr} {}

  //! Default copy constructor
  FaceTrackerCreateInfo2FB(const FaceTrackerCreateInfo2FB& rhs) = default;
  //! Default copy assignment
  FaceTrackerCreateInfo2FB& operator=(const FaceTrackerCreateInfo2FB& rhs) = default;
  //! Copy construct from raw
  FaceTrackerCreateInfo2FB(const XrFaceTrackerCreateInfo2FB& rhs) : FaceTrackerCreateInfo2FB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FaceTrackerCreateInfo2FB& operator=(const XrFaceTrackerCreateInfo2FB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFaceTrackerCreateInfo2FB&() const {
    return *reinterpret_cast<const XrFaceTrackerCreateInfo2FB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFaceTrackerCreateInfo2FB&() {
    return *reinterpret_cast<XrFaceTrackerCreateInfo2FB*>(this);
  }

  //! Accessor for this as the address of a raw XrFaceTrackerCreateInfo2FB
  XrFaceTrackerCreateInfo2FB const* get() const noexcept {
    return reinterpret_cast<XrFaceTrackerCreateInfo2FB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFaceTrackerCreateInfo2FB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFaceTrackerCreateInfo2FB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FaceTrackerCreateInfo2FB{};
      next = oldNext;
    }
    return reinterpret_cast<XrFaceTrackerCreateInfo2FB*>(this);
  }
  FaceExpressionSet2FB faceExpressionSet;
  uint32_t requestedDataSourceCount;
  FaceTrackingDataSource2FB* requestedDataSources;
};
static_assert(sizeof(XrFaceTrackerCreateInfo2FB) == sizeof(FaceTrackerCreateInfo2FB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFaceTrackerCreateInfo2FB pointer to const from a
 * FaceTrackerCreateInfo2FB reference to const.
 * @relates FaceTrackerCreateInfo2FB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceTrackerCreateInfo2FB const* get(FaceTrackerCreateInfo2FB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FaceTrackerCreateInfo2FB as
 * the address of a raw XrFaceTrackerCreateInfo2FB
 * @relates FaceTrackerCreateInfo2FB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceTrackerCreateInfo2FB* put(FaceTrackerCreateInfo2FB& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_face_tracking2

#ifdef XR_FB_face_tracking2
/*!
 * C++ projection of XrFaceExpressionInfo2FB
 *
 * Provided by the `XR_FB_face_tracking2` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionInfo2FB>
 * @xrentity{XrFaceExpressionInfo2FB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FaceExpressionInfo2FB : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FaceExpressionInfo2FB(const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::FaceExpressionInfo2FB, next_), time{time_} {}

  //! Default/empty constructor
  FaceExpressionInfo2FB(const void* next_ = nullptr)

      : Parent(StructureType::FaceExpressionInfo2FB, next_), time{} {}

  //! Default copy constructor
  FaceExpressionInfo2FB(const FaceExpressionInfo2FB& rhs) = default;
  //! Default copy assignment
  FaceExpressionInfo2FB& operator=(const FaceExpressionInfo2FB& rhs) = default;
  //! Copy construct from raw
  FaceExpressionInfo2FB(const XrFaceExpressionInfo2FB& rhs) : FaceExpressionInfo2FB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FaceExpressionInfo2FB& operator=(const XrFaceExpressionInfo2FB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFaceExpressionInfo2FB&() const {
    return *reinterpret_cast<const XrFaceExpressionInfo2FB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFaceExpressionInfo2FB&() { return *reinterpret_cast<XrFaceExpressionInfo2FB*>(this); }

  //! Accessor for this as the address of a raw XrFaceExpressionInfo2FB
  XrFaceExpressionInfo2FB const* get() const noexcept {
    return reinterpret_cast<XrFaceExpressionInfo2FB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFaceExpressionInfo2FB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFaceExpressionInfo2FB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FaceExpressionInfo2FB{};
      next = oldNext;
    }
    return reinterpret_cast<XrFaceExpressionInfo2FB*>(this);
  }
  Time time;
};
static_assert(sizeof(XrFaceExpressionInfo2FB) == sizeof(FaceExpressionInfo2FB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFaceExpressionInfo2FB pointer to const from a
 * FaceExpressionInfo2FB reference to const.
 * @relates FaceExpressionInfo2FB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceExpressionInfo2FB const* get(FaceExpressionInfo2FB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FaceExpressionInfo2FB as the
 * address of a raw XrFaceExpressionInfo2FB
 * @relates FaceExpressionInfo2FB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceExpressionInfo2FB* put(FaceExpressionInfo2FB& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_face_tracking2

#ifdef XR_FB_face_tracking2
/*!
 * C++ projection of XrFaceExpressionWeights2FB
 *
 * Provided by the `XR_FB_face_tracking2` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceExpressionWeights2FB>
 * @xrentity{XrFaceExpressionWeights2FB}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FaceExpressionWeights2FB : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FaceExpressionWeights2FB(void* next_ = nullptr)

      : Parent(StructureType::FaceExpressionWeights2FB, next_) {}

  //! Default copy constructor
  FaceExpressionWeights2FB(const FaceExpressionWeights2FB& rhs) = default;
  //! Default copy assignment
  FaceExpressionWeights2FB& operator=(const FaceExpressionWeights2FB& rhs) = default;
  //! Copy construct from raw
  FaceExpressionWeights2FB(const XrFaceExpressionWeights2FB& rhs) : FaceExpressionWeights2FB() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FaceExpressionWeights2FB& operator=(const XrFaceExpressionWeights2FB& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFaceExpressionWeights2FB&() const {
    return *reinterpret_cast<const XrFaceExpressionWeights2FB*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFaceExpressionWeights2FB&() {
    return *reinterpret_cast<XrFaceExpressionWeights2FB*>(this);
  }

  //! Accessor for this as the address of a raw XrFaceExpressionWeights2FB
  XrFaceExpressionWeights2FB const* get() const noexcept {
    return reinterpret_cast<XrFaceExpressionWeights2FB const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFaceExpressionWeights2FB.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFaceExpressionWeights2FB* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FaceExpressionWeights2FB{};
      next = oldNext;
    }
    return reinterpret_cast<XrFaceExpressionWeights2FB*>(this);
  }
  uint32_t weightCount;
  float* weights;
  uint32_t confidenceCount;
  float* confidences;
  Bool32 isValid;
  Bool32 isEyeFollowingBlendshapesValid;
  FaceTrackingDataSource2FB dataSource;
  Time time;
};
static_assert(sizeof(XrFaceExpressionWeights2FB) == sizeof(FaceExpressionWeights2FB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFaceExpressionWeights2FB pointer to const from a
 * FaceExpressionWeights2FB reference to const.
 * @relates FaceExpressionWeights2FB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceExpressionWeights2FB const* get(FaceExpressionWeights2FB const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FaceExpressionWeights2FB as
 * the address of a raw XrFaceExpressionWeights2FB
 * @relates FaceExpressionWeights2FB
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFaceExpressionWeights2FB* put(FaceExpressionWeights2FB& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_FB_face_tracking2

#ifdef XR_META_spatial_entity_sharing
/*!
 * C++ projection of XrSystemSpatialEntitySharingPropertiesMETA
 *
 * Provided by the `XR_META_spatial_entity_sharing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpatialEntitySharingPropertiesMETA>
 * @xrentity{XrSystemSpatialEntitySharingPropertiesMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemSpatialEntitySharingPropertiesMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemSpatialEntitySharingPropertiesMETA(void* next_ = nullptr)

      : Parent(StructureType::SystemSpatialEntitySharingPropertiesMETA, next_) {}

  //! Default copy constructor
  SystemSpatialEntitySharingPropertiesMETA(const SystemSpatialEntitySharingPropertiesMETA& rhs) =
      default;
  //! Default copy assignment
  SystemSpatialEntitySharingPropertiesMETA& operator=(
      const SystemSpatialEntitySharingPropertiesMETA& rhs) = default;
  //! Copy construct from raw
  SystemSpatialEntitySharingPropertiesMETA(const XrSystemSpatialEntitySharingPropertiesMETA& rhs)
      : SystemSpatialEntitySharingPropertiesMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemSpatialEntitySharingPropertiesMETA& operator=(
      const XrSystemSpatialEntitySharingPropertiesMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemSpatialEntitySharingPropertiesMETA&() const {
    return *reinterpret_cast<const XrSystemSpatialEntitySharingPropertiesMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemSpatialEntitySharingPropertiesMETA&() {
    return *reinterpret_cast<XrSystemSpatialEntitySharingPropertiesMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemSpatialEntitySharingPropertiesMETA
  XrSystemSpatialEntitySharingPropertiesMETA const* get() const noexcept {
    return reinterpret_cast<XrSystemSpatialEntitySharingPropertiesMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemSpatialEntitySharingPropertiesMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemSpatialEntitySharingPropertiesMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemSpatialEntitySharingPropertiesMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemSpatialEntitySharingPropertiesMETA*>(this);
  }
  Bool32 supportsSpatialEntitySharing;
};
static_assert(sizeof(XrSystemSpatialEntitySharingPropertiesMETA) ==
                  sizeof(SystemSpatialEntitySharingPropertiesMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemSpatialEntitySharingPropertiesMETA pointer to
 * const from a SystemSpatialEntitySharingPropertiesMETA reference to const.
 * @relates SystemSpatialEntitySharingPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialEntitySharingPropertiesMETA const* get(
    SystemSpatialEntitySharingPropertiesMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemSpatialEntitySharingPropertiesMETA as the address of a raw
 * XrSystemSpatialEntitySharingPropertiesMETA
 * @relates SystemSpatialEntitySharingPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialEntitySharingPropertiesMETA* put(
    SystemSpatialEntitySharingPropertiesMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_spatial_entity_sharing

#ifdef XR_META_spatial_entity_sharing
/*!
 * C++ projection of XrShareSpacesRecipientBaseHeaderMETA
 *
 * Provided by the `XR_META_spatial_entity_sharing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrShareSpacesRecipientBaseHeaderMETA>
 * @xrentity{XrShareSpacesRecipientBaseHeaderMETA}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS ShareSpacesRecipientBaseHeaderMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  ShareSpacesRecipientBaseHeaderMETA(StructureType type_, const void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrShareSpacesRecipientBaseHeaderMETA&() const {
    return *reinterpret_cast<const XrShareSpacesRecipientBaseHeaderMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrShareSpacesRecipientBaseHeaderMETA&() {
    return *reinterpret_cast<XrShareSpacesRecipientBaseHeaderMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrShareSpacesRecipientBaseHeaderMETA
  XrShareSpacesRecipientBaseHeaderMETA const* get() const noexcept {
    return reinterpret_cast<XrShareSpacesRecipientBaseHeaderMETA const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw XrShareSpacesRecipientBaseHeaderMETA.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrShareSpacesRecipientBaseHeaderMETA* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrShareSpacesRecipientBaseHeaderMETA*>(this);
  }
};
static_assert(sizeof(XrShareSpacesRecipientBaseHeaderMETA) ==
                  sizeof(ShareSpacesRecipientBaseHeaderMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrShareSpacesRecipientBaseHeaderMETA pointer to const from
 * a ShareSpacesRecipientBaseHeaderMETA reference to const.
 * @relates ShareSpacesRecipientBaseHeaderMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrShareSpacesRecipientBaseHeaderMETA const* get(
    ShareSpacesRecipientBaseHeaderMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ShareSpacesRecipientBaseHeaderMETA as the address of a raw XrShareSpacesRecipientBaseHeaderMETA
 * @relates ShareSpacesRecipientBaseHeaderMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrShareSpacesRecipientBaseHeaderMETA* put(
    ShareSpacesRecipientBaseHeaderMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_spatial_entity_sharing

#ifdef XR_META_spatial_entity_sharing
/*!
 * C++ projection of XrShareSpacesInfoMETA
 *
 * Provided by the `XR_META_spatial_entity_sharing` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrShareSpacesInfoMETA>
 * @xrentity{XrShareSpacesInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ShareSpacesInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ShareSpacesInfoMETA(uint32_t spaceCount_, Space* spaces_,
                      const ShareSpacesRecipientBaseHeaderMETA* recipientInfo_,
                      const void* next_ = nullptr)
      : Parent(StructureType::ShareSpacesInfoMETA, next_),
        spaceCount{spaceCount_},
        spaces{spaces_},
        recipientInfo{recipientInfo_} {}

  //! Default/empty constructor
  ShareSpacesInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::ShareSpacesInfoMETA, next_),
        spaceCount{0},
        spaces{nullptr},
        recipientInfo{nullptr} {}

  //! Default copy constructor
  ShareSpacesInfoMETA(const ShareSpacesInfoMETA& rhs) = default;
  //! Default copy assignment
  ShareSpacesInfoMETA& operator=(const ShareSpacesInfoMETA& rhs) = default;
  //! Copy construct from raw
  ShareSpacesInfoMETA(const XrShareSpacesInfoMETA& rhs) : ShareSpacesInfoMETA() { *put() = rhs; }
  //! Copy assign from raw
  ShareSpacesInfoMETA& operator=(const XrShareSpacesInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrShareSpacesInfoMETA&() const {
    return *reinterpret_cast<const XrShareSpacesInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrShareSpacesInfoMETA&() { return *reinterpret_cast<XrShareSpacesInfoMETA*>(this); }

  //! Accessor for this as the address of a raw XrShareSpacesInfoMETA
  XrShareSpacesInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrShareSpacesInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrShareSpacesInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrShareSpacesInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ShareSpacesInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrShareSpacesInfoMETA*>(this);
  }
  uint32_t spaceCount;
  Space* spaces;
  const ShareSpacesRecipientBaseHeaderMETA* recipientInfo;
};
static_assert(sizeof(XrShareSpacesInfoMETA) == sizeof(ShareSpacesInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrShareSpacesInfoMETA pointer to const from a
 * ShareSpacesInfoMETA reference to const.
 * @relates ShareSpacesInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrShareSpacesInfoMETA const* get(ShareSpacesInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ShareSpacesInfoMETA as the
 * address of a raw XrShareSpacesInfoMETA
 * @relates ShareSpacesInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrShareSpacesInfoMETA* put(ShareSpacesInfoMETA& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_spatial_entity_sharing

#ifdef XR_META_spatial_entity_sharing
/*!
 * C++ projection of XrEventDataShareSpacesCompleteMETA
 *
 * Provided by the `XR_META_spatial_entity_sharing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataShareSpacesCompleteMETA>
 * @xrentity{XrEventDataShareSpacesCompleteMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataShareSpacesCompleteMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataShareSpacesCompleteMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataShareSpacesCompleteMETA, next_) {}

  //! Default copy constructor
  EventDataShareSpacesCompleteMETA(const EventDataShareSpacesCompleteMETA& rhs) = default;
  //! Default copy assignment
  EventDataShareSpacesCompleteMETA& operator=(const EventDataShareSpacesCompleteMETA& rhs) =
      default;
  //! Copy construct from raw
  EventDataShareSpacesCompleteMETA(const XrEventDataShareSpacesCompleteMETA& rhs)
      : EventDataShareSpacesCompleteMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataShareSpacesCompleteMETA& operator=(const XrEventDataShareSpacesCompleteMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataShareSpacesCompleteMETA&() const {
    return *reinterpret_cast<const XrEventDataShareSpacesCompleteMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataShareSpacesCompleteMETA&() {
    return *reinterpret_cast<XrEventDataShareSpacesCompleteMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataShareSpacesCompleteMETA
  XrEventDataShareSpacesCompleteMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataShareSpacesCompleteMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataShareSpacesCompleteMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataShareSpacesCompleteMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataShareSpacesCompleteMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataShareSpacesCompleteMETA*>(this);
  }
  AsyncRequestIdFB requestId;
  Result result;
};
static_assert(sizeof(XrEventDataShareSpacesCompleteMETA) ==
                  sizeof(EventDataShareSpacesCompleteMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataShareSpacesCompleteMETA pointer to const from a
 * EventDataShareSpacesCompleteMETA reference to const.
 * @relates EventDataShareSpacesCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataShareSpacesCompleteMETA const* get(
    EventDataShareSpacesCompleteMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataShareSpacesCompleteMETA as the address of a raw XrEventDataShareSpacesCompleteMETA
 * @relates EventDataShareSpacesCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataShareSpacesCompleteMETA* put(
    EventDataShareSpacesCompleteMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_spatial_entity_sharing

#ifdef XR_META_environment_depth
/*!
 * C++ projection of XrEnvironmentDepthProviderCreateInfoMETA
 *
 * Provided by the `XR_META_environment_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEnvironmentDepthProviderCreateInfoMETA>
 * @xrentity{XrEnvironmentDepthProviderCreateInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EnvironmentDepthProviderCreateInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  EnvironmentDepthProviderCreateInfoMETA(
      const EnvironmentDepthProviderCreateFlagsMETA& createFlags_, const void* next_ = nullptr)
      : Parent(StructureType::EnvironmentDepthProviderCreateInfoMETA, next_),
        createFlags{createFlags_} {}

  //! Default/empty constructor
  EnvironmentDepthProviderCreateInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::EnvironmentDepthProviderCreateInfoMETA, next_), createFlags{} {}

  //! Default copy constructor
  EnvironmentDepthProviderCreateInfoMETA(const EnvironmentDepthProviderCreateInfoMETA& rhs) =
      default;
  //! Default copy assignment
  EnvironmentDepthProviderCreateInfoMETA& operator=(
      const EnvironmentDepthProviderCreateInfoMETA& rhs) = default;
  //! Copy construct from raw
  EnvironmentDepthProviderCreateInfoMETA(const XrEnvironmentDepthProviderCreateInfoMETA& rhs)
      : EnvironmentDepthProviderCreateInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EnvironmentDepthProviderCreateInfoMETA& operator=(
      const XrEnvironmentDepthProviderCreateInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEnvironmentDepthProviderCreateInfoMETA&() const {
    return *reinterpret_cast<const XrEnvironmentDepthProviderCreateInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEnvironmentDepthProviderCreateInfoMETA&() {
    return *reinterpret_cast<XrEnvironmentDepthProviderCreateInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEnvironmentDepthProviderCreateInfoMETA
  XrEnvironmentDepthProviderCreateInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrEnvironmentDepthProviderCreateInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEnvironmentDepthProviderCreateInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEnvironmentDepthProviderCreateInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EnvironmentDepthProviderCreateInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEnvironmentDepthProviderCreateInfoMETA*>(this);
  }
  EnvironmentDepthProviderCreateFlagsMETA createFlags;
};
static_assert(sizeof(XrEnvironmentDepthProviderCreateInfoMETA) ==
                  sizeof(EnvironmentDepthProviderCreateInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEnvironmentDepthProviderCreateInfoMETA pointer to const
 * from a EnvironmentDepthProviderCreateInfoMETA reference to const.
 * @relates EnvironmentDepthProviderCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthProviderCreateInfoMETA const* get(
    EnvironmentDepthProviderCreateInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EnvironmentDepthProviderCreateInfoMETA as the address of a raw
 * XrEnvironmentDepthProviderCreateInfoMETA
 * @relates EnvironmentDepthProviderCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthProviderCreateInfoMETA* put(
    EnvironmentDepthProviderCreateInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_environment_depth

#ifdef XR_META_environment_depth
/*!
 * C++ projection of XrEnvironmentDepthSwapchainCreateInfoMETA
 *
 * Provided by the `XR_META_environment_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEnvironmentDepthSwapchainCreateInfoMETA>
 * @xrentity{XrEnvironmentDepthSwapchainCreateInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EnvironmentDepthSwapchainCreateInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  EnvironmentDepthSwapchainCreateInfoMETA(
      const EnvironmentDepthSwapchainCreateFlagsMETA& createFlags_, const void* next_ = nullptr)
      : Parent(StructureType::EnvironmentDepthSwapchainCreateInfoMETA, next_),
        createFlags{createFlags_} {}

  //! Default/empty constructor
  EnvironmentDepthSwapchainCreateInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::EnvironmentDepthSwapchainCreateInfoMETA, next_), createFlags{} {}

  //! Default copy constructor
  EnvironmentDepthSwapchainCreateInfoMETA(const EnvironmentDepthSwapchainCreateInfoMETA& rhs) =
      default;
  //! Default copy assignment
  EnvironmentDepthSwapchainCreateInfoMETA& operator=(
      const EnvironmentDepthSwapchainCreateInfoMETA& rhs) = default;
  //! Copy construct from raw
  EnvironmentDepthSwapchainCreateInfoMETA(const XrEnvironmentDepthSwapchainCreateInfoMETA& rhs)
      : EnvironmentDepthSwapchainCreateInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EnvironmentDepthSwapchainCreateInfoMETA& operator=(
      const XrEnvironmentDepthSwapchainCreateInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEnvironmentDepthSwapchainCreateInfoMETA&() const {
    return *reinterpret_cast<const XrEnvironmentDepthSwapchainCreateInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEnvironmentDepthSwapchainCreateInfoMETA&() {
    return *reinterpret_cast<XrEnvironmentDepthSwapchainCreateInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEnvironmentDepthSwapchainCreateInfoMETA
  XrEnvironmentDepthSwapchainCreateInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrEnvironmentDepthSwapchainCreateInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEnvironmentDepthSwapchainCreateInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEnvironmentDepthSwapchainCreateInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EnvironmentDepthSwapchainCreateInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEnvironmentDepthSwapchainCreateInfoMETA*>(this);
  }
  EnvironmentDepthSwapchainCreateFlagsMETA createFlags;
};
static_assert(sizeof(XrEnvironmentDepthSwapchainCreateInfoMETA) ==
                  sizeof(EnvironmentDepthSwapchainCreateInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEnvironmentDepthSwapchainCreateInfoMETA pointer to const
 * from a EnvironmentDepthSwapchainCreateInfoMETA reference to const.
 * @relates EnvironmentDepthSwapchainCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthSwapchainCreateInfoMETA const* get(
    EnvironmentDepthSwapchainCreateInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EnvironmentDepthSwapchainCreateInfoMETA as the address of a raw
 * XrEnvironmentDepthSwapchainCreateInfoMETA
 * @relates EnvironmentDepthSwapchainCreateInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthSwapchainCreateInfoMETA* put(
    EnvironmentDepthSwapchainCreateInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_environment_depth

#ifdef XR_META_environment_depth
/*!
 * C++ projection of XrEnvironmentDepthSwapchainStateMETA
 *
 * Provided by the `XR_META_environment_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEnvironmentDepthSwapchainStateMETA>
 * @xrentity{XrEnvironmentDepthSwapchainStateMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EnvironmentDepthSwapchainStateMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EnvironmentDepthSwapchainStateMETA(void* next_ = nullptr)

      : Parent(StructureType::EnvironmentDepthSwapchainStateMETA, next_) {}

  //! Default copy constructor
  EnvironmentDepthSwapchainStateMETA(const EnvironmentDepthSwapchainStateMETA& rhs) = default;
  //! Default copy assignment
  EnvironmentDepthSwapchainStateMETA& operator=(const EnvironmentDepthSwapchainStateMETA& rhs) =
      default;
  //! Copy construct from raw
  EnvironmentDepthSwapchainStateMETA(const XrEnvironmentDepthSwapchainStateMETA& rhs)
      : EnvironmentDepthSwapchainStateMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EnvironmentDepthSwapchainStateMETA& operator=(const XrEnvironmentDepthSwapchainStateMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEnvironmentDepthSwapchainStateMETA&() const {
    return *reinterpret_cast<const XrEnvironmentDepthSwapchainStateMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEnvironmentDepthSwapchainStateMETA&() {
    return *reinterpret_cast<XrEnvironmentDepthSwapchainStateMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEnvironmentDepthSwapchainStateMETA
  XrEnvironmentDepthSwapchainStateMETA const* get() const noexcept {
    return reinterpret_cast<XrEnvironmentDepthSwapchainStateMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEnvironmentDepthSwapchainStateMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEnvironmentDepthSwapchainStateMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EnvironmentDepthSwapchainStateMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEnvironmentDepthSwapchainStateMETA*>(this);
  }
  uint32_t width;
  uint32_t height;
};
static_assert(sizeof(XrEnvironmentDepthSwapchainStateMETA) ==
                  sizeof(EnvironmentDepthSwapchainStateMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEnvironmentDepthSwapchainStateMETA pointer to const from
 * a EnvironmentDepthSwapchainStateMETA reference to const.
 * @relates EnvironmentDepthSwapchainStateMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthSwapchainStateMETA const* get(
    EnvironmentDepthSwapchainStateMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EnvironmentDepthSwapchainStateMETA as the address of a raw XrEnvironmentDepthSwapchainStateMETA
 * @relates EnvironmentDepthSwapchainStateMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthSwapchainStateMETA* put(
    EnvironmentDepthSwapchainStateMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_environment_depth

#ifdef XR_META_environment_depth
/*!
 * C++ projection of XrEnvironmentDepthImageAcquireInfoMETA
 *
 * Provided by the `XR_META_environment_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEnvironmentDepthImageAcquireInfoMETA>
 * @xrentity{XrEnvironmentDepthImageAcquireInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EnvironmentDepthImageAcquireInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  EnvironmentDepthImageAcquireInfoMETA(const Space& space_, const Time& displayTime_,
                                       const void* next_ = nullptr)
      : Parent(StructureType::EnvironmentDepthImageAcquireInfoMETA, next_),
        space{space_},
        displayTime{displayTime_} {}

  //! Default/empty constructor
  EnvironmentDepthImageAcquireInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::EnvironmentDepthImageAcquireInfoMETA, next_),
        space{},
        displayTime{} {}

  //! Default copy constructor
  EnvironmentDepthImageAcquireInfoMETA(const EnvironmentDepthImageAcquireInfoMETA& rhs) = default;
  //! Default copy assignment
  EnvironmentDepthImageAcquireInfoMETA& operator=(const EnvironmentDepthImageAcquireInfoMETA& rhs) =
      default;
  //! Copy construct from raw
  EnvironmentDepthImageAcquireInfoMETA(const XrEnvironmentDepthImageAcquireInfoMETA& rhs)
      : EnvironmentDepthImageAcquireInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EnvironmentDepthImageAcquireInfoMETA& operator=(
      const XrEnvironmentDepthImageAcquireInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEnvironmentDepthImageAcquireInfoMETA&() const {
    return *reinterpret_cast<const XrEnvironmentDepthImageAcquireInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEnvironmentDepthImageAcquireInfoMETA&() {
    return *reinterpret_cast<XrEnvironmentDepthImageAcquireInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEnvironmentDepthImageAcquireInfoMETA
  XrEnvironmentDepthImageAcquireInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrEnvironmentDepthImageAcquireInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEnvironmentDepthImageAcquireInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEnvironmentDepthImageAcquireInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EnvironmentDepthImageAcquireInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEnvironmentDepthImageAcquireInfoMETA*>(this);
  }
  Space space;
  Time displayTime;
};
static_assert(sizeof(XrEnvironmentDepthImageAcquireInfoMETA) ==
                  sizeof(EnvironmentDepthImageAcquireInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEnvironmentDepthImageAcquireInfoMETA pointer to const
 * from a EnvironmentDepthImageAcquireInfoMETA reference to const.
 * @relates EnvironmentDepthImageAcquireInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthImageAcquireInfoMETA const* get(
    EnvironmentDepthImageAcquireInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EnvironmentDepthImageAcquireInfoMETA as the address of a raw
 * XrEnvironmentDepthImageAcquireInfoMETA
 * @relates EnvironmentDepthImageAcquireInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthImageAcquireInfoMETA* put(
    EnvironmentDepthImageAcquireInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_environment_depth

#ifdef XR_META_environment_depth
/*!
 * C++ projection of XrEnvironmentDepthImageViewMETA
 *
 * Provided by the `XR_META_environment_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEnvironmentDepthImageViewMETA>
 * @xrentity{XrEnvironmentDepthImageViewMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EnvironmentDepthImageViewMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  EnvironmentDepthImageViewMETA(const Fovf& fov_, const Posef& pose_, const void* next_ = nullptr)
      : Parent(StructureType::EnvironmentDepthImageViewMETA, next_), fov{fov_}, pose{pose_} {}

  //! Default/empty constructor
  EnvironmentDepthImageViewMETA(const void* next_ = nullptr)

      : Parent(StructureType::EnvironmentDepthImageViewMETA, next_), fov{}, pose{} {}

  //! Default copy constructor
  EnvironmentDepthImageViewMETA(const EnvironmentDepthImageViewMETA& rhs) = default;
  //! Default copy assignment
  EnvironmentDepthImageViewMETA& operator=(const EnvironmentDepthImageViewMETA& rhs) = default;
  //! Copy construct from raw
  EnvironmentDepthImageViewMETA(const XrEnvironmentDepthImageViewMETA& rhs)
      : EnvironmentDepthImageViewMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EnvironmentDepthImageViewMETA& operator=(const XrEnvironmentDepthImageViewMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEnvironmentDepthImageViewMETA&() const {
    return *reinterpret_cast<const XrEnvironmentDepthImageViewMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEnvironmentDepthImageViewMETA&() {
    return *reinterpret_cast<XrEnvironmentDepthImageViewMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEnvironmentDepthImageViewMETA
  XrEnvironmentDepthImageViewMETA const* get() const noexcept {
    return reinterpret_cast<XrEnvironmentDepthImageViewMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEnvironmentDepthImageViewMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEnvironmentDepthImageViewMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EnvironmentDepthImageViewMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEnvironmentDepthImageViewMETA*>(this);
  }
  Fovf fov;
  Posef pose;
};
static_assert(sizeof(XrEnvironmentDepthImageViewMETA) == sizeof(EnvironmentDepthImageViewMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEnvironmentDepthImageViewMETA pointer to const from a
 * EnvironmentDepthImageViewMETA reference to const.
 * @relates EnvironmentDepthImageViewMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthImageViewMETA const* get(
    EnvironmentDepthImageViewMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EnvironmentDepthImageViewMETA
 * as the address of a raw XrEnvironmentDepthImageViewMETA
 * @relates EnvironmentDepthImageViewMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthImageViewMETA* put(EnvironmentDepthImageViewMETA& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_environment_depth

#ifdef XR_META_environment_depth
/*!
 * C++ projection of XrEnvironmentDepthImageMETA
 *
 * Provided by the `XR_META_environment_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEnvironmentDepthImageMETA>
 * @xrentity{XrEnvironmentDepthImageMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EnvironmentDepthImageMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  EnvironmentDepthImageMETA(uint32_t swapchainIndex_, float nearZ_, float farZ_,
                            EnvironmentDepthImageViewMETA views_[2], const void* next_ = nullptr)
      : Parent(StructureType::EnvironmentDepthImageMETA, next_),
        swapchainIndex{swapchainIndex_},
        nearZ{nearZ_},
        farZ{farZ_} {
    memcpy(views, views_, sizeof(views));
  }

  //! Default/empty constructor
  EnvironmentDepthImageMETA(const void* next_ = nullptr)

      : Parent(StructureType::EnvironmentDepthImageMETA, next_),
        swapchainIndex{0},
        nearZ{0.0f},
        farZ{0.0f},
        views{} {}

  //! Default copy constructor
  EnvironmentDepthImageMETA(const EnvironmentDepthImageMETA& rhs) = default;
  //! Default copy assignment
  EnvironmentDepthImageMETA& operator=(const EnvironmentDepthImageMETA& rhs) = default;
  //! Copy construct from raw
  EnvironmentDepthImageMETA(const XrEnvironmentDepthImageMETA& rhs) : EnvironmentDepthImageMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EnvironmentDepthImageMETA& operator=(const XrEnvironmentDepthImageMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEnvironmentDepthImageMETA&() const {
    return *reinterpret_cast<const XrEnvironmentDepthImageMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEnvironmentDepthImageMETA&() {
    return *reinterpret_cast<XrEnvironmentDepthImageMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEnvironmentDepthImageMETA
  XrEnvironmentDepthImageMETA const* get() const noexcept {
    return reinterpret_cast<XrEnvironmentDepthImageMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEnvironmentDepthImageMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEnvironmentDepthImageMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EnvironmentDepthImageMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEnvironmentDepthImageMETA*>(this);
  }
  uint32_t swapchainIndex;
  float nearZ;
  float farZ;
  EnvironmentDepthImageViewMETA views[2];
};
static_assert(sizeof(XrEnvironmentDepthImageMETA) == sizeof(EnvironmentDepthImageMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEnvironmentDepthImageMETA pointer to const from a
 * EnvironmentDepthImageMETA reference to const.
 * @relates EnvironmentDepthImageMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthImageMETA const* get(
    EnvironmentDepthImageMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EnvironmentDepthImageMETA as
 * the address of a raw XrEnvironmentDepthImageMETA
 * @relates EnvironmentDepthImageMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthImageMETA* put(EnvironmentDepthImageMETA& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_environment_depth

#ifdef XR_META_environment_depth
/*!
 * C++ projection of XrEnvironmentDepthHandRemovalSetInfoMETA
 *
 * Provided by the `XR_META_environment_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEnvironmentDepthHandRemovalSetInfoMETA>
 * @xrentity{XrEnvironmentDepthHandRemovalSetInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EnvironmentDepthHandRemovalSetInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  EnvironmentDepthHandRemovalSetInfoMETA(const Bool32& enabled_, const void* next_ = nullptr)
      : Parent(StructureType::EnvironmentDepthHandRemovalSetInfoMETA, next_), enabled{enabled_} {}

  //! Default/empty constructor
  EnvironmentDepthHandRemovalSetInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::EnvironmentDepthHandRemovalSetInfoMETA, next_), enabled{false} {}

  //! Default copy constructor
  EnvironmentDepthHandRemovalSetInfoMETA(const EnvironmentDepthHandRemovalSetInfoMETA& rhs) =
      default;
  //! Default copy assignment
  EnvironmentDepthHandRemovalSetInfoMETA& operator=(
      const EnvironmentDepthHandRemovalSetInfoMETA& rhs) = default;
  //! Copy construct from raw
  EnvironmentDepthHandRemovalSetInfoMETA(const XrEnvironmentDepthHandRemovalSetInfoMETA& rhs)
      : EnvironmentDepthHandRemovalSetInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EnvironmentDepthHandRemovalSetInfoMETA& operator=(
      const XrEnvironmentDepthHandRemovalSetInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEnvironmentDepthHandRemovalSetInfoMETA&() const {
    return *reinterpret_cast<const XrEnvironmentDepthHandRemovalSetInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEnvironmentDepthHandRemovalSetInfoMETA&() {
    return *reinterpret_cast<XrEnvironmentDepthHandRemovalSetInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEnvironmentDepthHandRemovalSetInfoMETA
  XrEnvironmentDepthHandRemovalSetInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrEnvironmentDepthHandRemovalSetInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEnvironmentDepthHandRemovalSetInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEnvironmentDepthHandRemovalSetInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EnvironmentDepthHandRemovalSetInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEnvironmentDepthHandRemovalSetInfoMETA*>(this);
  }
  Bool32 enabled;
};
static_assert(sizeof(XrEnvironmentDepthHandRemovalSetInfoMETA) ==
                  sizeof(EnvironmentDepthHandRemovalSetInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEnvironmentDepthHandRemovalSetInfoMETA pointer to const
 * from a EnvironmentDepthHandRemovalSetInfoMETA reference to const.
 * @relates EnvironmentDepthHandRemovalSetInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthHandRemovalSetInfoMETA const* get(
    EnvironmentDepthHandRemovalSetInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EnvironmentDepthHandRemovalSetInfoMETA as the address of a raw
 * XrEnvironmentDepthHandRemovalSetInfoMETA
 * @relates EnvironmentDepthHandRemovalSetInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthHandRemovalSetInfoMETA* put(
    EnvironmentDepthHandRemovalSetInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_environment_depth

#ifdef XR_META_environment_depth
/*!
 * C++ projection of XrSystemEnvironmentDepthPropertiesMETA
 *
 * Provided by the `XR_META_environment_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemEnvironmentDepthPropertiesMETA>
 * @xrentity{XrSystemEnvironmentDepthPropertiesMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemEnvironmentDepthPropertiesMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemEnvironmentDepthPropertiesMETA(void* next_ = nullptr)

      : Parent(StructureType::SystemEnvironmentDepthPropertiesMETA, next_) {}

  //! Default copy constructor
  SystemEnvironmentDepthPropertiesMETA(const SystemEnvironmentDepthPropertiesMETA& rhs) = default;
  //! Default copy assignment
  SystemEnvironmentDepthPropertiesMETA& operator=(const SystemEnvironmentDepthPropertiesMETA& rhs) =
      default;
  //! Copy construct from raw
  SystemEnvironmentDepthPropertiesMETA(const XrSystemEnvironmentDepthPropertiesMETA& rhs)
      : SystemEnvironmentDepthPropertiesMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemEnvironmentDepthPropertiesMETA& operator=(
      const XrSystemEnvironmentDepthPropertiesMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemEnvironmentDepthPropertiesMETA&() const {
    return *reinterpret_cast<const XrSystemEnvironmentDepthPropertiesMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemEnvironmentDepthPropertiesMETA&() {
    return *reinterpret_cast<XrSystemEnvironmentDepthPropertiesMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemEnvironmentDepthPropertiesMETA
  XrSystemEnvironmentDepthPropertiesMETA const* get() const noexcept {
    return reinterpret_cast<XrSystemEnvironmentDepthPropertiesMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemEnvironmentDepthPropertiesMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemEnvironmentDepthPropertiesMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemEnvironmentDepthPropertiesMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemEnvironmentDepthPropertiesMETA*>(this);
  }
  Bool32 supportsEnvironmentDepth;
  Bool32 supportsHandRemoval;
};
static_assert(sizeof(XrSystemEnvironmentDepthPropertiesMETA) ==
                  sizeof(SystemEnvironmentDepthPropertiesMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemEnvironmentDepthPropertiesMETA pointer to const
 * from a SystemEnvironmentDepthPropertiesMETA reference to const.
 * @relates SystemEnvironmentDepthPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemEnvironmentDepthPropertiesMETA const* get(
    SystemEnvironmentDepthPropertiesMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemEnvironmentDepthPropertiesMETA as the address of a raw
 * XrSystemEnvironmentDepthPropertiesMETA
 * @relates SystemEnvironmentDepthPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemEnvironmentDepthPropertiesMETA* put(
    SystemEnvironmentDepthPropertiesMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_environment_depth

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelCreateInfoEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelCreateInfoEXT>
 * @xrentity{XrRenderModelCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  RenderModelCreateInfoEXT(const RenderModelIdEXT& renderModelId_, uint32_t gltfExtensionCount_,
                           const char* const* gltfExtensions_, const void* next_ = nullptr)
      : Parent(StructureType::RenderModelCreateInfoEXT, next_),
        renderModelId{renderModelId_},
        gltfExtensionCount{gltfExtensionCount_},
        gltfExtensions{gltfExtensions_} {}

  //! Default/empty constructor
  RenderModelCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::RenderModelCreateInfoEXT, next_),
        renderModelId{},
        gltfExtensionCount{0},
        gltfExtensions{nullptr} {}

  //! Default copy constructor
  RenderModelCreateInfoEXT(const RenderModelCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  RenderModelCreateInfoEXT& operator=(const RenderModelCreateInfoEXT& rhs) = default;
  //! Copy construct from raw
  RenderModelCreateInfoEXT(const XrRenderModelCreateInfoEXT& rhs) : RenderModelCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelCreateInfoEXT& operator=(const XrRenderModelCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelCreateInfoEXT&() const {
    return *reinterpret_cast<const XrRenderModelCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelCreateInfoEXT&() {
    return *reinterpret_cast<XrRenderModelCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelCreateInfoEXT
  XrRenderModelCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelCreateInfoEXT*>(this);
  }
  RenderModelIdEXT renderModelId;
  uint32_t gltfExtensionCount;
  const char* const* gltfExtensions;
};
static_assert(sizeof(XrRenderModelCreateInfoEXT) == sizeof(RenderModelCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelCreateInfoEXT pointer to const from a
 * RenderModelCreateInfoEXT reference to const.
 * @relates RenderModelCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelCreateInfoEXT const* get(RenderModelCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelCreateInfoEXT as
 * the address of a raw XrRenderModelCreateInfoEXT
 * @relates RenderModelCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelCreateInfoEXT* put(RenderModelCreateInfoEXT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelPropertiesGetInfoEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelPropertiesGetInfoEXT>
 * @xrentity{XrRenderModelPropertiesGetInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelPropertiesGetInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  RenderModelPropertiesGetInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::RenderModelPropertiesGetInfoEXT, next_) {}

  //! Default copy constructor
  RenderModelPropertiesGetInfoEXT(const RenderModelPropertiesGetInfoEXT& rhs) = default;
  //! Default copy assignment
  RenderModelPropertiesGetInfoEXT& operator=(const RenderModelPropertiesGetInfoEXT& rhs) = default;
  //! Copy construct from raw
  RenderModelPropertiesGetInfoEXT(const XrRenderModelPropertiesGetInfoEXT& rhs)
      : RenderModelPropertiesGetInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelPropertiesGetInfoEXT& operator=(const XrRenderModelPropertiesGetInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelPropertiesGetInfoEXT&() const {
    return *reinterpret_cast<const XrRenderModelPropertiesGetInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelPropertiesGetInfoEXT&() {
    return *reinterpret_cast<XrRenderModelPropertiesGetInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelPropertiesGetInfoEXT
  XrRenderModelPropertiesGetInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelPropertiesGetInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelPropertiesGetInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelPropertiesGetInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelPropertiesGetInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelPropertiesGetInfoEXT*>(this);
  }
};
static_assert(sizeof(XrRenderModelPropertiesGetInfoEXT) == sizeof(RenderModelPropertiesGetInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelPropertiesGetInfoEXT pointer to const from a
 * RenderModelPropertiesGetInfoEXT reference to const.
 * @relates RenderModelPropertiesGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelPropertiesGetInfoEXT const* get(
    RenderModelPropertiesGetInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * RenderModelPropertiesGetInfoEXT as the address of a raw XrRenderModelPropertiesGetInfoEXT
 * @relates RenderModelPropertiesGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelPropertiesGetInfoEXT* put(RenderModelPropertiesGetInfoEXT& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelPropertiesEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelPropertiesEXT>
 * @xrentity{XrRenderModelPropertiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelPropertiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelPropertiesEXT(void* next_ = nullptr)

      : Parent(StructureType::RenderModelPropertiesEXT, next_) {}

  //! Default copy constructor
  RenderModelPropertiesEXT(const RenderModelPropertiesEXT& rhs) = default;
  //! Default copy assignment
  RenderModelPropertiesEXT& operator=(const RenderModelPropertiesEXT& rhs) = default;
  //! Copy construct from raw
  RenderModelPropertiesEXT(const XrRenderModelPropertiesEXT& rhs) : RenderModelPropertiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelPropertiesEXT& operator=(const XrRenderModelPropertiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelPropertiesEXT&() const {
    return *reinterpret_cast<const XrRenderModelPropertiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelPropertiesEXT&() {
    return *reinterpret_cast<XrRenderModelPropertiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelPropertiesEXT
  XrRenderModelPropertiesEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelPropertiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelPropertiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelPropertiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelPropertiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelPropertiesEXT*>(this);
  }
  UuidEXT cacheId;
  uint32_t animatableNodeCount;
};
static_assert(sizeof(XrRenderModelPropertiesEXT) == sizeof(RenderModelPropertiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelPropertiesEXT pointer to const from a
 * RenderModelPropertiesEXT reference to const.
 * @relates RenderModelPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelPropertiesEXT const* get(RenderModelPropertiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelPropertiesEXT as
 * the address of a raw XrRenderModelPropertiesEXT
 * @relates RenderModelPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelPropertiesEXT* put(RenderModelPropertiesEXT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelSpaceCreateInfoEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelSpaceCreateInfoEXT>
 * @xrentity{XrRenderModelSpaceCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelSpaceCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  RenderModelSpaceCreateInfoEXT(const RenderModelEXT& renderModel_, const void* next_ = nullptr)
      : Parent(StructureType::RenderModelSpaceCreateInfoEXT, next_), renderModel{renderModel_} {}

  //! Default/empty constructor
  RenderModelSpaceCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::RenderModelSpaceCreateInfoEXT, next_), renderModel{} {}

  //! Default copy constructor
  RenderModelSpaceCreateInfoEXT(const RenderModelSpaceCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  RenderModelSpaceCreateInfoEXT& operator=(const RenderModelSpaceCreateInfoEXT& rhs) = default;
  //! Copy construct from raw
  RenderModelSpaceCreateInfoEXT(const XrRenderModelSpaceCreateInfoEXT& rhs)
      : RenderModelSpaceCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelSpaceCreateInfoEXT& operator=(const XrRenderModelSpaceCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelSpaceCreateInfoEXT&() const {
    return *reinterpret_cast<const XrRenderModelSpaceCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelSpaceCreateInfoEXT&() {
    return *reinterpret_cast<XrRenderModelSpaceCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelSpaceCreateInfoEXT
  XrRenderModelSpaceCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelSpaceCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelSpaceCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelSpaceCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelSpaceCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelSpaceCreateInfoEXT*>(this);
  }
  RenderModelEXT renderModel;
};
static_assert(sizeof(XrRenderModelSpaceCreateInfoEXT) == sizeof(RenderModelSpaceCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelSpaceCreateInfoEXT pointer to const from a
 * RenderModelSpaceCreateInfoEXT reference to const.
 * @relates RenderModelSpaceCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelSpaceCreateInfoEXT const* get(
    RenderModelSpaceCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelSpaceCreateInfoEXT
 * as the address of a raw XrRenderModelSpaceCreateInfoEXT
 * @relates RenderModelSpaceCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelSpaceCreateInfoEXT* put(RenderModelSpaceCreateInfoEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelStateGetInfoEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelStateGetInfoEXT>
 * @xrentity{XrRenderModelStateGetInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelStateGetInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  RenderModelStateGetInfoEXT(const Time& displayTime_, const void* next_ = nullptr)
      : Parent(StructureType::RenderModelStateGetInfoEXT, next_), displayTime{displayTime_} {}

  //! Default/empty constructor
  RenderModelStateGetInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::RenderModelStateGetInfoEXT, next_), displayTime{} {}

  //! Default copy constructor
  RenderModelStateGetInfoEXT(const RenderModelStateGetInfoEXT& rhs) = default;
  //! Default copy assignment
  RenderModelStateGetInfoEXT& operator=(const RenderModelStateGetInfoEXT& rhs) = default;
  //! Copy construct from raw
  RenderModelStateGetInfoEXT(const XrRenderModelStateGetInfoEXT& rhs)
      : RenderModelStateGetInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelStateGetInfoEXT& operator=(const XrRenderModelStateGetInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelStateGetInfoEXT&() const {
    return *reinterpret_cast<const XrRenderModelStateGetInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelStateGetInfoEXT&() {
    return *reinterpret_cast<XrRenderModelStateGetInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelStateGetInfoEXT
  XrRenderModelStateGetInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelStateGetInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelStateGetInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelStateGetInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelStateGetInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelStateGetInfoEXT*>(this);
  }
  Time displayTime;
};
static_assert(sizeof(XrRenderModelStateGetInfoEXT) == sizeof(RenderModelStateGetInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelStateGetInfoEXT pointer to const from a
 * RenderModelStateGetInfoEXT reference to const.
 * @relates RenderModelStateGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelStateGetInfoEXT const* get(
    RenderModelStateGetInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelStateGetInfoEXT as
 * the address of a raw XrRenderModelStateGetInfoEXT
 * @relates RenderModelStateGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelStateGetInfoEXT* put(RenderModelStateGetInfoEXT& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelNodeStateEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelNodeStateEXT>
 * @xrentity{XrRenderModelNodeStateEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS RenderModelNodeStateEXT {
public:
  //! Constructor initializing all members.
  RenderModelNodeStateEXT(const Posef& nodePose_, const Bool32& isVisible_)
      : nodePose{nodePose_}, isVisible{isVisible_} {}

  //! Default/empty constructor
  RenderModelNodeStateEXT()

      : nodePose{}, isVisible{false} {}

  //! Default copy constructor
  RenderModelNodeStateEXT(const RenderModelNodeStateEXT& rhs) = default;
  //! Default copy assignment
  RenderModelNodeStateEXT& operator=(const RenderModelNodeStateEXT& rhs) = default;
  //! Copy construct from raw
  RenderModelNodeStateEXT(const XrRenderModelNodeStateEXT& rhs) : RenderModelNodeStateEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelNodeStateEXT& operator=(const XrRenderModelNodeStateEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelNodeStateEXT&() const {
    return *reinterpret_cast<const XrRenderModelNodeStateEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelNodeStateEXT&() {
    return *reinterpret_cast<XrRenderModelNodeStateEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelNodeStateEXT
  XrRenderModelNodeStateEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelNodeStateEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelNodeStateEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrRenderModelNodeStateEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = RenderModelNodeStateEXT{};
    }
    return reinterpret_cast<XrRenderModelNodeStateEXT*>(this);
  }
  Posef nodePose;
  Bool32 isVisible;
};
static_assert(sizeof(XrRenderModelNodeStateEXT) == sizeof(RenderModelNodeStateEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelNodeStateEXT pointer to const from a
 * RenderModelNodeStateEXT reference to const.
 * @relates RenderModelNodeStateEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelNodeStateEXT const* get(RenderModelNodeStateEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelNodeStateEXT as
 * the address of a raw XrRenderModelNodeStateEXT
 * @relates RenderModelNodeStateEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelNodeStateEXT* put(RenderModelNodeStateEXT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelStateEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelStateEXT>
 * @xrentity{XrRenderModelStateEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelStateEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelStateEXT(void* next_ = nullptr)

      : Parent(StructureType::RenderModelStateEXT, next_) {}

  //! Default copy constructor
  RenderModelStateEXT(const RenderModelStateEXT& rhs) = default;
  //! Default copy assignment
  RenderModelStateEXT& operator=(const RenderModelStateEXT& rhs) = default;
  //! Copy construct from raw
  RenderModelStateEXT(const XrRenderModelStateEXT& rhs) : RenderModelStateEXT() { *put() = rhs; }
  //! Copy assign from raw
  RenderModelStateEXT& operator=(const XrRenderModelStateEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelStateEXT&() const {
    return *reinterpret_cast<const XrRenderModelStateEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelStateEXT&() { return *reinterpret_cast<XrRenderModelStateEXT*>(this); }

  //! Accessor for this as the address of a raw XrRenderModelStateEXT
  XrRenderModelStateEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelStateEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrRenderModelStateEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelStateEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelStateEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelStateEXT*>(this);
  }
  uint32_t nodeStateCount;
  RenderModelNodeStateEXT* nodeStates;
};
static_assert(sizeof(XrRenderModelStateEXT) == sizeof(RenderModelStateEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelStateEXT pointer to const from a
 * RenderModelStateEXT reference to const.
 * @relates RenderModelStateEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelStateEXT const* get(RenderModelStateEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelStateEXT as the
 * address of a raw XrRenderModelStateEXT
 * @relates RenderModelStateEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelStateEXT* put(RenderModelStateEXT& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelAssetCreateInfoEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelAssetCreateInfoEXT>
 * @xrentity{XrRenderModelAssetCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelAssetCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  RenderModelAssetCreateInfoEXT(const UuidEXT& cacheId_, const void* next_ = nullptr)
      : Parent(StructureType::RenderModelAssetCreateInfoEXT, next_), cacheId{cacheId_} {}

  //! Default/empty constructor
  RenderModelAssetCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::RenderModelAssetCreateInfoEXT, next_), cacheId{} {}

  //! Default copy constructor
  RenderModelAssetCreateInfoEXT(const RenderModelAssetCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  RenderModelAssetCreateInfoEXT& operator=(const RenderModelAssetCreateInfoEXT& rhs) = default;
  //! Copy construct from raw
  RenderModelAssetCreateInfoEXT(const XrRenderModelAssetCreateInfoEXT& rhs)
      : RenderModelAssetCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelAssetCreateInfoEXT& operator=(const XrRenderModelAssetCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelAssetCreateInfoEXT&() const {
    return *reinterpret_cast<const XrRenderModelAssetCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelAssetCreateInfoEXT&() {
    return *reinterpret_cast<XrRenderModelAssetCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelAssetCreateInfoEXT
  XrRenderModelAssetCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelAssetCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelAssetCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelAssetCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelAssetCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelAssetCreateInfoEXT*>(this);
  }
  UuidEXT cacheId;
};
static_assert(sizeof(XrRenderModelAssetCreateInfoEXT) == sizeof(RenderModelAssetCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelAssetCreateInfoEXT pointer to const from a
 * RenderModelAssetCreateInfoEXT reference to const.
 * @relates RenderModelAssetCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelAssetCreateInfoEXT const* get(
    RenderModelAssetCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelAssetCreateInfoEXT
 * as the address of a raw XrRenderModelAssetCreateInfoEXT
 * @relates RenderModelAssetCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelAssetCreateInfoEXT* put(RenderModelAssetCreateInfoEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelAssetDataGetInfoEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelAssetDataGetInfoEXT>
 * @xrentity{XrRenderModelAssetDataGetInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelAssetDataGetInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  RenderModelAssetDataGetInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::RenderModelAssetDataGetInfoEXT, next_) {}

  //! Default copy constructor
  RenderModelAssetDataGetInfoEXT(const RenderModelAssetDataGetInfoEXT& rhs) = default;
  //! Default copy assignment
  RenderModelAssetDataGetInfoEXT& operator=(const RenderModelAssetDataGetInfoEXT& rhs) = default;
  //! Copy construct from raw
  RenderModelAssetDataGetInfoEXT(const XrRenderModelAssetDataGetInfoEXT& rhs)
      : RenderModelAssetDataGetInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelAssetDataGetInfoEXT& operator=(const XrRenderModelAssetDataGetInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelAssetDataGetInfoEXT&() const {
    return *reinterpret_cast<const XrRenderModelAssetDataGetInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelAssetDataGetInfoEXT&() {
    return *reinterpret_cast<XrRenderModelAssetDataGetInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelAssetDataGetInfoEXT
  XrRenderModelAssetDataGetInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelAssetDataGetInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelAssetDataGetInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelAssetDataGetInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelAssetDataGetInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelAssetDataGetInfoEXT*>(this);
  }
};
static_assert(sizeof(XrRenderModelAssetDataGetInfoEXT) == sizeof(RenderModelAssetDataGetInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelAssetDataGetInfoEXT pointer to const from a
 * RenderModelAssetDataGetInfoEXT reference to const.
 * @relates RenderModelAssetDataGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelAssetDataGetInfoEXT const* get(
    RenderModelAssetDataGetInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * RenderModelAssetDataGetInfoEXT as the address of a raw XrRenderModelAssetDataGetInfoEXT
 * @relates RenderModelAssetDataGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelAssetDataGetInfoEXT* put(RenderModelAssetDataGetInfoEXT& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelAssetDataEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelAssetDataEXT>
 * @xrentity{XrRenderModelAssetDataEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelAssetDataEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelAssetDataEXT(void* next_ = nullptr)

      : Parent(StructureType::RenderModelAssetDataEXT, next_) {}

  //! Default copy constructor
  RenderModelAssetDataEXT(const RenderModelAssetDataEXT& rhs) = default;
  //! Default copy assignment
  RenderModelAssetDataEXT& operator=(const RenderModelAssetDataEXT& rhs) = default;
  //! Copy construct from raw
  RenderModelAssetDataEXT(const XrRenderModelAssetDataEXT& rhs) : RenderModelAssetDataEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelAssetDataEXT& operator=(const XrRenderModelAssetDataEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelAssetDataEXT&() const {
    return *reinterpret_cast<const XrRenderModelAssetDataEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelAssetDataEXT&() {
    return *reinterpret_cast<XrRenderModelAssetDataEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelAssetDataEXT
  XrRenderModelAssetDataEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelAssetDataEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelAssetDataEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelAssetDataEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelAssetDataEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelAssetDataEXT*>(this);
  }
  uint32_t bufferCapacityInput;
  uint32_t bufferCountOutput;
  uint8_t* buffer;
};
static_assert(sizeof(XrRenderModelAssetDataEXT) == sizeof(RenderModelAssetDataEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelAssetDataEXT pointer to const from a
 * RenderModelAssetDataEXT reference to const.
 * @relates RenderModelAssetDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelAssetDataEXT const* get(RenderModelAssetDataEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelAssetDataEXT as
 * the address of a raw XrRenderModelAssetDataEXT
 * @relates RenderModelAssetDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelAssetDataEXT* put(RenderModelAssetDataEXT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelAssetPropertiesGetInfoEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelAssetPropertiesGetInfoEXT>
 * @xrentity{XrRenderModelAssetPropertiesGetInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelAssetPropertiesGetInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  RenderModelAssetPropertiesGetInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::RenderModelAssetPropertiesGetInfoEXT, next_) {}

  //! Default copy constructor
  RenderModelAssetPropertiesGetInfoEXT(const RenderModelAssetPropertiesGetInfoEXT& rhs) = default;
  //! Default copy assignment
  RenderModelAssetPropertiesGetInfoEXT& operator=(const RenderModelAssetPropertiesGetInfoEXT& rhs) =
      default;
  //! Copy construct from raw
  RenderModelAssetPropertiesGetInfoEXT(const XrRenderModelAssetPropertiesGetInfoEXT& rhs)
      : RenderModelAssetPropertiesGetInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelAssetPropertiesGetInfoEXT& operator=(
      const XrRenderModelAssetPropertiesGetInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelAssetPropertiesGetInfoEXT&() const {
    return *reinterpret_cast<const XrRenderModelAssetPropertiesGetInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelAssetPropertiesGetInfoEXT&() {
    return *reinterpret_cast<XrRenderModelAssetPropertiesGetInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelAssetPropertiesGetInfoEXT
  XrRenderModelAssetPropertiesGetInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelAssetPropertiesGetInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelAssetPropertiesGetInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelAssetPropertiesGetInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelAssetPropertiesGetInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelAssetPropertiesGetInfoEXT*>(this);
  }
};
static_assert(sizeof(XrRenderModelAssetPropertiesGetInfoEXT) ==
                  sizeof(RenderModelAssetPropertiesGetInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelAssetPropertiesGetInfoEXT pointer to const
 * from a RenderModelAssetPropertiesGetInfoEXT reference to const.
 * @relates RenderModelAssetPropertiesGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelAssetPropertiesGetInfoEXT const* get(
    RenderModelAssetPropertiesGetInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * RenderModelAssetPropertiesGetInfoEXT as the address of a raw
 * XrRenderModelAssetPropertiesGetInfoEXT
 * @relates RenderModelAssetPropertiesGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelAssetPropertiesGetInfoEXT* put(
    RenderModelAssetPropertiesGetInfoEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelAssetNodePropertiesEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelAssetNodePropertiesEXT>
 * @xrentity{XrRenderModelAssetNodePropertiesEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS RenderModelAssetNodePropertiesEXT {
public:
  //! Constructor initializing all members.
  RenderModelAssetNodePropertiesEXT(const char* uniqueName_) {
    if (nullptr != uniqueName_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(uniqueName, XR_MAX_RENDER_MODEL_ASSET_NODE_NAME_SIZE_EXT, uniqueName_,
                XR_MAX_RENDER_MODEL_ASSET_NODE_NAME_SIZE_EXT);
#else
      strncpy(uniqueName, uniqueName_, XR_MAX_RENDER_MODEL_ASSET_NODE_NAME_SIZE_EXT - 1);
      uniqueName[XR_MAX_RENDER_MODEL_ASSET_NODE_NAME_SIZE_EXT - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  RenderModelAssetNodePropertiesEXT()

  {}

  //! Default copy constructor
  RenderModelAssetNodePropertiesEXT(const RenderModelAssetNodePropertiesEXT& rhs) = default;
  //! Default copy assignment
  RenderModelAssetNodePropertiesEXT& operator=(const RenderModelAssetNodePropertiesEXT& rhs) =
      default;
  //! Copy construct from raw
  RenderModelAssetNodePropertiesEXT(const XrRenderModelAssetNodePropertiesEXT& rhs)
      : RenderModelAssetNodePropertiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelAssetNodePropertiesEXT& operator=(const XrRenderModelAssetNodePropertiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelAssetNodePropertiesEXT&() const {
    return *reinterpret_cast<const XrRenderModelAssetNodePropertiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelAssetNodePropertiesEXT&() {
    return *reinterpret_cast<XrRenderModelAssetNodePropertiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelAssetNodePropertiesEXT
  XrRenderModelAssetNodePropertiesEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelAssetNodePropertiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelAssetNodePropertiesEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrRenderModelAssetNodePropertiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = RenderModelAssetNodePropertiesEXT{};
    }
    return reinterpret_cast<XrRenderModelAssetNodePropertiesEXT*>(this);
  }
  char uniqueName[XR_MAX_RENDER_MODEL_ASSET_NODE_NAME_SIZE_EXT];
};
static_assert(sizeof(XrRenderModelAssetNodePropertiesEXT) ==
                  sizeof(RenderModelAssetNodePropertiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelAssetNodePropertiesEXT pointer to const from
 * a RenderModelAssetNodePropertiesEXT reference to const.
 * @relates RenderModelAssetNodePropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelAssetNodePropertiesEXT const* get(
    RenderModelAssetNodePropertiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * RenderModelAssetNodePropertiesEXT as the address of a raw XrRenderModelAssetNodePropertiesEXT
 * @relates RenderModelAssetNodePropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelAssetNodePropertiesEXT* put(
    RenderModelAssetNodePropertiesEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model
/*!
 * C++ projection of XrRenderModelAssetPropertiesEXT
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelAssetPropertiesEXT>
 * @xrentity{XrRenderModelAssetPropertiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS RenderModelAssetPropertiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  RenderModelAssetPropertiesEXT(void* next_ = nullptr)

      : Parent(StructureType::RenderModelAssetPropertiesEXT, next_) {}

  //! Default copy constructor
  RenderModelAssetPropertiesEXT(const RenderModelAssetPropertiesEXT& rhs) = default;
  //! Default copy assignment
  RenderModelAssetPropertiesEXT& operator=(const RenderModelAssetPropertiesEXT& rhs) = default;
  //! Copy construct from raw
  RenderModelAssetPropertiesEXT(const XrRenderModelAssetPropertiesEXT& rhs)
      : RenderModelAssetPropertiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  RenderModelAssetPropertiesEXT& operator=(const XrRenderModelAssetPropertiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrRenderModelAssetPropertiesEXT&() const {
    return *reinterpret_cast<const XrRenderModelAssetPropertiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrRenderModelAssetPropertiesEXT&() {
    return *reinterpret_cast<XrRenderModelAssetPropertiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrRenderModelAssetPropertiesEXT
  XrRenderModelAssetPropertiesEXT const* get() const noexcept {
    return reinterpret_cast<XrRenderModelAssetPropertiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrRenderModelAssetPropertiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrRenderModelAssetPropertiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = RenderModelAssetPropertiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrRenderModelAssetPropertiesEXT*>(this);
  }
  uint32_t nodePropertyCount;
  RenderModelAssetNodePropertiesEXT* nodeProperties;
};
static_assert(sizeof(XrRenderModelAssetPropertiesEXT) == sizeof(RenderModelAssetPropertiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrRenderModelAssetPropertiesEXT pointer to const from a
 * RenderModelAssetPropertiesEXT reference to const.
 * @relates RenderModelAssetPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelAssetPropertiesEXT const* get(
    RenderModelAssetPropertiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing RenderModelAssetPropertiesEXT
 * as the address of a raw XrRenderModelAssetPropertiesEXT
 * @relates RenderModelAssetPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrRenderModelAssetPropertiesEXT* put(RenderModelAssetPropertiesEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_interaction_render_model
/*!
 * C++ projection of XrInteractionRenderModelIdsEnumerateInfoEXT
 *
 * Provided by the `XR_EXT_interaction_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionRenderModelIdsEnumerateInfoEXT>
 * @xrentity{XrInteractionRenderModelIdsEnumerateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionRenderModelIdsEnumerateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  InteractionRenderModelIdsEnumerateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::InteractionRenderModelIdsEnumerateInfoEXT, next_) {}

  //! Default copy constructor
  InteractionRenderModelIdsEnumerateInfoEXT(const InteractionRenderModelIdsEnumerateInfoEXT& rhs) =
      default;
  //! Default copy assignment
  InteractionRenderModelIdsEnumerateInfoEXT& operator=(
      const InteractionRenderModelIdsEnumerateInfoEXT& rhs) = default;
  //! Copy construct from raw
  InteractionRenderModelIdsEnumerateInfoEXT(const XrInteractionRenderModelIdsEnumerateInfoEXT& rhs)
      : InteractionRenderModelIdsEnumerateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionRenderModelIdsEnumerateInfoEXT& operator=(
      const XrInteractionRenderModelIdsEnumerateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionRenderModelIdsEnumerateInfoEXT&() const {
    return *reinterpret_cast<const XrInteractionRenderModelIdsEnumerateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionRenderModelIdsEnumerateInfoEXT&() {
    return *reinterpret_cast<XrInteractionRenderModelIdsEnumerateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrInteractionRenderModelIdsEnumerateInfoEXT
  XrInteractionRenderModelIdsEnumerateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrInteractionRenderModelIdsEnumerateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionRenderModelIdsEnumerateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionRenderModelIdsEnumerateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionRenderModelIdsEnumerateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionRenderModelIdsEnumerateInfoEXT*>(this);
  }
};
static_assert(sizeof(XrInteractionRenderModelIdsEnumerateInfoEXT) ==
                  sizeof(InteractionRenderModelIdsEnumerateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionRenderModelIdsEnumerateInfoEXT pointer to
 * const from a InteractionRenderModelIdsEnumerateInfoEXT reference to const.
 * @relates InteractionRenderModelIdsEnumerateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionRenderModelIdsEnumerateInfoEXT const* get(
    InteractionRenderModelIdsEnumerateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InteractionRenderModelIdsEnumerateInfoEXT as the address of a raw
 * XrInteractionRenderModelIdsEnumerateInfoEXT
 * @relates InteractionRenderModelIdsEnumerateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionRenderModelIdsEnumerateInfoEXT* put(
    InteractionRenderModelIdsEnumerateInfoEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_interaction_render_model

#ifdef XR_EXT_interaction_render_model
/*!
 * C++ projection of XrInteractionRenderModelSubactionPathInfoEXT
 *
 * Provided by the `XR_EXT_interaction_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionRenderModelSubactionPathInfoEXT>
 * @xrentity{XrInteractionRenderModelSubactionPathInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionRenderModelSubactionPathInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  InteractionRenderModelSubactionPathInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::InteractionRenderModelSubactionPathInfoEXT, next_) {}

  //! Default copy constructor
  InteractionRenderModelSubactionPathInfoEXT(
      const InteractionRenderModelSubactionPathInfoEXT& rhs) = default;
  //! Default copy assignment
  InteractionRenderModelSubactionPathInfoEXT& operator=(
      const InteractionRenderModelSubactionPathInfoEXT& rhs) = default;
  //! Copy construct from raw
  InteractionRenderModelSubactionPathInfoEXT(
      const XrInteractionRenderModelSubactionPathInfoEXT& rhs)
      : InteractionRenderModelSubactionPathInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionRenderModelSubactionPathInfoEXT& operator=(
      const XrInteractionRenderModelSubactionPathInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionRenderModelSubactionPathInfoEXT&() const {
    return *reinterpret_cast<const XrInteractionRenderModelSubactionPathInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionRenderModelSubactionPathInfoEXT&() {
    return *reinterpret_cast<XrInteractionRenderModelSubactionPathInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrInteractionRenderModelSubactionPathInfoEXT
  XrInteractionRenderModelSubactionPathInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrInteractionRenderModelSubactionPathInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionRenderModelSubactionPathInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionRenderModelSubactionPathInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionRenderModelSubactionPathInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionRenderModelSubactionPathInfoEXT*>(this);
  }
};
static_assert(sizeof(XrInteractionRenderModelSubactionPathInfoEXT) ==
                  sizeof(InteractionRenderModelSubactionPathInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionRenderModelSubactionPathInfoEXT pointer to
 * const from a InteractionRenderModelSubactionPathInfoEXT reference to const.
 * @relates InteractionRenderModelSubactionPathInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionRenderModelSubactionPathInfoEXT const* get(
    InteractionRenderModelSubactionPathInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InteractionRenderModelSubactionPathInfoEXT as the address of a raw
 * XrInteractionRenderModelSubactionPathInfoEXT
 * @relates InteractionRenderModelSubactionPathInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionRenderModelSubactionPathInfoEXT* put(
    InteractionRenderModelSubactionPathInfoEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_interaction_render_model

#ifdef XR_EXT_interaction_render_model
/*!
 * C++ projection of XrInteractionRenderModelTopLevelUserPathGetInfoEXT
 *
 * Provided by the `XR_EXT_interaction_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInteractionRenderModelTopLevelUserPathGetInfoEXT>
 * @xrentity{XrInteractionRenderModelTopLevelUserPathGetInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS InteractionRenderModelTopLevelUserPathGetInfoEXT
    : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  InteractionRenderModelTopLevelUserPathGetInfoEXT(uint32_t topLevelUserPathCount_,
                                                   const Path* topLevelUserPaths_,
                                                   const void* next_ = nullptr)
      : Parent(StructureType::InteractionRenderModelTopLevelUserPathGetInfoEXT, next_),
        topLevelUserPathCount{topLevelUserPathCount_},
        topLevelUserPaths{topLevelUserPaths_} {}

  //! Default/empty constructor
  InteractionRenderModelTopLevelUserPathGetInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::InteractionRenderModelTopLevelUserPathGetInfoEXT, next_),
        topLevelUserPathCount{0},
        topLevelUserPaths{nullptr} {}

  //! Default copy constructor
  InteractionRenderModelTopLevelUserPathGetInfoEXT(
      const InteractionRenderModelTopLevelUserPathGetInfoEXT& rhs) = default;
  //! Default copy assignment
  InteractionRenderModelTopLevelUserPathGetInfoEXT& operator=(
      const InteractionRenderModelTopLevelUserPathGetInfoEXT& rhs) = default;
  //! Copy construct from raw
  InteractionRenderModelTopLevelUserPathGetInfoEXT(
      const XrInteractionRenderModelTopLevelUserPathGetInfoEXT& rhs)
      : InteractionRenderModelTopLevelUserPathGetInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  InteractionRenderModelTopLevelUserPathGetInfoEXT& operator=(
      const XrInteractionRenderModelTopLevelUserPathGetInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrInteractionRenderModelTopLevelUserPathGetInfoEXT&() const {
    return *reinterpret_cast<const XrInteractionRenderModelTopLevelUserPathGetInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrInteractionRenderModelTopLevelUserPathGetInfoEXT&() {
    return *reinterpret_cast<XrInteractionRenderModelTopLevelUserPathGetInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrInteractionRenderModelTopLevelUserPathGetInfoEXT
  XrInteractionRenderModelTopLevelUserPathGetInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrInteractionRenderModelTopLevelUserPathGetInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrInteractionRenderModelTopLevelUserPathGetInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrInteractionRenderModelTopLevelUserPathGetInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = InteractionRenderModelTopLevelUserPathGetInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrInteractionRenderModelTopLevelUserPathGetInfoEXT*>(this);
  }
  uint32_t topLevelUserPathCount;
  const Path* topLevelUserPaths;
};
static_assert(sizeof(XrInteractionRenderModelTopLevelUserPathGetInfoEXT) ==
                  sizeof(InteractionRenderModelTopLevelUserPathGetInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrInteractionRenderModelTopLevelUserPathGetInfoEXT pointer
 * to const from a InteractionRenderModelTopLevelUserPathGetInfoEXT reference to const.
 * @relates InteractionRenderModelTopLevelUserPathGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionRenderModelTopLevelUserPathGetInfoEXT const* get(
    InteractionRenderModelTopLevelUserPathGetInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * InteractionRenderModelTopLevelUserPathGetInfoEXT as the address of a raw
 * XrInteractionRenderModelTopLevelUserPathGetInfoEXT
 * @relates InteractionRenderModelTopLevelUserPathGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrInteractionRenderModelTopLevelUserPathGetInfoEXT* put(
    InteractionRenderModelTopLevelUserPathGetInfoEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_interaction_render_model

#ifdef XR_EXT_interaction_render_model
/*!
 * C++ projection of XrEventDataInteractionRenderModelsChangedEXT
 *
 * Provided by the `XR_EXT_interaction_render_model` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataInteractionRenderModelsChangedEXT>
 * @xrentity{XrEventDataInteractionRenderModelsChangedEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataInteractionRenderModelsChangedEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataInteractionRenderModelsChangedEXT(void* next_ = nullptr)

      : Parent(StructureType::EventDataInteractionRenderModelsChangedEXT, next_) {}

  //! Default copy constructor
  EventDataInteractionRenderModelsChangedEXT(
      const EventDataInteractionRenderModelsChangedEXT& rhs) = default;
  //! Default copy assignment
  EventDataInteractionRenderModelsChangedEXT& operator=(
      const EventDataInteractionRenderModelsChangedEXT& rhs) = default;
  //! Copy construct from raw
  EventDataInteractionRenderModelsChangedEXT(
      const XrEventDataInteractionRenderModelsChangedEXT& rhs)
      : EventDataInteractionRenderModelsChangedEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataInteractionRenderModelsChangedEXT& operator=(
      const XrEventDataInteractionRenderModelsChangedEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataInteractionRenderModelsChangedEXT&() const {
    return *reinterpret_cast<const XrEventDataInteractionRenderModelsChangedEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataInteractionRenderModelsChangedEXT&() {
    return *reinterpret_cast<XrEventDataInteractionRenderModelsChangedEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataInteractionRenderModelsChangedEXT
  XrEventDataInteractionRenderModelsChangedEXT const* get() const noexcept {
    return reinterpret_cast<XrEventDataInteractionRenderModelsChangedEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataInteractionRenderModelsChangedEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataInteractionRenderModelsChangedEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataInteractionRenderModelsChangedEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataInteractionRenderModelsChangedEXT*>(this);
  }
};
static_assert(sizeof(XrEventDataInteractionRenderModelsChangedEXT) ==
                  sizeof(EventDataInteractionRenderModelsChangedEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataInteractionRenderModelsChangedEXT pointer to
 * const from a EventDataInteractionRenderModelsChangedEXT reference to const.
 * @relates EventDataInteractionRenderModelsChangedEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInteractionRenderModelsChangedEXT const* get(
    EventDataInteractionRenderModelsChangedEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataInteractionRenderModelsChangedEXT as the address of a raw
 * XrEventDataInteractionRenderModelsChangedEXT
 * @relates EventDataInteractionRenderModelsChangedEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataInteractionRenderModelsChangedEXT* put(
    EventDataInteractionRenderModelsChangedEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_interaction_render_model

#ifdef XR_HTC_passthrough
/*!
 * C++ projection of XrPassthroughCreateInfoHTC
 *
 * Provided by the `XR_HTC_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughCreateInfoHTC>
 * @xrentity{XrPassthroughCreateInfoHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughCreateInfoHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughCreateInfoHTC(const PassthroughFormHTC& form_, const void* next_ = nullptr)
      : Parent(StructureType::PassthroughCreateInfoHTC, next_), form{form_} {}

  //! Default/empty constructor
  PassthroughCreateInfoHTC(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughCreateInfoHTC, next_), form{} {}

  //! Default copy constructor
  PassthroughCreateInfoHTC(const PassthroughCreateInfoHTC& rhs) = default;
  //! Default copy assignment
  PassthroughCreateInfoHTC& operator=(const PassthroughCreateInfoHTC& rhs) = default;
  //! Copy construct from raw
  PassthroughCreateInfoHTC(const XrPassthroughCreateInfoHTC& rhs) : PassthroughCreateInfoHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughCreateInfoHTC& operator=(const XrPassthroughCreateInfoHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughCreateInfoHTC&() const {
    return *reinterpret_cast<const XrPassthroughCreateInfoHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughCreateInfoHTC&() {
    return *reinterpret_cast<XrPassthroughCreateInfoHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughCreateInfoHTC
  XrPassthroughCreateInfoHTC const* get() const noexcept {
    return reinterpret_cast<XrPassthroughCreateInfoHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughCreateInfoHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughCreateInfoHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughCreateInfoHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughCreateInfoHTC*>(this);
  }
  PassthroughFormHTC form;
};
static_assert(sizeof(XrPassthroughCreateInfoHTC) == sizeof(PassthroughCreateInfoHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughCreateInfoHTC pointer to const from a
 * PassthroughCreateInfoHTC reference to const.
 * @relates PassthroughCreateInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughCreateInfoHTC const* get(PassthroughCreateInfoHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughCreateInfoHTC as
 * the address of a raw XrPassthroughCreateInfoHTC
 * @relates PassthroughCreateInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughCreateInfoHTC* put(PassthroughCreateInfoHTC& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_passthrough

#ifdef XR_HTC_passthrough
/*!
 * C++ projection of XrPassthroughColorHTC
 *
 * Provided by the `XR_HTC_passthrough` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorHTC>
 * @xrentity{XrPassthroughColorHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughColorHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughColorHTC(float alpha_, const void* next_ = nullptr)
      : Parent(StructureType::PassthroughColorHTC, next_), alpha{alpha_} {}

  //! Default/empty constructor
  PassthroughColorHTC(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughColorHTC, next_), alpha{0.0f} {}

  //! Default copy constructor
  PassthroughColorHTC(const PassthroughColorHTC& rhs) = default;
  //! Default copy assignment
  PassthroughColorHTC& operator=(const PassthroughColorHTC& rhs) = default;
  //! Copy construct from raw
  PassthroughColorHTC(const XrPassthroughColorHTC& rhs) : PassthroughColorHTC() { *put() = rhs; }
  //! Copy assign from raw
  PassthroughColorHTC& operator=(const XrPassthroughColorHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughColorHTC&() const {
    return *reinterpret_cast<const XrPassthroughColorHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughColorHTC&() { return *reinterpret_cast<XrPassthroughColorHTC*>(this); }

  //! Accessor for this as the address of a raw XrPassthroughColorHTC
  XrPassthroughColorHTC const* get() const noexcept {
    return reinterpret_cast<XrPassthroughColorHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrPassthroughColorHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughColorHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughColorHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughColorHTC*>(this);
  }
  float alpha;
};
static_assert(sizeof(XrPassthroughColorHTC) == sizeof(PassthroughColorHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughColorHTC pointer to const from a
 * PassthroughColorHTC reference to const.
 * @relates PassthroughColorHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorHTC const* get(PassthroughColorHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PassthroughColorHTC as the
 * address of a raw XrPassthroughColorHTC
 * @relates PassthroughColorHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughColorHTC* put(PassthroughColorHTC& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_passthrough

#ifdef XR_HTC_passthrough
/*!
 * C++ projection of XrPassthroughMeshTransformInfoHTC
 *
 * Provided by the `XR_HTC_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughMeshTransformInfoHTC>
 * @xrentity{XrPassthroughMeshTransformInfoHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PassthroughMeshTransformInfoHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PassthroughMeshTransformInfoHTC(uint32_t vertexCount_, const Vector3f* vertices_,
                                  uint32_t indexCount_, const uint32_t* indices_,
                                  const Space& baseSpace_, const Time& time_, const Posef& pose_,
                                  const Vector3f& scale_, const void* next_ = nullptr)
      : Parent(StructureType::PassthroughMeshTransformInfoHTC, next_),
        vertexCount{vertexCount_},
        vertices{vertices_},
        indexCount{indexCount_},
        indices{indices_},
        baseSpace{baseSpace_},
        time{time_},
        pose{pose_},
        scale{scale_} {}

  //! Default/empty constructor
  PassthroughMeshTransformInfoHTC(const void* next_ = nullptr)

      : Parent(StructureType::PassthroughMeshTransformInfoHTC, next_),
        vertexCount{0},
        vertices{nullptr},
        indexCount{0},
        indices{nullptr},
        baseSpace{},
        time{},
        pose{},
        scale{} {}

  //! Default copy constructor
  PassthroughMeshTransformInfoHTC(const PassthroughMeshTransformInfoHTC& rhs) = default;
  //! Default copy assignment
  PassthroughMeshTransformInfoHTC& operator=(const PassthroughMeshTransformInfoHTC& rhs) = default;
  //! Copy construct from raw
  PassthroughMeshTransformInfoHTC(const XrPassthroughMeshTransformInfoHTC& rhs)
      : PassthroughMeshTransformInfoHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PassthroughMeshTransformInfoHTC& operator=(const XrPassthroughMeshTransformInfoHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPassthroughMeshTransformInfoHTC&() const {
    return *reinterpret_cast<const XrPassthroughMeshTransformInfoHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPassthroughMeshTransformInfoHTC&() {
    return *reinterpret_cast<XrPassthroughMeshTransformInfoHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrPassthroughMeshTransformInfoHTC
  XrPassthroughMeshTransformInfoHTC const* get() const noexcept {
    return reinterpret_cast<XrPassthroughMeshTransformInfoHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPassthroughMeshTransformInfoHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPassthroughMeshTransformInfoHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PassthroughMeshTransformInfoHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrPassthroughMeshTransformInfoHTC*>(this);
  }
  uint32_t vertexCount;
  const Vector3f* vertices;
  uint32_t indexCount;
  const uint32_t* indices;
  Space baseSpace;
  Time time;
  Posef pose;
  Vector3f scale;
};
static_assert(sizeof(XrPassthroughMeshTransformInfoHTC) == sizeof(PassthroughMeshTransformInfoHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPassthroughMeshTransformInfoHTC pointer to const from a
 * PassthroughMeshTransformInfoHTC reference to const.
 * @relates PassthroughMeshTransformInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughMeshTransformInfoHTC const* get(
    PassthroughMeshTransformInfoHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * PassthroughMeshTransformInfoHTC as the address of a raw XrPassthroughMeshTransformInfoHTC
 * @relates PassthroughMeshTransformInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPassthroughMeshTransformInfoHTC* put(PassthroughMeshTransformInfoHTC& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_passthrough

#ifdef XR_HTC_passthrough
/*!
 * C++ projection of XrCompositionLayerPassthroughHTC
 *
 * Provided by the `XR_HTC_passthrough` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCompositionLayerPassthroughHTC>
 * @xrentity{XrCompositionLayerPassthroughHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CompositionLayerPassthroughHTC : public CompositionLayerBaseHeader {
private:
  using Parent = CompositionLayerBaseHeader;

public:
  //! Constructor initializing all members.
  CompositionLayerPassthroughHTC(const CompositionLayerFlags& layerFlags_, const Space& space_,
                                 const PassthroughHTC& passthrough_,
                                 const PassthroughColorHTC& color_, const void* next_ = nullptr)
      : Parent(StructureType::CompositionLayerPassthroughHTC, layerFlags_, space_, next_),
        passthrough{passthrough_},
        color{color_} {}

  //! Default/empty constructor
  CompositionLayerPassthroughHTC(const void* next_ = nullptr)

      : Parent(StructureType::CompositionLayerPassthroughHTC, {}, {}, next_),
        passthrough{},
        color{} {}

  //! Default copy constructor
  CompositionLayerPassthroughHTC(const CompositionLayerPassthroughHTC& rhs) = default;
  //! Default copy assignment
  CompositionLayerPassthroughHTC& operator=(const CompositionLayerPassthroughHTC& rhs) = default;
  //! Copy construct from raw
  CompositionLayerPassthroughHTC(const XrCompositionLayerPassthroughHTC& rhs)
      : CompositionLayerPassthroughHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CompositionLayerPassthroughHTC& operator=(const XrCompositionLayerPassthroughHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCompositionLayerPassthroughHTC&() const {
    return *reinterpret_cast<const XrCompositionLayerPassthroughHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCompositionLayerPassthroughHTC&() {
    return *reinterpret_cast<XrCompositionLayerPassthroughHTC*>(this);
  }

  //! Accessor for this as a raw, base XrCompositionLayerBaseHeader const pointer
  XrCompositionLayerBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrCompositionLayerBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrCompositionLayerPassthroughHTC
  XrCompositionLayerPassthroughHTC const* get() const noexcept {
    return reinterpret_cast<XrCompositionLayerPassthroughHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCompositionLayerPassthroughHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCompositionLayerPassthroughHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CompositionLayerPassthroughHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrCompositionLayerPassthroughHTC*>(this);
  }
  PassthroughHTC passthrough;
  PassthroughColorHTC color;
};
static_assert(sizeof(XrCompositionLayerPassthroughHTC) == sizeof(CompositionLayerPassthroughHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCompositionLayerPassthroughHTC pointer to const from a
 * CompositionLayerPassthroughHTC reference to const.
 * @relates CompositionLayerPassthroughHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerPassthroughHTC const* get(
    CompositionLayerPassthroughHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CompositionLayerPassthroughHTC as the address of a raw XrCompositionLayerPassthroughHTC
 * @relates CompositionLayerPassthroughHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerPassthroughHTC* put(CompositionLayerPassthroughHTC& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CompositionLayerPassthroughHTC as a raw,
 * pointer to const XrCompositionLayerBaseHeader (the base type)
 * @relates CompositionLayerPassthroughHTC
 * @relatesalso CompositionLayerBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCompositionLayerBaseHeader const* get_base(
    CompositionLayerPassthroughHTC const& h) {
  return h.get_base();
}
#endif  // XR_HTC_passthrough

#ifdef XR_HTC_foveation
/*!
 * C++ projection of XrFoveationApplyInfoHTC
 *
 * Provided by the `XR_HTC_foveation` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationApplyInfoHTC>
 * @xrentity{XrFoveationApplyInfoHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FoveationApplyInfoHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FoveationApplyInfoHTC(const FoveationModeHTC& mode_, uint32_t subImageCount_,
                        SwapchainSubImage* subImages_, const void* next_ = nullptr)
      : Parent(StructureType::FoveationApplyInfoHTC, next_),
        mode{mode_},
        subImageCount{subImageCount_},
        subImages{subImages_} {}

  //! Default/empty constructor
  FoveationApplyInfoHTC(const void* next_ = nullptr)

      : Parent(StructureType::FoveationApplyInfoHTC, next_),
        mode{},
        subImageCount{0},
        subImages{nullptr} {}

  //! Default copy constructor
  FoveationApplyInfoHTC(const FoveationApplyInfoHTC& rhs) = default;
  //! Default copy assignment
  FoveationApplyInfoHTC& operator=(const FoveationApplyInfoHTC& rhs) = default;
  //! Copy construct from raw
  FoveationApplyInfoHTC(const XrFoveationApplyInfoHTC& rhs) : FoveationApplyInfoHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FoveationApplyInfoHTC& operator=(const XrFoveationApplyInfoHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFoveationApplyInfoHTC&() const {
    return *reinterpret_cast<const XrFoveationApplyInfoHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFoveationApplyInfoHTC&() { return *reinterpret_cast<XrFoveationApplyInfoHTC*>(this); }

  //! Accessor for this as the address of a raw XrFoveationApplyInfoHTC
  XrFoveationApplyInfoHTC const* get() const noexcept {
    return reinterpret_cast<XrFoveationApplyInfoHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFoveationApplyInfoHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFoveationApplyInfoHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FoveationApplyInfoHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrFoveationApplyInfoHTC*>(this);
  }
  FoveationModeHTC mode;
  uint32_t subImageCount;
  SwapchainSubImage* subImages;
};
static_assert(sizeof(XrFoveationApplyInfoHTC) == sizeof(FoveationApplyInfoHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFoveationApplyInfoHTC pointer to const from a
 * FoveationApplyInfoHTC reference to const.
 * @relates FoveationApplyInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationApplyInfoHTC const* get(FoveationApplyInfoHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationApplyInfoHTC as the
 * address of a raw XrFoveationApplyInfoHTC
 * @relates FoveationApplyInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationApplyInfoHTC* put(FoveationApplyInfoHTC& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_foveation

#ifdef XR_HTC_foveation
/*!
 * C++ projection of XrFoveationConfigurationHTC
 *
 * Provided by the `XR_HTC_foveation` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationConfigurationHTC>
 * @xrentity{XrFoveationConfigurationHTC}
 * @ingroup structs
 */
struct XR_MAY_ALIAS FoveationConfigurationHTC {
public:
  //! Constructor initializing all members.
  FoveationConfigurationHTC(const FoveationLevelHTC& level_, float clearFovDegree_,
                            const Vector2f& focalCenterOffset_)
      : level{level_}, clearFovDegree{clearFovDegree_}, focalCenterOffset{focalCenterOffset_} {}

  //! Default/empty constructor
  FoveationConfigurationHTC()

      : level{}, clearFovDegree{0.0f}, focalCenterOffset{} {}

  //! Default copy constructor
  FoveationConfigurationHTC(const FoveationConfigurationHTC& rhs) = default;
  //! Default copy assignment
  FoveationConfigurationHTC& operator=(const FoveationConfigurationHTC& rhs) = default;
  //! Copy construct from raw
  FoveationConfigurationHTC(const XrFoveationConfigurationHTC& rhs) : FoveationConfigurationHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FoveationConfigurationHTC& operator=(const XrFoveationConfigurationHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFoveationConfigurationHTC&() const {
    return *reinterpret_cast<const XrFoveationConfigurationHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFoveationConfigurationHTC&() {
    return *reinterpret_cast<XrFoveationConfigurationHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrFoveationConfigurationHTC
  XrFoveationConfigurationHTC const* get() const noexcept {
    return reinterpret_cast<XrFoveationConfigurationHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFoveationConfigurationHTC.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrFoveationConfigurationHTC* put(bool clear = true) noexcept {
    if (clear) {
      *this = FoveationConfigurationHTC{};
    }
    return reinterpret_cast<XrFoveationConfigurationHTC*>(this);
  }
  FoveationLevelHTC level;
  float clearFovDegree;
  Vector2f focalCenterOffset;
};
static_assert(sizeof(XrFoveationConfigurationHTC) == sizeof(FoveationConfigurationHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFoveationConfigurationHTC pointer to const from a
 * FoveationConfigurationHTC reference to const.
 * @relates FoveationConfigurationHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationConfigurationHTC const* get(
    FoveationConfigurationHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationConfigurationHTC as
 * the address of a raw XrFoveationConfigurationHTC
 * @relates FoveationConfigurationHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationConfigurationHTC* put(FoveationConfigurationHTC& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_foveation

#ifdef XR_HTC_foveation
/*!
 * C++ projection of XrFoveationDynamicModeInfoHTC
 *
 * Provided by the `XR_HTC_foveation` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationDynamicModeInfoHTC>
 * @xrentity{XrFoveationDynamicModeInfoHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FoveationDynamicModeInfoHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FoveationDynamicModeInfoHTC(const FoveationDynamicFlagsHTC& dynamicFlags_,
                              const void* next_ = nullptr)
      : Parent(StructureType::FoveationDynamicModeInfoHTC, next_), dynamicFlags{dynamicFlags_} {}

  //! Default/empty constructor
  FoveationDynamicModeInfoHTC(const void* next_ = nullptr)

      : Parent(StructureType::FoveationDynamicModeInfoHTC, next_), dynamicFlags{} {}

  //! Default copy constructor
  FoveationDynamicModeInfoHTC(const FoveationDynamicModeInfoHTC& rhs) = default;
  //! Default copy assignment
  FoveationDynamicModeInfoHTC& operator=(const FoveationDynamicModeInfoHTC& rhs) = default;
  //! Copy construct from raw
  FoveationDynamicModeInfoHTC(const XrFoveationDynamicModeInfoHTC& rhs)
      : FoveationDynamicModeInfoHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FoveationDynamicModeInfoHTC& operator=(const XrFoveationDynamicModeInfoHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFoveationDynamicModeInfoHTC&() const {
    return *reinterpret_cast<const XrFoveationDynamicModeInfoHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFoveationDynamicModeInfoHTC&() {
    return *reinterpret_cast<XrFoveationDynamicModeInfoHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrFoveationDynamicModeInfoHTC
  XrFoveationDynamicModeInfoHTC const* get() const noexcept {
    return reinterpret_cast<XrFoveationDynamicModeInfoHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFoveationDynamicModeInfoHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFoveationDynamicModeInfoHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FoveationDynamicModeInfoHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrFoveationDynamicModeInfoHTC*>(this);
  }
  FoveationDynamicFlagsHTC dynamicFlags;
};
static_assert(sizeof(XrFoveationDynamicModeInfoHTC) == sizeof(FoveationDynamicModeInfoHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFoveationDynamicModeInfoHTC pointer to const from a
 * FoveationDynamicModeInfoHTC reference to const.
 * @relates FoveationDynamicModeInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationDynamicModeInfoHTC const* get(
    FoveationDynamicModeInfoHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationDynamicModeInfoHTC
 * as the address of a raw XrFoveationDynamicModeInfoHTC
 * @relates FoveationDynamicModeInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationDynamicModeInfoHTC* put(FoveationDynamicModeInfoHTC& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_foveation

#ifdef XR_HTC_foveation
/*!
 * C++ projection of XrFoveationCustomModeInfoHTC
 *
 * Provided by the `XR_HTC_foveation` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationCustomModeInfoHTC>
 * @xrentity{XrFoveationCustomModeInfoHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FoveationCustomModeInfoHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FoveationCustomModeInfoHTC(uint32_t configCount_, const FoveationConfigurationHTC* configs_,
                             const void* next_ = nullptr)
      : Parent(StructureType::FoveationCustomModeInfoHTC, next_),
        configCount{configCount_},
        configs{configs_} {}

  //! Default/empty constructor
  FoveationCustomModeInfoHTC(const void* next_ = nullptr)

      : Parent(StructureType::FoveationCustomModeInfoHTC, next_),
        configCount{0},
        configs{nullptr} {}

  //! Default copy constructor
  FoveationCustomModeInfoHTC(const FoveationCustomModeInfoHTC& rhs) = default;
  //! Default copy assignment
  FoveationCustomModeInfoHTC& operator=(const FoveationCustomModeInfoHTC& rhs) = default;
  //! Copy construct from raw
  FoveationCustomModeInfoHTC(const XrFoveationCustomModeInfoHTC& rhs)
      : FoveationCustomModeInfoHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FoveationCustomModeInfoHTC& operator=(const XrFoveationCustomModeInfoHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFoveationCustomModeInfoHTC&() const {
    return *reinterpret_cast<const XrFoveationCustomModeInfoHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFoveationCustomModeInfoHTC&() {
    return *reinterpret_cast<XrFoveationCustomModeInfoHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrFoveationCustomModeInfoHTC
  XrFoveationCustomModeInfoHTC const* get() const noexcept {
    return reinterpret_cast<XrFoveationCustomModeInfoHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFoveationCustomModeInfoHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFoveationCustomModeInfoHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FoveationCustomModeInfoHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrFoveationCustomModeInfoHTC*>(this);
  }
  uint32_t configCount;
  const FoveationConfigurationHTC* configs;
};
static_assert(sizeof(XrFoveationCustomModeInfoHTC) == sizeof(FoveationCustomModeInfoHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFoveationCustomModeInfoHTC pointer to const from a
 * FoveationCustomModeInfoHTC reference to const.
 * @relates FoveationCustomModeInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationCustomModeInfoHTC const* get(
    FoveationCustomModeInfoHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FoveationCustomModeInfoHTC as
 * the address of a raw XrFoveationCustomModeInfoHTC
 * @relates FoveationCustomModeInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFoveationCustomModeInfoHTC* put(FoveationCustomModeInfoHTC& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_foveation

#ifdef XR_HTC_anchor
/*!
 * C++ projection of XrSystemAnchorPropertiesHTC
 *
 * Provided by the `XR_HTC_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemAnchorPropertiesHTC>
 * @xrentity{XrSystemAnchorPropertiesHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemAnchorPropertiesHTC : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemAnchorPropertiesHTC(void* next_ = nullptr)

      : Parent(StructureType::SystemAnchorPropertiesHTC, next_) {}

  //! Default copy constructor
  SystemAnchorPropertiesHTC(const SystemAnchorPropertiesHTC& rhs) = default;
  //! Default copy assignment
  SystemAnchorPropertiesHTC& operator=(const SystemAnchorPropertiesHTC& rhs) = default;
  //! Copy construct from raw
  SystemAnchorPropertiesHTC(const XrSystemAnchorPropertiesHTC& rhs) : SystemAnchorPropertiesHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemAnchorPropertiesHTC& operator=(const XrSystemAnchorPropertiesHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemAnchorPropertiesHTC&() const {
    return *reinterpret_cast<const XrSystemAnchorPropertiesHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemAnchorPropertiesHTC&() {
    return *reinterpret_cast<XrSystemAnchorPropertiesHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemAnchorPropertiesHTC
  XrSystemAnchorPropertiesHTC const* get() const noexcept {
    return reinterpret_cast<XrSystemAnchorPropertiesHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemAnchorPropertiesHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemAnchorPropertiesHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemAnchorPropertiesHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemAnchorPropertiesHTC*>(this);
  }
  Bool32 supportsAnchor;
};
static_assert(sizeof(XrSystemAnchorPropertiesHTC) == sizeof(SystemAnchorPropertiesHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemAnchorPropertiesHTC pointer to const from a
 * SystemAnchorPropertiesHTC reference to const.
 * @relates SystemAnchorPropertiesHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemAnchorPropertiesHTC const* get(
    SystemAnchorPropertiesHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemAnchorPropertiesHTC as
 * the address of a raw XrSystemAnchorPropertiesHTC
 * @relates SystemAnchorPropertiesHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemAnchorPropertiesHTC* put(SystemAnchorPropertiesHTC& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_anchor

#ifdef XR_HTC_anchor
/*!
 * C++ projection of XrSpatialAnchorNameHTC
 *
 * Provided by the `XR_HTC_anchor` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorNameHTC>
 * @xrentity{XrSpatialAnchorNameHTC}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpatialAnchorNameHTC {
public:
  //! Constructor initializing all members.
  SpatialAnchorNameHTC(const char* name_) {
    if (nullptr != name_) {
#if defined(__STDC_LIB_EXT1__) || defined(_MSC_VER)
      strncpy_s(name, XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_HTC, name_,
                XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_HTC);
#else
      strncpy(name, name_, XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_HTC - 1);
      name[XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_HTC - 1] = '\0';
#endif
    }
  }

  //! Default/empty constructor
  SpatialAnchorNameHTC()

  {}

  //! Default copy constructor
  SpatialAnchorNameHTC(const SpatialAnchorNameHTC& rhs) = default;
  //! Default copy assignment
  SpatialAnchorNameHTC& operator=(const SpatialAnchorNameHTC& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorNameHTC(const XrSpatialAnchorNameHTC& rhs) : SpatialAnchorNameHTC() { *put() = rhs; }
  //! Copy assign from raw
  SpatialAnchorNameHTC& operator=(const XrSpatialAnchorNameHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorNameHTC&() const {
    return *reinterpret_cast<const XrSpatialAnchorNameHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorNameHTC&() { return *reinterpret_cast<XrSpatialAnchorNameHTC*>(this); }

  //! Accessor for this as the address of a raw XrSpatialAnchorNameHTC
  XrSpatialAnchorNameHTC const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorNameHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpatialAnchorNameHTC.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpatialAnchorNameHTC* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpatialAnchorNameHTC{};
    }
    return reinterpret_cast<XrSpatialAnchorNameHTC*>(this);
  }
  char name[XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_HTC];
};
static_assert(sizeof(XrSpatialAnchorNameHTC) == sizeof(SpatialAnchorNameHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorNameHTC pointer to const from a
 * SpatialAnchorNameHTC reference to const.
 * @relates SpatialAnchorNameHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorNameHTC const* get(SpatialAnchorNameHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorNameHTC as the
 * address of a raw XrSpatialAnchorNameHTC
 * @relates SpatialAnchorNameHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorNameHTC* put(SpatialAnchorNameHTC& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_anchor

#ifdef XR_HTC_anchor
/*!
 * C++ projection of XrSpatialAnchorCreateInfoHTC
 *
 * Provided by the `XR_HTC_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorCreateInfoHTC>
 * @xrentity{XrSpatialAnchorCreateInfoHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorCreateInfoHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorCreateInfoHTC(const Space& space_, const Posef& poseInSpace_,
                             const SpatialAnchorNameHTC& name_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorCreateInfoHTC, next_),
        space{space_},
        poseInSpace{poseInSpace_},
        name{name_} {}

  //! Default/empty constructor
  SpatialAnchorCreateInfoHTC(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorCreateInfoHTC, next_), space{}, poseInSpace{}, name{} {}

  //! Default copy constructor
  SpatialAnchorCreateInfoHTC(const SpatialAnchorCreateInfoHTC& rhs) = default;
  //! Default copy assignment
  SpatialAnchorCreateInfoHTC& operator=(const SpatialAnchorCreateInfoHTC& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorCreateInfoHTC(const XrSpatialAnchorCreateInfoHTC& rhs)
      : SpatialAnchorCreateInfoHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorCreateInfoHTC& operator=(const XrSpatialAnchorCreateInfoHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorCreateInfoHTC&() const {
    return *reinterpret_cast<const XrSpatialAnchorCreateInfoHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorCreateInfoHTC&() {
    return *reinterpret_cast<XrSpatialAnchorCreateInfoHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorCreateInfoHTC
  XrSpatialAnchorCreateInfoHTC const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorCreateInfoHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorCreateInfoHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorCreateInfoHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorCreateInfoHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorCreateInfoHTC*>(this);
  }
  Space space;
  Posef poseInSpace;
  SpatialAnchorNameHTC name;
};
static_assert(sizeof(XrSpatialAnchorCreateInfoHTC) == sizeof(SpatialAnchorCreateInfoHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorCreateInfoHTC pointer to const from a
 * SpatialAnchorCreateInfoHTC reference to const.
 * @relates SpatialAnchorCreateInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoHTC const* get(
    SpatialAnchorCreateInfoHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorCreateInfoHTC as
 * the address of a raw XrSpatialAnchorCreateInfoHTC
 * @relates SpatialAnchorCreateInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoHTC* put(SpatialAnchorCreateInfoHTC& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_anchor

#ifdef XR_HTC_body_tracking
/*!
 * C++ projection of XrSystemBodyTrackingPropertiesHTC
 *
 * Provided by the `XR_HTC_body_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemBodyTrackingPropertiesHTC>
 * @xrentity{XrSystemBodyTrackingPropertiesHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemBodyTrackingPropertiesHTC : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemBodyTrackingPropertiesHTC(void* next_ = nullptr)

      : Parent(StructureType::SystemBodyTrackingPropertiesHTC, next_) {}

  //! Default copy constructor
  SystemBodyTrackingPropertiesHTC(const SystemBodyTrackingPropertiesHTC& rhs) = default;
  //! Default copy assignment
  SystemBodyTrackingPropertiesHTC& operator=(const SystemBodyTrackingPropertiesHTC& rhs) = default;
  //! Copy construct from raw
  SystemBodyTrackingPropertiesHTC(const XrSystemBodyTrackingPropertiesHTC& rhs)
      : SystemBodyTrackingPropertiesHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemBodyTrackingPropertiesHTC& operator=(const XrSystemBodyTrackingPropertiesHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemBodyTrackingPropertiesHTC&() const {
    return *reinterpret_cast<const XrSystemBodyTrackingPropertiesHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemBodyTrackingPropertiesHTC&() {
    return *reinterpret_cast<XrSystemBodyTrackingPropertiesHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemBodyTrackingPropertiesHTC
  XrSystemBodyTrackingPropertiesHTC const* get() const noexcept {
    return reinterpret_cast<XrSystemBodyTrackingPropertiesHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemBodyTrackingPropertiesHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemBodyTrackingPropertiesHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemBodyTrackingPropertiesHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemBodyTrackingPropertiesHTC*>(this);
  }
  Bool32 supportsBodyTracking;
};
static_assert(sizeof(XrSystemBodyTrackingPropertiesHTC) == sizeof(SystemBodyTrackingPropertiesHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemBodyTrackingPropertiesHTC pointer to const from a
 * SystemBodyTrackingPropertiesHTC reference to const.
 * @relates SystemBodyTrackingPropertiesHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemBodyTrackingPropertiesHTC const* get(
    SystemBodyTrackingPropertiesHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemBodyTrackingPropertiesHTC as the address of a raw XrSystemBodyTrackingPropertiesHTC
 * @relates SystemBodyTrackingPropertiesHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemBodyTrackingPropertiesHTC* put(SystemBodyTrackingPropertiesHTC& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_body_tracking

#ifdef XR_HTC_body_tracking
/*!
 * C++ projection of XrBodyTrackerCreateInfoHTC
 *
 * Provided by the `XR_HTC_body_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyTrackerCreateInfoHTC>
 * @xrentity{XrBodyTrackerCreateInfoHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BodyTrackerCreateInfoHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  BodyTrackerCreateInfoHTC(const BodyJointSetHTC& bodyJointSet_, const void* next_ = nullptr)
      : Parent(StructureType::BodyTrackerCreateInfoHTC, next_), bodyJointSet{bodyJointSet_} {}

  //! Default/empty constructor
  BodyTrackerCreateInfoHTC(const void* next_ = nullptr)

      : Parent(StructureType::BodyTrackerCreateInfoHTC, next_), bodyJointSet{} {}

  //! Default copy constructor
  BodyTrackerCreateInfoHTC(const BodyTrackerCreateInfoHTC& rhs) = default;
  //! Default copy assignment
  BodyTrackerCreateInfoHTC& operator=(const BodyTrackerCreateInfoHTC& rhs) = default;
  //! Copy construct from raw
  BodyTrackerCreateInfoHTC(const XrBodyTrackerCreateInfoHTC& rhs) : BodyTrackerCreateInfoHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BodyTrackerCreateInfoHTC& operator=(const XrBodyTrackerCreateInfoHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodyTrackerCreateInfoHTC&() const {
    return *reinterpret_cast<const XrBodyTrackerCreateInfoHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodyTrackerCreateInfoHTC&() {
    return *reinterpret_cast<XrBodyTrackerCreateInfoHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrBodyTrackerCreateInfoHTC
  XrBodyTrackerCreateInfoHTC const* get() const noexcept {
    return reinterpret_cast<XrBodyTrackerCreateInfoHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrBodyTrackerCreateInfoHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBodyTrackerCreateInfoHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BodyTrackerCreateInfoHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrBodyTrackerCreateInfoHTC*>(this);
  }
  BodyJointSetHTC bodyJointSet;
};
static_assert(sizeof(XrBodyTrackerCreateInfoHTC) == sizeof(BodyTrackerCreateInfoHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodyTrackerCreateInfoHTC pointer to const from a
 * BodyTrackerCreateInfoHTC reference to const.
 * @relates BodyTrackerCreateInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyTrackerCreateInfoHTC const* get(BodyTrackerCreateInfoHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyTrackerCreateInfoHTC as
 * the address of a raw XrBodyTrackerCreateInfoHTC
 * @relates BodyTrackerCreateInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyTrackerCreateInfoHTC* put(BodyTrackerCreateInfoHTC& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_body_tracking

#ifdef XR_HTC_body_tracking
/*!
 * C++ projection of XrBodyJointsLocateInfoHTC
 *
 * Provided by the `XR_HTC_body_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointsLocateInfoHTC>
 * @xrentity{XrBodyJointsLocateInfoHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BodyJointsLocateInfoHTC : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  BodyJointsLocateInfoHTC(const Space& baseSpace_, const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::BodyJointsLocateInfoHTC, next_), baseSpace{baseSpace_}, time{time_} {}

  //! Default/empty constructor
  BodyJointsLocateInfoHTC(const void* next_ = nullptr)

      : Parent(StructureType::BodyJointsLocateInfoHTC, next_), baseSpace{}, time{} {}

  //! Default copy constructor
  BodyJointsLocateInfoHTC(const BodyJointsLocateInfoHTC& rhs) = default;
  //! Default copy assignment
  BodyJointsLocateInfoHTC& operator=(const BodyJointsLocateInfoHTC& rhs) = default;
  //! Copy construct from raw
  BodyJointsLocateInfoHTC(const XrBodyJointsLocateInfoHTC& rhs) : BodyJointsLocateInfoHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BodyJointsLocateInfoHTC& operator=(const XrBodyJointsLocateInfoHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodyJointsLocateInfoHTC&() const {
    return *reinterpret_cast<const XrBodyJointsLocateInfoHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodyJointsLocateInfoHTC&() {
    return *reinterpret_cast<XrBodyJointsLocateInfoHTC*>(this);
  }

  //! Accessor for this as the address of a raw XrBodyJointsLocateInfoHTC
  XrBodyJointsLocateInfoHTC const* get() const noexcept {
    return reinterpret_cast<XrBodyJointsLocateInfoHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrBodyJointsLocateInfoHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBodyJointsLocateInfoHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BodyJointsLocateInfoHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrBodyJointsLocateInfoHTC*>(this);
  }
  Space baseSpace;
  Time time;
};
static_assert(sizeof(XrBodyJointsLocateInfoHTC) == sizeof(BodyJointsLocateInfoHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodyJointsLocateInfoHTC pointer to const from a
 * BodyJointsLocateInfoHTC reference to const.
 * @relates BodyJointsLocateInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointsLocateInfoHTC const* get(BodyJointsLocateInfoHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyJointsLocateInfoHTC as
 * the address of a raw XrBodyJointsLocateInfoHTC
 * @relates BodyJointsLocateInfoHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointsLocateInfoHTC* put(BodyJointsLocateInfoHTC& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_body_tracking

#ifdef XR_HTC_body_tracking
/*!
 * C++ projection of XrBodyJointLocationHTC
 *
 * Provided by the `XR_HTC_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointLocationHTC>
 * @xrentity{XrBodyJointLocationHTC}
 * @ingroup structs
 */
struct XR_MAY_ALIAS BodyJointLocationHTC {
public:
  //! Empty constructor for a type that is marked as "returnonly"
  BodyJointLocationHTC()

  {}

  //! Default copy constructor
  BodyJointLocationHTC(const BodyJointLocationHTC& rhs) = default;
  //! Default copy assignment
  BodyJointLocationHTC& operator=(const BodyJointLocationHTC& rhs) = default;
  //! Copy construct from raw
  BodyJointLocationHTC(const XrBodyJointLocationHTC& rhs) : BodyJointLocationHTC() { *put() = rhs; }
  //! Copy assign from raw
  BodyJointLocationHTC& operator=(const XrBodyJointLocationHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodyJointLocationHTC&() const {
    return *reinterpret_cast<const XrBodyJointLocationHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodyJointLocationHTC&() { return *reinterpret_cast<XrBodyJointLocationHTC*>(this); }

  //! Accessor for this as the address of a raw XrBodyJointLocationHTC
  XrBodyJointLocationHTC const* get() const noexcept {
    return reinterpret_cast<XrBodyJointLocationHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBodyJointLocationHTC.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrBodyJointLocationHTC* put(bool clear = true) noexcept {
    if (clear) {
      *this = BodyJointLocationHTC{};
    }
    return reinterpret_cast<XrBodyJointLocationHTC*>(this);
  }
  SpaceLocationFlags locationFlags;
  Posef pose;
};
static_assert(sizeof(XrBodyJointLocationHTC) == sizeof(BodyJointLocationHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodyJointLocationHTC pointer to const from a
 * BodyJointLocationHTC reference to const.
 * @relates BodyJointLocationHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointLocationHTC const* get(BodyJointLocationHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyJointLocationHTC as the
 * address of a raw XrBodyJointLocationHTC
 * @relates BodyJointLocationHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointLocationHTC* put(BodyJointLocationHTC& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_body_tracking

#ifdef XR_HTC_body_tracking
/*!
 * C++ projection of XrBodyJointLocationsHTC
 *
 * Provided by the `XR_HTC_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointLocationsHTC>
 * @xrentity{XrBodyJointLocationsHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BodyJointLocationsHTC : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  BodyJointLocationsHTC(void* next_ = nullptr)

      : Parent(StructureType::BodyJointLocationsHTC, next_) {}

  //! Default copy constructor
  BodyJointLocationsHTC(const BodyJointLocationsHTC& rhs) = default;
  //! Default copy assignment
  BodyJointLocationsHTC& operator=(const BodyJointLocationsHTC& rhs) = default;
  //! Copy construct from raw
  BodyJointLocationsHTC(const XrBodyJointLocationsHTC& rhs) : BodyJointLocationsHTC() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BodyJointLocationsHTC& operator=(const XrBodyJointLocationsHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodyJointLocationsHTC&() const {
    return *reinterpret_cast<const XrBodyJointLocationsHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodyJointLocationsHTC&() { return *reinterpret_cast<XrBodyJointLocationsHTC*>(this); }

  //! Accessor for this as the address of a raw XrBodyJointLocationsHTC
  XrBodyJointLocationsHTC const* get() const noexcept {
    return reinterpret_cast<XrBodyJointLocationsHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBodyJointLocationsHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBodyJointLocationsHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BodyJointLocationsHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrBodyJointLocationsHTC*>(this);
  }
  SpaceLocationFlags combinedLocationFlags;
  BodyJointConfidenceHTC confidenceLevel;
  uint32_t jointLocationCount;
  BodyJointLocationHTC* jointLocations;
  uint32_t skeletonGenerationId;
};
static_assert(sizeof(XrBodyJointLocationsHTC) == sizeof(BodyJointLocationsHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodyJointLocationsHTC pointer to const from a
 * BodyJointLocationsHTC reference to const.
 * @relates BodyJointLocationsHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointLocationsHTC const* get(BodyJointLocationsHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyJointLocationsHTC as the
 * address of a raw XrBodyJointLocationsHTC
 * @relates BodyJointLocationsHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointLocationsHTC* put(BodyJointLocationsHTC& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_body_tracking

#ifdef XR_HTC_body_tracking
/*!
 * C++ projection of XrBodySkeletonJointHTC
 *
 * Provided by the `XR_HTC_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodySkeletonJointHTC>
 * @xrentity{XrBodySkeletonJointHTC}
 * @ingroup structs
 */
struct XR_MAY_ALIAS BodySkeletonJointHTC {
public:
  //! Constructor initializing all members.
  BodySkeletonJointHTC(const Posef& pose_) : pose{pose_} {}

  //! Default/empty constructor
  BodySkeletonJointHTC()

      : pose{} {}

  //! Default copy constructor
  BodySkeletonJointHTC(const BodySkeletonJointHTC& rhs) = default;
  //! Default copy assignment
  BodySkeletonJointHTC& operator=(const BodySkeletonJointHTC& rhs) = default;
  //! Copy construct from raw
  BodySkeletonJointHTC(const XrBodySkeletonJointHTC& rhs) : BodySkeletonJointHTC() { *put() = rhs; }
  //! Copy assign from raw
  BodySkeletonJointHTC& operator=(const XrBodySkeletonJointHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodySkeletonJointHTC&() const {
    return *reinterpret_cast<const XrBodySkeletonJointHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodySkeletonJointHTC&() { return *reinterpret_cast<XrBodySkeletonJointHTC*>(this); }

  //! Accessor for this as the address of a raw XrBodySkeletonJointHTC
  XrBodySkeletonJointHTC const* get() const noexcept {
    return reinterpret_cast<XrBodySkeletonJointHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBodySkeletonJointHTC.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrBodySkeletonJointHTC* put(bool clear = true) noexcept {
    if (clear) {
      *this = BodySkeletonJointHTC{};
    }
    return reinterpret_cast<XrBodySkeletonJointHTC*>(this);
  }
  Posef pose;
};
static_assert(sizeof(XrBodySkeletonJointHTC) == sizeof(BodySkeletonJointHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodySkeletonJointHTC pointer to const from a
 * BodySkeletonJointHTC reference to const.
 * @relates BodySkeletonJointHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodySkeletonJointHTC const* get(BodySkeletonJointHTC const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodySkeletonJointHTC as the
 * address of a raw XrBodySkeletonJointHTC
 * @relates BodySkeletonJointHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodySkeletonJointHTC* put(BodySkeletonJointHTC& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_body_tracking

#ifdef XR_HTC_body_tracking
/*!
 * C++ projection of XrBodySkeletonHTC
 *
 * Provided by the `XR_HTC_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodySkeletonHTC>
 * @xrentity{XrBodySkeletonHTC}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BodySkeletonHTC : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  BodySkeletonHTC(void* next_ = nullptr)

      : Parent(StructureType::BodySkeletonHTC, next_) {}

  //! Default copy constructor
  BodySkeletonHTC(const BodySkeletonHTC& rhs) = default;
  //! Default copy assignment
  BodySkeletonHTC& operator=(const BodySkeletonHTC& rhs) = default;
  //! Copy construct from raw
  BodySkeletonHTC(const XrBodySkeletonHTC& rhs) : BodySkeletonHTC() { *put() = rhs; }
  //! Copy assign from raw
  BodySkeletonHTC& operator=(const XrBodySkeletonHTC& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodySkeletonHTC&() const {
    return *reinterpret_cast<const XrBodySkeletonHTC*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodySkeletonHTC&() { return *reinterpret_cast<XrBodySkeletonHTC*>(this); }

  //! Accessor for this as the address of a raw XrBodySkeletonHTC
  XrBodySkeletonHTC const* get() const noexcept {
    return reinterpret_cast<XrBodySkeletonHTC const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBodySkeletonHTC.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBodySkeletonHTC* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BodySkeletonHTC{};
      next = oldNext;
    }
    return reinterpret_cast<XrBodySkeletonHTC*>(this);
  }
  uint32_t jointCount;
  BodySkeletonJointHTC* joints;
};
static_assert(sizeof(XrBodySkeletonHTC) == sizeof(BodySkeletonHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodySkeletonHTC pointer to const from a BodySkeletonHTC
 * reference to const.
 * @relates BodySkeletonHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodySkeletonHTC const* get(BodySkeletonHTC const& s) { return s.get(); }

/*!
 * @brief Free function accessor for clearing (by default) and passing BodySkeletonHTC as the
 * address of a raw XrBodySkeletonHTC
 * @relates BodySkeletonHTC
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodySkeletonHTC* put(BodySkeletonHTC& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_HTC_body_tracking

#ifdef XR_EXT_active_action_set_priority
/*!
 * C++ projection of XrActiveActionSetPriorityEXT
 *
 * Provided by the `XR_EXT_active_action_set_priority` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActiveActionSetPriorityEXT>
 * @xrentity{XrActiveActionSetPriorityEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ActiveActionSetPriorityEXT {
public:
  //! Constructor initializing all members.
  ActiveActionSetPriorityEXT(const ActionSet& actionSet_, uint32_t priorityOverride_)
      : actionSet{actionSet_}, priorityOverride{priorityOverride_} {}

  //! Default/empty constructor
  ActiveActionSetPriorityEXT()

      : actionSet{}, priorityOverride{0} {}

  //! Default copy constructor
  ActiveActionSetPriorityEXT(const ActiveActionSetPriorityEXT& rhs) = default;
  //! Default copy assignment
  ActiveActionSetPriorityEXT& operator=(const ActiveActionSetPriorityEXT& rhs) = default;
  //! Copy construct from raw
  ActiveActionSetPriorityEXT(const XrActiveActionSetPriorityEXT& rhs)
      : ActiveActionSetPriorityEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ActiveActionSetPriorityEXT& operator=(const XrActiveActionSetPriorityEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActiveActionSetPriorityEXT&() const {
    return *reinterpret_cast<const XrActiveActionSetPriorityEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActiveActionSetPriorityEXT&() {
    return *reinterpret_cast<XrActiveActionSetPriorityEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrActiveActionSetPriorityEXT
  XrActiveActionSetPriorityEXT const* get() const noexcept {
    return reinterpret_cast<XrActiveActionSetPriorityEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrActiveActionSetPriorityEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrActiveActionSetPriorityEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = ActiveActionSetPriorityEXT{};
    }
    return reinterpret_cast<XrActiveActionSetPriorityEXT*>(this);
  }
  ActionSet actionSet;
  uint32_t priorityOverride;
};
static_assert(sizeof(XrActiveActionSetPriorityEXT) == sizeof(ActiveActionSetPriorityEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActiveActionSetPriorityEXT pointer to const from a
 * ActiveActionSetPriorityEXT reference to const.
 * @relates ActiveActionSetPriorityEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActiveActionSetPriorityEXT const* get(
    ActiveActionSetPriorityEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActiveActionSetPriorityEXT as
 * the address of a raw XrActiveActionSetPriorityEXT
 * @relates ActiveActionSetPriorityEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActiveActionSetPriorityEXT* put(ActiveActionSetPriorityEXT& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_active_action_set_priority

#ifdef XR_EXT_active_action_set_priority
/*!
 * C++ projection of XrActiveActionSetPrioritiesEXT
 *
 * Provided by the `XR_EXT_active_action_set_priority` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActiveActionSetPrioritiesEXT>
 * @xrentity{XrActiveActionSetPrioritiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ActiveActionSetPrioritiesEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ActiveActionSetPrioritiesEXT(uint32_t actionSetPriorityCount_,
                               const ActiveActionSetPriorityEXT* actionSetPriorities_,
                               const void* next_ = nullptr)
      : Parent(StructureType::ActiveActionSetPrioritiesEXT, next_),
        actionSetPriorityCount{actionSetPriorityCount_},
        actionSetPriorities{actionSetPriorities_} {}

  //! Default/empty constructor
  ActiveActionSetPrioritiesEXT(const void* next_ = nullptr)

      : Parent(StructureType::ActiveActionSetPrioritiesEXT, next_),
        actionSetPriorityCount{0},
        actionSetPriorities{nullptr} {}

  //! Default copy constructor
  ActiveActionSetPrioritiesEXT(const ActiveActionSetPrioritiesEXT& rhs) = default;
  //! Default copy assignment
  ActiveActionSetPrioritiesEXT& operator=(const ActiveActionSetPrioritiesEXT& rhs) = default;
  //! Copy construct from raw
  ActiveActionSetPrioritiesEXT(const XrActiveActionSetPrioritiesEXT& rhs)
      : ActiveActionSetPrioritiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ActiveActionSetPrioritiesEXT& operator=(const XrActiveActionSetPrioritiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrActiveActionSetPrioritiesEXT&() const {
    return *reinterpret_cast<const XrActiveActionSetPrioritiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrActiveActionSetPrioritiesEXT&() {
    return *reinterpret_cast<XrActiveActionSetPrioritiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrActiveActionSetPrioritiesEXT
  XrActiveActionSetPrioritiesEXT const* get() const noexcept {
    return reinterpret_cast<XrActiveActionSetPrioritiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrActiveActionSetPrioritiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrActiveActionSetPrioritiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ActiveActionSetPrioritiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrActiveActionSetPrioritiesEXT*>(this);
  }
  uint32_t actionSetPriorityCount;
  const ActiveActionSetPriorityEXT* actionSetPriorities;
};
static_assert(sizeof(XrActiveActionSetPrioritiesEXT) == sizeof(ActiveActionSetPrioritiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrActiveActionSetPrioritiesEXT pointer to const from a
 * ActiveActionSetPrioritiesEXT reference to const.
 * @relates ActiveActionSetPrioritiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActiveActionSetPrioritiesEXT const* get(
    ActiveActionSetPrioritiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing ActiveActionSetPrioritiesEXT
 * as the address of a raw XrActiveActionSetPrioritiesEXT
 * @relates ActiveActionSetPrioritiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrActiveActionSetPrioritiesEXT* put(ActiveActionSetPrioritiesEXT& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_active_action_set_priority

#ifdef XR_MNDX_force_feedback_curl
/*!
 * C++ projection of XrSystemForceFeedbackCurlPropertiesMNDX
 *
 * Provided by the `XR_MNDX_force_feedback_curl` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemForceFeedbackCurlPropertiesMNDX>
 * @xrentity{XrSystemForceFeedbackCurlPropertiesMNDX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemForceFeedbackCurlPropertiesMNDX : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemForceFeedbackCurlPropertiesMNDX(void* next_ = nullptr)

      : Parent(StructureType::SystemForceFeedbackCurlPropertiesMNDX, next_) {}

  //! Default copy constructor
  SystemForceFeedbackCurlPropertiesMNDX(const SystemForceFeedbackCurlPropertiesMNDX& rhs) = default;
  //! Default copy assignment
  SystemForceFeedbackCurlPropertiesMNDX& operator=(
      const SystemForceFeedbackCurlPropertiesMNDX& rhs) = default;
  //! Copy construct from raw
  SystemForceFeedbackCurlPropertiesMNDX(const XrSystemForceFeedbackCurlPropertiesMNDX& rhs)
      : SystemForceFeedbackCurlPropertiesMNDX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemForceFeedbackCurlPropertiesMNDX& operator=(
      const XrSystemForceFeedbackCurlPropertiesMNDX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemForceFeedbackCurlPropertiesMNDX&() const {
    return *reinterpret_cast<const XrSystemForceFeedbackCurlPropertiesMNDX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemForceFeedbackCurlPropertiesMNDX&() {
    return *reinterpret_cast<XrSystemForceFeedbackCurlPropertiesMNDX*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemForceFeedbackCurlPropertiesMNDX
  XrSystemForceFeedbackCurlPropertiesMNDX const* get() const noexcept {
    return reinterpret_cast<XrSystemForceFeedbackCurlPropertiesMNDX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemForceFeedbackCurlPropertiesMNDX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemForceFeedbackCurlPropertiesMNDX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemForceFeedbackCurlPropertiesMNDX{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemForceFeedbackCurlPropertiesMNDX*>(this);
  }
  Bool32 supportsForceFeedbackCurl;
};
static_assert(sizeof(XrSystemForceFeedbackCurlPropertiesMNDX) ==
                  sizeof(SystemForceFeedbackCurlPropertiesMNDX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemForceFeedbackCurlPropertiesMNDX pointer to const
 * from a SystemForceFeedbackCurlPropertiesMNDX reference to const.
 * @relates SystemForceFeedbackCurlPropertiesMNDX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemForceFeedbackCurlPropertiesMNDX const* get(
    SystemForceFeedbackCurlPropertiesMNDX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemForceFeedbackCurlPropertiesMNDX as the address of a raw
 * XrSystemForceFeedbackCurlPropertiesMNDX
 * @relates SystemForceFeedbackCurlPropertiesMNDX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemForceFeedbackCurlPropertiesMNDX* put(
    SystemForceFeedbackCurlPropertiesMNDX& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MNDX_force_feedback_curl

#ifdef XR_MNDX_force_feedback_curl
/*!
 * C++ projection of XrForceFeedbackCurlApplyLocationMNDX
 *
 * Provided by the `XR_MNDX_force_feedback_curl` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrForceFeedbackCurlApplyLocationMNDX>
 * @xrentity{XrForceFeedbackCurlApplyLocationMNDX}
 * @ingroup structs
 */
struct XR_MAY_ALIAS ForceFeedbackCurlApplyLocationMNDX {
public:
  //! Constructor initializing all members.
  ForceFeedbackCurlApplyLocationMNDX(const ForceFeedbackCurlLocationMNDX& location_, float value_)
      : location{location_}, value{value_} {}

  //! Default/empty constructor
  ForceFeedbackCurlApplyLocationMNDX()

      : location{}, value{0.0f} {}

  //! Default copy constructor
  ForceFeedbackCurlApplyLocationMNDX(const ForceFeedbackCurlApplyLocationMNDX& rhs) = default;
  //! Default copy assignment
  ForceFeedbackCurlApplyLocationMNDX& operator=(const ForceFeedbackCurlApplyLocationMNDX& rhs) =
      default;
  //! Copy construct from raw
  ForceFeedbackCurlApplyLocationMNDX(const XrForceFeedbackCurlApplyLocationMNDX& rhs)
      : ForceFeedbackCurlApplyLocationMNDX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ForceFeedbackCurlApplyLocationMNDX& operator=(const XrForceFeedbackCurlApplyLocationMNDX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrForceFeedbackCurlApplyLocationMNDX&() const {
    return *reinterpret_cast<const XrForceFeedbackCurlApplyLocationMNDX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrForceFeedbackCurlApplyLocationMNDX&() {
    return *reinterpret_cast<XrForceFeedbackCurlApplyLocationMNDX*>(this);
  }

  //! Accessor for this as the address of a raw XrForceFeedbackCurlApplyLocationMNDX
  XrForceFeedbackCurlApplyLocationMNDX const* get() const noexcept {
    return reinterpret_cast<XrForceFeedbackCurlApplyLocationMNDX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrForceFeedbackCurlApplyLocationMNDX.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrForceFeedbackCurlApplyLocationMNDX* put(bool clear = true) noexcept {
    if (clear) {
      *this = ForceFeedbackCurlApplyLocationMNDX{};
    }
    return reinterpret_cast<XrForceFeedbackCurlApplyLocationMNDX*>(this);
  }
  ForceFeedbackCurlLocationMNDX location;
  float value;
};
static_assert(sizeof(XrForceFeedbackCurlApplyLocationMNDX) ==
                  sizeof(ForceFeedbackCurlApplyLocationMNDX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrForceFeedbackCurlApplyLocationMNDX pointer to const from
 * a ForceFeedbackCurlApplyLocationMNDX reference to const.
 * @relates ForceFeedbackCurlApplyLocationMNDX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrForceFeedbackCurlApplyLocationMNDX const* get(
    ForceFeedbackCurlApplyLocationMNDX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ForceFeedbackCurlApplyLocationMNDX as the address of a raw XrForceFeedbackCurlApplyLocationMNDX
 * @relates ForceFeedbackCurlApplyLocationMNDX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrForceFeedbackCurlApplyLocationMNDX* put(
    ForceFeedbackCurlApplyLocationMNDX& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MNDX_force_feedback_curl

#ifdef XR_MNDX_force_feedback_curl
/*!
 * C++ projection of XrForceFeedbackCurlApplyLocationsMNDX
 *
 * Provided by the `XR_MNDX_force_feedback_curl` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrForceFeedbackCurlApplyLocationsMNDX>
 * @xrentity{XrForceFeedbackCurlApplyLocationsMNDX}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ForceFeedbackCurlApplyLocationsMNDX : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ForceFeedbackCurlApplyLocationsMNDX(uint32_t locationCount_,
                                      ForceFeedbackCurlApplyLocationMNDX* locations_,
                                      const void* next_ = nullptr)
      : Parent(StructureType::ForceFeedbackCurlApplyLocationsMNDX, next_),
        locationCount{locationCount_},
        locations{locations_} {}

  //! Default/empty constructor
  ForceFeedbackCurlApplyLocationsMNDX(const void* next_ = nullptr)

      : Parent(StructureType::ForceFeedbackCurlApplyLocationsMNDX, next_),
        locationCount{0},
        locations{nullptr} {}

  //! Default copy constructor
  ForceFeedbackCurlApplyLocationsMNDX(const ForceFeedbackCurlApplyLocationsMNDX& rhs) = default;
  //! Default copy assignment
  ForceFeedbackCurlApplyLocationsMNDX& operator=(const ForceFeedbackCurlApplyLocationsMNDX& rhs) =
      default;
  //! Copy construct from raw
  ForceFeedbackCurlApplyLocationsMNDX(const XrForceFeedbackCurlApplyLocationsMNDX& rhs)
      : ForceFeedbackCurlApplyLocationsMNDX() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ForceFeedbackCurlApplyLocationsMNDX& operator=(const XrForceFeedbackCurlApplyLocationsMNDX& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrForceFeedbackCurlApplyLocationsMNDX&() const {
    return *reinterpret_cast<const XrForceFeedbackCurlApplyLocationsMNDX*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrForceFeedbackCurlApplyLocationsMNDX&() {
    return *reinterpret_cast<XrForceFeedbackCurlApplyLocationsMNDX*>(this);
  }

  //! Accessor for this as the address of a raw XrForceFeedbackCurlApplyLocationsMNDX
  XrForceFeedbackCurlApplyLocationsMNDX const* get() const noexcept {
    return reinterpret_cast<XrForceFeedbackCurlApplyLocationsMNDX const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrForceFeedbackCurlApplyLocationsMNDX.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrForceFeedbackCurlApplyLocationsMNDX* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ForceFeedbackCurlApplyLocationsMNDX{};
      next = oldNext;
    }
    return reinterpret_cast<XrForceFeedbackCurlApplyLocationsMNDX*>(this);
  }
  uint32_t locationCount;
  ForceFeedbackCurlApplyLocationMNDX* locations;
};
static_assert(sizeof(XrForceFeedbackCurlApplyLocationsMNDX) ==
                  sizeof(ForceFeedbackCurlApplyLocationsMNDX),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrForceFeedbackCurlApplyLocationsMNDX pointer to const
 * from a ForceFeedbackCurlApplyLocationsMNDX reference to const.
 * @relates ForceFeedbackCurlApplyLocationsMNDX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrForceFeedbackCurlApplyLocationsMNDX const* get(
    ForceFeedbackCurlApplyLocationsMNDX const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ForceFeedbackCurlApplyLocationsMNDX as the address of a raw XrForceFeedbackCurlApplyLocationsMNDX
 * @relates ForceFeedbackCurlApplyLocationsMNDX
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrForceFeedbackCurlApplyLocationsMNDX* put(
    ForceFeedbackCurlApplyLocationsMNDX& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_MNDX_force_feedback_curl

#ifdef XR_BD_body_tracking
/*!
 * C++ projection of XrSystemBodyTrackingPropertiesBD
 *
 * Provided by the `XR_BD_body_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemBodyTrackingPropertiesBD>
 * @xrentity{XrSystemBodyTrackingPropertiesBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemBodyTrackingPropertiesBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemBodyTrackingPropertiesBD(void* next_ = nullptr)

      : Parent(StructureType::SystemBodyTrackingPropertiesBD, next_) {}

  //! Default copy constructor
  SystemBodyTrackingPropertiesBD(const SystemBodyTrackingPropertiesBD& rhs) = default;
  //! Default copy assignment
  SystemBodyTrackingPropertiesBD& operator=(const SystemBodyTrackingPropertiesBD& rhs) = default;
  //! Copy construct from raw
  SystemBodyTrackingPropertiesBD(const XrSystemBodyTrackingPropertiesBD& rhs)
      : SystemBodyTrackingPropertiesBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemBodyTrackingPropertiesBD& operator=(const XrSystemBodyTrackingPropertiesBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemBodyTrackingPropertiesBD&() const {
    return *reinterpret_cast<const XrSystemBodyTrackingPropertiesBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemBodyTrackingPropertiesBD&() {
    return *reinterpret_cast<XrSystemBodyTrackingPropertiesBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemBodyTrackingPropertiesBD
  XrSystemBodyTrackingPropertiesBD const* get() const noexcept {
    return reinterpret_cast<XrSystemBodyTrackingPropertiesBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemBodyTrackingPropertiesBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemBodyTrackingPropertiesBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemBodyTrackingPropertiesBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemBodyTrackingPropertiesBD*>(this);
  }
  Bool32 supportsBodyTracking;
};
static_assert(sizeof(XrSystemBodyTrackingPropertiesBD) == sizeof(SystemBodyTrackingPropertiesBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemBodyTrackingPropertiesBD pointer to const from a
 * SystemBodyTrackingPropertiesBD reference to const.
 * @relates SystemBodyTrackingPropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemBodyTrackingPropertiesBD const* get(
    SystemBodyTrackingPropertiesBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemBodyTrackingPropertiesBD as the address of a raw XrSystemBodyTrackingPropertiesBD
 * @relates SystemBodyTrackingPropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemBodyTrackingPropertiesBD* put(SystemBodyTrackingPropertiesBD& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_body_tracking

#ifdef XR_BD_body_tracking
/*!
 * C++ projection of XrBodyTrackerCreateInfoBD
 *
 * Provided by the `XR_BD_body_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyTrackerCreateInfoBD>
 * @xrentity{XrBodyTrackerCreateInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BodyTrackerCreateInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  BodyTrackerCreateInfoBD(const BodyJointSetBD& jointSet_, const void* next_ = nullptr)
      : Parent(StructureType::BodyTrackerCreateInfoBD, next_), jointSet{jointSet_} {}

  //! Default/empty constructor
  BodyTrackerCreateInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::BodyTrackerCreateInfoBD, next_), jointSet{} {}

  //! Default copy constructor
  BodyTrackerCreateInfoBD(const BodyTrackerCreateInfoBD& rhs) = default;
  //! Default copy assignment
  BodyTrackerCreateInfoBD& operator=(const BodyTrackerCreateInfoBD& rhs) = default;
  //! Copy construct from raw
  BodyTrackerCreateInfoBD(const XrBodyTrackerCreateInfoBD& rhs) : BodyTrackerCreateInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BodyTrackerCreateInfoBD& operator=(const XrBodyTrackerCreateInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodyTrackerCreateInfoBD&() const {
    return *reinterpret_cast<const XrBodyTrackerCreateInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodyTrackerCreateInfoBD&() {
    return *reinterpret_cast<XrBodyTrackerCreateInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrBodyTrackerCreateInfoBD
  XrBodyTrackerCreateInfoBD const* get() const noexcept {
    return reinterpret_cast<XrBodyTrackerCreateInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrBodyTrackerCreateInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBodyTrackerCreateInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BodyTrackerCreateInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrBodyTrackerCreateInfoBD*>(this);
  }
  BodyJointSetBD jointSet;
};
static_assert(sizeof(XrBodyTrackerCreateInfoBD) == sizeof(BodyTrackerCreateInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodyTrackerCreateInfoBD pointer to const from a
 * BodyTrackerCreateInfoBD reference to const.
 * @relates BodyTrackerCreateInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyTrackerCreateInfoBD const* get(BodyTrackerCreateInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyTrackerCreateInfoBD as
 * the address of a raw XrBodyTrackerCreateInfoBD
 * @relates BodyTrackerCreateInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyTrackerCreateInfoBD* put(BodyTrackerCreateInfoBD& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_body_tracking

#ifdef XR_BD_body_tracking
/*!
 * C++ projection of XrBodyJointsLocateInfoBD
 *
 * Provided by the `XR_BD_body_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointsLocateInfoBD>
 * @xrentity{XrBodyJointsLocateInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BodyJointsLocateInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  BodyJointsLocateInfoBD(const Space& baseSpace_, const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::BodyJointsLocateInfoBD, next_), baseSpace{baseSpace_}, time{time_} {}

  //! Default/empty constructor
  BodyJointsLocateInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::BodyJointsLocateInfoBD, next_), baseSpace{}, time{} {}

  //! Default copy constructor
  BodyJointsLocateInfoBD(const BodyJointsLocateInfoBD& rhs) = default;
  //! Default copy assignment
  BodyJointsLocateInfoBD& operator=(const BodyJointsLocateInfoBD& rhs) = default;
  //! Copy construct from raw
  BodyJointsLocateInfoBD(const XrBodyJointsLocateInfoBD& rhs) : BodyJointsLocateInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  BodyJointsLocateInfoBD& operator=(const XrBodyJointsLocateInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodyJointsLocateInfoBD&() const {
    return *reinterpret_cast<const XrBodyJointsLocateInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodyJointsLocateInfoBD&() {
    return *reinterpret_cast<XrBodyJointsLocateInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrBodyJointsLocateInfoBD
  XrBodyJointsLocateInfoBD const* get() const noexcept {
    return reinterpret_cast<XrBodyJointsLocateInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBodyJointsLocateInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBodyJointsLocateInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BodyJointsLocateInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrBodyJointsLocateInfoBD*>(this);
  }
  Space baseSpace;
  Time time;
};
static_assert(sizeof(XrBodyJointsLocateInfoBD) == sizeof(BodyJointsLocateInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodyJointsLocateInfoBD pointer to const from a
 * BodyJointsLocateInfoBD reference to const.
 * @relates BodyJointsLocateInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointsLocateInfoBD const* get(BodyJointsLocateInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyJointsLocateInfoBD as the
 * address of a raw XrBodyJointsLocateInfoBD
 * @relates BodyJointsLocateInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointsLocateInfoBD* put(BodyJointsLocateInfoBD& s,
                                                       bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_body_tracking

#ifdef XR_BD_body_tracking
/*!
 * C++ projection of XrBodyJointLocationBD
 *
 * Provided by the `XR_BD_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointLocationBD>
 * @xrentity{XrBodyJointLocationBD}
 * @ingroup structs
 */
struct XR_MAY_ALIAS BodyJointLocationBD {
public:
  //! Constructor initializing all members.
  BodyJointLocationBD(const SpaceLocationFlags& locationFlags_, const Posef& pose_)
      : locationFlags{locationFlags_}, pose{pose_} {}

  //! Default/empty constructor
  BodyJointLocationBD()

      : locationFlags{}, pose{} {}

  //! Default copy constructor
  BodyJointLocationBD(const BodyJointLocationBD& rhs) = default;
  //! Default copy assignment
  BodyJointLocationBD& operator=(const BodyJointLocationBD& rhs) = default;
  //! Copy construct from raw
  BodyJointLocationBD(const XrBodyJointLocationBD& rhs) : BodyJointLocationBD() { *put() = rhs; }
  //! Copy assign from raw
  BodyJointLocationBD& operator=(const XrBodyJointLocationBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodyJointLocationBD&() const {
    return *reinterpret_cast<const XrBodyJointLocationBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodyJointLocationBD&() { return *reinterpret_cast<XrBodyJointLocationBD*>(this); }

  //! Accessor for this as the address of a raw XrBodyJointLocationBD
  XrBodyJointLocationBD const* get() const noexcept {
    return reinterpret_cast<XrBodyJointLocationBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBodyJointLocationBD.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrBodyJointLocationBD* put(bool clear = true) noexcept {
    if (clear) {
      *this = BodyJointLocationBD{};
    }
    return reinterpret_cast<XrBodyJointLocationBD*>(this);
  }
  SpaceLocationFlags locationFlags;
  Posef pose;
};
static_assert(sizeof(XrBodyJointLocationBD) == sizeof(BodyJointLocationBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodyJointLocationBD pointer to const from a
 * BodyJointLocationBD reference to const.
 * @relates BodyJointLocationBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointLocationBD const* get(BodyJointLocationBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyJointLocationBD as the
 * address of a raw XrBodyJointLocationBD
 * @relates BodyJointLocationBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointLocationBD* put(BodyJointLocationBD& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_body_tracking

#ifdef XR_BD_body_tracking
/*!
 * C++ projection of XrBodyJointLocationsBD
 *
 * Provided by the `XR_BD_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyJointLocationsBD>
 * @xrentity{XrBodyJointLocationsBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS BodyJointLocationsBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  BodyJointLocationsBD(void* next_ = nullptr)

      : Parent(StructureType::BodyJointLocationsBD, next_) {}

  //! Default copy constructor
  BodyJointLocationsBD(const BodyJointLocationsBD& rhs) = default;
  //! Default copy assignment
  BodyJointLocationsBD& operator=(const BodyJointLocationsBD& rhs) = default;
  //! Copy construct from raw
  BodyJointLocationsBD(const XrBodyJointLocationsBD& rhs) : BodyJointLocationsBD() { *put() = rhs; }
  //! Copy assign from raw
  BodyJointLocationsBD& operator=(const XrBodyJointLocationsBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrBodyJointLocationsBD&() const {
    return *reinterpret_cast<const XrBodyJointLocationsBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrBodyJointLocationsBD&() { return *reinterpret_cast<XrBodyJointLocationsBD*>(this); }

  //! Accessor for this as the address of a raw XrBodyJointLocationsBD
  XrBodyJointLocationsBD const* get() const noexcept {
    return reinterpret_cast<XrBodyJointLocationsBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrBodyJointLocationsBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrBodyJointLocationsBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = BodyJointLocationsBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrBodyJointLocationsBD*>(this);
  }
  Bool32 allJointPosesTracked;
  uint32_t jointLocationCount;
  BodyJointLocationBD* jointLocations;
};
static_assert(sizeof(XrBodyJointLocationsBD) == sizeof(BodyJointLocationsBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrBodyJointLocationsBD pointer to const from a
 * BodyJointLocationsBD reference to const.
 * @relates BodyJointLocationsBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointLocationsBD const* get(BodyJointLocationsBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing BodyJointLocationsBD as the
 * address of a raw XrBodyJointLocationsBD
 * @relates BodyJointLocationsBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrBodyJointLocationsBD* put(BodyJointLocationsBD& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_body_tracking

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSystemSpatialSensingPropertiesBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpatialSensingPropertiesBD>
 * @xrentity{XrSystemSpatialSensingPropertiesBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemSpatialSensingPropertiesBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemSpatialSensingPropertiesBD(void* next_ = nullptr)

      : Parent(StructureType::SystemSpatialSensingPropertiesBD, next_) {}

  //! Default copy constructor
  SystemSpatialSensingPropertiesBD(const SystemSpatialSensingPropertiesBD& rhs) = default;
  //! Default copy assignment
  SystemSpatialSensingPropertiesBD& operator=(const SystemSpatialSensingPropertiesBD& rhs) =
      default;
  //! Copy construct from raw
  SystemSpatialSensingPropertiesBD(const XrSystemSpatialSensingPropertiesBD& rhs)
      : SystemSpatialSensingPropertiesBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemSpatialSensingPropertiesBD& operator=(const XrSystemSpatialSensingPropertiesBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemSpatialSensingPropertiesBD&() const {
    return *reinterpret_cast<const XrSystemSpatialSensingPropertiesBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemSpatialSensingPropertiesBD&() {
    return *reinterpret_cast<XrSystemSpatialSensingPropertiesBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemSpatialSensingPropertiesBD
  XrSystemSpatialSensingPropertiesBD const* get() const noexcept {
    return reinterpret_cast<XrSystemSpatialSensingPropertiesBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemSpatialSensingPropertiesBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemSpatialSensingPropertiesBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemSpatialSensingPropertiesBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemSpatialSensingPropertiesBD*>(this);
  }
  Bool32 supportsSpatialSensing;
};
static_assert(sizeof(XrSystemSpatialSensingPropertiesBD) ==
                  sizeof(SystemSpatialSensingPropertiesBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemSpatialSensingPropertiesBD pointer to const from a
 * SystemSpatialSensingPropertiesBD reference to const.
 * @relates SystemSpatialSensingPropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialSensingPropertiesBD const* get(
    SystemSpatialSensingPropertiesBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemSpatialSensingPropertiesBD as the address of a raw XrSystemSpatialSensingPropertiesBD
 * @relates SystemSpatialSensingPropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialSensingPropertiesBD* put(
    SystemSpatialSensingPropertiesBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSpatialEntityComponentGetInfoBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityComponentGetInfoBD>
 * @xrentity{XrSpatialEntityComponentGetInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityComponentGetInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialEntityComponentGetInfoBD(const SpatialEntityIdBD& entityId_,
                                  const SpatialEntityComponentTypeBD& componentType_,
                                  const void* next_ = nullptr)
      : Parent(StructureType::SpatialEntityComponentGetInfoBD, next_),
        entityId{entityId_},
        componentType{componentType_} {}

  //! Default/empty constructor
  SpatialEntityComponentGetInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityComponentGetInfoBD, next_),
        entityId{},
        componentType{} {}

  //! Default copy constructor
  SpatialEntityComponentGetInfoBD(const SpatialEntityComponentGetInfoBD& rhs) = default;
  //! Default copy assignment
  SpatialEntityComponentGetInfoBD& operator=(const SpatialEntityComponentGetInfoBD& rhs) = default;
  //! Copy construct from raw
  SpatialEntityComponentGetInfoBD(const XrSpatialEntityComponentGetInfoBD& rhs)
      : SpatialEntityComponentGetInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityComponentGetInfoBD& operator=(const XrSpatialEntityComponentGetInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityComponentGetInfoBD&() const {
    return *reinterpret_cast<const XrSpatialEntityComponentGetInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityComponentGetInfoBD&() {
    return *reinterpret_cast<XrSpatialEntityComponentGetInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityComponentGetInfoBD
  XrSpatialEntityComponentGetInfoBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityComponentGetInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityComponentGetInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityComponentGetInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityComponentGetInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityComponentGetInfoBD*>(this);
  }
  SpatialEntityIdBD entityId;
  SpatialEntityComponentTypeBD componentType;
};
static_assert(sizeof(XrSpatialEntityComponentGetInfoBD) == sizeof(SpatialEntityComponentGetInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityComponentGetInfoBD pointer to const from a
 * SpatialEntityComponentGetInfoBD reference to const.
 * @relates SpatialEntityComponentGetInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentGetInfoBD const* get(
    SpatialEntityComponentGetInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialEntityComponentGetInfoBD as the address of a raw XrSpatialEntityComponentGetInfoBD
 * @relates SpatialEntityComponentGetInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentGetInfoBD* put(SpatialEntityComponentGetInfoBD& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSpatialEntityComponentDataBaseHeaderBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityComponentDataBaseHeaderBD>
 * @xrentity{XrSpatialEntityComponentDataBaseHeaderBD}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS SpatialEntityComponentDataBaseHeaderBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  SpatialEntityComponentDataBaseHeaderBD(StructureType type_, void* next_ = nullptr)
      : Parent(type_, next_) {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityComponentDataBaseHeaderBD&() const {
    return *reinterpret_cast<const XrSpatialEntityComponentDataBaseHeaderBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityComponentDataBaseHeaderBD&() {
    return *reinterpret_cast<XrSpatialEntityComponentDataBaseHeaderBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityComponentDataBaseHeaderBD
  XrSpatialEntityComponentDataBaseHeaderBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityComponentDataBaseHeaderBD const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw
   * XrSpatialEntityComponentDataBaseHeaderBD.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrSpatialEntityComponentDataBaseHeaderBD* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrSpatialEntityComponentDataBaseHeaderBD*>(this);
  }
};
static_assert(sizeof(XrSpatialEntityComponentDataBaseHeaderBD) ==
                  sizeof(SpatialEntityComponentDataBaseHeaderBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityComponentDataBaseHeaderBD pointer to const
 * from a SpatialEntityComponentDataBaseHeaderBD reference to const.
 * @relates SpatialEntityComponentDataBaseHeaderBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataBaseHeaderBD const* get(
    SpatialEntityComponentDataBaseHeaderBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialEntityComponentDataBaseHeaderBD as the address of a raw
 * XrSpatialEntityComponentDataBaseHeaderBD
 * @relates SpatialEntityComponentDataBaseHeaderBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataBaseHeaderBD* put(
    SpatialEntityComponentDataBaseHeaderBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSpatialEntityLocationGetInfoBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityLocationGetInfoBD>
 * @xrentity{XrSpatialEntityLocationGetInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityLocationGetInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialEntityLocationGetInfoBD(const Space& baseSpace_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialEntityLocationGetInfoBD, next_), baseSpace{baseSpace_} {}

  //! Default/empty constructor
  SpatialEntityLocationGetInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityLocationGetInfoBD, next_), baseSpace{} {}

  //! Default copy constructor
  SpatialEntityLocationGetInfoBD(const SpatialEntityLocationGetInfoBD& rhs) = default;
  //! Default copy assignment
  SpatialEntityLocationGetInfoBD& operator=(const SpatialEntityLocationGetInfoBD& rhs) = default;
  //! Copy construct from raw
  SpatialEntityLocationGetInfoBD(const XrSpatialEntityLocationGetInfoBD& rhs)
      : SpatialEntityLocationGetInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityLocationGetInfoBD& operator=(const XrSpatialEntityLocationGetInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityLocationGetInfoBD&() const {
    return *reinterpret_cast<const XrSpatialEntityLocationGetInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityLocationGetInfoBD&() {
    return *reinterpret_cast<XrSpatialEntityLocationGetInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityLocationGetInfoBD
  XrSpatialEntityLocationGetInfoBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityLocationGetInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityLocationGetInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityLocationGetInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityLocationGetInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityLocationGetInfoBD*>(this);
  }
  Space baseSpace;
};
static_assert(sizeof(XrSpatialEntityLocationGetInfoBD) == sizeof(SpatialEntityLocationGetInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityLocationGetInfoBD pointer to const from a
 * SpatialEntityLocationGetInfoBD reference to const.
 * @relates SpatialEntityLocationGetInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityLocationGetInfoBD const* get(
    SpatialEntityLocationGetInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialEntityLocationGetInfoBD as the address of a raw XrSpatialEntityLocationGetInfoBD
 * @relates SpatialEntityLocationGetInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityLocationGetInfoBD* put(SpatialEntityLocationGetInfoBD& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSpatialEntityComponentDataLocationBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityComponentDataLocationBD>
 * @xrentity{XrSpatialEntityComponentDataLocationBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityComponentDataLocationBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialEntityComponentDataLocationBD(void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityComponentDataLocationBD, next_) {}

  //! Default copy constructor
  SpatialEntityComponentDataLocationBD(const SpatialEntityComponentDataLocationBD& rhs) = default;
  //! Default copy assignment
  SpatialEntityComponentDataLocationBD& operator=(const SpatialEntityComponentDataLocationBD& rhs) =
      default;
  //! Copy construct from raw
  SpatialEntityComponentDataLocationBD(const XrSpatialEntityComponentDataLocationBD& rhs)
      : SpatialEntityComponentDataLocationBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityComponentDataLocationBD& operator=(
      const XrSpatialEntityComponentDataLocationBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityComponentDataLocationBD&() const {
    return *reinterpret_cast<const XrSpatialEntityComponentDataLocationBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityComponentDataLocationBD&() {
    return *reinterpret_cast<XrSpatialEntityComponentDataLocationBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityComponentDataLocationBD
  XrSpatialEntityComponentDataLocationBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityComponentDataLocationBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityComponentDataLocationBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityComponentDataLocationBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityComponentDataLocationBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityComponentDataLocationBD*>(this);
  }
  SpaceLocation location;
};
static_assert(sizeof(XrSpatialEntityComponentDataLocationBD) ==
                  sizeof(SpatialEntityComponentDataLocationBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityComponentDataLocationBD pointer to const
 * from a SpatialEntityComponentDataLocationBD reference to const.
 * @relates SpatialEntityComponentDataLocationBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataLocationBD const* get(
    SpatialEntityComponentDataLocationBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialEntityComponentDataLocationBD as the address of a raw
 * XrSpatialEntityComponentDataLocationBD
 * @relates SpatialEntityComponentDataLocationBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataLocationBD* put(
    SpatialEntityComponentDataLocationBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSpatialEntityComponentDataSemanticBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityComponentDataSemanticBD>
 * @xrentity{XrSpatialEntityComponentDataSemanticBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityComponentDataSemanticBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialEntityComponentDataSemanticBD(void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityComponentDataSemanticBD, next_) {}

  //! Default copy constructor
  SpatialEntityComponentDataSemanticBD(const SpatialEntityComponentDataSemanticBD& rhs) = default;
  //! Default copy assignment
  SpatialEntityComponentDataSemanticBD& operator=(const SpatialEntityComponentDataSemanticBD& rhs) =
      default;
  //! Copy construct from raw
  SpatialEntityComponentDataSemanticBD(const XrSpatialEntityComponentDataSemanticBD& rhs)
      : SpatialEntityComponentDataSemanticBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityComponentDataSemanticBD& operator=(
      const XrSpatialEntityComponentDataSemanticBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityComponentDataSemanticBD&() const {
    return *reinterpret_cast<const XrSpatialEntityComponentDataSemanticBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityComponentDataSemanticBD&() {
    return *reinterpret_cast<XrSpatialEntityComponentDataSemanticBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityComponentDataSemanticBD
  XrSpatialEntityComponentDataSemanticBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityComponentDataSemanticBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityComponentDataSemanticBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityComponentDataSemanticBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityComponentDataSemanticBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityComponentDataSemanticBD*>(this);
  }
  uint32_t labelCapacityInput;
  uint32_t labelCountOutput;
  SemanticLabelBD* labels;
};
static_assert(sizeof(XrSpatialEntityComponentDataSemanticBD) ==
                  sizeof(SpatialEntityComponentDataSemanticBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityComponentDataSemanticBD pointer to const
 * from a SpatialEntityComponentDataSemanticBD reference to const.
 * @relates SpatialEntityComponentDataSemanticBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataSemanticBD const* get(
    SpatialEntityComponentDataSemanticBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialEntityComponentDataSemanticBD as the address of a raw
 * XrSpatialEntityComponentDataSemanticBD
 * @relates SpatialEntityComponentDataSemanticBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataSemanticBD* put(
    SpatialEntityComponentDataSemanticBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSpatialEntityComponentDataBoundingBox2DBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityComponentDataBoundingBox2DBD>
 * @xrentity{XrSpatialEntityComponentDataBoundingBox2DBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityComponentDataBoundingBox2DBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialEntityComponentDataBoundingBox2DBD(void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityComponentDataBoundingBox2DBD, next_) {}

  //! Default copy constructor
  SpatialEntityComponentDataBoundingBox2DBD(const SpatialEntityComponentDataBoundingBox2DBD& rhs) =
      default;
  //! Default copy assignment
  SpatialEntityComponentDataBoundingBox2DBD& operator=(
      const SpatialEntityComponentDataBoundingBox2DBD& rhs) = default;
  //! Copy construct from raw
  SpatialEntityComponentDataBoundingBox2DBD(const XrSpatialEntityComponentDataBoundingBox2DBD& rhs)
      : SpatialEntityComponentDataBoundingBox2DBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityComponentDataBoundingBox2DBD& operator=(
      const XrSpatialEntityComponentDataBoundingBox2DBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityComponentDataBoundingBox2DBD&() const {
    return *reinterpret_cast<const XrSpatialEntityComponentDataBoundingBox2DBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityComponentDataBoundingBox2DBD&() {
    return *reinterpret_cast<XrSpatialEntityComponentDataBoundingBox2DBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityComponentDataBoundingBox2DBD
  XrSpatialEntityComponentDataBoundingBox2DBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityComponentDataBoundingBox2DBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityComponentDataBoundingBox2DBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityComponentDataBoundingBox2DBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityComponentDataBoundingBox2DBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityComponentDataBoundingBox2DBD*>(this);
  }
  Rect2Df boundingBox2D;
};
static_assert(sizeof(XrSpatialEntityComponentDataBoundingBox2DBD) ==
                  sizeof(SpatialEntityComponentDataBoundingBox2DBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityComponentDataBoundingBox2DBD pointer to
 * const from a SpatialEntityComponentDataBoundingBox2DBD reference to const.
 * @relates SpatialEntityComponentDataBoundingBox2DBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataBoundingBox2DBD const* get(
    SpatialEntityComponentDataBoundingBox2DBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialEntityComponentDataBoundingBox2DBD as the address of a raw
 * XrSpatialEntityComponentDataBoundingBox2DBD
 * @relates SpatialEntityComponentDataBoundingBox2DBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataBoundingBox2DBD* put(
    SpatialEntityComponentDataBoundingBox2DBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSpatialEntityComponentDataPolygonBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityComponentDataPolygonBD>
 * @xrentity{XrSpatialEntityComponentDataPolygonBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityComponentDataPolygonBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialEntityComponentDataPolygonBD(void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityComponentDataPolygonBD, next_) {}

  //! Default copy constructor
  SpatialEntityComponentDataPolygonBD(const SpatialEntityComponentDataPolygonBD& rhs) = default;
  //! Default copy assignment
  SpatialEntityComponentDataPolygonBD& operator=(const SpatialEntityComponentDataPolygonBD& rhs) =
      default;
  //! Copy construct from raw
  SpatialEntityComponentDataPolygonBD(const XrSpatialEntityComponentDataPolygonBD& rhs)
      : SpatialEntityComponentDataPolygonBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityComponentDataPolygonBD& operator=(const XrSpatialEntityComponentDataPolygonBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityComponentDataPolygonBD&() const {
    return *reinterpret_cast<const XrSpatialEntityComponentDataPolygonBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityComponentDataPolygonBD&() {
    return *reinterpret_cast<XrSpatialEntityComponentDataPolygonBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityComponentDataPolygonBD
  XrSpatialEntityComponentDataPolygonBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityComponentDataPolygonBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityComponentDataPolygonBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityComponentDataPolygonBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityComponentDataPolygonBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityComponentDataPolygonBD*>(this);
  }
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  Vector2f* vertices;
};
static_assert(sizeof(XrSpatialEntityComponentDataPolygonBD) ==
                  sizeof(SpatialEntityComponentDataPolygonBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityComponentDataPolygonBD pointer to const
 * from a SpatialEntityComponentDataPolygonBD reference to const.
 * @relates SpatialEntityComponentDataPolygonBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataPolygonBD const* get(
    SpatialEntityComponentDataPolygonBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialEntityComponentDataPolygonBD as the address of a raw XrSpatialEntityComponentDataPolygonBD
 * @relates SpatialEntityComponentDataPolygonBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataPolygonBD* put(
    SpatialEntityComponentDataPolygonBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSpatialEntityComponentDataBoundingBox3DBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityComponentDataBoundingBox3DBD>
 * @xrentity{XrSpatialEntityComponentDataBoundingBox3DBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityComponentDataBoundingBox3DBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialEntityComponentDataBoundingBox3DBD(void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityComponentDataBoundingBox3DBD, next_) {}

  //! Default copy constructor
  SpatialEntityComponentDataBoundingBox3DBD(const SpatialEntityComponentDataBoundingBox3DBD& rhs) =
      default;
  //! Default copy assignment
  SpatialEntityComponentDataBoundingBox3DBD& operator=(
      const SpatialEntityComponentDataBoundingBox3DBD& rhs) = default;
  //! Copy construct from raw
  SpatialEntityComponentDataBoundingBox3DBD(const XrSpatialEntityComponentDataBoundingBox3DBD& rhs)
      : SpatialEntityComponentDataBoundingBox3DBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityComponentDataBoundingBox3DBD& operator=(
      const XrSpatialEntityComponentDataBoundingBox3DBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityComponentDataBoundingBox3DBD&() const {
    return *reinterpret_cast<const XrSpatialEntityComponentDataBoundingBox3DBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityComponentDataBoundingBox3DBD&() {
    return *reinterpret_cast<XrSpatialEntityComponentDataBoundingBox3DBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityComponentDataBoundingBox3DBD
  XrSpatialEntityComponentDataBoundingBox3DBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityComponentDataBoundingBox3DBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityComponentDataBoundingBox3DBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityComponentDataBoundingBox3DBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityComponentDataBoundingBox3DBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityComponentDataBoundingBox3DBD*>(this);
  }
  Boxf boundingBox3D;
};
static_assert(sizeof(XrSpatialEntityComponentDataBoundingBox3DBD) ==
                  sizeof(SpatialEntityComponentDataBoundingBox3DBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityComponentDataBoundingBox3DBD pointer to
 * const from a SpatialEntityComponentDataBoundingBox3DBD reference to const.
 * @relates SpatialEntityComponentDataBoundingBox3DBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataBoundingBox3DBD const* get(
    SpatialEntityComponentDataBoundingBox3DBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialEntityComponentDataBoundingBox3DBD as the address of a raw
 * XrSpatialEntityComponentDataBoundingBox3DBD
 * @relates SpatialEntityComponentDataBoundingBox3DBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataBoundingBox3DBD* put(
    SpatialEntityComponentDataBoundingBox3DBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSpatialEntityComponentDataTriangleMeshBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityComponentDataTriangleMeshBD>
 * @xrentity{XrSpatialEntityComponentDataTriangleMeshBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityComponentDataTriangleMeshBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialEntityComponentDataTriangleMeshBD(void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityComponentDataTriangleMeshBD, next_) {}

  //! Default copy constructor
  SpatialEntityComponentDataTriangleMeshBD(const SpatialEntityComponentDataTriangleMeshBD& rhs) =
      default;
  //! Default copy assignment
  SpatialEntityComponentDataTriangleMeshBD& operator=(
      const SpatialEntityComponentDataTriangleMeshBD& rhs) = default;
  //! Copy construct from raw
  SpatialEntityComponentDataTriangleMeshBD(const XrSpatialEntityComponentDataTriangleMeshBD& rhs)
      : SpatialEntityComponentDataTriangleMeshBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityComponentDataTriangleMeshBD& operator=(
      const XrSpatialEntityComponentDataTriangleMeshBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityComponentDataTriangleMeshBD&() const {
    return *reinterpret_cast<const XrSpatialEntityComponentDataTriangleMeshBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityComponentDataTriangleMeshBD&() {
    return *reinterpret_cast<XrSpatialEntityComponentDataTriangleMeshBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityComponentDataTriangleMeshBD
  XrSpatialEntityComponentDataTriangleMeshBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityComponentDataTriangleMeshBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityComponentDataTriangleMeshBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityComponentDataTriangleMeshBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityComponentDataTriangleMeshBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityComponentDataTriangleMeshBD*>(this);
  }
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  Vector3f* vertices;
  uint32_t indexCapacityInput;
  uint32_t indexCountOutput;
  uint16_t* indices;
};
static_assert(sizeof(XrSpatialEntityComponentDataTriangleMeshBD) ==
                  sizeof(SpatialEntityComponentDataTriangleMeshBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityComponentDataTriangleMeshBD pointer to
 * const from a SpatialEntityComponentDataTriangleMeshBD reference to const.
 * @relates SpatialEntityComponentDataTriangleMeshBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataTriangleMeshBD const* get(
    SpatialEntityComponentDataTriangleMeshBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialEntityComponentDataTriangleMeshBD as the address of a raw
 * XrSpatialEntityComponentDataTriangleMeshBD
 * @relates SpatialEntityComponentDataTriangleMeshBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataTriangleMeshBD* put(
    SpatialEntityComponentDataTriangleMeshBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSenseDataProviderCreateInfoBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSenseDataProviderCreateInfoBD>
 * @xrentity{XrSenseDataProviderCreateInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SenseDataProviderCreateInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SenseDataProviderCreateInfoBD(const SenseDataProviderTypeBD& providerType_,
                                const void* next_ = nullptr)
      : Parent(StructureType::SenseDataProviderCreateInfoBD, next_), providerType{providerType_} {}

  //! Default/empty constructor
  SenseDataProviderCreateInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::SenseDataProviderCreateInfoBD, next_), providerType{} {}

  //! Default copy constructor
  SenseDataProviderCreateInfoBD(const SenseDataProviderCreateInfoBD& rhs) = default;
  //! Default copy assignment
  SenseDataProviderCreateInfoBD& operator=(const SenseDataProviderCreateInfoBD& rhs) = default;
  //! Copy construct from raw
  SenseDataProviderCreateInfoBD(const XrSenseDataProviderCreateInfoBD& rhs)
      : SenseDataProviderCreateInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SenseDataProviderCreateInfoBD& operator=(const XrSenseDataProviderCreateInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSenseDataProviderCreateInfoBD&() const {
    return *reinterpret_cast<const XrSenseDataProviderCreateInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSenseDataProviderCreateInfoBD&() {
    return *reinterpret_cast<XrSenseDataProviderCreateInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSenseDataProviderCreateInfoBD
  XrSenseDataProviderCreateInfoBD const* get() const noexcept {
    return reinterpret_cast<XrSenseDataProviderCreateInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSenseDataProviderCreateInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSenseDataProviderCreateInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SenseDataProviderCreateInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSenseDataProviderCreateInfoBD*>(this);
  }
  SenseDataProviderTypeBD providerType;
};
static_assert(sizeof(XrSenseDataProviderCreateInfoBD) == sizeof(SenseDataProviderCreateInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSenseDataProviderCreateInfoBD pointer to const from a
 * SenseDataProviderCreateInfoBD reference to const.
 * @relates SenseDataProviderCreateInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataProviderCreateInfoBD const* get(
    SenseDataProviderCreateInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SenseDataProviderCreateInfoBD
 * as the address of a raw XrSenseDataProviderCreateInfoBD
 * @relates SenseDataProviderCreateInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataProviderCreateInfoBD* put(SenseDataProviderCreateInfoBD& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSenseDataProviderStartInfoBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSenseDataProviderStartInfoBD>
 * @xrentity{XrSenseDataProviderStartInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SenseDataProviderStartInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SenseDataProviderStartInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::SenseDataProviderStartInfoBD, next_) {}

  //! Default copy constructor
  SenseDataProviderStartInfoBD(const SenseDataProviderStartInfoBD& rhs) = default;
  //! Default copy assignment
  SenseDataProviderStartInfoBD& operator=(const SenseDataProviderStartInfoBD& rhs) = default;
  //! Copy construct from raw
  SenseDataProviderStartInfoBD(const XrSenseDataProviderStartInfoBD& rhs)
      : SenseDataProviderStartInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SenseDataProviderStartInfoBD& operator=(const XrSenseDataProviderStartInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSenseDataProviderStartInfoBD&() const {
    return *reinterpret_cast<const XrSenseDataProviderStartInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSenseDataProviderStartInfoBD&() {
    return *reinterpret_cast<XrSenseDataProviderStartInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSenseDataProviderStartInfoBD
  XrSenseDataProviderStartInfoBD const* get() const noexcept {
    return reinterpret_cast<XrSenseDataProviderStartInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSenseDataProviderStartInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSenseDataProviderStartInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SenseDataProviderStartInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSenseDataProviderStartInfoBD*>(this);
  }
};
static_assert(sizeof(XrSenseDataProviderStartInfoBD) == sizeof(SenseDataProviderStartInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSenseDataProviderStartInfoBD pointer to const from a
 * SenseDataProviderStartInfoBD reference to const.
 * @relates SenseDataProviderStartInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataProviderStartInfoBD const* get(
    SenseDataProviderStartInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SenseDataProviderStartInfoBD
 * as the address of a raw XrSenseDataProviderStartInfoBD
 * @relates SenseDataProviderStartInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataProviderStartInfoBD* put(SenseDataProviderStartInfoBD& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrEventDataSenseDataProviderStateChangedBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSenseDataProviderStateChangedBD>
 * @xrentity{XrEventDataSenseDataProviderStateChangedBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSenseDataProviderStateChangedBD : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSenseDataProviderStateChangedBD(void* next_ = nullptr)

      : Parent(StructureType::EventDataSenseDataProviderStateChangedBD, next_) {}

  //! Default copy constructor
  EventDataSenseDataProviderStateChangedBD(const EventDataSenseDataProviderStateChangedBD& rhs) =
      default;
  //! Default copy assignment
  EventDataSenseDataProviderStateChangedBD& operator=(
      const EventDataSenseDataProviderStateChangedBD& rhs) = default;
  //! Copy construct from raw
  EventDataSenseDataProviderStateChangedBD(const XrEventDataSenseDataProviderStateChangedBD& rhs)
      : EventDataSenseDataProviderStateChangedBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSenseDataProviderStateChangedBD& operator=(
      const XrEventDataSenseDataProviderStateChangedBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSenseDataProviderStateChangedBD&() const {
    return *reinterpret_cast<const XrEventDataSenseDataProviderStateChangedBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSenseDataProviderStateChangedBD&() {
    return *reinterpret_cast<XrEventDataSenseDataProviderStateChangedBD*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSenseDataProviderStateChangedBD
  XrEventDataSenseDataProviderStateChangedBD const* get() const noexcept {
    return reinterpret_cast<XrEventDataSenseDataProviderStateChangedBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSenseDataProviderStateChangedBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSenseDataProviderStateChangedBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSenseDataProviderStateChangedBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSenseDataProviderStateChangedBD*>(this);
  }
  SenseDataProviderBD provider;
  SenseDataProviderStateBD newState;
};
static_assert(sizeof(XrEventDataSenseDataProviderStateChangedBD) ==
                  sizeof(EventDataSenseDataProviderStateChangedBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSenseDataProviderStateChangedBD pointer to
 * const from a EventDataSenseDataProviderStateChangedBD reference to const.
 * @relates EventDataSenseDataProviderStateChangedBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSenseDataProviderStateChangedBD const* get(
    EventDataSenseDataProviderStateChangedBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataSenseDataProviderStateChangedBD as the address of a raw
 * XrEventDataSenseDataProviderStateChangedBD
 * @relates EventDataSenseDataProviderStateChangedBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSenseDataProviderStateChangedBD* put(
    EventDataSenseDataProviderStateChangedBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSenseDataProviderStateChangedBD
 * as a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSenseDataProviderStateChangedBD
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSenseDataProviderStateChangedBD const& h) {
  return h.get_base();
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrEventDataSenseDataUpdatedBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSenseDataUpdatedBD>
 * @xrentity{XrEventDataSenseDataUpdatedBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSenseDataUpdatedBD : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSenseDataUpdatedBD(void* next_ = nullptr)

      : Parent(StructureType::EventDataSenseDataUpdatedBD, next_) {}

  //! Default copy constructor
  EventDataSenseDataUpdatedBD(const EventDataSenseDataUpdatedBD& rhs) = default;
  //! Default copy assignment
  EventDataSenseDataUpdatedBD& operator=(const EventDataSenseDataUpdatedBD& rhs) = default;
  //! Copy construct from raw
  EventDataSenseDataUpdatedBD(const XrEventDataSenseDataUpdatedBD& rhs)
      : EventDataSenseDataUpdatedBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSenseDataUpdatedBD& operator=(const XrEventDataSenseDataUpdatedBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSenseDataUpdatedBD&() const {
    return *reinterpret_cast<const XrEventDataSenseDataUpdatedBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSenseDataUpdatedBD&() {
    return *reinterpret_cast<XrEventDataSenseDataUpdatedBD*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSenseDataUpdatedBD
  XrEventDataSenseDataUpdatedBD const* get() const noexcept {
    return reinterpret_cast<XrEventDataSenseDataUpdatedBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSenseDataUpdatedBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSenseDataUpdatedBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSenseDataUpdatedBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSenseDataUpdatedBD*>(this);
  }
  SenseDataProviderBD provider;
};
static_assert(sizeof(XrEventDataSenseDataUpdatedBD) == sizeof(EventDataSenseDataUpdatedBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSenseDataUpdatedBD pointer to const from a
 * EventDataSenseDataUpdatedBD reference to const.
 * @relates EventDataSenseDataUpdatedBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSenseDataUpdatedBD const* get(
    EventDataSenseDataUpdatedBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataSenseDataUpdatedBD
 * as the address of a raw XrEventDataSenseDataUpdatedBD
 * @relates EventDataSenseDataUpdatedBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSenseDataUpdatedBD* put(EventDataSenseDataUpdatedBD& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSenseDataUpdatedBD as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSenseDataUpdatedBD
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSenseDataUpdatedBD const& h) {
  return h.get_base();
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSenseDataQueryInfoBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSenseDataQueryInfoBD>
 * @xrentity{XrSenseDataQueryInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SenseDataQueryInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SenseDataQueryInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::SenseDataQueryInfoBD, next_) {}

  //! Default copy constructor
  SenseDataQueryInfoBD(const SenseDataQueryInfoBD& rhs) = default;
  //! Default copy assignment
  SenseDataQueryInfoBD& operator=(const SenseDataQueryInfoBD& rhs) = default;
  //! Copy construct from raw
  SenseDataQueryInfoBD(const XrSenseDataQueryInfoBD& rhs) : SenseDataQueryInfoBD() { *put() = rhs; }
  //! Copy assign from raw
  SenseDataQueryInfoBD& operator=(const XrSenseDataQueryInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSenseDataQueryInfoBD&() const {
    return *reinterpret_cast<const XrSenseDataQueryInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSenseDataQueryInfoBD&() { return *reinterpret_cast<XrSenseDataQueryInfoBD*>(this); }

  //! Accessor for this as the address of a raw XrSenseDataQueryInfoBD
  XrSenseDataQueryInfoBD const* get() const noexcept {
    return reinterpret_cast<XrSenseDataQueryInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSenseDataQueryInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSenseDataQueryInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SenseDataQueryInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSenseDataQueryInfoBD*>(this);
  }
};
static_assert(sizeof(XrSenseDataQueryInfoBD) == sizeof(SenseDataQueryInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSenseDataQueryInfoBD pointer to const from a
 * SenseDataQueryInfoBD reference to const.
 * @relates SenseDataQueryInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataQueryInfoBD const* get(SenseDataQueryInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SenseDataQueryInfoBD as the
 * address of a raw XrSenseDataQueryInfoBD
 * @relates SenseDataQueryInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataQueryInfoBD* put(SenseDataQueryInfoBD& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSenseDataQueryCompletionBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSenseDataQueryCompletionBD>
 * @xrentity{XrSenseDataQueryCompletionBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SenseDataQueryCompletionBD : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SenseDataQueryCompletionBD(void* next_ = nullptr)

      : Parent(StructureType::SenseDataQueryCompletionBD, {}, next_) {}

  //! Default copy constructor
  SenseDataQueryCompletionBD(const SenseDataQueryCompletionBD& rhs) = default;
  //! Default copy assignment
  SenseDataQueryCompletionBD& operator=(const SenseDataQueryCompletionBD& rhs) = default;
  //! Copy construct from raw
  SenseDataQueryCompletionBD(const XrSenseDataQueryCompletionBD& rhs)
      : SenseDataQueryCompletionBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SenseDataQueryCompletionBD& operator=(const XrSenseDataQueryCompletionBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSenseDataQueryCompletionBD&() const {
    return *reinterpret_cast<const XrSenseDataQueryCompletionBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSenseDataQueryCompletionBD&() {
    return *reinterpret_cast<XrSenseDataQueryCompletionBD*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrSenseDataQueryCompletionBD
  XrSenseDataQueryCompletionBD const* get() const noexcept {
    return reinterpret_cast<XrSenseDataQueryCompletionBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSenseDataQueryCompletionBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSenseDataQueryCompletionBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SenseDataQueryCompletionBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSenseDataQueryCompletionBD*>(this);
  }
  SenseDataSnapshotBD snapshot;
};
static_assert(sizeof(XrSenseDataQueryCompletionBD) == sizeof(SenseDataQueryCompletionBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSenseDataQueryCompletionBD pointer to const from a
 * SenseDataQueryCompletionBD reference to const.
 * @relates SenseDataQueryCompletionBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataQueryCompletionBD const* get(
    SenseDataQueryCompletionBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SenseDataQueryCompletionBD as
 * the address of a raw XrSenseDataQueryCompletionBD
 * @relates SenseDataQueryCompletionBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataQueryCompletionBD* put(SenseDataQueryCompletionBD& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SenseDataQueryCompletionBD as a raw,
 * pointer to const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates SenseDataQueryCompletionBD
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    SenseDataQueryCompletionBD const& h) {
  return h.get_base();
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrQueriedSenseDataGetInfoBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrQueriedSenseDataGetInfoBD>
 * @xrentity{XrQueriedSenseDataGetInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS QueriedSenseDataGetInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  QueriedSenseDataGetInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::QueriedSenseDataGetInfoBD, next_) {}

  //! Default copy constructor
  QueriedSenseDataGetInfoBD(const QueriedSenseDataGetInfoBD& rhs) = default;
  //! Default copy assignment
  QueriedSenseDataGetInfoBD& operator=(const QueriedSenseDataGetInfoBD& rhs) = default;
  //! Copy construct from raw
  QueriedSenseDataGetInfoBD(const XrQueriedSenseDataGetInfoBD& rhs) : QueriedSenseDataGetInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  QueriedSenseDataGetInfoBD& operator=(const XrQueriedSenseDataGetInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrQueriedSenseDataGetInfoBD&() const {
    return *reinterpret_cast<const XrQueriedSenseDataGetInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrQueriedSenseDataGetInfoBD&() {
    return *reinterpret_cast<XrQueriedSenseDataGetInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrQueriedSenseDataGetInfoBD
  XrQueriedSenseDataGetInfoBD const* get() const noexcept {
    return reinterpret_cast<XrQueriedSenseDataGetInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrQueriedSenseDataGetInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrQueriedSenseDataGetInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = QueriedSenseDataGetInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrQueriedSenseDataGetInfoBD*>(this);
  }
};
static_assert(sizeof(XrQueriedSenseDataGetInfoBD) == sizeof(QueriedSenseDataGetInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrQueriedSenseDataGetInfoBD pointer to const from a
 * QueriedSenseDataGetInfoBD reference to const.
 * @relates QueriedSenseDataGetInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrQueriedSenseDataGetInfoBD const* get(
    QueriedSenseDataGetInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing QueriedSenseDataGetInfoBD as
 * the address of a raw XrQueriedSenseDataGetInfoBD
 * @relates QueriedSenseDataGetInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrQueriedSenseDataGetInfoBD* put(QueriedSenseDataGetInfoBD& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSpatialEntityStateBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityStateBD>
 * @xrentity{XrSpatialEntityStateBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityStateBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialEntityStateBD(void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityStateBD, next_) {}

  //! Default copy constructor
  SpatialEntityStateBD(const SpatialEntityStateBD& rhs) = default;
  //! Default copy assignment
  SpatialEntityStateBD& operator=(const SpatialEntityStateBD& rhs) = default;
  //! Copy construct from raw
  SpatialEntityStateBD(const XrSpatialEntityStateBD& rhs) : SpatialEntityStateBD() { *put() = rhs; }
  //! Copy assign from raw
  SpatialEntityStateBD& operator=(const XrSpatialEntityStateBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityStateBD&() const {
    return *reinterpret_cast<const XrSpatialEntityStateBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityStateBD&() { return *reinterpret_cast<XrSpatialEntityStateBD*>(this); }

  //! Accessor for this as the address of a raw XrSpatialEntityStateBD
  XrSpatialEntityStateBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityStateBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpatialEntityStateBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityStateBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityStateBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityStateBD*>(this);
  }
  SpatialEntityIdBD entityId;
  Time lastUpdateTime;
  UuidEXT uuid;
};
static_assert(sizeof(XrSpatialEntityStateBD) == sizeof(SpatialEntityStateBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityStateBD pointer to const from a
 * SpatialEntityStateBD reference to const.
 * @relates SpatialEntityStateBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityStateBD const* get(SpatialEntityStateBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialEntityStateBD as the
 * address of a raw XrSpatialEntityStateBD
 * @relates SpatialEntityStateBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityStateBD* put(SpatialEntityStateBD& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrQueriedSenseDataBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrQueriedSenseDataBD>
 * @xrentity{XrQueriedSenseDataBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS QueriedSenseDataBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  QueriedSenseDataBD(void* next_ = nullptr)

      : Parent(StructureType::QueriedSenseDataBD, next_) {}

  //! Default copy constructor
  QueriedSenseDataBD(const QueriedSenseDataBD& rhs) = default;
  //! Default copy assignment
  QueriedSenseDataBD& operator=(const QueriedSenseDataBD& rhs) = default;
  //! Copy construct from raw
  QueriedSenseDataBD(const XrQueriedSenseDataBD& rhs) : QueriedSenseDataBD() { *put() = rhs; }
  //! Copy assign from raw
  QueriedSenseDataBD& operator=(const XrQueriedSenseDataBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrQueriedSenseDataBD&() const {
    return *reinterpret_cast<const XrQueriedSenseDataBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrQueriedSenseDataBD&() { return *reinterpret_cast<XrQueriedSenseDataBD*>(this); }

  //! Accessor for this as the address of a raw XrQueriedSenseDataBD
  XrQueriedSenseDataBD const* get() const noexcept {
    return reinterpret_cast<XrQueriedSenseDataBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrQueriedSenseDataBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrQueriedSenseDataBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = QueriedSenseDataBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrQueriedSenseDataBD*>(this);
  }
  uint32_t stateCapacityInput;
  uint32_t stateCountOutput;
  SpatialEntityStateBD* states;
};
static_assert(sizeof(XrQueriedSenseDataBD) == sizeof(QueriedSenseDataBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrQueriedSenseDataBD pointer to const from a
 * QueriedSenseDataBD reference to const.
 * @relates QueriedSenseDataBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrQueriedSenseDataBD const* get(QueriedSenseDataBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing QueriedSenseDataBD as the
 * address of a raw XrQueriedSenseDataBD
 * @relates QueriedSenseDataBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrQueriedSenseDataBD* put(QueriedSenseDataBD& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSenseDataFilterUuidBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSenseDataFilterUuidBD>
 * @xrentity{XrSenseDataFilterUuidBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SenseDataFilterUuidBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SenseDataFilterUuidBD(uint32_t uuidCount_, const UuidEXT* uuids_, const void* next_ = nullptr)
      : Parent(StructureType::SenseDataFilterUuidBD, next_), uuidCount{uuidCount_}, uuids{uuids_} {}

  //! Default/empty constructor
  SenseDataFilterUuidBD(const void* next_ = nullptr)

      : Parent(StructureType::SenseDataFilterUuidBD, next_), uuidCount{0}, uuids{nullptr} {}

  //! Default copy constructor
  SenseDataFilterUuidBD(const SenseDataFilterUuidBD& rhs) = default;
  //! Default copy assignment
  SenseDataFilterUuidBD& operator=(const SenseDataFilterUuidBD& rhs) = default;
  //! Copy construct from raw
  SenseDataFilterUuidBD(const XrSenseDataFilterUuidBD& rhs) : SenseDataFilterUuidBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SenseDataFilterUuidBD& operator=(const XrSenseDataFilterUuidBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSenseDataFilterUuidBD&() const {
    return *reinterpret_cast<const XrSenseDataFilterUuidBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSenseDataFilterUuidBD&() { return *reinterpret_cast<XrSenseDataFilterUuidBD*>(this); }

  //! Accessor for this as the address of a raw XrSenseDataFilterUuidBD
  XrSenseDataFilterUuidBD const* get() const noexcept {
    return reinterpret_cast<XrSenseDataFilterUuidBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSenseDataFilterUuidBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSenseDataFilterUuidBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SenseDataFilterUuidBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSenseDataFilterUuidBD*>(this);
  }
  uint32_t uuidCount;
  const UuidEXT* uuids;
};
static_assert(sizeof(XrSenseDataFilterUuidBD) == sizeof(SenseDataFilterUuidBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSenseDataFilterUuidBD pointer to const from a
 * SenseDataFilterUuidBD reference to const.
 * @relates SenseDataFilterUuidBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataFilterUuidBD const* get(SenseDataFilterUuidBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SenseDataFilterUuidBD as the
 * address of a raw XrSenseDataFilterUuidBD
 * @relates SenseDataFilterUuidBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataFilterUuidBD* put(SenseDataFilterUuidBD& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSenseDataFilterSemanticBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSenseDataFilterSemanticBD>
 * @xrentity{XrSenseDataFilterSemanticBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SenseDataFilterSemanticBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SenseDataFilterSemanticBD(uint32_t labelCount_, const SemanticLabelBD* labels_,
                            const void* next_ = nullptr)
      : Parent(StructureType::SenseDataFilterSemanticBD, next_),
        labelCount{labelCount_},
        labels{labels_} {}

  //! Default/empty constructor
  SenseDataFilterSemanticBD(const void* next_ = nullptr)

      : Parent(StructureType::SenseDataFilterSemanticBD, next_), labelCount{0}, labels{nullptr} {}

  //! Default copy constructor
  SenseDataFilterSemanticBD(const SenseDataFilterSemanticBD& rhs) = default;
  //! Default copy assignment
  SenseDataFilterSemanticBD& operator=(const SenseDataFilterSemanticBD& rhs) = default;
  //! Copy construct from raw
  SenseDataFilterSemanticBD(const XrSenseDataFilterSemanticBD& rhs) : SenseDataFilterSemanticBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SenseDataFilterSemanticBD& operator=(const XrSenseDataFilterSemanticBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSenseDataFilterSemanticBD&() const {
    return *reinterpret_cast<const XrSenseDataFilterSemanticBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSenseDataFilterSemanticBD&() {
    return *reinterpret_cast<XrSenseDataFilterSemanticBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSenseDataFilterSemanticBD
  XrSenseDataFilterSemanticBD const* get() const noexcept {
    return reinterpret_cast<XrSenseDataFilterSemanticBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSenseDataFilterSemanticBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSenseDataFilterSemanticBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SenseDataFilterSemanticBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSenseDataFilterSemanticBD*>(this);
  }
  uint32_t labelCount;
  const SemanticLabelBD* labels;
};
static_assert(sizeof(XrSenseDataFilterSemanticBD) == sizeof(SenseDataFilterSemanticBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSenseDataFilterSemanticBD pointer to const from a
 * SenseDataFilterSemanticBD reference to const.
 * @relates SenseDataFilterSemanticBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataFilterSemanticBD const* get(
    SenseDataFilterSemanticBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SenseDataFilterSemanticBD as
 * the address of a raw XrSenseDataFilterSemanticBD
 * @relates SenseDataFilterSemanticBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataFilterSemanticBD* put(SenseDataFilterSemanticBD& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrSpatialEntityAnchorCreateInfoBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityAnchorCreateInfoBD>
 * @xrentity{XrSpatialEntityAnchorCreateInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityAnchorCreateInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialEntityAnchorCreateInfoBD(const SenseDataSnapshotBD& snapshot_,
                                  const SpatialEntityIdBD& entityId_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialEntityAnchorCreateInfoBD, next_),
        snapshot{snapshot_},
        entityId{entityId_} {}

  //! Default/empty constructor
  SpatialEntityAnchorCreateInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityAnchorCreateInfoBD, next_), snapshot{}, entityId{} {}

  //! Default copy constructor
  SpatialEntityAnchorCreateInfoBD(const SpatialEntityAnchorCreateInfoBD& rhs) = default;
  //! Default copy assignment
  SpatialEntityAnchorCreateInfoBD& operator=(const SpatialEntityAnchorCreateInfoBD& rhs) = default;
  //! Copy construct from raw
  SpatialEntityAnchorCreateInfoBD(const XrSpatialEntityAnchorCreateInfoBD& rhs)
      : SpatialEntityAnchorCreateInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityAnchorCreateInfoBD& operator=(const XrSpatialEntityAnchorCreateInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityAnchorCreateInfoBD&() const {
    return *reinterpret_cast<const XrSpatialEntityAnchorCreateInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityAnchorCreateInfoBD&() {
    return *reinterpret_cast<XrSpatialEntityAnchorCreateInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityAnchorCreateInfoBD
  XrSpatialEntityAnchorCreateInfoBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityAnchorCreateInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityAnchorCreateInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityAnchorCreateInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityAnchorCreateInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityAnchorCreateInfoBD*>(this);
  }
  SenseDataSnapshotBD snapshot;
  SpatialEntityIdBD entityId;
};
static_assert(sizeof(XrSpatialEntityAnchorCreateInfoBD) == sizeof(SpatialEntityAnchorCreateInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityAnchorCreateInfoBD pointer to const from a
 * SpatialEntityAnchorCreateInfoBD reference to const.
 * @relates SpatialEntityAnchorCreateInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityAnchorCreateInfoBD const* get(
    SpatialEntityAnchorCreateInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialEntityAnchorCreateInfoBD as the address of a raw XrSpatialEntityAnchorCreateInfoBD
 * @relates SpatialEntityAnchorCreateInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityAnchorCreateInfoBD* put(SpatialEntityAnchorCreateInfoBD& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrAnchorSpaceCreateInfoBD
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrAnchorSpaceCreateInfoBD>
 * @xrentity{XrAnchorSpaceCreateInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS AnchorSpaceCreateInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  AnchorSpaceCreateInfoBD(const AnchorBD& anchor_, const Posef& poseInAnchorSpace_,
                          const void* next_ = nullptr)
      : Parent(StructureType::AnchorSpaceCreateInfoBD, next_),
        anchor{anchor_},
        poseInAnchorSpace{poseInAnchorSpace_} {}

  //! Default/empty constructor
  AnchorSpaceCreateInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::AnchorSpaceCreateInfoBD, next_), anchor{}, poseInAnchorSpace{} {}

  //! Default copy constructor
  AnchorSpaceCreateInfoBD(const AnchorSpaceCreateInfoBD& rhs) = default;
  //! Default copy assignment
  AnchorSpaceCreateInfoBD& operator=(const AnchorSpaceCreateInfoBD& rhs) = default;
  //! Copy construct from raw
  AnchorSpaceCreateInfoBD(const XrAnchorSpaceCreateInfoBD& rhs) : AnchorSpaceCreateInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  AnchorSpaceCreateInfoBD& operator=(const XrAnchorSpaceCreateInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrAnchorSpaceCreateInfoBD&() const {
    return *reinterpret_cast<const XrAnchorSpaceCreateInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrAnchorSpaceCreateInfoBD&() {
    return *reinterpret_cast<XrAnchorSpaceCreateInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrAnchorSpaceCreateInfoBD
  XrAnchorSpaceCreateInfoBD const* get() const noexcept {
    return reinterpret_cast<XrAnchorSpaceCreateInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrAnchorSpaceCreateInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrAnchorSpaceCreateInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = AnchorSpaceCreateInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrAnchorSpaceCreateInfoBD*>(this);
  }
  AnchorBD anchor;
  Posef poseInAnchorSpace;
};
static_assert(sizeof(XrAnchorSpaceCreateInfoBD) == sizeof(AnchorSpaceCreateInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrAnchorSpaceCreateInfoBD pointer to const from a
 * AnchorSpaceCreateInfoBD reference to const.
 * @relates AnchorSpaceCreateInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrAnchorSpaceCreateInfoBD const* get(AnchorSpaceCreateInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing AnchorSpaceCreateInfoBD as
 * the address of a raw XrAnchorSpaceCreateInfoBD
 * @relates AnchorSpaceCreateInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrAnchorSpaceCreateInfoBD* put(AnchorSpaceCreateInfoBD& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing
/*!
 * C++ projection of XrFutureCompletionEXT
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFutureCompletionEXT>
 * @xrentity{XrFutureCompletionEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FutureCompletionEXT : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FutureCompletionEXT(void* next_ = nullptr)

      : Parent(StructureType::FutureCompletionEXT, {}, next_) {}

  //! Default copy constructor
  FutureCompletionEXT(const FutureCompletionEXT& rhs) = default;
  //! Default copy assignment
  FutureCompletionEXT& operator=(const FutureCompletionEXT& rhs) = default;
  //! Copy construct from raw
  FutureCompletionEXT(const XrFutureCompletionEXT& rhs) : FutureCompletionEXT() { *put() = rhs; }
  //! Copy assign from raw
  FutureCompletionEXT& operator=(const XrFutureCompletionEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFutureCompletionEXT&() const {
    return *reinterpret_cast<const XrFutureCompletionEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFutureCompletionEXT&() { return *reinterpret_cast<XrFutureCompletionEXT*>(this); }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrFutureCompletionEXT
  XrFutureCompletionEXT const* get() const noexcept {
    return reinterpret_cast<XrFutureCompletionEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFutureCompletionEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFutureCompletionEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FutureCompletionEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrFutureCompletionEXT*>(this);
  }
};
static_assert(sizeof(XrFutureCompletionEXT) == sizeof(FutureCompletionEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFutureCompletionEXT pointer to const from a
 * FutureCompletionEXT reference to const.
 * @relates FutureCompletionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionEXT const* get(FutureCompletionEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FutureCompletionEXT as the
 * address of a raw XrFutureCompletionEXT
 * @relates FutureCompletionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionEXT* put(FutureCompletionEXT& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const FutureCompletionEXT as a raw, pointer to
 * const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates FutureCompletionEXT
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    FutureCompletionEXT const& h) {
  return h.get_base();
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_anchor
/*!
 * C++ projection of XrSystemSpatialAnchorPropertiesBD
 *
 * Provided by the `XR_BD_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpatialAnchorPropertiesBD>
 * @xrentity{XrSystemSpatialAnchorPropertiesBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemSpatialAnchorPropertiesBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemSpatialAnchorPropertiesBD(void* next_ = nullptr)

      : Parent(StructureType::SystemSpatialAnchorPropertiesBD, next_) {}

  //! Default copy constructor
  SystemSpatialAnchorPropertiesBD(const SystemSpatialAnchorPropertiesBD& rhs) = default;
  //! Default copy assignment
  SystemSpatialAnchorPropertiesBD& operator=(const SystemSpatialAnchorPropertiesBD& rhs) = default;
  //! Copy construct from raw
  SystemSpatialAnchorPropertiesBD(const XrSystemSpatialAnchorPropertiesBD& rhs)
      : SystemSpatialAnchorPropertiesBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemSpatialAnchorPropertiesBD& operator=(const XrSystemSpatialAnchorPropertiesBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemSpatialAnchorPropertiesBD&() const {
    return *reinterpret_cast<const XrSystemSpatialAnchorPropertiesBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemSpatialAnchorPropertiesBD&() {
    return *reinterpret_cast<XrSystemSpatialAnchorPropertiesBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemSpatialAnchorPropertiesBD
  XrSystemSpatialAnchorPropertiesBD const* get() const noexcept {
    return reinterpret_cast<XrSystemSpatialAnchorPropertiesBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemSpatialAnchorPropertiesBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemSpatialAnchorPropertiesBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemSpatialAnchorPropertiesBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemSpatialAnchorPropertiesBD*>(this);
  }
  Bool32 supportsSpatialAnchor;
};
static_assert(sizeof(XrSystemSpatialAnchorPropertiesBD) == sizeof(SystemSpatialAnchorPropertiesBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemSpatialAnchorPropertiesBD pointer to const from a
 * SystemSpatialAnchorPropertiesBD reference to const.
 * @relates SystemSpatialAnchorPropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialAnchorPropertiesBD const* get(
    SystemSpatialAnchorPropertiesBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemSpatialAnchorPropertiesBD as the address of a raw XrSystemSpatialAnchorPropertiesBD
 * @relates SystemSpatialAnchorPropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialAnchorPropertiesBD* put(SystemSpatialAnchorPropertiesBD& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_anchor

#ifdef XR_BD_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorCreateInfoBD
 *
 * Provided by the `XR_BD_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorCreateInfoBD>
 * @xrentity{XrSpatialAnchorCreateInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorCreateInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorCreateInfoBD(const Space& space_, const Posef& pose_, const Time& time_,
                            const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorCreateInfoBD, next_),
        space{space_},
        pose{pose_},
        time{time_} {}

  //! Default/empty constructor
  SpatialAnchorCreateInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorCreateInfoBD, next_), space{}, pose{}, time{} {}

  //! Default copy constructor
  SpatialAnchorCreateInfoBD(const SpatialAnchorCreateInfoBD& rhs) = default;
  //! Default copy assignment
  SpatialAnchorCreateInfoBD& operator=(const SpatialAnchorCreateInfoBD& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorCreateInfoBD(const XrSpatialAnchorCreateInfoBD& rhs) : SpatialAnchorCreateInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorCreateInfoBD& operator=(const XrSpatialAnchorCreateInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorCreateInfoBD&() const {
    return *reinterpret_cast<const XrSpatialAnchorCreateInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorCreateInfoBD&() {
    return *reinterpret_cast<XrSpatialAnchorCreateInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorCreateInfoBD
  XrSpatialAnchorCreateInfoBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorCreateInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorCreateInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorCreateInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorCreateInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorCreateInfoBD*>(this);
  }
  Space space;
  Posef pose;
  Time time;
};
static_assert(sizeof(XrSpatialAnchorCreateInfoBD) == sizeof(SpatialAnchorCreateInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorCreateInfoBD pointer to const from a
 * SpatialAnchorCreateInfoBD reference to const.
 * @relates SpatialAnchorCreateInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoBD const* get(
    SpatialAnchorCreateInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorCreateInfoBD as
 * the address of a raw XrSpatialAnchorCreateInfoBD
 * @relates SpatialAnchorCreateInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoBD* put(SpatialAnchorCreateInfoBD& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_anchor

#ifdef XR_BD_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorCreateCompletionBD
 *
 * Provided by the `XR_BD_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorCreateCompletionBD>
 * @xrentity{XrSpatialAnchorCreateCompletionBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorCreateCompletionBD : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialAnchorCreateCompletionBD(void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorCreateCompletionBD, {}, next_) {}

  //! Default copy constructor
  SpatialAnchorCreateCompletionBD(const SpatialAnchorCreateCompletionBD& rhs) = default;
  //! Default copy assignment
  SpatialAnchorCreateCompletionBD& operator=(const SpatialAnchorCreateCompletionBD& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorCreateCompletionBD(const XrSpatialAnchorCreateCompletionBD& rhs)
      : SpatialAnchorCreateCompletionBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorCreateCompletionBD& operator=(const XrSpatialAnchorCreateCompletionBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorCreateCompletionBD&() const {
    return *reinterpret_cast<const XrSpatialAnchorCreateCompletionBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorCreateCompletionBD&() {
    return *reinterpret_cast<XrSpatialAnchorCreateCompletionBD*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialAnchorCreateCompletionBD
  XrSpatialAnchorCreateCompletionBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorCreateCompletionBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorCreateCompletionBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorCreateCompletionBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorCreateCompletionBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorCreateCompletionBD*>(this);
  }
  AnchorBD anchor;
  UuidEXT uuid;
};
static_assert(sizeof(XrSpatialAnchorCreateCompletionBD) == sizeof(SpatialAnchorCreateCompletionBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorCreateCompletionBD pointer to const from a
 * SpatialAnchorCreateCompletionBD reference to const.
 * @relates SpatialAnchorCreateCompletionBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateCompletionBD const* get(
    SpatialAnchorCreateCompletionBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialAnchorCreateCompletionBD as the address of a raw XrSpatialAnchorCreateCompletionBD
 * @relates SpatialAnchorCreateCompletionBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateCompletionBD* put(SpatialAnchorCreateCompletionBD& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpatialAnchorCreateCompletionBD as a raw,
 * pointer to const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates SpatialAnchorCreateCompletionBD
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    SpatialAnchorCreateCompletionBD const& h) {
  return h.get_base();
}
#endif  // XR_BD_spatial_anchor

#ifdef XR_BD_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorPersistInfoBD
 *
 * Provided by the `XR_BD_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorPersistInfoBD>
 * @xrentity{XrSpatialAnchorPersistInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorPersistInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorPersistInfoBD(const PersistenceLocationBD& location_, const AnchorBD& anchor_,
                             const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorPersistInfoBD, next_),
        location{location_},
        anchor{anchor_} {}

  //! Default/empty constructor
  SpatialAnchorPersistInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorPersistInfoBD, next_), location{}, anchor{} {}

  //! Default copy constructor
  SpatialAnchorPersistInfoBD(const SpatialAnchorPersistInfoBD& rhs) = default;
  //! Default copy assignment
  SpatialAnchorPersistInfoBD& operator=(const SpatialAnchorPersistInfoBD& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorPersistInfoBD(const XrSpatialAnchorPersistInfoBD& rhs)
      : SpatialAnchorPersistInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorPersistInfoBD& operator=(const XrSpatialAnchorPersistInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorPersistInfoBD&() const {
    return *reinterpret_cast<const XrSpatialAnchorPersistInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorPersistInfoBD&() {
    return *reinterpret_cast<XrSpatialAnchorPersistInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorPersistInfoBD
  XrSpatialAnchorPersistInfoBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorPersistInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorPersistInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorPersistInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorPersistInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorPersistInfoBD*>(this);
  }
  PersistenceLocationBD location;
  AnchorBD anchor;
};
static_assert(sizeof(XrSpatialAnchorPersistInfoBD) == sizeof(SpatialAnchorPersistInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorPersistInfoBD pointer to const from a
 * SpatialAnchorPersistInfoBD reference to const.
 * @relates SpatialAnchorPersistInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorPersistInfoBD const* get(
    SpatialAnchorPersistInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorPersistInfoBD as
 * the address of a raw XrSpatialAnchorPersistInfoBD
 * @relates SpatialAnchorPersistInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorPersistInfoBD* put(SpatialAnchorPersistInfoBD& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_anchor

#ifdef XR_BD_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorUnpersistInfoBD
 *
 * Provided by the `XR_BD_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorUnpersistInfoBD>
 * @xrentity{XrSpatialAnchorUnpersistInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorUnpersistInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorUnpersistInfoBD(const PersistenceLocationBD& location_, const AnchorBD& anchor_,
                               const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorUnpersistInfoBD, next_),
        location{location_},
        anchor{anchor_} {}

  //! Default/empty constructor
  SpatialAnchorUnpersistInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorUnpersistInfoBD, next_), location{}, anchor{} {}

  //! Default copy constructor
  SpatialAnchorUnpersistInfoBD(const SpatialAnchorUnpersistInfoBD& rhs) = default;
  //! Default copy assignment
  SpatialAnchorUnpersistInfoBD& operator=(const SpatialAnchorUnpersistInfoBD& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorUnpersistInfoBD(const XrSpatialAnchorUnpersistInfoBD& rhs)
      : SpatialAnchorUnpersistInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorUnpersistInfoBD& operator=(const XrSpatialAnchorUnpersistInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorUnpersistInfoBD&() const {
    return *reinterpret_cast<const XrSpatialAnchorUnpersistInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorUnpersistInfoBD&() {
    return *reinterpret_cast<XrSpatialAnchorUnpersistInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorUnpersistInfoBD
  XrSpatialAnchorUnpersistInfoBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorUnpersistInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorUnpersistInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorUnpersistInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorUnpersistInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorUnpersistInfoBD*>(this);
  }
  PersistenceLocationBD location;
  AnchorBD anchor;
};
static_assert(sizeof(XrSpatialAnchorUnpersistInfoBD) == sizeof(SpatialAnchorUnpersistInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorUnpersistInfoBD pointer to const from a
 * SpatialAnchorUnpersistInfoBD reference to const.
 * @relates SpatialAnchorUnpersistInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorUnpersistInfoBD const* get(
    SpatialAnchorUnpersistInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorUnpersistInfoBD
 * as the address of a raw XrSpatialAnchorUnpersistInfoBD
 * @relates SpatialAnchorUnpersistInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorUnpersistInfoBD* put(SpatialAnchorUnpersistInfoBD& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_anchor

#ifdef XR_BD_spatial_anchor_sharing
/*!
 * C++ projection of XrSystemSpatialAnchorSharingPropertiesBD
 *
 * Provided by the `XR_BD_spatial_anchor_sharing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpatialAnchorSharingPropertiesBD>
 * @xrentity{XrSystemSpatialAnchorSharingPropertiesBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemSpatialAnchorSharingPropertiesBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemSpatialAnchorSharingPropertiesBD(void* next_ = nullptr)

      : Parent(StructureType::SystemSpatialAnchorSharingPropertiesBD, next_) {}

  //! Default copy constructor
  SystemSpatialAnchorSharingPropertiesBD(const SystemSpatialAnchorSharingPropertiesBD& rhs) =
      default;
  //! Default copy assignment
  SystemSpatialAnchorSharingPropertiesBD& operator=(
      const SystemSpatialAnchorSharingPropertiesBD& rhs) = default;
  //! Copy construct from raw
  SystemSpatialAnchorSharingPropertiesBD(const XrSystemSpatialAnchorSharingPropertiesBD& rhs)
      : SystemSpatialAnchorSharingPropertiesBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemSpatialAnchorSharingPropertiesBD& operator=(
      const XrSystemSpatialAnchorSharingPropertiesBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemSpatialAnchorSharingPropertiesBD&() const {
    return *reinterpret_cast<const XrSystemSpatialAnchorSharingPropertiesBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemSpatialAnchorSharingPropertiesBD&() {
    return *reinterpret_cast<XrSystemSpatialAnchorSharingPropertiesBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemSpatialAnchorSharingPropertiesBD
  XrSystemSpatialAnchorSharingPropertiesBD const* get() const noexcept {
    return reinterpret_cast<XrSystemSpatialAnchorSharingPropertiesBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemSpatialAnchorSharingPropertiesBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemSpatialAnchorSharingPropertiesBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemSpatialAnchorSharingPropertiesBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemSpatialAnchorSharingPropertiesBD*>(this);
  }
  Bool32 supportsSpatialAnchorSharing;
};
static_assert(sizeof(XrSystemSpatialAnchorSharingPropertiesBD) ==
                  sizeof(SystemSpatialAnchorSharingPropertiesBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemSpatialAnchorSharingPropertiesBD pointer to const
 * from a SystemSpatialAnchorSharingPropertiesBD reference to const.
 * @relates SystemSpatialAnchorSharingPropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialAnchorSharingPropertiesBD const* get(
    SystemSpatialAnchorSharingPropertiesBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemSpatialAnchorSharingPropertiesBD as the address of a raw
 * XrSystemSpatialAnchorSharingPropertiesBD
 * @relates SystemSpatialAnchorSharingPropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialAnchorSharingPropertiesBD* put(
    SystemSpatialAnchorSharingPropertiesBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_anchor_sharing

#ifdef XR_BD_spatial_anchor_sharing
/*!
 * C++ projection of XrSpatialAnchorShareInfoBD
 *
 * Provided by the `XR_BD_spatial_anchor_sharing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorShareInfoBD>
 * @xrentity{XrSpatialAnchorShareInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorShareInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorShareInfoBD(const AnchorBD& anchor_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorShareInfoBD, next_), anchor{anchor_} {}

  //! Default/empty constructor
  SpatialAnchorShareInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorShareInfoBD, next_), anchor{} {}

  //! Default copy constructor
  SpatialAnchorShareInfoBD(const SpatialAnchorShareInfoBD& rhs) = default;
  //! Default copy assignment
  SpatialAnchorShareInfoBD& operator=(const SpatialAnchorShareInfoBD& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorShareInfoBD(const XrSpatialAnchorShareInfoBD& rhs) : SpatialAnchorShareInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorShareInfoBD& operator=(const XrSpatialAnchorShareInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorShareInfoBD&() const {
    return *reinterpret_cast<const XrSpatialAnchorShareInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorShareInfoBD&() {
    return *reinterpret_cast<XrSpatialAnchorShareInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorShareInfoBD
  XrSpatialAnchorShareInfoBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorShareInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorShareInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorShareInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorShareInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorShareInfoBD*>(this);
  }
  AnchorBD anchor;
};
static_assert(sizeof(XrSpatialAnchorShareInfoBD) == sizeof(SpatialAnchorShareInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorShareInfoBD pointer to const from a
 * SpatialAnchorShareInfoBD reference to const.
 * @relates SpatialAnchorShareInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorShareInfoBD const* get(SpatialAnchorShareInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorShareInfoBD as
 * the address of a raw XrSpatialAnchorShareInfoBD
 * @relates SpatialAnchorShareInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorShareInfoBD* put(SpatialAnchorShareInfoBD& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_anchor_sharing

#ifdef XR_BD_spatial_anchor_sharing
/*!
 * C++ projection of XrSharedSpatialAnchorDownloadInfoBD
 *
 * Provided by the `XR_BD_spatial_anchor_sharing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSharedSpatialAnchorDownloadInfoBD>
 * @xrentity{XrSharedSpatialAnchorDownloadInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SharedSpatialAnchorDownloadInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SharedSpatialAnchorDownloadInfoBD(const UuidEXT& uuid_, const void* next_ = nullptr)
      : Parent(StructureType::SharedSpatialAnchorDownloadInfoBD, next_), uuid{uuid_} {}

  //! Default/empty constructor
  SharedSpatialAnchorDownloadInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::SharedSpatialAnchorDownloadInfoBD, next_), uuid{} {}

  //! Default copy constructor
  SharedSpatialAnchorDownloadInfoBD(const SharedSpatialAnchorDownloadInfoBD& rhs) = default;
  //! Default copy assignment
  SharedSpatialAnchorDownloadInfoBD& operator=(const SharedSpatialAnchorDownloadInfoBD& rhs) =
      default;
  //! Copy construct from raw
  SharedSpatialAnchorDownloadInfoBD(const XrSharedSpatialAnchorDownloadInfoBD& rhs)
      : SharedSpatialAnchorDownloadInfoBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SharedSpatialAnchorDownloadInfoBD& operator=(const XrSharedSpatialAnchorDownloadInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSharedSpatialAnchorDownloadInfoBD&() const {
    return *reinterpret_cast<const XrSharedSpatialAnchorDownloadInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSharedSpatialAnchorDownloadInfoBD&() {
    return *reinterpret_cast<XrSharedSpatialAnchorDownloadInfoBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSharedSpatialAnchorDownloadInfoBD
  XrSharedSpatialAnchorDownloadInfoBD const* get() const noexcept {
    return reinterpret_cast<XrSharedSpatialAnchorDownloadInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSharedSpatialAnchorDownloadInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSharedSpatialAnchorDownloadInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SharedSpatialAnchorDownloadInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSharedSpatialAnchorDownloadInfoBD*>(this);
  }
  UuidEXT uuid;
};
static_assert(sizeof(XrSharedSpatialAnchorDownloadInfoBD) ==
                  sizeof(SharedSpatialAnchorDownloadInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSharedSpatialAnchorDownloadInfoBD pointer to const from
 * a SharedSpatialAnchorDownloadInfoBD reference to const.
 * @relates SharedSpatialAnchorDownloadInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSharedSpatialAnchorDownloadInfoBD const* get(
    SharedSpatialAnchorDownloadInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SharedSpatialAnchorDownloadInfoBD as the address of a raw XrSharedSpatialAnchorDownloadInfoBD
 * @relates SharedSpatialAnchorDownloadInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSharedSpatialAnchorDownloadInfoBD* put(
    SharedSpatialAnchorDownloadInfoBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_anchor_sharing

#ifdef XR_BD_spatial_scene
/*!
 * C++ projection of XrSystemSpatialScenePropertiesBD
 *
 * Provided by the `XR_BD_spatial_scene` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpatialScenePropertiesBD>
 * @xrentity{XrSystemSpatialScenePropertiesBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemSpatialScenePropertiesBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemSpatialScenePropertiesBD(void* next_ = nullptr)

      : Parent(StructureType::SystemSpatialScenePropertiesBD, next_) {}

  //! Default copy constructor
  SystemSpatialScenePropertiesBD(const SystemSpatialScenePropertiesBD& rhs) = default;
  //! Default copy assignment
  SystemSpatialScenePropertiesBD& operator=(const SystemSpatialScenePropertiesBD& rhs) = default;
  //! Copy construct from raw
  SystemSpatialScenePropertiesBD(const XrSystemSpatialScenePropertiesBD& rhs)
      : SystemSpatialScenePropertiesBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemSpatialScenePropertiesBD& operator=(const XrSystemSpatialScenePropertiesBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemSpatialScenePropertiesBD&() const {
    return *reinterpret_cast<const XrSystemSpatialScenePropertiesBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemSpatialScenePropertiesBD&() {
    return *reinterpret_cast<XrSystemSpatialScenePropertiesBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemSpatialScenePropertiesBD
  XrSystemSpatialScenePropertiesBD const* get() const noexcept {
    return reinterpret_cast<XrSystemSpatialScenePropertiesBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemSpatialScenePropertiesBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemSpatialScenePropertiesBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemSpatialScenePropertiesBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemSpatialScenePropertiesBD*>(this);
  }
  Bool32 supportsSpatialScene;
};
static_assert(sizeof(XrSystemSpatialScenePropertiesBD) == sizeof(SystemSpatialScenePropertiesBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemSpatialScenePropertiesBD pointer to const from a
 * SystemSpatialScenePropertiesBD reference to const.
 * @relates SystemSpatialScenePropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialScenePropertiesBD const* get(
    SystemSpatialScenePropertiesBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemSpatialScenePropertiesBD as the address of a raw XrSystemSpatialScenePropertiesBD
 * @relates SystemSpatialScenePropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialScenePropertiesBD* put(SystemSpatialScenePropertiesBD& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_scene

#ifdef XR_BD_spatial_scene
/*!
 * C++ projection of XrSceneCaptureInfoBD
 *
 * Provided by the `XR_BD_spatial_scene` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneCaptureInfoBD>
 * @xrentity{XrSceneCaptureInfoBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SceneCaptureInfoBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SceneCaptureInfoBD(const void* next_ = nullptr)

      : Parent(StructureType::SceneCaptureInfoBD, next_) {}

  //! Default copy constructor
  SceneCaptureInfoBD(const SceneCaptureInfoBD& rhs) = default;
  //! Default copy assignment
  SceneCaptureInfoBD& operator=(const SceneCaptureInfoBD& rhs) = default;
  //! Copy construct from raw
  SceneCaptureInfoBD(const XrSceneCaptureInfoBD& rhs) : SceneCaptureInfoBD() { *put() = rhs; }
  //! Copy assign from raw
  SceneCaptureInfoBD& operator=(const XrSceneCaptureInfoBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSceneCaptureInfoBD&() const {
    return *reinterpret_cast<const XrSceneCaptureInfoBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSceneCaptureInfoBD&() { return *reinterpret_cast<XrSceneCaptureInfoBD*>(this); }

  //! Accessor for this as the address of a raw XrSceneCaptureInfoBD
  XrSceneCaptureInfoBD const* get() const noexcept {
    return reinterpret_cast<XrSceneCaptureInfoBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSceneCaptureInfoBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSceneCaptureInfoBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SceneCaptureInfoBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSceneCaptureInfoBD*>(this);
  }
};
static_assert(sizeof(XrSceneCaptureInfoBD) == sizeof(SceneCaptureInfoBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSceneCaptureInfoBD pointer to const from a
 * SceneCaptureInfoBD reference to const.
 * @relates SceneCaptureInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneCaptureInfoBD const* get(SceneCaptureInfoBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SceneCaptureInfoBD as the
 * address of a raw XrSceneCaptureInfoBD
 * @relates SceneCaptureInfoBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSceneCaptureInfoBD* put(SceneCaptureInfoBD& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_scene

#ifdef XR_BD_spatial_mesh
/*!
 * C++ projection of XrSystemSpatialMeshPropertiesBD
 *
 * Provided by the `XR_BD_spatial_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpatialMeshPropertiesBD>
 * @xrentity{XrSystemSpatialMeshPropertiesBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemSpatialMeshPropertiesBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemSpatialMeshPropertiesBD(void* next_ = nullptr)

      : Parent(StructureType::SystemSpatialMeshPropertiesBD, next_) {}

  //! Default copy constructor
  SystemSpatialMeshPropertiesBD(const SystemSpatialMeshPropertiesBD& rhs) = default;
  //! Default copy assignment
  SystemSpatialMeshPropertiesBD& operator=(const SystemSpatialMeshPropertiesBD& rhs) = default;
  //! Copy construct from raw
  SystemSpatialMeshPropertiesBD(const XrSystemSpatialMeshPropertiesBD& rhs)
      : SystemSpatialMeshPropertiesBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemSpatialMeshPropertiesBD& operator=(const XrSystemSpatialMeshPropertiesBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemSpatialMeshPropertiesBD&() const {
    return *reinterpret_cast<const XrSystemSpatialMeshPropertiesBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemSpatialMeshPropertiesBD&() {
    return *reinterpret_cast<XrSystemSpatialMeshPropertiesBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemSpatialMeshPropertiesBD
  XrSystemSpatialMeshPropertiesBD const* get() const noexcept {
    return reinterpret_cast<XrSystemSpatialMeshPropertiesBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemSpatialMeshPropertiesBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemSpatialMeshPropertiesBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemSpatialMeshPropertiesBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemSpatialMeshPropertiesBD*>(this);
  }
  Bool32 supportsSpatialMesh;
};
static_assert(sizeof(XrSystemSpatialMeshPropertiesBD) == sizeof(SystemSpatialMeshPropertiesBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemSpatialMeshPropertiesBD pointer to const from a
 * SystemSpatialMeshPropertiesBD reference to const.
 * @relates SystemSpatialMeshPropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialMeshPropertiesBD const* get(
    SystemSpatialMeshPropertiesBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemSpatialMeshPropertiesBD
 * as the address of a raw XrSystemSpatialMeshPropertiesBD
 * @relates SystemSpatialMeshPropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialMeshPropertiesBD* put(SystemSpatialMeshPropertiesBD& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_mesh

#ifdef XR_BD_spatial_mesh
/*!
 * C++ projection of XrSenseDataProviderCreateInfoSpatialMeshBD
 *
 * Provided by the `XR_BD_spatial_mesh` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSenseDataProviderCreateInfoSpatialMeshBD>
 * @xrentity{XrSenseDataProviderCreateInfoSpatialMeshBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SenseDataProviderCreateInfoSpatialMeshBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SenseDataProviderCreateInfoSpatialMeshBD(const SpatialMeshConfigFlagsBD& configFlags_,
                                           const SpatialMeshLodBD& lod_,
                                           const void* next_ = nullptr)
      : Parent(StructureType::SenseDataProviderCreateInfoSpatialMeshBD, next_),
        configFlags{configFlags_},
        lod{lod_} {}

  //! Default/empty constructor
  SenseDataProviderCreateInfoSpatialMeshBD(const void* next_ = nullptr)

      : Parent(StructureType::SenseDataProviderCreateInfoSpatialMeshBD, next_),
        configFlags{},
        lod{} {}

  //! Default copy constructor
  SenseDataProviderCreateInfoSpatialMeshBD(const SenseDataProviderCreateInfoSpatialMeshBD& rhs) =
      default;
  //! Default copy assignment
  SenseDataProviderCreateInfoSpatialMeshBD& operator=(
      const SenseDataProviderCreateInfoSpatialMeshBD& rhs) = default;
  //! Copy construct from raw
  SenseDataProviderCreateInfoSpatialMeshBD(const XrSenseDataProviderCreateInfoSpatialMeshBD& rhs)
      : SenseDataProviderCreateInfoSpatialMeshBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SenseDataProviderCreateInfoSpatialMeshBD& operator=(
      const XrSenseDataProviderCreateInfoSpatialMeshBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSenseDataProviderCreateInfoSpatialMeshBD&() const {
    return *reinterpret_cast<const XrSenseDataProviderCreateInfoSpatialMeshBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSenseDataProviderCreateInfoSpatialMeshBD&() {
    return *reinterpret_cast<XrSenseDataProviderCreateInfoSpatialMeshBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSenseDataProviderCreateInfoSpatialMeshBD
  XrSenseDataProviderCreateInfoSpatialMeshBD const* get() const noexcept {
    return reinterpret_cast<XrSenseDataProviderCreateInfoSpatialMeshBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSenseDataProviderCreateInfoSpatialMeshBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSenseDataProviderCreateInfoSpatialMeshBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SenseDataProviderCreateInfoSpatialMeshBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSenseDataProviderCreateInfoSpatialMeshBD*>(this);
  }
  SpatialMeshConfigFlagsBD configFlags;
  SpatialMeshLodBD lod;
};
static_assert(sizeof(XrSenseDataProviderCreateInfoSpatialMeshBD) ==
                  sizeof(SenseDataProviderCreateInfoSpatialMeshBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSenseDataProviderCreateInfoSpatialMeshBD pointer to
 * const from a SenseDataProviderCreateInfoSpatialMeshBD reference to const.
 * @relates SenseDataProviderCreateInfoSpatialMeshBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataProviderCreateInfoSpatialMeshBD const* get(
    SenseDataProviderCreateInfoSpatialMeshBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SenseDataProviderCreateInfoSpatialMeshBD as the address of a raw
 * XrSenseDataProviderCreateInfoSpatialMeshBD
 * @relates SenseDataProviderCreateInfoSpatialMeshBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataProviderCreateInfoSpatialMeshBD* put(
    SenseDataProviderCreateInfoSpatialMeshBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_mesh

#ifdef XR_BD_future_progress
/*!
 * C++ projection of XrFuturePollResultProgressBD
 *
 * Provided by the `XR_BD_future_progress` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFuturePollResultProgressBD>
 * @xrentity{XrFuturePollResultProgressBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FuturePollResultProgressBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FuturePollResultProgressBD(void* next_ = nullptr)

      : Parent(StructureType::FuturePollResultProgressBD, next_) {}

  //! Default copy constructor
  FuturePollResultProgressBD(const FuturePollResultProgressBD& rhs) = default;
  //! Default copy assignment
  FuturePollResultProgressBD& operator=(const FuturePollResultProgressBD& rhs) = default;
  //! Copy construct from raw
  FuturePollResultProgressBD(const XrFuturePollResultProgressBD& rhs)
      : FuturePollResultProgressBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FuturePollResultProgressBD& operator=(const XrFuturePollResultProgressBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFuturePollResultProgressBD&() const {
    return *reinterpret_cast<const XrFuturePollResultProgressBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFuturePollResultProgressBD&() {
    return *reinterpret_cast<XrFuturePollResultProgressBD*>(this);
  }

  //! Accessor for this as the address of a raw XrFuturePollResultProgressBD
  XrFuturePollResultProgressBD const* get() const noexcept {
    return reinterpret_cast<XrFuturePollResultProgressBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFuturePollResultProgressBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFuturePollResultProgressBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FuturePollResultProgressBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrFuturePollResultProgressBD*>(this);
  }
  Bool32 isSupported;
  uint32_t progressPercentage;
};
static_assert(sizeof(XrFuturePollResultProgressBD) == sizeof(FuturePollResultProgressBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFuturePollResultProgressBD pointer to const from a
 * FuturePollResultProgressBD reference to const.
 * @relates FuturePollResultProgressBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFuturePollResultProgressBD const* get(
    FuturePollResultProgressBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FuturePollResultProgressBD as
 * the address of a raw XrFuturePollResultProgressBD
 * @relates FuturePollResultProgressBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFuturePollResultProgressBD* put(FuturePollResultProgressBD& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_future_progress

#ifdef XR_BD_spatial_plane
/*!
 * C++ projection of XrSystemSpatialPlanePropertiesBD
 *
 * Provided by the `XR_BD_spatial_plane` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpatialPlanePropertiesBD>
 * @xrentity{XrSystemSpatialPlanePropertiesBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemSpatialPlanePropertiesBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemSpatialPlanePropertiesBD(void* next_ = nullptr)

      : Parent(StructureType::SystemSpatialPlanePropertiesBD, next_) {}

  //! Default copy constructor
  SystemSpatialPlanePropertiesBD(const SystemSpatialPlanePropertiesBD& rhs) = default;
  //! Default copy assignment
  SystemSpatialPlanePropertiesBD& operator=(const SystemSpatialPlanePropertiesBD& rhs) = default;
  //! Copy construct from raw
  SystemSpatialPlanePropertiesBD(const XrSystemSpatialPlanePropertiesBD& rhs)
      : SystemSpatialPlanePropertiesBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemSpatialPlanePropertiesBD& operator=(const XrSystemSpatialPlanePropertiesBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemSpatialPlanePropertiesBD&() const {
    return *reinterpret_cast<const XrSystemSpatialPlanePropertiesBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemSpatialPlanePropertiesBD&() {
    return *reinterpret_cast<XrSystemSpatialPlanePropertiesBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemSpatialPlanePropertiesBD
  XrSystemSpatialPlanePropertiesBD const* get() const noexcept {
    return reinterpret_cast<XrSystemSpatialPlanePropertiesBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemSpatialPlanePropertiesBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemSpatialPlanePropertiesBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemSpatialPlanePropertiesBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemSpatialPlanePropertiesBD*>(this);
  }
  Bool32 supportsSpatialPlane;
};
static_assert(sizeof(XrSystemSpatialPlanePropertiesBD) == sizeof(SystemSpatialPlanePropertiesBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemSpatialPlanePropertiesBD pointer to const from a
 * SystemSpatialPlanePropertiesBD reference to const.
 * @relates SystemSpatialPlanePropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialPlanePropertiesBD const* get(
    SystemSpatialPlanePropertiesBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemSpatialPlanePropertiesBD as the address of a raw XrSystemSpatialPlanePropertiesBD
 * @relates SystemSpatialPlanePropertiesBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialPlanePropertiesBD* put(SystemSpatialPlanePropertiesBD& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_plane

#ifdef XR_BD_spatial_plane
/*!
 * C++ projection of XrSpatialEntityComponentDataPlaneOrientationBD
 *
 * Provided by the `XR_BD_spatial_plane` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityComponentDataPlaneOrientationBD>
 * @xrentity{XrSpatialEntityComponentDataPlaneOrientationBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityComponentDataPlaneOrientationBD : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialEntityComponentDataPlaneOrientationBD(void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityComponentDataPlaneOrientationBD, next_) {}

  //! Default copy constructor
  SpatialEntityComponentDataPlaneOrientationBD(
      const SpatialEntityComponentDataPlaneOrientationBD& rhs) = default;
  //! Default copy assignment
  SpatialEntityComponentDataPlaneOrientationBD& operator=(
      const SpatialEntityComponentDataPlaneOrientationBD& rhs) = default;
  //! Copy construct from raw
  SpatialEntityComponentDataPlaneOrientationBD(
      const XrSpatialEntityComponentDataPlaneOrientationBD& rhs)
      : SpatialEntityComponentDataPlaneOrientationBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityComponentDataPlaneOrientationBD& operator=(
      const XrSpatialEntityComponentDataPlaneOrientationBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityComponentDataPlaneOrientationBD&() const {
    return *reinterpret_cast<const XrSpatialEntityComponentDataPlaneOrientationBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityComponentDataPlaneOrientationBD&() {
    return *reinterpret_cast<XrSpatialEntityComponentDataPlaneOrientationBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityComponentDataPlaneOrientationBD
  XrSpatialEntityComponentDataPlaneOrientationBD const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityComponentDataPlaneOrientationBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityComponentDataPlaneOrientationBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityComponentDataPlaneOrientationBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityComponentDataPlaneOrientationBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityComponentDataPlaneOrientationBD*>(this);
  }
  PlaneOrientationBD orientation;
};
static_assert(sizeof(XrSpatialEntityComponentDataPlaneOrientationBD) ==
                  sizeof(SpatialEntityComponentDataPlaneOrientationBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityComponentDataPlaneOrientationBD pointer to
 * const from a SpatialEntityComponentDataPlaneOrientationBD reference to const.
 * @relates SpatialEntityComponentDataPlaneOrientationBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataPlaneOrientationBD const* get(
    SpatialEntityComponentDataPlaneOrientationBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialEntityComponentDataPlaneOrientationBD as the address of a raw
 * XrSpatialEntityComponentDataPlaneOrientationBD
 * @relates SpatialEntityComponentDataPlaneOrientationBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityComponentDataPlaneOrientationBD* put(
    SpatialEntityComponentDataPlaneOrientationBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_plane

#ifdef XR_BD_spatial_plane
/*!
 * C++ projection of XrSenseDataFilterPlaneOrientationBD
 *
 * Provided by the `XR_BD_spatial_plane` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSenseDataFilterPlaneOrientationBD>
 * @xrentity{XrSenseDataFilterPlaneOrientationBD}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SenseDataFilterPlaneOrientationBD : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SenseDataFilterPlaneOrientationBD(uint32_t orientationCount_, PlaneOrientationBD* orientations_,
                                    const void* next_ = nullptr)
      : Parent(StructureType::SenseDataFilterPlaneOrientationBD, next_),
        orientationCount{orientationCount_},
        orientations{orientations_} {}

  //! Default/empty constructor
  SenseDataFilterPlaneOrientationBD(const void* next_ = nullptr)

      : Parent(StructureType::SenseDataFilterPlaneOrientationBD, next_),
        orientationCount{0},
        orientations{nullptr} {}

  //! Default copy constructor
  SenseDataFilterPlaneOrientationBD(const SenseDataFilterPlaneOrientationBD& rhs) = default;
  //! Default copy assignment
  SenseDataFilterPlaneOrientationBD& operator=(const SenseDataFilterPlaneOrientationBD& rhs) =
      default;
  //! Copy construct from raw
  SenseDataFilterPlaneOrientationBD(const XrSenseDataFilterPlaneOrientationBD& rhs)
      : SenseDataFilterPlaneOrientationBD() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SenseDataFilterPlaneOrientationBD& operator=(const XrSenseDataFilterPlaneOrientationBD& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSenseDataFilterPlaneOrientationBD&() const {
    return *reinterpret_cast<const XrSenseDataFilterPlaneOrientationBD*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSenseDataFilterPlaneOrientationBD&() {
    return *reinterpret_cast<XrSenseDataFilterPlaneOrientationBD*>(this);
  }

  //! Accessor for this as the address of a raw XrSenseDataFilterPlaneOrientationBD
  XrSenseDataFilterPlaneOrientationBD const* get() const noexcept {
    return reinterpret_cast<XrSenseDataFilterPlaneOrientationBD const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSenseDataFilterPlaneOrientationBD.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSenseDataFilterPlaneOrientationBD* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SenseDataFilterPlaneOrientationBD{};
      next = oldNext;
    }
    return reinterpret_cast<XrSenseDataFilterPlaneOrientationBD*>(this);
  }
  uint32_t orientationCount;
  PlaneOrientationBD* orientations;
};
static_assert(sizeof(XrSenseDataFilterPlaneOrientationBD) ==
                  sizeof(SenseDataFilterPlaneOrientationBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSenseDataFilterPlaneOrientationBD pointer to const from
 * a SenseDataFilterPlaneOrientationBD reference to const.
 * @relates SenseDataFilterPlaneOrientationBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataFilterPlaneOrientationBD const* get(
    SenseDataFilterPlaneOrientationBD const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SenseDataFilterPlaneOrientationBD as the address of a raw XrSenseDataFilterPlaneOrientationBD
 * @relates SenseDataFilterPlaneOrientationBD
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSenseDataFilterPlaneOrientationBD* put(
    SenseDataFilterPlaneOrientationBD& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_BD_spatial_plane

#ifdef XR_EXT_hand_tracking_data_source
/*!
 * C++ projection of XrHandTrackingDataSourceInfoEXT
 *
 * Provided by the `XR_EXT_hand_tracking_data_source` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingDataSourceInfoEXT>
 * @xrentity{XrHandTrackingDataSourceInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackingDataSourceInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  HandTrackingDataSourceInfoEXT(uint32_t requestedDataSourceCount_,
                                HandTrackingDataSourceEXT* requestedDataSources_,
                                const void* next_ = nullptr)
      : Parent(StructureType::HandTrackingDataSourceInfoEXT, next_),
        requestedDataSourceCount{requestedDataSourceCount_},
        requestedDataSources{requestedDataSources_} {}

  //! Default/empty constructor
  HandTrackingDataSourceInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::HandTrackingDataSourceInfoEXT, next_),
        requestedDataSourceCount{0},
        requestedDataSources{nullptr} {}

  //! Default copy constructor
  HandTrackingDataSourceInfoEXT(const HandTrackingDataSourceInfoEXT& rhs) = default;
  //! Default copy assignment
  HandTrackingDataSourceInfoEXT& operator=(const HandTrackingDataSourceInfoEXT& rhs) = default;
  //! Copy construct from raw
  HandTrackingDataSourceInfoEXT(const XrHandTrackingDataSourceInfoEXT& rhs)
      : HandTrackingDataSourceInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandTrackingDataSourceInfoEXT& operator=(const XrHandTrackingDataSourceInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackingDataSourceInfoEXT&() const {
    return *reinterpret_cast<const XrHandTrackingDataSourceInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackingDataSourceInfoEXT&() {
    return *reinterpret_cast<XrHandTrackingDataSourceInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandTrackingDataSourceInfoEXT
  XrHandTrackingDataSourceInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrHandTrackingDataSourceInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandTrackingDataSourceInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackingDataSourceInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackingDataSourceInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackingDataSourceInfoEXT*>(this);
  }
  uint32_t requestedDataSourceCount;
  HandTrackingDataSourceEXT* requestedDataSources;
};
static_assert(sizeof(XrHandTrackingDataSourceInfoEXT) == sizeof(HandTrackingDataSourceInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackingDataSourceInfoEXT pointer to const from a
 * HandTrackingDataSourceInfoEXT reference to const.
 * @relates HandTrackingDataSourceInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingDataSourceInfoEXT const* get(
    HandTrackingDataSourceInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing HandTrackingDataSourceInfoEXT
 * as the address of a raw XrHandTrackingDataSourceInfoEXT
 * @relates HandTrackingDataSourceInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingDataSourceInfoEXT* put(HandTrackingDataSourceInfoEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking_data_source

#ifdef XR_EXT_hand_tracking_data_source
/*!
 * C++ projection of XrHandTrackingDataSourceStateEXT
 *
 * Provided by the `XR_EXT_hand_tracking_data_source` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackingDataSourceStateEXT>
 * @xrentity{XrHandTrackingDataSourceStateEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS HandTrackingDataSourceStateEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  HandTrackingDataSourceStateEXT(void* next_ = nullptr)

      : Parent(StructureType::HandTrackingDataSourceStateEXT, next_) {}

  //! Default copy constructor
  HandTrackingDataSourceStateEXT(const HandTrackingDataSourceStateEXT& rhs) = default;
  //! Default copy assignment
  HandTrackingDataSourceStateEXT& operator=(const HandTrackingDataSourceStateEXT& rhs) = default;
  //! Copy construct from raw
  HandTrackingDataSourceStateEXT(const XrHandTrackingDataSourceStateEXT& rhs)
      : HandTrackingDataSourceStateEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  HandTrackingDataSourceStateEXT& operator=(const XrHandTrackingDataSourceStateEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrHandTrackingDataSourceStateEXT&() const {
    return *reinterpret_cast<const XrHandTrackingDataSourceStateEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrHandTrackingDataSourceStateEXT&() {
    return *reinterpret_cast<XrHandTrackingDataSourceStateEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrHandTrackingDataSourceStateEXT
  XrHandTrackingDataSourceStateEXT const* get() const noexcept {
    return reinterpret_cast<XrHandTrackingDataSourceStateEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrHandTrackingDataSourceStateEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrHandTrackingDataSourceStateEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = HandTrackingDataSourceStateEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrHandTrackingDataSourceStateEXT*>(this);
  }
  Bool32 isActive;
  HandTrackingDataSourceEXT dataSource;
};
static_assert(sizeof(XrHandTrackingDataSourceStateEXT) == sizeof(HandTrackingDataSourceStateEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrHandTrackingDataSourceStateEXT pointer to const from a
 * HandTrackingDataSourceStateEXT reference to const.
 * @relates HandTrackingDataSourceStateEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingDataSourceStateEXT const* get(
    HandTrackingDataSourceStateEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * HandTrackingDataSourceStateEXT as the address of a raw XrHandTrackingDataSourceStateEXT
 * @relates HandTrackingDataSourceStateEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrHandTrackingDataSourceStateEXT* put(HandTrackingDataSourceStateEXT& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_hand_tracking_data_source

#ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrSystemPlaneDetectionPropertiesEXT
 *
 * Provided by the `XR_EXT_plane_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemPlaneDetectionPropertiesEXT>
 * @xrentity{XrSystemPlaneDetectionPropertiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemPlaneDetectionPropertiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemPlaneDetectionPropertiesEXT(void* next_ = nullptr)

      : Parent(StructureType::SystemPlaneDetectionPropertiesEXT, next_) {}

  //! Default copy constructor
  SystemPlaneDetectionPropertiesEXT(const SystemPlaneDetectionPropertiesEXT& rhs) = default;
  //! Default copy assignment
  SystemPlaneDetectionPropertiesEXT& operator=(const SystemPlaneDetectionPropertiesEXT& rhs) =
      default;
  //! Copy construct from raw
  SystemPlaneDetectionPropertiesEXT(const XrSystemPlaneDetectionPropertiesEXT& rhs)
      : SystemPlaneDetectionPropertiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemPlaneDetectionPropertiesEXT& operator=(const XrSystemPlaneDetectionPropertiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemPlaneDetectionPropertiesEXT&() const {
    return *reinterpret_cast<const XrSystemPlaneDetectionPropertiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemPlaneDetectionPropertiesEXT&() {
    return *reinterpret_cast<XrSystemPlaneDetectionPropertiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemPlaneDetectionPropertiesEXT
  XrSystemPlaneDetectionPropertiesEXT const* get() const noexcept {
    return reinterpret_cast<XrSystemPlaneDetectionPropertiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemPlaneDetectionPropertiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemPlaneDetectionPropertiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemPlaneDetectionPropertiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemPlaneDetectionPropertiesEXT*>(this);
  }
  PlaneDetectionCapabilityFlagsEXT supportedFeatures;
};
static_assert(sizeof(XrSystemPlaneDetectionPropertiesEXT) ==
                  sizeof(SystemPlaneDetectionPropertiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemPlaneDetectionPropertiesEXT pointer to const from
 * a SystemPlaneDetectionPropertiesEXT reference to const.
 * @relates SystemPlaneDetectionPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemPlaneDetectionPropertiesEXT const* get(
    SystemPlaneDetectionPropertiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemPlaneDetectionPropertiesEXT as the address of a raw XrSystemPlaneDetectionPropertiesEXT
 * @relates SystemPlaneDetectionPropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemPlaneDetectionPropertiesEXT* put(
    SystemPlaneDetectionPropertiesEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_plane_detection

#ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrPlaneDetectorCreateInfoEXT
 *
 * Provided by the `XR_EXT_plane_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorCreateInfoEXT>
 * @xrentity{XrPlaneDetectorCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PlaneDetectorCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PlaneDetectorCreateInfoEXT(const PlaneDetectorFlagsEXT& flags_, const void* next_ = nullptr)
      : Parent(StructureType::PlaneDetectorCreateInfoEXT, next_), flags{flags_} {}

  //! Default/empty constructor
  PlaneDetectorCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::PlaneDetectorCreateInfoEXT, next_), flags{} {}

  //! Default copy constructor
  PlaneDetectorCreateInfoEXT(const PlaneDetectorCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  PlaneDetectorCreateInfoEXT& operator=(const PlaneDetectorCreateInfoEXT& rhs) = default;
  //! Copy construct from raw
  PlaneDetectorCreateInfoEXT(const XrPlaneDetectorCreateInfoEXT& rhs)
      : PlaneDetectorCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PlaneDetectorCreateInfoEXT& operator=(const XrPlaneDetectorCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPlaneDetectorCreateInfoEXT&() const {
    return *reinterpret_cast<const XrPlaneDetectorCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPlaneDetectorCreateInfoEXT&() {
    return *reinterpret_cast<XrPlaneDetectorCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrPlaneDetectorCreateInfoEXT
  XrPlaneDetectorCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrPlaneDetectorCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPlaneDetectorCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPlaneDetectorCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PlaneDetectorCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrPlaneDetectorCreateInfoEXT*>(this);
  }
  PlaneDetectorFlagsEXT flags;
};
static_assert(sizeof(XrPlaneDetectorCreateInfoEXT) == sizeof(PlaneDetectorCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPlaneDetectorCreateInfoEXT pointer to const from a
 * PlaneDetectorCreateInfoEXT reference to const.
 * @relates PlaneDetectorCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPlaneDetectorCreateInfoEXT const* get(
    PlaneDetectorCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PlaneDetectorCreateInfoEXT as
 * the address of a raw XrPlaneDetectorCreateInfoEXT
 * @relates PlaneDetectorCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPlaneDetectorCreateInfoEXT* put(PlaneDetectorCreateInfoEXT& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_plane_detection

#ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrPlaneDetectorBeginInfoEXT
 *
 * Provided by the `XR_EXT_plane_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorBeginInfoEXT>
 * @xrentity{XrPlaneDetectorBeginInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PlaneDetectorBeginInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PlaneDetectorBeginInfoEXT(const Space& baseSpace_, const Time& time_, uint32_t orientationCount_,
                            const PlaneDetectorOrientationEXT* orientations_,
                            uint32_t semanticTypeCount_,
                            const PlaneDetectorSemanticTypeEXT* semanticTypes_, uint32_t maxPlanes_,
                            float minArea_, const Posef& boundingBoxPose_,
                            const Extent3DfEXT& boundingBoxExtent_, const void* next_ = nullptr)
      : Parent(StructureType::PlaneDetectorBeginInfoEXT, next_),
        baseSpace{baseSpace_},
        time{time_},
        orientationCount{orientationCount_},
        orientations{orientations_},
        semanticTypeCount{semanticTypeCount_},
        semanticTypes{semanticTypes_},
        maxPlanes{maxPlanes_},
        minArea{minArea_},
        boundingBoxPose{boundingBoxPose_},
        boundingBoxExtent{boundingBoxExtent_} {}

  //! Default/empty constructor
  PlaneDetectorBeginInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::PlaneDetectorBeginInfoEXT, next_),
        baseSpace{},
        time{},
        orientationCount{0},
        orientations{nullptr},
        semanticTypeCount{0},
        semanticTypes{nullptr},
        maxPlanes{0},
        minArea{0.0f},
        boundingBoxPose{},
        boundingBoxExtent{} {}

  //! Default copy constructor
  PlaneDetectorBeginInfoEXT(const PlaneDetectorBeginInfoEXT& rhs) = default;
  //! Default copy assignment
  PlaneDetectorBeginInfoEXT& operator=(const PlaneDetectorBeginInfoEXT& rhs) = default;
  //! Copy construct from raw
  PlaneDetectorBeginInfoEXT(const XrPlaneDetectorBeginInfoEXT& rhs) : PlaneDetectorBeginInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PlaneDetectorBeginInfoEXT& operator=(const XrPlaneDetectorBeginInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPlaneDetectorBeginInfoEXT&() const {
    return *reinterpret_cast<const XrPlaneDetectorBeginInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPlaneDetectorBeginInfoEXT&() {
    return *reinterpret_cast<XrPlaneDetectorBeginInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrPlaneDetectorBeginInfoEXT
  XrPlaneDetectorBeginInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrPlaneDetectorBeginInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPlaneDetectorBeginInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPlaneDetectorBeginInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PlaneDetectorBeginInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrPlaneDetectorBeginInfoEXT*>(this);
  }
  Space baseSpace;
  Time time;
  uint32_t orientationCount;
  const PlaneDetectorOrientationEXT* orientations;
  uint32_t semanticTypeCount;
  const PlaneDetectorSemanticTypeEXT* semanticTypes;
  uint32_t maxPlanes;
  float minArea;
  Posef boundingBoxPose;
  Extent3DfEXT boundingBoxExtent;
};
static_assert(sizeof(XrPlaneDetectorBeginInfoEXT) == sizeof(PlaneDetectorBeginInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPlaneDetectorBeginInfoEXT pointer to const from a
 * PlaneDetectorBeginInfoEXT reference to const.
 * @relates PlaneDetectorBeginInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPlaneDetectorBeginInfoEXT const* get(
    PlaneDetectorBeginInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PlaneDetectorBeginInfoEXT as
 * the address of a raw XrPlaneDetectorBeginInfoEXT
 * @relates PlaneDetectorBeginInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPlaneDetectorBeginInfoEXT* put(PlaneDetectorBeginInfoEXT& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_plane_detection

#ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrPlaneDetectorGetInfoEXT
 *
 * Provided by the `XR_EXT_plane_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorGetInfoEXT>
 * @xrentity{XrPlaneDetectorGetInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PlaneDetectorGetInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  PlaneDetectorGetInfoEXT(const Space& baseSpace_, const Time& time_, const void* next_ = nullptr)
      : Parent(StructureType::PlaneDetectorGetInfoEXT, next_), baseSpace{baseSpace_}, time{time_} {}

  //! Default/empty constructor
  PlaneDetectorGetInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::PlaneDetectorGetInfoEXT, next_), baseSpace{}, time{} {}

  //! Default copy constructor
  PlaneDetectorGetInfoEXT(const PlaneDetectorGetInfoEXT& rhs) = default;
  //! Default copy assignment
  PlaneDetectorGetInfoEXT& operator=(const PlaneDetectorGetInfoEXT& rhs) = default;
  //! Copy construct from raw
  PlaneDetectorGetInfoEXT(const XrPlaneDetectorGetInfoEXT& rhs) : PlaneDetectorGetInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PlaneDetectorGetInfoEXT& operator=(const XrPlaneDetectorGetInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPlaneDetectorGetInfoEXT&() const {
    return *reinterpret_cast<const XrPlaneDetectorGetInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPlaneDetectorGetInfoEXT&() {
    return *reinterpret_cast<XrPlaneDetectorGetInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrPlaneDetectorGetInfoEXT
  XrPlaneDetectorGetInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrPlaneDetectorGetInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPlaneDetectorGetInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPlaneDetectorGetInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PlaneDetectorGetInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrPlaneDetectorGetInfoEXT*>(this);
  }
  Space baseSpace;
  Time time;
};
static_assert(sizeof(XrPlaneDetectorGetInfoEXT) == sizeof(PlaneDetectorGetInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPlaneDetectorGetInfoEXT pointer to const from a
 * PlaneDetectorGetInfoEXT reference to const.
 * @relates PlaneDetectorGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPlaneDetectorGetInfoEXT const* get(PlaneDetectorGetInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PlaneDetectorGetInfoEXT as
 * the address of a raw XrPlaneDetectorGetInfoEXT
 * @relates PlaneDetectorGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPlaneDetectorGetInfoEXT* put(PlaneDetectorGetInfoEXT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_plane_detection

#ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrPlaneDetectorLocationEXT
 *
 * Provided by the `XR_EXT_plane_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorLocationEXT>
 * @xrentity{XrPlaneDetectorLocationEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PlaneDetectorLocationEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  PlaneDetectorLocationEXT(void* next_ = nullptr)

      : Parent(StructureType::PlaneDetectorLocationEXT, next_) {}

  //! Default copy constructor
  PlaneDetectorLocationEXT(const PlaneDetectorLocationEXT& rhs) = default;
  //! Default copy assignment
  PlaneDetectorLocationEXT& operator=(const PlaneDetectorLocationEXT& rhs) = default;
  //! Copy construct from raw
  PlaneDetectorLocationEXT(const XrPlaneDetectorLocationEXT& rhs) : PlaneDetectorLocationEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PlaneDetectorLocationEXT& operator=(const XrPlaneDetectorLocationEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPlaneDetectorLocationEXT&() const {
    return *reinterpret_cast<const XrPlaneDetectorLocationEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPlaneDetectorLocationEXT&() {
    return *reinterpret_cast<XrPlaneDetectorLocationEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrPlaneDetectorLocationEXT
  XrPlaneDetectorLocationEXT const* get() const noexcept {
    return reinterpret_cast<XrPlaneDetectorLocationEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPlaneDetectorLocationEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPlaneDetectorLocationEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PlaneDetectorLocationEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrPlaneDetectorLocationEXT*>(this);
  }
  uint64_t planeId;
  SpaceLocationFlags locationFlags;
  Posef pose;
  Extent2Df extents;
  PlaneDetectorOrientationEXT orientation;
  PlaneDetectorSemanticTypeEXT semanticType;
  uint32_t polygonBufferCount;
};
static_assert(sizeof(XrPlaneDetectorLocationEXT) == sizeof(PlaneDetectorLocationEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPlaneDetectorLocationEXT pointer to const from a
 * PlaneDetectorLocationEXT reference to const.
 * @relates PlaneDetectorLocationEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPlaneDetectorLocationEXT const* get(PlaneDetectorLocationEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PlaneDetectorLocationEXT as
 * the address of a raw XrPlaneDetectorLocationEXT
 * @relates PlaneDetectorLocationEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPlaneDetectorLocationEXT* put(PlaneDetectorLocationEXT& s,
                                                         bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_plane_detection

#ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrPlaneDetectorLocationsEXT
 *
 * Provided by the `XR_EXT_plane_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorLocationsEXT>
 * @xrentity{XrPlaneDetectorLocationsEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PlaneDetectorLocationsEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  PlaneDetectorLocationsEXT(void* next_ = nullptr)

      : Parent(StructureType::PlaneDetectorLocationsEXT, next_) {}

  //! Default copy constructor
  PlaneDetectorLocationsEXT(const PlaneDetectorLocationsEXT& rhs) = default;
  //! Default copy assignment
  PlaneDetectorLocationsEXT& operator=(const PlaneDetectorLocationsEXT& rhs) = default;
  //! Copy construct from raw
  PlaneDetectorLocationsEXT(const XrPlaneDetectorLocationsEXT& rhs) : PlaneDetectorLocationsEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PlaneDetectorLocationsEXT& operator=(const XrPlaneDetectorLocationsEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPlaneDetectorLocationsEXT&() const {
    return *reinterpret_cast<const XrPlaneDetectorLocationsEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPlaneDetectorLocationsEXT&() {
    return *reinterpret_cast<XrPlaneDetectorLocationsEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrPlaneDetectorLocationsEXT
  XrPlaneDetectorLocationsEXT const* get() const noexcept {
    return reinterpret_cast<XrPlaneDetectorLocationsEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPlaneDetectorLocationsEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPlaneDetectorLocationsEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PlaneDetectorLocationsEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrPlaneDetectorLocationsEXT*>(this);
  }
  uint32_t planeLocationCapacityInput;
  uint32_t planeLocationCountOutput;
  PlaneDetectorLocationEXT* planeLocations;
};
static_assert(sizeof(XrPlaneDetectorLocationsEXT) == sizeof(PlaneDetectorLocationsEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPlaneDetectorLocationsEXT pointer to const from a
 * PlaneDetectorLocationsEXT reference to const.
 * @relates PlaneDetectorLocationsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPlaneDetectorLocationsEXT const* get(
    PlaneDetectorLocationsEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PlaneDetectorLocationsEXT as
 * the address of a raw XrPlaneDetectorLocationsEXT
 * @relates PlaneDetectorLocationsEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPlaneDetectorLocationsEXT* put(PlaneDetectorLocationsEXT& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_plane_detection

#ifdef XR_EXT_plane_detection
/*!
 * C++ projection of XrPlaneDetectorPolygonBufferEXT
 *
 * Provided by the `XR_EXT_plane_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorPolygonBufferEXT>
 * @xrentity{XrPlaneDetectorPolygonBufferEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PlaneDetectorPolygonBufferEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  PlaneDetectorPolygonBufferEXT(void* next_ = nullptr)

      : Parent(StructureType::PlaneDetectorPolygonBufferEXT, next_) {}

  //! Default copy constructor
  PlaneDetectorPolygonBufferEXT(const PlaneDetectorPolygonBufferEXT& rhs) = default;
  //! Default copy assignment
  PlaneDetectorPolygonBufferEXT& operator=(const PlaneDetectorPolygonBufferEXT& rhs) = default;
  //! Copy construct from raw
  PlaneDetectorPolygonBufferEXT(const XrPlaneDetectorPolygonBufferEXT& rhs)
      : PlaneDetectorPolygonBufferEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PlaneDetectorPolygonBufferEXT& operator=(const XrPlaneDetectorPolygonBufferEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPlaneDetectorPolygonBufferEXT&() const {
    return *reinterpret_cast<const XrPlaneDetectorPolygonBufferEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPlaneDetectorPolygonBufferEXT&() {
    return *reinterpret_cast<XrPlaneDetectorPolygonBufferEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrPlaneDetectorPolygonBufferEXT
  XrPlaneDetectorPolygonBufferEXT const* get() const noexcept {
    return reinterpret_cast<XrPlaneDetectorPolygonBufferEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPlaneDetectorPolygonBufferEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPlaneDetectorPolygonBufferEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PlaneDetectorPolygonBufferEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrPlaneDetectorPolygonBufferEXT*>(this);
  }
  uint32_t vertexCapacityInput;
  uint32_t vertexCountOutput;
  Vector2f* vertices;
};
static_assert(sizeof(XrPlaneDetectorPolygonBufferEXT) == sizeof(PlaneDetectorPolygonBufferEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPlaneDetectorPolygonBufferEXT pointer to const from a
 * PlaneDetectorPolygonBufferEXT reference to const.
 * @relates PlaneDetectorPolygonBufferEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPlaneDetectorPolygonBufferEXT const* get(
    PlaneDetectorPolygonBufferEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing PlaneDetectorPolygonBufferEXT
 * as the address of a raw XrPlaneDetectorPolygonBufferEXT
 * @relates PlaneDetectorPolygonBufferEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPlaneDetectorPolygonBufferEXT* put(PlaneDetectorPolygonBufferEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_plane_detection

#ifdef XR_EXT_future
/*!
 * C++ projection of XrFutureCancelInfoEXT
 *
 * Provided by the `XR_EXT_future` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFutureCancelInfoEXT>
 * @xrentity{XrFutureCancelInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FutureCancelInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FutureCancelInfoEXT(const FutureEXT& future_, const void* next_ = nullptr)
      : Parent(StructureType::FutureCancelInfoEXT, next_), future{future_} {}

  //! Default/empty constructor
  FutureCancelInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::FutureCancelInfoEXT, next_), future{} {}

  //! Default copy constructor
  FutureCancelInfoEXT(const FutureCancelInfoEXT& rhs) = default;
  //! Default copy assignment
  FutureCancelInfoEXT& operator=(const FutureCancelInfoEXT& rhs) = default;
  //! Copy construct from raw
  FutureCancelInfoEXT(const XrFutureCancelInfoEXT& rhs) : FutureCancelInfoEXT() { *put() = rhs; }
  //! Copy assign from raw
  FutureCancelInfoEXT& operator=(const XrFutureCancelInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFutureCancelInfoEXT&() const {
    return *reinterpret_cast<const XrFutureCancelInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFutureCancelInfoEXT&() { return *reinterpret_cast<XrFutureCancelInfoEXT*>(this); }

  //! Accessor for this as the address of a raw XrFutureCancelInfoEXT
  XrFutureCancelInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrFutureCancelInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFutureCancelInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFutureCancelInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FutureCancelInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrFutureCancelInfoEXT*>(this);
  }
  FutureEXT future;
};
static_assert(sizeof(XrFutureCancelInfoEXT) == sizeof(FutureCancelInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFutureCancelInfoEXT pointer to const from a
 * FutureCancelInfoEXT reference to const.
 * @relates FutureCancelInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCancelInfoEXT const* get(FutureCancelInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FutureCancelInfoEXT as the
 * address of a raw XrFutureCancelInfoEXT
 * @relates FutureCancelInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCancelInfoEXT* put(FutureCancelInfoEXT& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_future

#ifdef XR_EXT_future
/*!
 * C++ projection of XrFuturePollInfoEXT
 *
 * Provided by the `XR_EXT_future` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFuturePollInfoEXT>
 * @xrentity{XrFuturePollInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FuturePollInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FuturePollInfoEXT(const FutureEXT& future_, const void* next_ = nullptr)
      : Parent(StructureType::FuturePollInfoEXT, next_), future{future_} {}

  //! Default/empty constructor
  FuturePollInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::FuturePollInfoEXT, next_), future{} {}

  //! Default copy constructor
  FuturePollInfoEXT(const FuturePollInfoEXT& rhs) = default;
  //! Default copy assignment
  FuturePollInfoEXT& operator=(const FuturePollInfoEXT& rhs) = default;
  //! Copy construct from raw
  FuturePollInfoEXT(const XrFuturePollInfoEXT& rhs) : FuturePollInfoEXT() { *put() = rhs; }
  //! Copy assign from raw
  FuturePollInfoEXT& operator=(const XrFuturePollInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFuturePollInfoEXT&() const {
    return *reinterpret_cast<const XrFuturePollInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFuturePollInfoEXT&() { return *reinterpret_cast<XrFuturePollInfoEXT*>(this); }

  //! Accessor for this as the address of a raw XrFuturePollInfoEXT
  XrFuturePollInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrFuturePollInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFuturePollInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFuturePollInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FuturePollInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrFuturePollInfoEXT*>(this);
  }
  FutureEXT future;
};
static_assert(sizeof(XrFuturePollInfoEXT) == sizeof(FuturePollInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFuturePollInfoEXT pointer to const from a
 * FuturePollInfoEXT reference to const.
 * @relates FuturePollInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFuturePollInfoEXT const* get(FuturePollInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FuturePollInfoEXT as the
 * address of a raw XrFuturePollInfoEXT
 * @relates FuturePollInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFuturePollInfoEXT* put(FuturePollInfoEXT& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_future

#ifdef XR_EXT_future
/*!
 * C++ projection of XrFuturePollResultEXT
 *
 * Provided by the `XR_EXT_future` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFuturePollResultEXT>
 * @xrentity{XrFuturePollResultEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FuturePollResultEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FuturePollResultEXT(void* next_ = nullptr)

      : Parent(StructureType::FuturePollResultEXT, next_) {}

  //! Default copy constructor
  FuturePollResultEXT(const FuturePollResultEXT& rhs) = default;
  //! Default copy assignment
  FuturePollResultEXT& operator=(const FuturePollResultEXT& rhs) = default;
  //! Copy construct from raw
  FuturePollResultEXT(const XrFuturePollResultEXT& rhs) : FuturePollResultEXT() { *put() = rhs; }
  //! Copy assign from raw
  FuturePollResultEXT& operator=(const XrFuturePollResultEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFuturePollResultEXT&() const {
    return *reinterpret_cast<const XrFuturePollResultEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFuturePollResultEXT&() { return *reinterpret_cast<XrFuturePollResultEXT*>(this); }

  //! Accessor for this as the address of a raw XrFuturePollResultEXT
  XrFuturePollResultEXT const* get() const noexcept {
    return reinterpret_cast<XrFuturePollResultEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrFuturePollResultEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFuturePollResultEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FuturePollResultEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrFuturePollResultEXT*>(this);
  }
  FutureStateEXT state;
};
static_assert(sizeof(XrFuturePollResultEXT) == sizeof(FuturePollResultEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFuturePollResultEXT pointer to const from a
 * FuturePollResultEXT reference to const.
 * @relates FuturePollResultEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFuturePollResultEXT const* get(FuturePollResultEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing FuturePollResultEXT as the
 * address of a raw XrFuturePollResultEXT
 * @relates FuturePollResultEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFuturePollResultEXT* put(FuturePollResultEXT& s,
                                                    bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_future

#ifdef XR_EXT_user_presence
/*!
 * C++ projection of XrEventDataUserPresenceChangedEXT
 *
 * Provided by the `XR_EXT_user_presence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataUserPresenceChangedEXT>
 * @xrentity{XrEventDataUserPresenceChangedEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataUserPresenceChangedEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataUserPresenceChangedEXT(void* next_ = nullptr)

      : Parent(StructureType::EventDataUserPresenceChangedEXT, next_) {}

  //! Default copy constructor
  EventDataUserPresenceChangedEXT(const EventDataUserPresenceChangedEXT& rhs) = default;
  //! Default copy assignment
  EventDataUserPresenceChangedEXT& operator=(const EventDataUserPresenceChangedEXT& rhs) = default;
  //! Copy construct from raw
  EventDataUserPresenceChangedEXT(const XrEventDataUserPresenceChangedEXT& rhs)
      : EventDataUserPresenceChangedEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataUserPresenceChangedEXT& operator=(const XrEventDataUserPresenceChangedEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataUserPresenceChangedEXT&() const {
    return *reinterpret_cast<const XrEventDataUserPresenceChangedEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataUserPresenceChangedEXT&() {
    return *reinterpret_cast<XrEventDataUserPresenceChangedEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataUserPresenceChangedEXT
  XrEventDataUserPresenceChangedEXT const* get() const noexcept {
    return reinterpret_cast<XrEventDataUserPresenceChangedEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataUserPresenceChangedEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataUserPresenceChangedEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataUserPresenceChangedEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataUserPresenceChangedEXT*>(this);
  }
  Session session;
  Bool32 isUserPresent;
};
static_assert(sizeof(XrEventDataUserPresenceChangedEXT) == sizeof(EventDataUserPresenceChangedEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataUserPresenceChangedEXT pointer to const from a
 * EventDataUserPresenceChangedEXT reference to const.
 * @relates EventDataUserPresenceChangedEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataUserPresenceChangedEXT const* get(
    EventDataUserPresenceChangedEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataUserPresenceChangedEXT as the address of a raw XrEventDataUserPresenceChangedEXT
 * @relates EventDataUserPresenceChangedEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataUserPresenceChangedEXT* put(EventDataUserPresenceChangedEXT& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_user_presence

#ifdef XR_EXT_user_presence
/*!
 * C++ projection of XrSystemUserPresencePropertiesEXT
 *
 * Provided by the `XR_EXT_user_presence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemUserPresencePropertiesEXT>
 * @xrentity{XrSystemUserPresencePropertiesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemUserPresencePropertiesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemUserPresencePropertiesEXT(void* next_ = nullptr)

      : Parent(StructureType::SystemUserPresencePropertiesEXT, next_) {}

  //! Default copy constructor
  SystemUserPresencePropertiesEXT(const SystemUserPresencePropertiesEXT& rhs) = default;
  //! Default copy assignment
  SystemUserPresencePropertiesEXT& operator=(const SystemUserPresencePropertiesEXT& rhs) = default;
  //! Copy construct from raw
  SystemUserPresencePropertiesEXT(const XrSystemUserPresencePropertiesEXT& rhs)
      : SystemUserPresencePropertiesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemUserPresencePropertiesEXT& operator=(const XrSystemUserPresencePropertiesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemUserPresencePropertiesEXT&() const {
    return *reinterpret_cast<const XrSystemUserPresencePropertiesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemUserPresencePropertiesEXT&() {
    return *reinterpret_cast<XrSystemUserPresencePropertiesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemUserPresencePropertiesEXT
  XrSystemUserPresencePropertiesEXT const* get() const noexcept {
    return reinterpret_cast<XrSystemUserPresencePropertiesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemUserPresencePropertiesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemUserPresencePropertiesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemUserPresencePropertiesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemUserPresencePropertiesEXT*>(this);
  }
  Bool32 supportsUserPresence;
};
static_assert(sizeof(XrSystemUserPresencePropertiesEXT) == sizeof(SystemUserPresencePropertiesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemUserPresencePropertiesEXT pointer to const from a
 * SystemUserPresencePropertiesEXT reference to const.
 * @relates SystemUserPresencePropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemUserPresencePropertiesEXT const* get(
    SystemUserPresencePropertiesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemUserPresencePropertiesEXT as the address of a raw XrSystemUserPresencePropertiesEXT
 * @relates SystemUserPresencePropertiesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemUserPresencePropertiesEXT* put(SystemUserPresencePropertiesEXT& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_user_presence

#ifdef XR_ML_user_calibration
/*!
 * C++ projection of XrEventDataHeadsetFitChangedML
 *
 * Provided by the `XR_ML_user_calibration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataHeadsetFitChangedML>
 * @xrentity{XrEventDataHeadsetFitChangedML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataHeadsetFitChangedML : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataHeadsetFitChangedML(void* next_ = nullptr)

      : Parent(StructureType::EventDataHeadsetFitChangedML, next_) {}

  //! Default copy constructor
  EventDataHeadsetFitChangedML(const EventDataHeadsetFitChangedML& rhs) = default;
  //! Default copy assignment
  EventDataHeadsetFitChangedML& operator=(const EventDataHeadsetFitChangedML& rhs) = default;
  //! Copy construct from raw
  EventDataHeadsetFitChangedML(const XrEventDataHeadsetFitChangedML& rhs)
      : EventDataHeadsetFitChangedML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataHeadsetFitChangedML& operator=(const XrEventDataHeadsetFitChangedML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataHeadsetFitChangedML&() const {
    return *reinterpret_cast<const XrEventDataHeadsetFitChangedML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataHeadsetFitChangedML&() {
    return *reinterpret_cast<XrEventDataHeadsetFitChangedML*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataHeadsetFitChangedML
  XrEventDataHeadsetFitChangedML const* get() const noexcept {
    return reinterpret_cast<XrEventDataHeadsetFitChangedML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataHeadsetFitChangedML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataHeadsetFitChangedML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataHeadsetFitChangedML{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataHeadsetFitChangedML*>(this);
  }
  HeadsetFitStatusML status;
  Time time;
};
static_assert(sizeof(XrEventDataHeadsetFitChangedML) == sizeof(EventDataHeadsetFitChangedML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataHeadsetFitChangedML pointer to const from a
 * EventDataHeadsetFitChangedML reference to const.
 * @relates EventDataHeadsetFitChangedML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataHeadsetFitChangedML const* get(
    EventDataHeadsetFitChangedML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing EventDataHeadsetFitChangedML
 * as the address of a raw XrEventDataHeadsetFitChangedML
 * @relates EventDataHeadsetFitChangedML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataHeadsetFitChangedML* put(EventDataHeadsetFitChangedML& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataHeadsetFitChangedML as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataHeadsetFitChangedML
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataHeadsetFitChangedML const& h) {
  return h.get_base();
}
#endif  // XR_ML_user_calibration

#ifdef XR_ML_user_calibration
/*!
 * C++ projection of XrEventDataEyeCalibrationChangedML
 *
 * Provided by the `XR_ML_user_calibration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataEyeCalibrationChangedML>
 * @xrentity{XrEventDataEyeCalibrationChangedML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataEyeCalibrationChangedML : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataEyeCalibrationChangedML(void* next_ = nullptr)

      : Parent(StructureType::EventDataEyeCalibrationChangedML, next_) {}

  //! Default copy constructor
  EventDataEyeCalibrationChangedML(const EventDataEyeCalibrationChangedML& rhs) = default;
  //! Default copy assignment
  EventDataEyeCalibrationChangedML& operator=(const EventDataEyeCalibrationChangedML& rhs) =
      default;
  //! Copy construct from raw
  EventDataEyeCalibrationChangedML(const XrEventDataEyeCalibrationChangedML& rhs)
      : EventDataEyeCalibrationChangedML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataEyeCalibrationChangedML& operator=(const XrEventDataEyeCalibrationChangedML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataEyeCalibrationChangedML&() const {
    return *reinterpret_cast<const XrEventDataEyeCalibrationChangedML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataEyeCalibrationChangedML&() {
    return *reinterpret_cast<XrEventDataEyeCalibrationChangedML*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataEyeCalibrationChangedML
  XrEventDataEyeCalibrationChangedML const* get() const noexcept {
    return reinterpret_cast<XrEventDataEyeCalibrationChangedML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataEyeCalibrationChangedML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataEyeCalibrationChangedML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataEyeCalibrationChangedML{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataEyeCalibrationChangedML*>(this);
  }
  EyeCalibrationStatusML status;
};
static_assert(sizeof(XrEventDataEyeCalibrationChangedML) ==
                  sizeof(EventDataEyeCalibrationChangedML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataEyeCalibrationChangedML pointer to const from a
 * EventDataEyeCalibrationChangedML reference to const.
 * @relates EventDataEyeCalibrationChangedML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataEyeCalibrationChangedML const* get(
    EventDataEyeCalibrationChangedML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataEyeCalibrationChangedML as the address of a raw XrEventDataEyeCalibrationChangedML
 * @relates EventDataEyeCalibrationChangedML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataEyeCalibrationChangedML* put(
    EventDataEyeCalibrationChangedML& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataEyeCalibrationChangedML as a raw,
 * pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataEyeCalibrationChangedML
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataEyeCalibrationChangedML const& h) {
  return h.get_base();
}
#endif  // XR_ML_user_calibration

#ifdef XR_ML_user_calibration
/*!
 * C++ projection of XrUserCalibrationEnableEventsInfoML
 *
 * Provided by the `XR_ML_user_calibration` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrUserCalibrationEnableEventsInfoML>
 * @xrentity{XrUserCalibrationEnableEventsInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS UserCalibrationEnableEventsInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  UserCalibrationEnableEventsInfoML(const Bool32& enabled_, const void* next_ = nullptr)
      : Parent(StructureType::UserCalibrationEnableEventsInfoML, next_), enabled{enabled_} {}

  //! Default/empty constructor
  UserCalibrationEnableEventsInfoML(const void* next_ = nullptr)

      : Parent(StructureType::UserCalibrationEnableEventsInfoML, next_), enabled{false} {}

  //! Default copy constructor
  UserCalibrationEnableEventsInfoML(const UserCalibrationEnableEventsInfoML& rhs) = default;
  //! Default copy assignment
  UserCalibrationEnableEventsInfoML& operator=(const UserCalibrationEnableEventsInfoML& rhs) =
      default;
  //! Copy construct from raw
  UserCalibrationEnableEventsInfoML(const XrUserCalibrationEnableEventsInfoML& rhs)
      : UserCalibrationEnableEventsInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  UserCalibrationEnableEventsInfoML& operator=(const XrUserCalibrationEnableEventsInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrUserCalibrationEnableEventsInfoML&() const {
    return *reinterpret_cast<const XrUserCalibrationEnableEventsInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrUserCalibrationEnableEventsInfoML&() {
    return *reinterpret_cast<XrUserCalibrationEnableEventsInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrUserCalibrationEnableEventsInfoML
  XrUserCalibrationEnableEventsInfoML const* get() const noexcept {
    return reinterpret_cast<XrUserCalibrationEnableEventsInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrUserCalibrationEnableEventsInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrUserCalibrationEnableEventsInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = UserCalibrationEnableEventsInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrUserCalibrationEnableEventsInfoML*>(this);
  }
  Bool32 enabled;
};
static_assert(sizeof(XrUserCalibrationEnableEventsInfoML) ==
                  sizeof(UserCalibrationEnableEventsInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrUserCalibrationEnableEventsInfoML pointer to const from
 * a UserCalibrationEnableEventsInfoML reference to const.
 * @relates UserCalibrationEnableEventsInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrUserCalibrationEnableEventsInfoML const* get(
    UserCalibrationEnableEventsInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * UserCalibrationEnableEventsInfoML as the address of a raw XrUserCalibrationEnableEventsInfoML
 * @relates UserCalibrationEnableEventsInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrUserCalibrationEnableEventsInfoML* put(
    UserCalibrationEnableEventsInfoML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_user_calibration

#ifdef XR_ML_system_notifications
/*!
 * C++ projection of XrSystemNotificationsSetInfoML
 *
 * Provided by the `XR_ML_system_notifications` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemNotificationsSetInfoML>
 * @xrentity{XrSystemNotificationsSetInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemNotificationsSetInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SystemNotificationsSetInfoML(const Bool32& suppressNotifications_, const void* next_ = nullptr)
      : Parent(StructureType::SystemNotificationsSetInfoML, next_),
        suppressNotifications{suppressNotifications_} {}

  //! Default/empty constructor
  SystemNotificationsSetInfoML(const void* next_ = nullptr)

      : Parent(StructureType::SystemNotificationsSetInfoML, next_), suppressNotifications{false} {}

  //! Default copy constructor
  SystemNotificationsSetInfoML(const SystemNotificationsSetInfoML& rhs) = default;
  //! Default copy assignment
  SystemNotificationsSetInfoML& operator=(const SystemNotificationsSetInfoML& rhs) = default;
  //! Copy construct from raw
  SystemNotificationsSetInfoML(const XrSystemNotificationsSetInfoML& rhs)
      : SystemNotificationsSetInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemNotificationsSetInfoML& operator=(const XrSystemNotificationsSetInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemNotificationsSetInfoML&() const {
    return *reinterpret_cast<const XrSystemNotificationsSetInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemNotificationsSetInfoML&() {
    return *reinterpret_cast<XrSystemNotificationsSetInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemNotificationsSetInfoML
  XrSystemNotificationsSetInfoML const* get() const noexcept {
    return reinterpret_cast<XrSystemNotificationsSetInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemNotificationsSetInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemNotificationsSetInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemNotificationsSetInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemNotificationsSetInfoML*>(this);
  }
  Bool32 suppressNotifications;
};
static_assert(sizeof(XrSystemNotificationsSetInfoML) == sizeof(SystemNotificationsSetInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemNotificationsSetInfoML pointer to const from a
 * SystemNotificationsSetInfoML reference to const.
 * @relates SystemNotificationsSetInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemNotificationsSetInfoML const* get(
    SystemNotificationsSetInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SystemNotificationsSetInfoML
 * as the address of a raw XrSystemNotificationsSetInfoML
 * @relates SystemNotificationsSetInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemNotificationsSetInfoML* put(SystemNotificationsSetInfoML& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_system_notifications

#ifdef XR_ML_world_mesh_detection
/*!
 * C++ projection of XrWorldMeshDetectorCreateInfoML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshDetectorCreateInfoML>
 * @xrentity{XrWorldMeshDetectorCreateInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS WorldMeshDetectorCreateInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  WorldMeshDetectorCreateInfoML(const void* next_ = nullptr)

      : Parent(StructureType::WorldMeshDetectorCreateInfoML, next_) {}

  //! Default copy constructor
  WorldMeshDetectorCreateInfoML(const WorldMeshDetectorCreateInfoML& rhs) = default;
  //! Default copy assignment
  WorldMeshDetectorCreateInfoML& operator=(const WorldMeshDetectorCreateInfoML& rhs) = default;
  //! Copy construct from raw
  WorldMeshDetectorCreateInfoML(const XrWorldMeshDetectorCreateInfoML& rhs)
      : WorldMeshDetectorCreateInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  WorldMeshDetectorCreateInfoML& operator=(const XrWorldMeshDetectorCreateInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrWorldMeshDetectorCreateInfoML&() const {
    return *reinterpret_cast<const XrWorldMeshDetectorCreateInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrWorldMeshDetectorCreateInfoML&() {
    return *reinterpret_cast<XrWorldMeshDetectorCreateInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrWorldMeshDetectorCreateInfoML
  XrWorldMeshDetectorCreateInfoML const* get() const noexcept {
    return reinterpret_cast<XrWorldMeshDetectorCreateInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrWorldMeshDetectorCreateInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrWorldMeshDetectorCreateInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = WorldMeshDetectorCreateInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrWorldMeshDetectorCreateInfoML*>(this);
  }
};
static_assert(sizeof(XrWorldMeshDetectorCreateInfoML) == sizeof(WorldMeshDetectorCreateInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrWorldMeshDetectorCreateInfoML pointer to const from a
 * WorldMeshDetectorCreateInfoML reference to const.
 * @relates WorldMeshDetectorCreateInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshDetectorCreateInfoML const* get(
    WorldMeshDetectorCreateInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing WorldMeshDetectorCreateInfoML
 * as the address of a raw XrWorldMeshDetectorCreateInfoML
 * @relates WorldMeshDetectorCreateInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshDetectorCreateInfoML* put(WorldMeshDetectorCreateInfoML& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_world_mesh_detection
/*!
 * C++ projection of XrWorldMeshBlockStateML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshBlockStateML>
 * @xrentity{XrWorldMeshBlockStateML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS WorldMeshBlockStateML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  WorldMeshBlockStateML(void* next_ = nullptr)

      : Parent(StructureType::WorldMeshBlockStateML, next_) {}

  //! Default copy constructor
  WorldMeshBlockStateML(const WorldMeshBlockStateML& rhs) = default;
  //! Default copy assignment
  WorldMeshBlockStateML& operator=(const WorldMeshBlockStateML& rhs) = default;
  //! Copy construct from raw
  WorldMeshBlockStateML(const XrWorldMeshBlockStateML& rhs) : WorldMeshBlockStateML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  WorldMeshBlockStateML& operator=(const XrWorldMeshBlockStateML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrWorldMeshBlockStateML&() const {
    return *reinterpret_cast<const XrWorldMeshBlockStateML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrWorldMeshBlockStateML&() { return *reinterpret_cast<XrWorldMeshBlockStateML*>(this); }

  //! Accessor for this as the address of a raw XrWorldMeshBlockStateML
  XrWorldMeshBlockStateML const* get() const noexcept {
    return reinterpret_cast<XrWorldMeshBlockStateML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrWorldMeshBlockStateML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrWorldMeshBlockStateML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = WorldMeshBlockStateML{};
      next = oldNext;
    }
    return reinterpret_cast<XrWorldMeshBlockStateML*>(this);
  }
  UuidEXT uuid;
  Posef meshBoundingBoxCenter;
  Extent3DfEXT meshBoundingBoxExtents;
  Time lastUpdateTime;
  WorldMeshBlockStatusML status;
};
static_assert(sizeof(XrWorldMeshBlockStateML) == sizeof(WorldMeshBlockStateML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrWorldMeshBlockStateML pointer to const from a
 * WorldMeshBlockStateML reference to const.
 * @relates WorldMeshBlockStateML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshBlockStateML const* get(WorldMeshBlockStateML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing WorldMeshBlockStateML as the
 * address of a raw XrWorldMeshBlockStateML
 * @relates WorldMeshBlockStateML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshBlockStateML* put(WorldMeshBlockStateML& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_world_mesh_detection
/*!
 * C++ projection of XrWorldMeshStateRequestInfoML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshStateRequestInfoML>
 * @xrentity{XrWorldMeshStateRequestInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS WorldMeshStateRequestInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  WorldMeshStateRequestInfoML(const Space& baseSpace_, const Time& time_,
                              const Posef& boundingBoxCenter_,
                              const Extent3DfEXT& boundingBoxExtents_, const void* next_ = nullptr)
      : Parent(StructureType::WorldMeshStateRequestInfoML, next_),
        baseSpace{baseSpace_},
        time{time_},
        boundingBoxCenter{boundingBoxCenter_},
        boundingBoxExtents{boundingBoxExtents_} {}

  //! Default/empty constructor
  WorldMeshStateRequestInfoML(const void* next_ = nullptr)

      : Parent(StructureType::WorldMeshStateRequestInfoML, next_),
        baseSpace{},
        time{},
        boundingBoxCenter{},
        boundingBoxExtents{} {}

  //! Default copy constructor
  WorldMeshStateRequestInfoML(const WorldMeshStateRequestInfoML& rhs) = default;
  //! Default copy assignment
  WorldMeshStateRequestInfoML& operator=(const WorldMeshStateRequestInfoML& rhs) = default;
  //! Copy construct from raw
  WorldMeshStateRequestInfoML(const XrWorldMeshStateRequestInfoML& rhs)
      : WorldMeshStateRequestInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  WorldMeshStateRequestInfoML& operator=(const XrWorldMeshStateRequestInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrWorldMeshStateRequestInfoML&() const {
    return *reinterpret_cast<const XrWorldMeshStateRequestInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrWorldMeshStateRequestInfoML&() {
    return *reinterpret_cast<XrWorldMeshStateRequestInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrWorldMeshStateRequestInfoML
  XrWorldMeshStateRequestInfoML const* get() const noexcept {
    return reinterpret_cast<XrWorldMeshStateRequestInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrWorldMeshStateRequestInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrWorldMeshStateRequestInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = WorldMeshStateRequestInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrWorldMeshStateRequestInfoML*>(this);
  }
  Space baseSpace;
  Time time;
  Posef boundingBoxCenter;
  Extent3DfEXT boundingBoxExtents;
};
static_assert(sizeof(XrWorldMeshStateRequestInfoML) == sizeof(WorldMeshStateRequestInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrWorldMeshStateRequestInfoML pointer to const from a
 * WorldMeshStateRequestInfoML reference to const.
 * @relates WorldMeshStateRequestInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshStateRequestInfoML const* get(
    WorldMeshStateRequestInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing WorldMeshStateRequestInfoML
 * as the address of a raw XrWorldMeshStateRequestInfoML
 * @relates WorldMeshStateRequestInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshStateRequestInfoML* put(WorldMeshStateRequestInfoML& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_world_mesh_detection
/*!
 * C++ projection of XrWorldMeshStateRequestCompletionML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshStateRequestCompletionML>
 * @xrentity{XrWorldMeshStateRequestCompletionML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS WorldMeshStateRequestCompletionML : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  WorldMeshStateRequestCompletionML(void* next_ = nullptr)

      : Parent(StructureType::WorldMeshStateRequestCompletionML, {}, next_) {}

  //! Default copy constructor
  WorldMeshStateRequestCompletionML(const WorldMeshStateRequestCompletionML& rhs) = default;
  //! Default copy assignment
  WorldMeshStateRequestCompletionML& operator=(const WorldMeshStateRequestCompletionML& rhs) =
      default;
  //! Copy construct from raw
  WorldMeshStateRequestCompletionML(const XrWorldMeshStateRequestCompletionML& rhs)
      : WorldMeshStateRequestCompletionML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  WorldMeshStateRequestCompletionML& operator=(const XrWorldMeshStateRequestCompletionML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrWorldMeshStateRequestCompletionML&() const {
    return *reinterpret_cast<const XrWorldMeshStateRequestCompletionML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrWorldMeshStateRequestCompletionML&() {
    return *reinterpret_cast<XrWorldMeshStateRequestCompletionML*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrWorldMeshStateRequestCompletionML
  XrWorldMeshStateRequestCompletionML const* get() const noexcept {
    return reinterpret_cast<XrWorldMeshStateRequestCompletionML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrWorldMeshStateRequestCompletionML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrWorldMeshStateRequestCompletionML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = WorldMeshStateRequestCompletionML{};
      next = oldNext;
    }
    return reinterpret_cast<XrWorldMeshStateRequestCompletionML*>(this);
  }
  Time timestamp;
  uint32_t meshBlockStateCapacityInput;
  uint32_t meshBlockStateCountOutput;
  WorldMeshBlockStateML* meshBlockStates;
};
static_assert(sizeof(XrWorldMeshStateRequestCompletionML) ==
                  sizeof(WorldMeshStateRequestCompletionML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrWorldMeshStateRequestCompletionML pointer to const from
 * a WorldMeshStateRequestCompletionML reference to const.
 * @relates WorldMeshStateRequestCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshStateRequestCompletionML const* get(
    WorldMeshStateRequestCompletionML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * WorldMeshStateRequestCompletionML as the address of a raw XrWorldMeshStateRequestCompletionML
 * @relates WorldMeshStateRequestCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshStateRequestCompletionML* put(
    WorldMeshStateRequestCompletionML& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const WorldMeshStateRequestCompletionML as a
 * raw, pointer to const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates WorldMeshStateRequestCompletionML
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    WorldMeshStateRequestCompletionML const& h) {
  return h.get_base();
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_world_mesh_detection
/*!
 * C++ projection of XrWorldMeshBufferRecommendedSizeInfoML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshBufferRecommendedSizeInfoML>
 * @xrentity{XrWorldMeshBufferRecommendedSizeInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS WorldMeshBufferRecommendedSizeInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  WorldMeshBufferRecommendedSizeInfoML(uint32_t maxBlockCount_, const void* next_ = nullptr)
      : Parent(StructureType::WorldMeshBufferRecommendedSizeInfoML, next_),
        maxBlockCount{maxBlockCount_} {}

  //! Default/empty constructor
  WorldMeshBufferRecommendedSizeInfoML(const void* next_ = nullptr)

      : Parent(StructureType::WorldMeshBufferRecommendedSizeInfoML, next_), maxBlockCount{0} {}

  //! Default copy constructor
  WorldMeshBufferRecommendedSizeInfoML(const WorldMeshBufferRecommendedSizeInfoML& rhs) = default;
  //! Default copy assignment
  WorldMeshBufferRecommendedSizeInfoML& operator=(const WorldMeshBufferRecommendedSizeInfoML& rhs) =
      default;
  //! Copy construct from raw
  WorldMeshBufferRecommendedSizeInfoML(const XrWorldMeshBufferRecommendedSizeInfoML& rhs)
      : WorldMeshBufferRecommendedSizeInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  WorldMeshBufferRecommendedSizeInfoML& operator=(
      const XrWorldMeshBufferRecommendedSizeInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrWorldMeshBufferRecommendedSizeInfoML&() const {
    return *reinterpret_cast<const XrWorldMeshBufferRecommendedSizeInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrWorldMeshBufferRecommendedSizeInfoML&() {
    return *reinterpret_cast<XrWorldMeshBufferRecommendedSizeInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrWorldMeshBufferRecommendedSizeInfoML
  XrWorldMeshBufferRecommendedSizeInfoML const* get() const noexcept {
    return reinterpret_cast<XrWorldMeshBufferRecommendedSizeInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrWorldMeshBufferRecommendedSizeInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrWorldMeshBufferRecommendedSizeInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = WorldMeshBufferRecommendedSizeInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrWorldMeshBufferRecommendedSizeInfoML*>(this);
  }
  uint32_t maxBlockCount;
};
static_assert(sizeof(XrWorldMeshBufferRecommendedSizeInfoML) ==
                  sizeof(WorldMeshBufferRecommendedSizeInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrWorldMeshBufferRecommendedSizeInfoML pointer to const
 * from a WorldMeshBufferRecommendedSizeInfoML reference to const.
 * @relates WorldMeshBufferRecommendedSizeInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshBufferRecommendedSizeInfoML const* get(
    WorldMeshBufferRecommendedSizeInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * WorldMeshBufferRecommendedSizeInfoML as the address of a raw
 * XrWorldMeshBufferRecommendedSizeInfoML
 * @relates WorldMeshBufferRecommendedSizeInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshBufferRecommendedSizeInfoML* put(
    WorldMeshBufferRecommendedSizeInfoML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_world_mesh_detection
/*!
 * C++ projection of XrWorldMeshBufferSizeML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshBufferSizeML>
 * @xrentity{XrWorldMeshBufferSizeML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS WorldMeshBufferSizeML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  WorldMeshBufferSizeML(void* next_ = nullptr)

      : Parent(StructureType::WorldMeshBufferSizeML, next_) {}

  //! Default copy constructor
  WorldMeshBufferSizeML(const WorldMeshBufferSizeML& rhs) = default;
  //! Default copy assignment
  WorldMeshBufferSizeML& operator=(const WorldMeshBufferSizeML& rhs) = default;
  //! Copy construct from raw
  WorldMeshBufferSizeML(const XrWorldMeshBufferSizeML& rhs) : WorldMeshBufferSizeML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  WorldMeshBufferSizeML& operator=(const XrWorldMeshBufferSizeML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrWorldMeshBufferSizeML&() const {
    return *reinterpret_cast<const XrWorldMeshBufferSizeML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrWorldMeshBufferSizeML&() { return *reinterpret_cast<XrWorldMeshBufferSizeML*>(this); }

  //! Accessor for this as the address of a raw XrWorldMeshBufferSizeML
  XrWorldMeshBufferSizeML const* get() const noexcept {
    return reinterpret_cast<XrWorldMeshBufferSizeML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrWorldMeshBufferSizeML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrWorldMeshBufferSizeML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = WorldMeshBufferSizeML{};
      next = oldNext;
    }
    return reinterpret_cast<XrWorldMeshBufferSizeML*>(this);
  }
  uint32_t size;
};
static_assert(sizeof(XrWorldMeshBufferSizeML) == sizeof(WorldMeshBufferSizeML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrWorldMeshBufferSizeML pointer to const from a
 * WorldMeshBufferSizeML reference to const.
 * @relates WorldMeshBufferSizeML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshBufferSizeML const* get(WorldMeshBufferSizeML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing WorldMeshBufferSizeML as the
 * address of a raw XrWorldMeshBufferSizeML
 * @relates WorldMeshBufferSizeML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshBufferSizeML* put(WorldMeshBufferSizeML& s,
                                                      bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_world_mesh_detection
/*!
 * C++ projection of XrWorldMeshBufferML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshBufferML>
 * @xrentity{XrWorldMeshBufferML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS WorldMeshBufferML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  WorldMeshBufferML(void* next_ = nullptr)

      : Parent(StructureType::WorldMeshBufferML, next_) {}

  //! Default copy constructor
  WorldMeshBufferML(const WorldMeshBufferML& rhs) = default;
  //! Default copy assignment
  WorldMeshBufferML& operator=(const WorldMeshBufferML& rhs) = default;
  //! Copy construct from raw
  WorldMeshBufferML(const XrWorldMeshBufferML& rhs) : WorldMeshBufferML() { *put() = rhs; }
  //! Copy assign from raw
  WorldMeshBufferML& operator=(const XrWorldMeshBufferML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrWorldMeshBufferML&() const {
    return *reinterpret_cast<const XrWorldMeshBufferML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrWorldMeshBufferML&() { return *reinterpret_cast<XrWorldMeshBufferML*>(this); }

  //! Accessor for this as the address of a raw XrWorldMeshBufferML
  XrWorldMeshBufferML const* get() const noexcept {
    return reinterpret_cast<XrWorldMeshBufferML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrWorldMeshBufferML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrWorldMeshBufferML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = WorldMeshBufferML{};
      next = oldNext;
    }
    return reinterpret_cast<XrWorldMeshBufferML*>(this);
  }
  uint32_t bufferSize;
  void* XR_MAY_ALIAS buffer;
};
static_assert(sizeof(XrWorldMeshBufferML) == sizeof(WorldMeshBufferML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrWorldMeshBufferML pointer to const from a
 * WorldMeshBufferML reference to const.
 * @relates WorldMeshBufferML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshBufferML const* get(WorldMeshBufferML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing WorldMeshBufferML as the
 * address of a raw XrWorldMeshBufferML
 * @relates WorldMeshBufferML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshBufferML* put(WorldMeshBufferML& s,
                                                  bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_world_mesh_detection
/*!
 * C++ projection of XrWorldMeshBlockRequestML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshBlockRequestML>
 * @xrentity{XrWorldMeshBlockRequestML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS WorldMeshBlockRequestML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  WorldMeshBlockRequestML(void* next_ = nullptr)

      : Parent(StructureType::WorldMeshBlockRequestML, next_) {}

  //! Default copy constructor
  WorldMeshBlockRequestML(const WorldMeshBlockRequestML& rhs) = default;
  //! Default copy assignment
  WorldMeshBlockRequestML& operator=(const WorldMeshBlockRequestML& rhs) = default;
  //! Copy construct from raw
  WorldMeshBlockRequestML(const XrWorldMeshBlockRequestML& rhs) : WorldMeshBlockRequestML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  WorldMeshBlockRequestML& operator=(const XrWorldMeshBlockRequestML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrWorldMeshBlockRequestML&() const {
    return *reinterpret_cast<const XrWorldMeshBlockRequestML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrWorldMeshBlockRequestML&() {
    return *reinterpret_cast<XrWorldMeshBlockRequestML*>(this);
  }

  //! Accessor for this as the address of a raw XrWorldMeshBlockRequestML
  XrWorldMeshBlockRequestML const* get() const noexcept {
    return reinterpret_cast<XrWorldMeshBlockRequestML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrWorldMeshBlockRequestML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrWorldMeshBlockRequestML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = WorldMeshBlockRequestML{};
      next = oldNext;
    }
    return reinterpret_cast<XrWorldMeshBlockRequestML*>(this);
  }
  UuidEXT uuid;
  WorldMeshDetectorLodML lod;
};
static_assert(sizeof(XrWorldMeshBlockRequestML) == sizeof(WorldMeshBlockRequestML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrWorldMeshBlockRequestML pointer to const from a
 * WorldMeshBlockRequestML reference to const.
 * @relates WorldMeshBlockRequestML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshBlockRequestML const* get(WorldMeshBlockRequestML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing WorldMeshBlockRequestML as
 * the address of a raw XrWorldMeshBlockRequestML
 * @relates WorldMeshBlockRequestML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshBlockRequestML* put(WorldMeshBlockRequestML& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_world_mesh_detection
/*!
 * C++ projection of XrWorldMeshGetInfoML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshGetInfoML>
 * @xrentity{XrWorldMeshGetInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS WorldMeshGetInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  WorldMeshGetInfoML(const WorldMeshDetectorFlagsML& flags_, float fillHoleLength_,
                     float disconnectedComponentArea_, uint32_t blockCount_,
                     WorldMeshBlockRequestML* blocks_, const void* next_ = nullptr)
      : Parent(StructureType::WorldMeshGetInfoML, next_),
        flags{flags_},
        fillHoleLength{fillHoleLength_},
        disconnectedComponentArea{disconnectedComponentArea_},
        blockCount{blockCount_},
        blocks{blocks_} {}

  //! Default/empty constructor
  WorldMeshGetInfoML(const void* next_ = nullptr)

      : Parent(StructureType::WorldMeshGetInfoML, next_),
        flags{},
        fillHoleLength{0.0f},
        disconnectedComponentArea{0.0f},
        blockCount{0},
        blocks{nullptr} {}

  //! Default copy constructor
  WorldMeshGetInfoML(const WorldMeshGetInfoML& rhs) = default;
  //! Default copy assignment
  WorldMeshGetInfoML& operator=(const WorldMeshGetInfoML& rhs) = default;
  //! Copy construct from raw
  WorldMeshGetInfoML(const XrWorldMeshGetInfoML& rhs) : WorldMeshGetInfoML() { *put() = rhs; }
  //! Copy assign from raw
  WorldMeshGetInfoML& operator=(const XrWorldMeshGetInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrWorldMeshGetInfoML&() const {
    return *reinterpret_cast<const XrWorldMeshGetInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrWorldMeshGetInfoML&() { return *reinterpret_cast<XrWorldMeshGetInfoML*>(this); }

  //! Accessor for this as the address of a raw XrWorldMeshGetInfoML
  XrWorldMeshGetInfoML const* get() const noexcept {
    return reinterpret_cast<XrWorldMeshGetInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrWorldMeshGetInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrWorldMeshGetInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = WorldMeshGetInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrWorldMeshGetInfoML*>(this);
  }
  WorldMeshDetectorFlagsML flags;
  float fillHoleLength;
  float disconnectedComponentArea;
  uint32_t blockCount;
  WorldMeshBlockRequestML* blocks;
};
static_assert(sizeof(XrWorldMeshGetInfoML) == sizeof(WorldMeshGetInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrWorldMeshGetInfoML pointer to const from a
 * WorldMeshGetInfoML reference to const.
 * @relates WorldMeshGetInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshGetInfoML const* get(WorldMeshGetInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing WorldMeshGetInfoML as the
 * address of a raw XrWorldMeshGetInfoML
 * @relates WorldMeshGetInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshGetInfoML* put(WorldMeshGetInfoML& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_world_mesh_detection
/*!
 * C++ projection of XrWorldMeshBlockML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshBlockML>
 * @xrentity{XrWorldMeshBlockML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS WorldMeshBlockML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  WorldMeshBlockML(void* next_ = nullptr)

      : Parent(StructureType::WorldMeshBlockML, next_) {}

  //! Default copy constructor
  WorldMeshBlockML(const WorldMeshBlockML& rhs) = default;
  //! Default copy assignment
  WorldMeshBlockML& operator=(const WorldMeshBlockML& rhs) = default;
  //! Copy construct from raw
  WorldMeshBlockML(const XrWorldMeshBlockML& rhs) : WorldMeshBlockML() { *put() = rhs; }
  //! Copy assign from raw
  WorldMeshBlockML& operator=(const XrWorldMeshBlockML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrWorldMeshBlockML&() const {
    return *reinterpret_cast<const XrWorldMeshBlockML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrWorldMeshBlockML&() { return *reinterpret_cast<XrWorldMeshBlockML*>(this); }

  //! Accessor for this as the address of a raw XrWorldMeshBlockML
  XrWorldMeshBlockML const* get() const noexcept {
    return reinterpret_cast<XrWorldMeshBlockML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrWorldMeshBlockML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrWorldMeshBlockML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = WorldMeshBlockML{};
      next = oldNext;
    }
    return reinterpret_cast<XrWorldMeshBlockML*>(this);
  }
  UuidEXT uuid;
  WorldMeshBlockResultML blockResult;
  WorldMeshDetectorLodML lod;
  WorldMeshDetectorFlagsML flags;
  uint32_t indexCount;
  uint16_t* indexBuffer;
  uint32_t vertexCount;
  Vector3f* vertexBuffer;
  uint32_t normalCount;
  Vector3f* normalBuffer;
  uint32_t confidenceCount;
  float* confidenceBuffer;
};
static_assert(sizeof(XrWorldMeshBlockML) == sizeof(WorldMeshBlockML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrWorldMeshBlockML pointer to const from a
 * WorldMeshBlockML reference to const.
 * @relates WorldMeshBlockML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshBlockML const* get(WorldMeshBlockML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing WorldMeshBlockML as the
 * address of a raw XrWorldMeshBlockML
 * @relates WorldMeshBlockML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshBlockML* put(WorldMeshBlockML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_world_mesh_detection
/*!
 * C++ projection of XrWorldMeshRequestCompletionInfoML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshRequestCompletionInfoML>
 * @xrentity{XrWorldMeshRequestCompletionInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS WorldMeshRequestCompletionInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  WorldMeshRequestCompletionInfoML(const Space& meshSpace_, const Time& meshSpaceLocateTime_,
                                   const void* next_ = nullptr)
      : Parent(StructureType::WorldMeshRequestCompletionInfoML, next_),
        meshSpace{meshSpace_},
        meshSpaceLocateTime{meshSpaceLocateTime_} {}

  //! Default/empty constructor
  WorldMeshRequestCompletionInfoML(const void* next_ = nullptr)

      : Parent(StructureType::WorldMeshRequestCompletionInfoML, next_),
        meshSpace{},
        meshSpaceLocateTime{} {}

  //! Default copy constructor
  WorldMeshRequestCompletionInfoML(const WorldMeshRequestCompletionInfoML& rhs) = default;
  //! Default copy assignment
  WorldMeshRequestCompletionInfoML& operator=(const WorldMeshRequestCompletionInfoML& rhs) =
      default;
  //! Copy construct from raw
  WorldMeshRequestCompletionInfoML(const XrWorldMeshRequestCompletionInfoML& rhs)
      : WorldMeshRequestCompletionInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  WorldMeshRequestCompletionInfoML& operator=(const XrWorldMeshRequestCompletionInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrWorldMeshRequestCompletionInfoML&() const {
    return *reinterpret_cast<const XrWorldMeshRequestCompletionInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrWorldMeshRequestCompletionInfoML&() {
    return *reinterpret_cast<XrWorldMeshRequestCompletionInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrWorldMeshRequestCompletionInfoML
  XrWorldMeshRequestCompletionInfoML const* get() const noexcept {
    return reinterpret_cast<XrWorldMeshRequestCompletionInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrWorldMeshRequestCompletionInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrWorldMeshRequestCompletionInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = WorldMeshRequestCompletionInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrWorldMeshRequestCompletionInfoML*>(this);
  }
  Space meshSpace;
  Time meshSpaceLocateTime;
};
static_assert(sizeof(XrWorldMeshRequestCompletionInfoML) ==
                  sizeof(WorldMeshRequestCompletionInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrWorldMeshRequestCompletionInfoML pointer to const from a
 * WorldMeshRequestCompletionInfoML reference to const.
 * @relates WorldMeshRequestCompletionInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshRequestCompletionInfoML const* get(
    WorldMeshRequestCompletionInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * WorldMeshRequestCompletionInfoML as the address of a raw XrWorldMeshRequestCompletionInfoML
 * @relates WorldMeshRequestCompletionInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshRequestCompletionInfoML* put(
    WorldMeshRequestCompletionInfoML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_world_mesh_detection
/*!
 * C++ projection of XrWorldMeshRequestCompletionML
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshRequestCompletionML>
 * @xrentity{XrWorldMeshRequestCompletionML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS WorldMeshRequestCompletionML : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  WorldMeshRequestCompletionML(void* next_ = nullptr)

      : Parent(StructureType::WorldMeshRequestCompletionML, {}, next_) {}

  //! Default copy constructor
  WorldMeshRequestCompletionML(const WorldMeshRequestCompletionML& rhs) = default;
  //! Default copy assignment
  WorldMeshRequestCompletionML& operator=(const WorldMeshRequestCompletionML& rhs) = default;
  //! Copy construct from raw
  WorldMeshRequestCompletionML(const XrWorldMeshRequestCompletionML& rhs)
      : WorldMeshRequestCompletionML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  WorldMeshRequestCompletionML& operator=(const XrWorldMeshRequestCompletionML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrWorldMeshRequestCompletionML&() const {
    return *reinterpret_cast<const XrWorldMeshRequestCompletionML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrWorldMeshRequestCompletionML&() {
    return *reinterpret_cast<XrWorldMeshRequestCompletionML*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrWorldMeshRequestCompletionML
  XrWorldMeshRequestCompletionML const* get() const noexcept {
    return reinterpret_cast<XrWorldMeshRequestCompletionML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrWorldMeshRequestCompletionML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrWorldMeshRequestCompletionML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = WorldMeshRequestCompletionML{};
      next = oldNext;
    }
    return reinterpret_cast<XrWorldMeshRequestCompletionML*>(this);
  }
  uint32_t blockCount;
  WorldMeshBlockML* blocks;
};
static_assert(sizeof(XrWorldMeshRequestCompletionML) == sizeof(WorldMeshRequestCompletionML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrWorldMeshRequestCompletionML pointer to const from a
 * WorldMeshRequestCompletionML reference to const.
 * @relates WorldMeshRequestCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshRequestCompletionML const* get(
    WorldMeshRequestCompletionML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing WorldMeshRequestCompletionML
 * as the address of a raw XrWorldMeshRequestCompletionML
 * @relates WorldMeshRequestCompletionML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrWorldMeshRequestCompletionML* put(WorldMeshRequestCompletionML& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const WorldMeshRequestCompletionML as a raw,
 * pointer to const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates WorldMeshRequestCompletionML
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    WorldMeshRequestCompletionML const& h) {
  return h.get_base();
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_facial_expression
/*!
 * C++ projection of XrSystemFacialExpressionPropertiesML
 *
 * Provided by the `XR_ML_facial_expression` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemFacialExpressionPropertiesML>
 * @xrentity{XrSystemFacialExpressionPropertiesML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemFacialExpressionPropertiesML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemFacialExpressionPropertiesML(void* next_ = nullptr)

      : Parent(StructureType::SystemFacialExpressionPropertiesML, next_) {}

  //! Default copy constructor
  SystemFacialExpressionPropertiesML(const SystemFacialExpressionPropertiesML& rhs) = default;
  //! Default copy assignment
  SystemFacialExpressionPropertiesML& operator=(const SystemFacialExpressionPropertiesML& rhs) =
      default;
  //! Copy construct from raw
  SystemFacialExpressionPropertiesML(const XrSystemFacialExpressionPropertiesML& rhs)
      : SystemFacialExpressionPropertiesML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemFacialExpressionPropertiesML& operator=(const XrSystemFacialExpressionPropertiesML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemFacialExpressionPropertiesML&() const {
    return *reinterpret_cast<const XrSystemFacialExpressionPropertiesML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemFacialExpressionPropertiesML&() {
    return *reinterpret_cast<XrSystemFacialExpressionPropertiesML*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemFacialExpressionPropertiesML
  XrSystemFacialExpressionPropertiesML const* get() const noexcept {
    return reinterpret_cast<XrSystemFacialExpressionPropertiesML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemFacialExpressionPropertiesML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemFacialExpressionPropertiesML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemFacialExpressionPropertiesML{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemFacialExpressionPropertiesML*>(this);
  }
  Bool32 supportsFacialExpression;
};
static_assert(sizeof(XrSystemFacialExpressionPropertiesML) ==
                  sizeof(SystemFacialExpressionPropertiesML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemFacialExpressionPropertiesML pointer to const from
 * a SystemFacialExpressionPropertiesML reference to const.
 * @relates SystemFacialExpressionPropertiesML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFacialExpressionPropertiesML const* get(
    SystemFacialExpressionPropertiesML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemFacialExpressionPropertiesML as the address of a raw XrSystemFacialExpressionPropertiesML
 * @relates SystemFacialExpressionPropertiesML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemFacialExpressionPropertiesML* put(
    SystemFacialExpressionPropertiesML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_facial_expression

#ifdef XR_ML_facial_expression
/*!
 * C++ projection of XrFacialExpressionClientCreateInfoML
 *
 * Provided by the `XR_ML_facial_expression` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialExpressionClientCreateInfoML>
 * @xrentity{XrFacialExpressionClientCreateInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FacialExpressionClientCreateInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  FacialExpressionClientCreateInfoML(uint32_t requestedCount_,
                                     const FacialBlendShapeML* requestedFacialBlendShapes_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::FacialExpressionClientCreateInfoML, next_),
        requestedCount{requestedCount_},
        requestedFacialBlendShapes{requestedFacialBlendShapes_} {}

  //! Default/empty constructor
  FacialExpressionClientCreateInfoML(const void* next_ = nullptr)

      : Parent(StructureType::FacialExpressionClientCreateInfoML, next_),
        requestedCount{0},
        requestedFacialBlendShapes{nullptr} {}

  //! Default copy constructor
  FacialExpressionClientCreateInfoML(const FacialExpressionClientCreateInfoML& rhs) = default;
  //! Default copy assignment
  FacialExpressionClientCreateInfoML& operator=(const FacialExpressionClientCreateInfoML& rhs) =
      default;
  //! Copy construct from raw
  FacialExpressionClientCreateInfoML(const XrFacialExpressionClientCreateInfoML& rhs)
      : FacialExpressionClientCreateInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FacialExpressionClientCreateInfoML& operator=(const XrFacialExpressionClientCreateInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFacialExpressionClientCreateInfoML&() const {
    return *reinterpret_cast<const XrFacialExpressionClientCreateInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFacialExpressionClientCreateInfoML&() {
    return *reinterpret_cast<XrFacialExpressionClientCreateInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrFacialExpressionClientCreateInfoML
  XrFacialExpressionClientCreateInfoML const* get() const noexcept {
    return reinterpret_cast<XrFacialExpressionClientCreateInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFacialExpressionClientCreateInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFacialExpressionClientCreateInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FacialExpressionClientCreateInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrFacialExpressionClientCreateInfoML*>(this);
  }
  uint32_t requestedCount;
  const FacialBlendShapeML* requestedFacialBlendShapes;
};
static_assert(sizeof(XrFacialExpressionClientCreateInfoML) ==
                  sizeof(FacialExpressionClientCreateInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFacialExpressionClientCreateInfoML pointer to const from
 * a FacialExpressionClientCreateInfoML reference to const.
 * @relates FacialExpressionClientCreateInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialExpressionClientCreateInfoML const* get(
    FacialExpressionClientCreateInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * FacialExpressionClientCreateInfoML as the address of a raw XrFacialExpressionClientCreateInfoML
 * @relates FacialExpressionClientCreateInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialExpressionClientCreateInfoML* put(
    FacialExpressionClientCreateInfoML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_facial_expression

#ifdef XR_ML_facial_expression
/*!
 * C++ projection of XrFacialExpressionBlendShapeGetInfoML
 *
 * Provided by the `XR_ML_facial_expression` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialExpressionBlendShapeGetInfoML>
 * @xrentity{XrFacialExpressionBlendShapeGetInfoML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FacialExpressionBlendShapeGetInfoML : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  FacialExpressionBlendShapeGetInfoML(const void* next_ = nullptr)

      : Parent(StructureType::FacialExpressionBlendShapeGetInfoML, next_) {}

  //! Default copy constructor
  FacialExpressionBlendShapeGetInfoML(const FacialExpressionBlendShapeGetInfoML& rhs) = default;
  //! Default copy assignment
  FacialExpressionBlendShapeGetInfoML& operator=(const FacialExpressionBlendShapeGetInfoML& rhs) =
      default;
  //! Copy construct from raw
  FacialExpressionBlendShapeGetInfoML(const XrFacialExpressionBlendShapeGetInfoML& rhs)
      : FacialExpressionBlendShapeGetInfoML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FacialExpressionBlendShapeGetInfoML& operator=(const XrFacialExpressionBlendShapeGetInfoML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFacialExpressionBlendShapeGetInfoML&() const {
    return *reinterpret_cast<const XrFacialExpressionBlendShapeGetInfoML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFacialExpressionBlendShapeGetInfoML&() {
    return *reinterpret_cast<XrFacialExpressionBlendShapeGetInfoML*>(this);
  }

  //! Accessor for this as the address of a raw XrFacialExpressionBlendShapeGetInfoML
  XrFacialExpressionBlendShapeGetInfoML const* get() const noexcept {
    return reinterpret_cast<XrFacialExpressionBlendShapeGetInfoML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFacialExpressionBlendShapeGetInfoML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFacialExpressionBlendShapeGetInfoML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FacialExpressionBlendShapeGetInfoML{};
      next = oldNext;
    }
    return reinterpret_cast<XrFacialExpressionBlendShapeGetInfoML*>(this);
  }
};
static_assert(sizeof(XrFacialExpressionBlendShapeGetInfoML) ==
                  sizeof(FacialExpressionBlendShapeGetInfoML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFacialExpressionBlendShapeGetInfoML pointer to const
 * from a FacialExpressionBlendShapeGetInfoML reference to const.
 * @relates FacialExpressionBlendShapeGetInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialExpressionBlendShapeGetInfoML const* get(
    FacialExpressionBlendShapeGetInfoML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * FacialExpressionBlendShapeGetInfoML as the address of a raw XrFacialExpressionBlendShapeGetInfoML
 * @relates FacialExpressionBlendShapeGetInfoML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialExpressionBlendShapeGetInfoML* put(
    FacialExpressionBlendShapeGetInfoML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_facial_expression

#ifdef XR_ML_facial_expression
/*!
 * C++ projection of XrFacialExpressionBlendShapePropertiesML
 *
 * Provided by the `XR_ML_facial_expression` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialExpressionBlendShapePropertiesML>
 * @xrentity{XrFacialExpressionBlendShapePropertiesML}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS FacialExpressionBlendShapePropertiesML : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  FacialExpressionBlendShapePropertiesML(void* next_ = nullptr)

      : Parent(StructureType::FacialExpressionBlendShapePropertiesML, next_) {}

  //! Default copy constructor
  FacialExpressionBlendShapePropertiesML(const FacialExpressionBlendShapePropertiesML& rhs) =
      default;
  //! Default copy assignment
  FacialExpressionBlendShapePropertiesML& operator=(
      const FacialExpressionBlendShapePropertiesML& rhs) = default;
  //! Copy construct from raw
  FacialExpressionBlendShapePropertiesML(const XrFacialExpressionBlendShapePropertiesML& rhs)
      : FacialExpressionBlendShapePropertiesML() {
    *put() = rhs;
  }
  //! Copy assign from raw
  FacialExpressionBlendShapePropertiesML& operator=(
      const XrFacialExpressionBlendShapePropertiesML& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrFacialExpressionBlendShapePropertiesML&() const {
    return *reinterpret_cast<const XrFacialExpressionBlendShapePropertiesML*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrFacialExpressionBlendShapePropertiesML&() {
    return *reinterpret_cast<XrFacialExpressionBlendShapePropertiesML*>(this);
  }

  //! Accessor for this as the address of a raw XrFacialExpressionBlendShapePropertiesML
  XrFacialExpressionBlendShapePropertiesML const* get() const noexcept {
    return reinterpret_cast<XrFacialExpressionBlendShapePropertiesML const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrFacialExpressionBlendShapePropertiesML.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrFacialExpressionBlendShapePropertiesML* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = FacialExpressionBlendShapePropertiesML{};
      next = oldNext;
    }
    return reinterpret_cast<XrFacialExpressionBlendShapePropertiesML*>(this);
  }
  FacialBlendShapeML requestedFacialBlendShape;
  float weight;
  FacialExpressionBlendShapePropertiesFlagsML flags;
  Time time;
};
static_assert(sizeof(XrFacialExpressionBlendShapePropertiesML) ==
                  sizeof(FacialExpressionBlendShapePropertiesML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrFacialExpressionBlendShapePropertiesML pointer to const
 * from a FacialExpressionBlendShapePropertiesML reference to const.
 * @relates FacialExpressionBlendShapePropertiesML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialExpressionBlendShapePropertiesML const* get(
    FacialExpressionBlendShapePropertiesML const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * FacialExpressionBlendShapePropertiesML as the address of a raw
 * XrFacialExpressionBlendShapePropertiesML
 * @relates FacialExpressionBlendShapePropertiesML
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFacialExpressionBlendShapePropertiesML* put(
    FacialExpressionBlendShapePropertiesML& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_ML_facial_expression

#ifdef XR_META_simultaneous_hands_and_controllers
/*!
 * C++ projection of XrSystemSimultaneousHandsAndControllersPropertiesMETA
 *
 * Provided by the `XR_META_simultaneous_hands_and_controllers` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSimultaneousHandsAndControllersPropertiesMETA>
 * @xrentity{XrSystemSimultaneousHandsAndControllersPropertiesMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemSimultaneousHandsAndControllersPropertiesMETA
    : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemSimultaneousHandsAndControllersPropertiesMETA(void* next_ = nullptr)

      : Parent(StructureType::SystemSimultaneousHandsAndControllersPropertiesMETA, next_) {}

  //! Default copy constructor
  SystemSimultaneousHandsAndControllersPropertiesMETA(
      const SystemSimultaneousHandsAndControllersPropertiesMETA& rhs) = default;
  //! Default copy assignment
  SystemSimultaneousHandsAndControllersPropertiesMETA& operator=(
      const SystemSimultaneousHandsAndControllersPropertiesMETA& rhs) = default;
  //! Copy construct from raw
  SystemSimultaneousHandsAndControllersPropertiesMETA(
      const XrSystemSimultaneousHandsAndControllersPropertiesMETA& rhs)
      : SystemSimultaneousHandsAndControllersPropertiesMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemSimultaneousHandsAndControllersPropertiesMETA& operator=(
      const XrSystemSimultaneousHandsAndControllersPropertiesMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemSimultaneousHandsAndControllersPropertiesMETA&() const {
    return *reinterpret_cast<const XrSystemSimultaneousHandsAndControllersPropertiesMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemSimultaneousHandsAndControllersPropertiesMETA&() {
    return *reinterpret_cast<XrSystemSimultaneousHandsAndControllersPropertiesMETA*>(this);
  }

  //! Accessor for this as the address of a raw
  //! XrSystemSimultaneousHandsAndControllersPropertiesMETA
  XrSystemSimultaneousHandsAndControllersPropertiesMETA const* get() const noexcept {
    return reinterpret_cast<XrSystemSimultaneousHandsAndControllersPropertiesMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemSimultaneousHandsAndControllersPropertiesMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemSimultaneousHandsAndControllersPropertiesMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemSimultaneousHandsAndControllersPropertiesMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemSimultaneousHandsAndControllersPropertiesMETA*>(this);
  }
  Bool32 supportsSimultaneousHandsAndControllers;
};
static_assert(sizeof(XrSystemSimultaneousHandsAndControllersPropertiesMETA) ==
                  sizeof(SystemSimultaneousHandsAndControllersPropertiesMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemSimultaneousHandsAndControllersPropertiesMETA
 * pointer to const from a SystemSimultaneousHandsAndControllersPropertiesMETA reference to const.
 * @relates SystemSimultaneousHandsAndControllersPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSimultaneousHandsAndControllersPropertiesMETA const* get(
    SystemSimultaneousHandsAndControllersPropertiesMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemSimultaneousHandsAndControllersPropertiesMETA as the address of a raw
 * XrSystemSimultaneousHandsAndControllersPropertiesMETA
 * @relates SystemSimultaneousHandsAndControllersPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSimultaneousHandsAndControllersPropertiesMETA* put(
    SystemSimultaneousHandsAndControllersPropertiesMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_simultaneous_hands_and_controllers

#ifdef XR_META_simultaneous_hands_and_controllers
/*!
 * C++ projection of XrSimultaneousHandsAndControllersTrackingResumeInfoMETA
 *
 * Provided by the `XR_META_simultaneous_hands_and_controllers` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSimultaneousHandsAndControllersTrackingResumeInfoMETA>
 * @xrentity{XrSimultaneousHandsAndControllersTrackingResumeInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SimultaneousHandsAndControllersTrackingResumeInfoMETA
    : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SimultaneousHandsAndControllersTrackingResumeInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::SimultaneousHandsAndControllersTrackingResumeInfoMETA, next_) {}

  //! Default copy constructor
  SimultaneousHandsAndControllersTrackingResumeInfoMETA(
      const SimultaneousHandsAndControllersTrackingResumeInfoMETA& rhs) = default;
  //! Default copy assignment
  SimultaneousHandsAndControllersTrackingResumeInfoMETA& operator=(
      const SimultaneousHandsAndControllersTrackingResumeInfoMETA& rhs) = default;
  //! Copy construct from raw
  SimultaneousHandsAndControllersTrackingResumeInfoMETA(
      const XrSimultaneousHandsAndControllersTrackingResumeInfoMETA& rhs)
      : SimultaneousHandsAndControllersTrackingResumeInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SimultaneousHandsAndControllersTrackingResumeInfoMETA& operator=(
      const XrSimultaneousHandsAndControllersTrackingResumeInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSimultaneousHandsAndControllersTrackingResumeInfoMETA&() const {
    return *reinterpret_cast<const XrSimultaneousHandsAndControllersTrackingResumeInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSimultaneousHandsAndControllersTrackingResumeInfoMETA&() {
    return *reinterpret_cast<XrSimultaneousHandsAndControllersTrackingResumeInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw
  //! XrSimultaneousHandsAndControllersTrackingResumeInfoMETA
  XrSimultaneousHandsAndControllersTrackingResumeInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrSimultaneousHandsAndControllersTrackingResumeInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSimultaneousHandsAndControllersTrackingResumeInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSimultaneousHandsAndControllersTrackingResumeInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SimultaneousHandsAndControllersTrackingResumeInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSimultaneousHandsAndControllersTrackingResumeInfoMETA*>(this);
  }
};
static_assert(sizeof(XrSimultaneousHandsAndControllersTrackingResumeInfoMETA) ==
                  sizeof(SimultaneousHandsAndControllersTrackingResumeInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSimultaneousHandsAndControllersTrackingResumeInfoMETA
 * pointer to const from a SimultaneousHandsAndControllersTrackingResumeInfoMETA reference to const.
 * @relates SimultaneousHandsAndControllersTrackingResumeInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSimultaneousHandsAndControllersTrackingResumeInfoMETA const* get(
    SimultaneousHandsAndControllersTrackingResumeInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SimultaneousHandsAndControllersTrackingResumeInfoMETA as the address of a raw
 * XrSimultaneousHandsAndControllersTrackingResumeInfoMETA
 * @relates SimultaneousHandsAndControllersTrackingResumeInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSimultaneousHandsAndControllersTrackingResumeInfoMETA* put(
    SimultaneousHandsAndControllersTrackingResumeInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_simultaneous_hands_and_controllers

#ifdef XR_META_simultaneous_hands_and_controllers
/*!
 * C++ projection of XrSimultaneousHandsAndControllersTrackingPauseInfoMETA
 *
 * Provided by the `XR_META_simultaneous_hands_and_controllers` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSimultaneousHandsAndControllersTrackingPauseInfoMETA>
 * @xrentity{XrSimultaneousHandsAndControllersTrackingPauseInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SimultaneousHandsAndControllersTrackingPauseInfoMETA
    : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  SimultaneousHandsAndControllersTrackingPauseInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::SimultaneousHandsAndControllersTrackingPauseInfoMETA, next_) {}

  //! Default copy constructor
  SimultaneousHandsAndControllersTrackingPauseInfoMETA(
      const SimultaneousHandsAndControllersTrackingPauseInfoMETA& rhs) = default;
  //! Default copy assignment
  SimultaneousHandsAndControllersTrackingPauseInfoMETA& operator=(
      const SimultaneousHandsAndControllersTrackingPauseInfoMETA& rhs) = default;
  //! Copy construct from raw
  SimultaneousHandsAndControllersTrackingPauseInfoMETA(
      const XrSimultaneousHandsAndControllersTrackingPauseInfoMETA& rhs)
      : SimultaneousHandsAndControllersTrackingPauseInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SimultaneousHandsAndControllersTrackingPauseInfoMETA& operator=(
      const XrSimultaneousHandsAndControllersTrackingPauseInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSimultaneousHandsAndControllersTrackingPauseInfoMETA&() const {
    return *reinterpret_cast<const XrSimultaneousHandsAndControllersTrackingPauseInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSimultaneousHandsAndControllersTrackingPauseInfoMETA&() {
    return *reinterpret_cast<XrSimultaneousHandsAndControllersTrackingPauseInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw
  //! XrSimultaneousHandsAndControllersTrackingPauseInfoMETA
  XrSimultaneousHandsAndControllersTrackingPauseInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrSimultaneousHandsAndControllersTrackingPauseInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSimultaneousHandsAndControllersTrackingPauseInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSimultaneousHandsAndControllersTrackingPauseInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SimultaneousHandsAndControllersTrackingPauseInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSimultaneousHandsAndControllersTrackingPauseInfoMETA*>(this);
  }
};
static_assert(sizeof(XrSimultaneousHandsAndControllersTrackingPauseInfoMETA) ==
                  sizeof(SimultaneousHandsAndControllersTrackingPauseInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSimultaneousHandsAndControllersTrackingPauseInfoMETA
 * pointer to const from a SimultaneousHandsAndControllersTrackingPauseInfoMETA reference to const.
 * @relates SimultaneousHandsAndControllersTrackingPauseInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSimultaneousHandsAndControllersTrackingPauseInfoMETA const* get(
    SimultaneousHandsAndControllersTrackingPauseInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SimultaneousHandsAndControllersTrackingPauseInfoMETA as the address of a raw
 * XrSimultaneousHandsAndControllersTrackingPauseInfoMETA
 * @relates SimultaneousHandsAndControllersTrackingPauseInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSimultaneousHandsAndControllersTrackingPauseInfoMETA* put(
    SimultaneousHandsAndControllersTrackingPauseInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_simultaneous_hands_and_controllers

#ifdef XR_META_colocation_discovery
/*!
 * C++ projection of XrColocationDiscoveryStartInfoMETA
 *
 * Provided by the `XR_META_colocation_discovery` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrColocationDiscoveryStartInfoMETA>
 * @xrentity{XrColocationDiscoveryStartInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ColocationDiscoveryStartInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  ColocationDiscoveryStartInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::ColocationDiscoveryStartInfoMETA, next_) {}

  //! Default copy constructor
  ColocationDiscoveryStartInfoMETA(const ColocationDiscoveryStartInfoMETA& rhs) = default;
  //! Default copy assignment
  ColocationDiscoveryStartInfoMETA& operator=(const ColocationDiscoveryStartInfoMETA& rhs) =
      default;
  //! Copy construct from raw
  ColocationDiscoveryStartInfoMETA(const XrColocationDiscoveryStartInfoMETA& rhs)
      : ColocationDiscoveryStartInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ColocationDiscoveryStartInfoMETA& operator=(const XrColocationDiscoveryStartInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrColocationDiscoveryStartInfoMETA&() const {
    return *reinterpret_cast<const XrColocationDiscoveryStartInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrColocationDiscoveryStartInfoMETA&() {
    return *reinterpret_cast<XrColocationDiscoveryStartInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrColocationDiscoveryStartInfoMETA
  XrColocationDiscoveryStartInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrColocationDiscoveryStartInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrColocationDiscoveryStartInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrColocationDiscoveryStartInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ColocationDiscoveryStartInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrColocationDiscoveryStartInfoMETA*>(this);
  }
};
static_assert(sizeof(XrColocationDiscoveryStartInfoMETA) ==
                  sizeof(ColocationDiscoveryStartInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrColocationDiscoveryStartInfoMETA pointer to const from a
 * ColocationDiscoveryStartInfoMETA reference to const.
 * @relates ColocationDiscoveryStartInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColocationDiscoveryStartInfoMETA const* get(
    ColocationDiscoveryStartInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ColocationDiscoveryStartInfoMETA as the address of a raw XrColocationDiscoveryStartInfoMETA
 * @relates ColocationDiscoveryStartInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColocationDiscoveryStartInfoMETA* put(
    ColocationDiscoveryStartInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery
/*!
 * C++ projection of XrColocationDiscoveryStopInfoMETA
 *
 * Provided by the `XR_META_colocation_discovery` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrColocationDiscoveryStopInfoMETA>
 * @xrentity{XrColocationDiscoveryStopInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ColocationDiscoveryStopInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  ColocationDiscoveryStopInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::ColocationDiscoveryStopInfoMETA, next_) {}

  //! Default copy constructor
  ColocationDiscoveryStopInfoMETA(const ColocationDiscoveryStopInfoMETA& rhs) = default;
  //! Default copy assignment
  ColocationDiscoveryStopInfoMETA& operator=(const ColocationDiscoveryStopInfoMETA& rhs) = default;
  //! Copy construct from raw
  ColocationDiscoveryStopInfoMETA(const XrColocationDiscoveryStopInfoMETA& rhs)
      : ColocationDiscoveryStopInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ColocationDiscoveryStopInfoMETA& operator=(const XrColocationDiscoveryStopInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrColocationDiscoveryStopInfoMETA&() const {
    return *reinterpret_cast<const XrColocationDiscoveryStopInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrColocationDiscoveryStopInfoMETA&() {
    return *reinterpret_cast<XrColocationDiscoveryStopInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrColocationDiscoveryStopInfoMETA
  XrColocationDiscoveryStopInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrColocationDiscoveryStopInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrColocationDiscoveryStopInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrColocationDiscoveryStopInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ColocationDiscoveryStopInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrColocationDiscoveryStopInfoMETA*>(this);
  }
};
static_assert(sizeof(XrColocationDiscoveryStopInfoMETA) == sizeof(ColocationDiscoveryStopInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrColocationDiscoveryStopInfoMETA pointer to const from a
 * ColocationDiscoveryStopInfoMETA reference to const.
 * @relates ColocationDiscoveryStopInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColocationDiscoveryStopInfoMETA const* get(
    ColocationDiscoveryStopInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ColocationDiscoveryStopInfoMETA as the address of a raw XrColocationDiscoveryStopInfoMETA
 * @relates ColocationDiscoveryStopInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColocationDiscoveryStopInfoMETA* put(ColocationDiscoveryStopInfoMETA& s,
                                                                bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery
/*!
 * C++ projection of XrColocationAdvertisementStartInfoMETA
 *
 * Provided by the `XR_META_colocation_discovery` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrColocationAdvertisementStartInfoMETA>
 * @xrentity{XrColocationAdvertisementStartInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ColocationAdvertisementStartInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  ColocationAdvertisementStartInfoMETA(uint32_t bufferSize_, uint8_t* buffer_,
                                       const void* next_ = nullptr)
      : Parent(StructureType::ColocationAdvertisementStartInfoMETA, next_),
        bufferSize{bufferSize_},
        buffer{buffer_} {}

  //! Default/empty constructor
  ColocationAdvertisementStartInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::ColocationAdvertisementStartInfoMETA, next_),
        bufferSize{0},
        buffer{nullptr} {}

  //! Default copy constructor
  ColocationAdvertisementStartInfoMETA(const ColocationAdvertisementStartInfoMETA& rhs) = default;
  //! Default copy assignment
  ColocationAdvertisementStartInfoMETA& operator=(const ColocationAdvertisementStartInfoMETA& rhs) =
      default;
  //! Copy construct from raw
  ColocationAdvertisementStartInfoMETA(const XrColocationAdvertisementStartInfoMETA& rhs)
      : ColocationAdvertisementStartInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ColocationAdvertisementStartInfoMETA& operator=(
      const XrColocationAdvertisementStartInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrColocationAdvertisementStartInfoMETA&() const {
    return *reinterpret_cast<const XrColocationAdvertisementStartInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrColocationAdvertisementStartInfoMETA&() {
    return *reinterpret_cast<XrColocationAdvertisementStartInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrColocationAdvertisementStartInfoMETA
  XrColocationAdvertisementStartInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrColocationAdvertisementStartInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrColocationAdvertisementStartInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrColocationAdvertisementStartInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ColocationAdvertisementStartInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrColocationAdvertisementStartInfoMETA*>(this);
  }
  uint32_t bufferSize;
  uint8_t* buffer;
};
static_assert(sizeof(XrColocationAdvertisementStartInfoMETA) ==
                  sizeof(ColocationAdvertisementStartInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrColocationAdvertisementStartInfoMETA pointer to const
 * from a ColocationAdvertisementStartInfoMETA reference to const.
 * @relates ColocationAdvertisementStartInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColocationAdvertisementStartInfoMETA const* get(
    ColocationAdvertisementStartInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ColocationAdvertisementStartInfoMETA as the address of a raw
 * XrColocationAdvertisementStartInfoMETA
 * @relates ColocationAdvertisementStartInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColocationAdvertisementStartInfoMETA* put(
    ColocationAdvertisementStartInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery
/*!
 * C++ projection of XrColocationAdvertisementStopInfoMETA
 *
 * Provided by the `XR_META_colocation_discovery` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrColocationAdvertisementStopInfoMETA>
 * @xrentity{XrColocationAdvertisementStopInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ColocationAdvertisementStopInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Default/empty constructor
  ColocationAdvertisementStopInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::ColocationAdvertisementStopInfoMETA, next_) {}

  //! Default copy constructor
  ColocationAdvertisementStopInfoMETA(const ColocationAdvertisementStopInfoMETA& rhs) = default;
  //! Default copy assignment
  ColocationAdvertisementStopInfoMETA& operator=(const ColocationAdvertisementStopInfoMETA& rhs) =
      default;
  //! Copy construct from raw
  ColocationAdvertisementStopInfoMETA(const XrColocationAdvertisementStopInfoMETA& rhs)
      : ColocationAdvertisementStopInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ColocationAdvertisementStopInfoMETA& operator=(const XrColocationAdvertisementStopInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrColocationAdvertisementStopInfoMETA&() const {
    return *reinterpret_cast<const XrColocationAdvertisementStopInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrColocationAdvertisementStopInfoMETA&() {
    return *reinterpret_cast<XrColocationAdvertisementStopInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrColocationAdvertisementStopInfoMETA
  XrColocationAdvertisementStopInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrColocationAdvertisementStopInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrColocationAdvertisementStopInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrColocationAdvertisementStopInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ColocationAdvertisementStopInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrColocationAdvertisementStopInfoMETA*>(this);
  }
};
static_assert(sizeof(XrColocationAdvertisementStopInfoMETA) ==
                  sizeof(ColocationAdvertisementStopInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrColocationAdvertisementStopInfoMETA pointer to const
 * from a ColocationAdvertisementStopInfoMETA reference to const.
 * @relates ColocationAdvertisementStopInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColocationAdvertisementStopInfoMETA const* get(
    ColocationAdvertisementStopInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ColocationAdvertisementStopInfoMETA as the address of a raw XrColocationAdvertisementStopInfoMETA
 * @relates ColocationAdvertisementStopInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrColocationAdvertisementStopInfoMETA* put(
    ColocationAdvertisementStopInfoMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery
/*!
 * C++ projection of XrEventDataStartColocationAdvertisementCompleteMETA
 *
 * Provided by the `XR_META_colocation_discovery` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataStartColocationAdvertisementCompleteMETA>
 * @xrentity{XrEventDataStartColocationAdvertisementCompleteMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataStartColocationAdvertisementCompleteMETA
    : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataStartColocationAdvertisementCompleteMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataStartColocationAdvertisementCompleteMETA, next_) {}

  //! Default copy constructor
  EventDataStartColocationAdvertisementCompleteMETA(
      const EventDataStartColocationAdvertisementCompleteMETA& rhs) = default;
  //! Default copy assignment
  EventDataStartColocationAdvertisementCompleteMETA& operator=(
      const EventDataStartColocationAdvertisementCompleteMETA& rhs) = default;
  //! Copy construct from raw
  EventDataStartColocationAdvertisementCompleteMETA(
      const XrEventDataStartColocationAdvertisementCompleteMETA& rhs)
      : EventDataStartColocationAdvertisementCompleteMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataStartColocationAdvertisementCompleteMETA& operator=(
      const XrEventDataStartColocationAdvertisementCompleteMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataStartColocationAdvertisementCompleteMETA&() const {
    return *reinterpret_cast<const XrEventDataStartColocationAdvertisementCompleteMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataStartColocationAdvertisementCompleteMETA&() {
    return *reinterpret_cast<XrEventDataStartColocationAdvertisementCompleteMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataStartColocationAdvertisementCompleteMETA
  XrEventDataStartColocationAdvertisementCompleteMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataStartColocationAdvertisementCompleteMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataStartColocationAdvertisementCompleteMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataStartColocationAdvertisementCompleteMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataStartColocationAdvertisementCompleteMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataStartColocationAdvertisementCompleteMETA*>(this);
  }
  AsyncRequestIdFB advertisementRequestId;
  Result result;
  Uuid advertisementUuid;
};
static_assert(sizeof(XrEventDataStartColocationAdvertisementCompleteMETA) ==
                  sizeof(EventDataStartColocationAdvertisementCompleteMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataStartColocationAdvertisementCompleteMETA
 * pointer to const from a EventDataStartColocationAdvertisementCompleteMETA reference to const.
 * @relates EventDataStartColocationAdvertisementCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataStartColocationAdvertisementCompleteMETA const* get(
    EventDataStartColocationAdvertisementCompleteMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataStartColocationAdvertisementCompleteMETA as the address of a raw
 * XrEventDataStartColocationAdvertisementCompleteMETA
 * @relates EventDataStartColocationAdvertisementCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataStartColocationAdvertisementCompleteMETA* put(
    EventDataStartColocationAdvertisementCompleteMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery
/*!
 * C++ projection of XrEventDataStopColocationAdvertisementCompleteMETA
 *
 * Provided by the `XR_META_colocation_discovery` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataStopColocationAdvertisementCompleteMETA>
 * @xrentity{XrEventDataStopColocationAdvertisementCompleteMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataStopColocationAdvertisementCompleteMETA
    : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataStopColocationAdvertisementCompleteMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataStopColocationAdvertisementCompleteMETA, next_) {}

  //! Default copy constructor
  EventDataStopColocationAdvertisementCompleteMETA(
      const EventDataStopColocationAdvertisementCompleteMETA& rhs) = default;
  //! Default copy assignment
  EventDataStopColocationAdvertisementCompleteMETA& operator=(
      const EventDataStopColocationAdvertisementCompleteMETA& rhs) = default;
  //! Copy construct from raw
  EventDataStopColocationAdvertisementCompleteMETA(
      const XrEventDataStopColocationAdvertisementCompleteMETA& rhs)
      : EventDataStopColocationAdvertisementCompleteMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataStopColocationAdvertisementCompleteMETA& operator=(
      const XrEventDataStopColocationAdvertisementCompleteMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataStopColocationAdvertisementCompleteMETA&() const {
    return *reinterpret_cast<const XrEventDataStopColocationAdvertisementCompleteMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataStopColocationAdvertisementCompleteMETA&() {
    return *reinterpret_cast<XrEventDataStopColocationAdvertisementCompleteMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataStopColocationAdvertisementCompleteMETA
  XrEventDataStopColocationAdvertisementCompleteMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataStopColocationAdvertisementCompleteMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataStopColocationAdvertisementCompleteMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataStopColocationAdvertisementCompleteMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataStopColocationAdvertisementCompleteMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataStopColocationAdvertisementCompleteMETA*>(this);
  }
  AsyncRequestIdFB requestId;
  Result result;
};
static_assert(sizeof(XrEventDataStopColocationAdvertisementCompleteMETA) ==
                  sizeof(EventDataStopColocationAdvertisementCompleteMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataStopColocationAdvertisementCompleteMETA pointer
 * to const from a EventDataStopColocationAdvertisementCompleteMETA reference to const.
 * @relates EventDataStopColocationAdvertisementCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataStopColocationAdvertisementCompleteMETA const* get(
    EventDataStopColocationAdvertisementCompleteMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataStopColocationAdvertisementCompleteMETA as the address of a raw
 * XrEventDataStopColocationAdvertisementCompleteMETA
 * @relates EventDataStopColocationAdvertisementCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataStopColocationAdvertisementCompleteMETA* put(
    EventDataStopColocationAdvertisementCompleteMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery
/*!
 * C++ projection of XrEventDataColocationAdvertisementCompleteMETA
 *
 * Provided by the `XR_META_colocation_discovery` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataColocationAdvertisementCompleteMETA>
 * @xrentity{XrEventDataColocationAdvertisementCompleteMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataColocationAdvertisementCompleteMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataColocationAdvertisementCompleteMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataColocationAdvertisementCompleteMETA, next_) {}

  //! Default copy constructor
  EventDataColocationAdvertisementCompleteMETA(
      const EventDataColocationAdvertisementCompleteMETA& rhs) = default;
  //! Default copy assignment
  EventDataColocationAdvertisementCompleteMETA& operator=(
      const EventDataColocationAdvertisementCompleteMETA& rhs) = default;
  //! Copy construct from raw
  EventDataColocationAdvertisementCompleteMETA(
      const XrEventDataColocationAdvertisementCompleteMETA& rhs)
      : EventDataColocationAdvertisementCompleteMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataColocationAdvertisementCompleteMETA& operator=(
      const XrEventDataColocationAdvertisementCompleteMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataColocationAdvertisementCompleteMETA&() const {
    return *reinterpret_cast<const XrEventDataColocationAdvertisementCompleteMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataColocationAdvertisementCompleteMETA&() {
    return *reinterpret_cast<XrEventDataColocationAdvertisementCompleteMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataColocationAdvertisementCompleteMETA
  XrEventDataColocationAdvertisementCompleteMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataColocationAdvertisementCompleteMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataColocationAdvertisementCompleteMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataColocationAdvertisementCompleteMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataColocationAdvertisementCompleteMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataColocationAdvertisementCompleteMETA*>(this);
  }
  AsyncRequestIdFB advertisementRequestId;
  Result result;
};
static_assert(sizeof(XrEventDataColocationAdvertisementCompleteMETA) ==
                  sizeof(EventDataColocationAdvertisementCompleteMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataColocationAdvertisementCompleteMETA pointer to
 * const from a EventDataColocationAdvertisementCompleteMETA reference to const.
 * @relates EventDataColocationAdvertisementCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataColocationAdvertisementCompleteMETA const* get(
    EventDataColocationAdvertisementCompleteMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataColocationAdvertisementCompleteMETA as the address of a raw
 * XrEventDataColocationAdvertisementCompleteMETA
 * @relates EventDataColocationAdvertisementCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataColocationAdvertisementCompleteMETA* put(
    EventDataColocationAdvertisementCompleteMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery
/*!
 * C++ projection of XrEventDataStartColocationDiscoveryCompleteMETA
 *
 * Provided by the `XR_META_colocation_discovery` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataStartColocationDiscoveryCompleteMETA>
 * @xrentity{XrEventDataStartColocationDiscoveryCompleteMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataStartColocationDiscoveryCompleteMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataStartColocationDiscoveryCompleteMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataStartColocationDiscoveryCompleteMETA, next_) {}

  //! Default copy constructor
  EventDataStartColocationDiscoveryCompleteMETA(
      const EventDataStartColocationDiscoveryCompleteMETA& rhs) = default;
  //! Default copy assignment
  EventDataStartColocationDiscoveryCompleteMETA& operator=(
      const EventDataStartColocationDiscoveryCompleteMETA& rhs) = default;
  //! Copy construct from raw
  EventDataStartColocationDiscoveryCompleteMETA(
      const XrEventDataStartColocationDiscoveryCompleteMETA& rhs)
      : EventDataStartColocationDiscoveryCompleteMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataStartColocationDiscoveryCompleteMETA& operator=(
      const XrEventDataStartColocationDiscoveryCompleteMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataStartColocationDiscoveryCompleteMETA&() const {
    return *reinterpret_cast<const XrEventDataStartColocationDiscoveryCompleteMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataStartColocationDiscoveryCompleteMETA&() {
    return *reinterpret_cast<XrEventDataStartColocationDiscoveryCompleteMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataStartColocationDiscoveryCompleteMETA
  XrEventDataStartColocationDiscoveryCompleteMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataStartColocationDiscoveryCompleteMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataStartColocationDiscoveryCompleteMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataStartColocationDiscoveryCompleteMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataStartColocationDiscoveryCompleteMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataStartColocationDiscoveryCompleteMETA*>(this);
  }
  AsyncRequestIdFB discoveryRequestId;
  Result result;
};
static_assert(sizeof(XrEventDataStartColocationDiscoveryCompleteMETA) ==
                  sizeof(EventDataStartColocationDiscoveryCompleteMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataStartColocationDiscoveryCompleteMETA pointer to
 * const from a EventDataStartColocationDiscoveryCompleteMETA reference to const.
 * @relates EventDataStartColocationDiscoveryCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataStartColocationDiscoveryCompleteMETA const* get(
    EventDataStartColocationDiscoveryCompleteMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataStartColocationDiscoveryCompleteMETA as the address of a raw
 * XrEventDataStartColocationDiscoveryCompleteMETA
 * @relates EventDataStartColocationDiscoveryCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataStartColocationDiscoveryCompleteMETA* put(
    EventDataStartColocationDiscoveryCompleteMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery
/*!
 * C++ projection of XrEventDataColocationDiscoveryResultMETA
 *
 * Provided by the `XR_META_colocation_discovery` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataColocationDiscoveryResultMETA>
 * @xrentity{XrEventDataColocationDiscoveryResultMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataColocationDiscoveryResultMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataColocationDiscoveryResultMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataColocationDiscoveryResultMETA, next_) {}

  //! Default copy constructor
  EventDataColocationDiscoveryResultMETA(const EventDataColocationDiscoveryResultMETA& rhs) =
      default;
  //! Default copy assignment
  EventDataColocationDiscoveryResultMETA& operator=(
      const EventDataColocationDiscoveryResultMETA& rhs) = default;
  //! Copy construct from raw
  EventDataColocationDiscoveryResultMETA(const XrEventDataColocationDiscoveryResultMETA& rhs)
      : EventDataColocationDiscoveryResultMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataColocationDiscoveryResultMETA& operator=(
      const XrEventDataColocationDiscoveryResultMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataColocationDiscoveryResultMETA&() const {
    return *reinterpret_cast<const XrEventDataColocationDiscoveryResultMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataColocationDiscoveryResultMETA&() {
    return *reinterpret_cast<XrEventDataColocationDiscoveryResultMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataColocationDiscoveryResultMETA
  XrEventDataColocationDiscoveryResultMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataColocationDiscoveryResultMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataColocationDiscoveryResultMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataColocationDiscoveryResultMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataColocationDiscoveryResultMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataColocationDiscoveryResultMETA*>(this);
  }
  AsyncRequestIdFB discoveryRequestId;
  Uuid advertisementUuid;
  uint32_t bufferSize;
  uint8_t buffer[XR_MAX_COLOCATION_DISCOVERY_BUFFER_SIZE_META];
};
static_assert(sizeof(XrEventDataColocationDiscoveryResultMETA) ==
                  sizeof(EventDataColocationDiscoveryResultMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataColocationDiscoveryResultMETA pointer to const
 * from a EventDataColocationDiscoveryResultMETA reference to const.
 * @relates EventDataColocationDiscoveryResultMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataColocationDiscoveryResultMETA const* get(
    EventDataColocationDiscoveryResultMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataColocationDiscoveryResultMETA as the address of a raw
 * XrEventDataColocationDiscoveryResultMETA
 * @relates EventDataColocationDiscoveryResultMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataColocationDiscoveryResultMETA* put(
    EventDataColocationDiscoveryResultMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery
/*!
 * C++ projection of XrEventDataColocationDiscoveryCompleteMETA
 *
 * Provided by the `XR_META_colocation_discovery` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataColocationDiscoveryCompleteMETA>
 * @xrentity{XrEventDataColocationDiscoveryCompleteMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataColocationDiscoveryCompleteMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataColocationDiscoveryCompleteMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataColocationDiscoveryCompleteMETA, next_) {}

  //! Default copy constructor
  EventDataColocationDiscoveryCompleteMETA(const EventDataColocationDiscoveryCompleteMETA& rhs) =
      default;
  //! Default copy assignment
  EventDataColocationDiscoveryCompleteMETA& operator=(
      const EventDataColocationDiscoveryCompleteMETA& rhs) = default;
  //! Copy construct from raw
  EventDataColocationDiscoveryCompleteMETA(const XrEventDataColocationDiscoveryCompleteMETA& rhs)
      : EventDataColocationDiscoveryCompleteMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataColocationDiscoveryCompleteMETA& operator=(
      const XrEventDataColocationDiscoveryCompleteMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataColocationDiscoveryCompleteMETA&() const {
    return *reinterpret_cast<const XrEventDataColocationDiscoveryCompleteMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataColocationDiscoveryCompleteMETA&() {
    return *reinterpret_cast<XrEventDataColocationDiscoveryCompleteMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataColocationDiscoveryCompleteMETA
  XrEventDataColocationDiscoveryCompleteMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataColocationDiscoveryCompleteMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataColocationDiscoveryCompleteMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataColocationDiscoveryCompleteMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataColocationDiscoveryCompleteMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataColocationDiscoveryCompleteMETA*>(this);
  }
  AsyncRequestIdFB discoveryRequestId;
  Result result;
};
static_assert(sizeof(XrEventDataColocationDiscoveryCompleteMETA) ==
                  sizeof(EventDataColocationDiscoveryCompleteMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataColocationDiscoveryCompleteMETA pointer to
 * const from a EventDataColocationDiscoveryCompleteMETA reference to const.
 * @relates EventDataColocationDiscoveryCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataColocationDiscoveryCompleteMETA const* get(
    EventDataColocationDiscoveryCompleteMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataColocationDiscoveryCompleteMETA as the address of a raw
 * XrEventDataColocationDiscoveryCompleteMETA
 * @relates EventDataColocationDiscoveryCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataColocationDiscoveryCompleteMETA* put(
    EventDataColocationDiscoveryCompleteMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery
/*!
 * C++ projection of XrEventDataStopColocationDiscoveryCompleteMETA
 *
 * Provided by the `XR_META_colocation_discovery` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataStopColocationDiscoveryCompleteMETA>
 * @xrentity{XrEventDataStopColocationDiscoveryCompleteMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataStopColocationDiscoveryCompleteMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataStopColocationDiscoveryCompleteMETA(void* next_ = nullptr)

      : Parent(StructureType::EventDataStopColocationDiscoveryCompleteMETA, next_) {}

  //! Default copy constructor
  EventDataStopColocationDiscoveryCompleteMETA(
      const EventDataStopColocationDiscoveryCompleteMETA& rhs) = default;
  //! Default copy assignment
  EventDataStopColocationDiscoveryCompleteMETA& operator=(
      const EventDataStopColocationDiscoveryCompleteMETA& rhs) = default;
  //! Copy construct from raw
  EventDataStopColocationDiscoveryCompleteMETA(
      const XrEventDataStopColocationDiscoveryCompleteMETA& rhs)
      : EventDataStopColocationDiscoveryCompleteMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataStopColocationDiscoveryCompleteMETA& operator=(
      const XrEventDataStopColocationDiscoveryCompleteMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataStopColocationDiscoveryCompleteMETA&() const {
    return *reinterpret_cast<const XrEventDataStopColocationDiscoveryCompleteMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataStopColocationDiscoveryCompleteMETA&() {
    return *reinterpret_cast<XrEventDataStopColocationDiscoveryCompleteMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrEventDataStopColocationDiscoveryCompleteMETA
  XrEventDataStopColocationDiscoveryCompleteMETA const* get() const noexcept {
    return reinterpret_cast<XrEventDataStopColocationDiscoveryCompleteMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataStopColocationDiscoveryCompleteMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataStopColocationDiscoveryCompleteMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataStopColocationDiscoveryCompleteMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataStopColocationDiscoveryCompleteMETA*>(this);
  }
  AsyncRequestIdFB requestId;
  Result result;
};
static_assert(sizeof(XrEventDataStopColocationDiscoveryCompleteMETA) ==
                  sizeof(EventDataStopColocationDiscoveryCompleteMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataStopColocationDiscoveryCompleteMETA pointer to
 * const from a EventDataStopColocationDiscoveryCompleteMETA reference to const.
 * @relates EventDataStopColocationDiscoveryCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataStopColocationDiscoveryCompleteMETA const* get(
    EventDataStopColocationDiscoveryCompleteMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataStopColocationDiscoveryCompleteMETA as the address of a raw
 * XrEventDataStopColocationDiscoveryCompleteMETA
 * @relates EventDataStopColocationDiscoveryCompleteMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataStopColocationDiscoveryCompleteMETA* put(
    EventDataStopColocationDiscoveryCompleteMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery
/*!
 * C++ projection of XrSystemColocationDiscoveryPropertiesMETA
 *
 * Provided by the `XR_META_colocation_discovery` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemColocationDiscoveryPropertiesMETA>
 * @xrentity{XrSystemColocationDiscoveryPropertiesMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemColocationDiscoveryPropertiesMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemColocationDiscoveryPropertiesMETA(void* next_ = nullptr)

      : Parent(StructureType::SystemColocationDiscoveryPropertiesMETA, next_) {}

  //! Default copy constructor
  SystemColocationDiscoveryPropertiesMETA(const SystemColocationDiscoveryPropertiesMETA& rhs) =
      default;
  //! Default copy assignment
  SystemColocationDiscoveryPropertiesMETA& operator=(
      const SystemColocationDiscoveryPropertiesMETA& rhs) = default;
  //! Copy construct from raw
  SystemColocationDiscoveryPropertiesMETA(const XrSystemColocationDiscoveryPropertiesMETA& rhs)
      : SystemColocationDiscoveryPropertiesMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemColocationDiscoveryPropertiesMETA& operator=(
      const XrSystemColocationDiscoveryPropertiesMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemColocationDiscoveryPropertiesMETA&() const {
    return *reinterpret_cast<const XrSystemColocationDiscoveryPropertiesMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemColocationDiscoveryPropertiesMETA&() {
    return *reinterpret_cast<XrSystemColocationDiscoveryPropertiesMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemColocationDiscoveryPropertiesMETA
  XrSystemColocationDiscoveryPropertiesMETA const* get() const noexcept {
    return reinterpret_cast<XrSystemColocationDiscoveryPropertiesMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemColocationDiscoveryPropertiesMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemColocationDiscoveryPropertiesMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemColocationDiscoveryPropertiesMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemColocationDiscoveryPropertiesMETA*>(this);
  }
  Bool32 supportsColocationDiscovery;
};
static_assert(sizeof(XrSystemColocationDiscoveryPropertiesMETA) ==
                  sizeof(SystemColocationDiscoveryPropertiesMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemColocationDiscoveryPropertiesMETA pointer to const
 * from a SystemColocationDiscoveryPropertiesMETA reference to const.
 * @relates SystemColocationDiscoveryPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemColocationDiscoveryPropertiesMETA const* get(
    SystemColocationDiscoveryPropertiesMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemColocationDiscoveryPropertiesMETA as the address of a raw
 * XrSystemColocationDiscoveryPropertiesMETA
 * @relates SystemColocationDiscoveryPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemColocationDiscoveryPropertiesMETA* put(
    SystemColocationDiscoveryPropertiesMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_colocation_discovery

#ifdef XR_META_spatial_entity_group_sharing
/*!
 * C++ projection of XrSystemSpatialEntityGroupSharingPropertiesMETA
 *
 * Provided by the `XR_META_spatial_entity_group_sharing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSystemSpatialEntityGroupSharingPropertiesMETA>
 * @xrentity{XrSystemSpatialEntityGroupSharingPropertiesMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SystemSpatialEntityGroupSharingPropertiesMETA : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SystemSpatialEntityGroupSharingPropertiesMETA(void* next_ = nullptr)

      : Parent(StructureType::SystemSpatialEntityGroupSharingPropertiesMETA, next_) {}

  //! Default copy constructor
  SystemSpatialEntityGroupSharingPropertiesMETA(
      const SystemSpatialEntityGroupSharingPropertiesMETA& rhs) = default;
  //! Default copy assignment
  SystemSpatialEntityGroupSharingPropertiesMETA& operator=(
      const SystemSpatialEntityGroupSharingPropertiesMETA& rhs) = default;
  //! Copy construct from raw
  SystemSpatialEntityGroupSharingPropertiesMETA(
      const XrSystemSpatialEntityGroupSharingPropertiesMETA& rhs)
      : SystemSpatialEntityGroupSharingPropertiesMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SystemSpatialEntityGroupSharingPropertiesMETA& operator=(
      const XrSystemSpatialEntityGroupSharingPropertiesMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSystemSpatialEntityGroupSharingPropertiesMETA&() const {
    return *reinterpret_cast<const XrSystemSpatialEntityGroupSharingPropertiesMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSystemSpatialEntityGroupSharingPropertiesMETA&() {
    return *reinterpret_cast<XrSystemSpatialEntityGroupSharingPropertiesMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrSystemSpatialEntityGroupSharingPropertiesMETA
  XrSystemSpatialEntityGroupSharingPropertiesMETA const* get() const noexcept {
    return reinterpret_cast<XrSystemSpatialEntityGroupSharingPropertiesMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSystemSpatialEntityGroupSharingPropertiesMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSystemSpatialEntityGroupSharingPropertiesMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SystemSpatialEntityGroupSharingPropertiesMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSystemSpatialEntityGroupSharingPropertiesMETA*>(this);
  }
  Bool32 supportsSpatialEntityGroupSharing;
};
static_assert(sizeof(XrSystemSpatialEntityGroupSharingPropertiesMETA) ==
                  sizeof(SystemSpatialEntityGroupSharingPropertiesMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSystemSpatialEntityGroupSharingPropertiesMETA pointer to
 * const from a SystemSpatialEntityGroupSharingPropertiesMETA reference to const.
 * @relates SystemSpatialEntityGroupSharingPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialEntityGroupSharingPropertiesMETA const* get(
    SystemSpatialEntityGroupSharingPropertiesMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SystemSpatialEntityGroupSharingPropertiesMETA as the address of a raw
 * XrSystemSpatialEntityGroupSharingPropertiesMETA
 * @relates SystemSpatialEntityGroupSharingPropertiesMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSystemSpatialEntityGroupSharingPropertiesMETA* put(
    SystemSpatialEntityGroupSharingPropertiesMETA& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_spatial_entity_group_sharing

#ifdef XR_META_spatial_entity_group_sharing
/*!
 * C++ projection of XrShareSpacesRecipientGroupsMETA
 *
 * Provided by the `XR_META_spatial_entity_group_sharing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrShareSpacesRecipientGroupsMETA>
 * @xrentity{XrShareSpacesRecipientGroupsMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS ShareSpacesRecipientGroupsMETA : public ShareSpacesRecipientBaseHeaderMETA {
private:
  using Parent = ShareSpacesRecipientBaseHeaderMETA;

public:
  //! Constructor initializing all members.
  ShareSpacesRecipientGroupsMETA(uint32_t groupCount_, Uuid* groups_, const void* next_ = nullptr)
      : Parent(StructureType::ShareSpacesRecipientGroupsMETA, next_),
        groupCount{groupCount_},
        groups{groups_} {}

  //! Default/empty constructor
  ShareSpacesRecipientGroupsMETA(const void* next_ = nullptr)

      : Parent(StructureType::ShareSpacesRecipientGroupsMETA, next_),
        groupCount{0},
        groups{nullptr} {}

  //! Default copy constructor
  ShareSpacesRecipientGroupsMETA(const ShareSpacesRecipientGroupsMETA& rhs) = default;
  //! Default copy assignment
  ShareSpacesRecipientGroupsMETA& operator=(const ShareSpacesRecipientGroupsMETA& rhs) = default;
  //! Copy construct from raw
  ShareSpacesRecipientGroupsMETA(const XrShareSpacesRecipientGroupsMETA& rhs)
      : ShareSpacesRecipientGroupsMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  ShareSpacesRecipientGroupsMETA& operator=(const XrShareSpacesRecipientGroupsMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrShareSpacesRecipientGroupsMETA&() const {
    return *reinterpret_cast<const XrShareSpacesRecipientGroupsMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrShareSpacesRecipientGroupsMETA&() {
    return *reinterpret_cast<XrShareSpacesRecipientGroupsMETA*>(this);
  }

  //! Accessor for this as a raw, base XrShareSpacesRecipientBaseHeaderMETA const pointer
  XrShareSpacesRecipientBaseHeaderMETA const* get_base() const noexcept {
    return reinterpret_cast<XrShareSpacesRecipientBaseHeaderMETA const*>(this);
  }
  //! Accessor for this as the address of a raw XrShareSpacesRecipientGroupsMETA
  XrShareSpacesRecipientGroupsMETA const* get() const noexcept {
    return reinterpret_cast<XrShareSpacesRecipientGroupsMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrShareSpacesRecipientGroupsMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrShareSpacesRecipientGroupsMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = ShareSpacesRecipientGroupsMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrShareSpacesRecipientGroupsMETA*>(this);
  }
  uint32_t groupCount;
  Uuid* groups;
};
static_assert(sizeof(XrShareSpacesRecipientGroupsMETA) == sizeof(ShareSpacesRecipientGroupsMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrShareSpacesRecipientGroupsMETA pointer to const from a
 * ShareSpacesRecipientGroupsMETA reference to const.
 * @relates ShareSpacesRecipientGroupsMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrShareSpacesRecipientGroupsMETA const* get(
    ShareSpacesRecipientGroupsMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * ShareSpacesRecipientGroupsMETA as the address of a raw XrShareSpacesRecipientGroupsMETA
 * @relates ShareSpacesRecipientGroupsMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrShareSpacesRecipientGroupsMETA* put(ShareSpacesRecipientGroupsMETA& s,
                                                               bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const ShareSpacesRecipientGroupsMETA as a raw,
 * pointer to const XrShareSpacesRecipientBaseHeaderMETA (the base type)
 * @relates ShareSpacesRecipientGroupsMETA
 * @relatesalso ShareSpacesRecipientBaseHeaderMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrShareSpacesRecipientBaseHeaderMETA const* get_base(
    ShareSpacesRecipientGroupsMETA const& h) {
  return h.get_base();
}
#endif  // XR_META_spatial_entity_group_sharing

#ifdef XR_META_spatial_entity_group_sharing
/*!
 * C++ projection of XrSpaceGroupUuidFilterInfoMETA
 *
 * Provided by the `XR_META_spatial_entity_group_sharing` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceGroupUuidFilterInfoMETA>
 * @xrentity{XrSpaceGroupUuidFilterInfoMETA}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpaceGroupUuidFilterInfoMETA : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpaceGroupUuidFilterInfoMETA(const Uuid& groupUuid_, const void* next_ = nullptr)
      : Parent(StructureType::SpaceGroupUuidFilterInfoMETA, next_), groupUuid{groupUuid_} {}

  //! Default/empty constructor
  SpaceGroupUuidFilterInfoMETA(const void* next_ = nullptr)

      : Parent(StructureType::SpaceGroupUuidFilterInfoMETA, next_), groupUuid{} {}

  //! Default copy constructor
  SpaceGroupUuidFilterInfoMETA(const SpaceGroupUuidFilterInfoMETA& rhs) = default;
  //! Default copy assignment
  SpaceGroupUuidFilterInfoMETA& operator=(const SpaceGroupUuidFilterInfoMETA& rhs) = default;
  //! Copy construct from raw
  SpaceGroupUuidFilterInfoMETA(const XrSpaceGroupUuidFilterInfoMETA& rhs)
      : SpaceGroupUuidFilterInfoMETA() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpaceGroupUuidFilterInfoMETA& operator=(const XrSpaceGroupUuidFilterInfoMETA& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpaceGroupUuidFilterInfoMETA&() const {
    return *reinterpret_cast<const XrSpaceGroupUuidFilterInfoMETA*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpaceGroupUuidFilterInfoMETA&() {
    return *reinterpret_cast<XrSpaceGroupUuidFilterInfoMETA*>(this);
  }

  //! Accessor for this as the address of a raw XrSpaceGroupUuidFilterInfoMETA
  XrSpaceGroupUuidFilterInfoMETA const* get() const noexcept {
    return reinterpret_cast<XrSpaceGroupUuidFilterInfoMETA const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpaceGroupUuidFilterInfoMETA.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpaceGroupUuidFilterInfoMETA* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpaceGroupUuidFilterInfoMETA{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpaceGroupUuidFilterInfoMETA*>(this);
  }
  Uuid groupUuid;
};
static_assert(sizeof(XrSpaceGroupUuidFilterInfoMETA) == sizeof(SpaceGroupUuidFilterInfoMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpaceGroupUuidFilterInfoMETA pointer to const from a
 * SpaceGroupUuidFilterInfoMETA reference to const.
 * @relates SpaceGroupUuidFilterInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceGroupUuidFilterInfoMETA const* get(
    SpaceGroupUuidFilterInfoMETA const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpaceGroupUuidFilterInfoMETA
 * as the address of a raw XrSpaceGroupUuidFilterInfoMETA
 * @relates SpaceGroupUuidFilterInfoMETA
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpaceGroupUuidFilterInfoMETA* put(SpaceGroupUuidFilterInfoMETA& s,
                                                             bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_META_spatial_entity_group_sharing

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialCapabilityComponentTypesEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialCapabilityComponentTypesEXT>
 * @xrentity{XrSpatialCapabilityComponentTypesEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialCapabilityComponentTypesEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialCapabilityComponentTypesEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialCapabilityComponentTypesEXT, next_) {}

  //! Default copy constructor
  SpatialCapabilityComponentTypesEXT(const SpatialCapabilityComponentTypesEXT& rhs) = default;
  //! Default copy assignment
  SpatialCapabilityComponentTypesEXT& operator=(const SpatialCapabilityComponentTypesEXT& rhs) =
      default;
  //! Copy construct from raw
  SpatialCapabilityComponentTypesEXT(const XrSpatialCapabilityComponentTypesEXT& rhs)
      : SpatialCapabilityComponentTypesEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialCapabilityComponentTypesEXT& operator=(const XrSpatialCapabilityComponentTypesEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialCapabilityComponentTypesEXT&() const {
    return *reinterpret_cast<const XrSpatialCapabilityComponentTypesEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialCapabilityComponentTypesEXT&() {
    return *reinterpret_cast<XrSpatialCapabilityComponentTypesEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialCapabilityComponentTypesEXT
  XrSpatialCapabilityComponentTypesEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityComponentTypesEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialCapabilityComponentTypesEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialCapabilityComponentTypesEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialCapabilityComponentTypesEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialCapabilityComponentTypesEXT*>(this);
  }
  uint32_t componentTypeCapacityInput;
  uint32_t componentTypeCountOutput;
  SpatialComponentTypeEXT* componentTypes;
};
static_assert(sizeof(XrSpatialCapabilityComponentTypesEXT) ==
                  sizeof(SpatialCapabilityComponentTypesEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialCapabilityComponentTypesEXT pointer to const from
 * a SpatialCapabilityComponentTypesEXT reference to const.
 * @relates SpatialCapabilityComponentTypesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityComponentTypesEXT const* get(
    SpatialCapabilityComponentTypesEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialCapabilityComponentTypesEXT as the address of a raw XrSpatialCapabilityComponentTypesEXT
 * @relates SpatialCapabilityComponentTypesEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityComponentTypesEXT* put(
    SpatialCapabilityComponentTypesEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialCapabilityConfigurationBaseHeaderEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialCapabilityConfigurationBaseHeaderEXT>
 * @xrentity{XrSpatialCapabilityConfigurationBaseHeaderEXT}
 * @ingroup abstracttypedstructs
 */
struct XR_MAY_ALIAS SpatialCapabilityConfigurationBaseHeaderEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

protected:
  //! Protected constructor: this type is abstract.
  SpatialCapabilityConfigurationBaseHeaderEXT(StructureType type_,
                                              const SpatialCapabilityEXT& capability_,
                                              uint32_t enabledComponentCount_,
                                              const SpatialComponentTypeEXT* enabledComponents_,
                                              const void* next_ = nullptr)
      : Parent(type_, next_),
        capability{capability_},
        enabledComponentCount{enabledComponentCount_},
        enabledComponents{enabledComponents_} {}

public:
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialCapabilityConfigurationBaseHeaderEXT&() const {
    return *reinterpret_cast<const XrSpatialCapabilityConfigurationBaseHeaderEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialCapabilityConfigurationBaseHeaderEXT&() {
    return *reinterpret_cast<XrSpatialCapabilityConfigurationBaseHeaderEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialCapabilityConfigurationBaseHeaderEXT
  XrSpatialCapabilityConfigurationBaseHeaderEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationBaseHeaderEXT const*>(this);
  }

  /*!
   * @brief Accessor for passing this as the address of a raw
   * XrSpatialCapabilityConfigurationBaseHeaderEXT.
   *
   * The optional clear argument is not used in this abstract class
   */
  XrSpatialCapabilityConfigurationBaseHeaderEXT* put([[maybe_unused]] bool clear = true) noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationBaseHeaderEXT*>(this);
  }
  SpatialCapabilityEXT capability;
  uint32_t enabledComponentCount;
  const SpatialComponentTypeEXT* enabledComponents;
};
static_assert(sizeof(XrSpatialCapabilityConfigurationBaseHeaderEXT) ==
                  sizeof(SpatialCapabilityConfigurationBaseHeaderEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialCapabilityConfigurationBaseHeaderEXT pointer to
 * const from a SpatialCapabilityConfigurationBaseHeaderEXT reference to const.
 * @relates SpatialCapabilityConfigurationBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationBaseHeaderEXT const* get(
    SpatialCapabilityConfigurationBaseHeaderEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialCapabilityConfigurationBaseHeaderEXT as the address of a raw
 * XrSpatialCapabilityConfigurationBaseHeaderEXT
 * @relates SpatialCapabilityConfigurationBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationBaseHeaderEXT* put(
    SpatialCapabilityConfigurationBaseHeaderEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialContextCreateInfoEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialContextCreateInfoEXT>
 * @xrentity{XrSpatialContextCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialContextCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialContextCreateInfoEXT(
      uint32_t capabilityConfigCount_,
      const SpatialCapabilityConfigurationBaseHeaderEXT* const* capabilityConfigs_,
      const void* next_ = nullptr)
      : Parent(StructureType::SpatialContextCreateInfoEXT, next_),
        capabilityConfigCount{capabilityConfigCount_},
        capabilityConfigs{capabilityConfigs_} {}

  //! Default/empty constructor
  SpatialContextCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialContextCreateInfoEXT, next_),
        capabilityConfigCount{0},
        capabilityConfigs{nullptr} {}

  //! Default copy constructor
  SpatialContextCreateInfoEXT(const SpatialContextCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  SpatialContextCreateInfoEXT& operator=(const SpatialContextCreateInfoEXT& rhs) = default;
  //! Copy construct from raw
  SpatialContextCreateInfoEXT(const XrSpatialContextCreateInfoEXT& rhs)
      : SpatialContextCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialContextCreateInfoEXT& operator=(const XrSpatialContextCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialContextCreateInfoEXT&() const {
    return *reinterpret_cast<const XrSpatialContextCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialContextCreateInfoEXT&() {
    return *reinterpret_cast<XrSpatialContextCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialContextCreateInfoEXT
  XrSpatialContextCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialContextCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialContextCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialContextCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialContextCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialContextCreateInfoEXT*>(this);
  }
  uint32_t capabilityConfigCount;
  const SpatialCapabilityConfigurationBaseHeaderEXT* const* capabilityConfigs;
};
static_assert(sizeof(XrSpatialContextCreateInfoEXT) == sizeof(SpatialContextCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialContextCreateInfoEXT pointer to const from a
 * SpatialContextCreateInfoEXT reference to const.
 * @relates SpatialContextCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialContextCreateInfoEXT const* get(
    SpatialContextCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialContextCreateInfoEXT
 * as the address of a raw XrSpatialContextCreateInfoEXT
 * @relates SpatialContextCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialContextCreateInfoEXT* put(SpatialContextCreateInfoEXT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrCreateSpatialContextCompletionEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCreateSpatialContextCompletionEXT>
 * @xrentity{XrCreateSpatialContextCompletionEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CreateSpatialContextCompletionEXT : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  CreateSpatialContextCompletionEXT(void* next_ = nullptr)

      : Parent(StructureType::CreateSpatialContextCompletionEXT, {}, next_) {}

  //! Default copy constructor
  CreateSpatialContextCompletionEXT(const CreateSpatialContextCompletionEXT& rhs) = default;
  //! Default copy assignment
  CreateSpatialContextCompletionEXT& operator=(const CreateSpatialContextCompletionEXT& rhs) =
      default;
  //! Copy construct from raw
  CreateSpatialContextCompletionEXT(const XrCreateSpatialContextCompletionEXT& rhs)
      : CreateSpatialContextCompletionEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CreateSpatialContextCompletionEXT& operator=(const XrCreateSpatialContextCompletionEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCreateSpatialContextCompletionEXT&() const {
    return *reinterpret_cast<const XrCreateSpatialContextCompletionEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCreateSpatialContextCompletionEXT&() {
    return *reinterpret_cast<XrCreateSpatialContextCompletionEXT*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrCreateSpatialContextCompletionEXT
  XrCreateSpatialContextCompletionEXT const* get() const noexcept {
    return reinterpret_cast<XrCreateSpatialContextCompletionEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCreateSpatialContextCompletionEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCreateSpatialContextCompletionEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CreateSpatialContextCompletionEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrCreateSpatialContextCompletionEXT*>(this);
  }
  SpatialContextEXT spatialContext;
};
static_assert(sizeof(XrCreateSpatialContextCompletionEXT) ==
                  sizeof(CreateSpatialContextCompletionEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCreateSpatialContextCompletionEXT pointer to const from
 * a CreateSpatialContextCompletionEXT reference to const.
 * @relates CreateSpatialContextCompletionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCreateSpatialContextCompletionEXT const* get(
    CreateSpatialContextCompletionEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CreateSpatialContextCompletionEXT as the address of a raw XrCreateSpatialContextCompletionEXT
 * @relates CreateSpatialContextCompletionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCreateSpatialContextCompletionEXT* put(
    CreateSpatialContextCompletionEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const CreateSpatialContextCompletionEXT as a
 * raw, pointer to const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates CreateSpatialContextCompletionEXT
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    CreateSpatialContextCompletionEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialDiscoverySnapshotCreateInfoEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialDiscoverySnapshotCreateInfoEXT>
 * @xrentity{XrSpatialDiscoverySnapshotCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialDiscoverySnapshotCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialDiscoverySnapshotCreateInfoEXT(uint32_t componentTypeCount_,
                                        const SpatialComponentTypeEXT* componentTypes_,
                                        const void* next_ = nullptr)
      : Parent(StructureType::SpatialDiscoverySnapshotCreateInfoEXT, next_),
        componentTypeCount{componentTypeCount_},
        componentTypes{componentTypes_} {}

  //! Default/empty constructor
  SpatialDiscoverySnapshotCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialDiscoverySnapshotCreateInfoEXT, next_),
        componentTypeCount{0},
        componentTypes{nullptr} {}

  //! Default copy constructor
  SpatialDiscoverySnapshotCreateInfoEXT(const SpatialDiscoverySnapshotCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  SpatialDiscoverySnapshotCreateInfoEXT& operator=(
      const SpatialDiscoverySnapshotCreateInfoEXT& rhs) = default;
  //! Copy construct from raw
  SpatialDiscoverySnapshotCreateInfoEXT(const XrSpatialDiscoverySnapshotCreateInfoEXT& rhs)
      : SpatialDiscoverySnapshotCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialDiscoverySnapshotCreateInfoEXT& operator=(
      const XrSpatialDiscoverySnapshotCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialDiscoverySnapshotCreateInfoEXT&() const {
    return *reinterpret_cast<const XrSpatialDiscoverySnapshotCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialDiscoverySnapshotCreateInfoEXT&() {
    return *reinterpret_cast<XrSpatialDiscoverySnapshotCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialDiscoverySnapshotCreateInfoEXT
  XrSpatialDiscoverySnapshotCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialDiscoverySnapshotCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialDiscoverySnapshotCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialDiscoverySnapshotCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialDiscoverySnapshotCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialDiscoverySnapshotCreateInfoEXT*>(this);
  }
  uint32_t componentTypeCount;
  const SpatialComponentTypeEXT* componentTypes;
};
static_assert(sizeof(XrSpatialDiscoverySnapshotCreateInfoEXT) ==
                  sizeof(SpatialDiscoverySnapshotCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialDiscoverySnapshotCreateInfoEXT pointer to const
 * from a SpatialDiscoverySnapshotCreateInfoEXT reference to const.
 * @relates SpatialDiscoverySnapshotCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialDiscoverySnapshotCreateInfoEXT const* get(
    SpatialDiscoverySnapshotCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialDiscoverySnapshotCreateInfoEXT as the address of a raw
 * XrSpatialDiscoverySnapshotCreateInfoEXT
 * @relates SpatialDiscoverySnapshotCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialDiscoverySnapshotCreateInfoEXT* put(
    SpatialDiscoverySnapshotCreateInfoEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrCreateSpatialDiscoverySnapshotCompletionInfoEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCreateSpatialDiscoverySnapshotCompletionInfoEXT>
 * @xrentity{XrCreateSpatialDiscoverySnapshotCompletionInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CreateSpatialDiscoverySnapshotCompletionInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  CreateSpatialDiscoverySnapshotCompletionInfoEXT(const Space& baseSpace_, const Time& time_,
                                                  const FutureEXT& future_,
                                                  const void* next_ = nullptr)
      : Parent(StructureType::CreateSpatialDiscoverySnapshotCompletionInfoEXT, next_),
        baseSpace{baseSpace_},
        time{time_},
        future{future_} {}

  //! Default/empty constructor
  CreateSpatialDiscoverySnapshotCompletionInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::CreateSpatialDiscoverySnapshotCompletionInfoEXT, next_),
        baseSpace{},
        time{},
        future{} {}

  //! Default copy constructor
  CreateSpatialDiscoverySnapshotCompletionInfoEXT(
      const CreateSpatialDiscoverySnapshotCompletionInfoEXT& rhs) = default;
  //! Default copy assignment
  CreateSpatialDiscoverySnapshotCompletionInfoEXT& operator=(
      const CreateSpatialDiscoverySnapshotCompletionInfoEXT& rhs) = default;
  //! Copy construct from raw
  CreateSpatialDiscoverySnapshotCompletionInfoEXT(
      const XrCreateSpatialDiscoverySnapshotCompletionInfoEXT& rhs)
      : CreateSpatialDiscoverySnapshotCompletionInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CreateSpatialDiscoverySnapshotCompletionInfoEXT& operator=(
      const XrCreateSpatialDiscoverySnapshotCompletionInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCreateSpatialDiscoverySnapshotCompletionInfoEXT&() const {
    return *reinterpret_cast<const XrCreateSpatialDiscoverySnapshotCompletionInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCreateSpatialDiscoverySnapshotCompletionInfoEXT&() {
    return *reinterpret_cast<XrCreateSpatialDiscoverySnapshotCompletionInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrCreateSpatialDiscoverySnapshotCompletionInfoEXT
  XrCreateSpatialDiscoverySnapshotCompletionInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrCreateSpatialDiscoverySnapshotCompletionInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCreateSpatialDiscoverySnapshotCompletionInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCreateSpatialDiscoverySnapshotCompletionInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CreateSpatialDiscoverySnapshotCompletionInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrCreateSpatialDiscoverySnapshotCompletionInfoEXT*>(this);
  }
  Space baseSpace;
  Time time;
  FutureEXT future;
};
static_assert(sizeof(XrCreateSpatialDiscoverySnapshotCompletionInfoEXT) ==
                  sizeof(CreateSpatialDiscoverySnapshotCompletionInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCreateSpatialDiscoverySnapshotCompletionInfoEXT pointer
 * to const from a CreateSpatialDiscoverySnapshotCompletionInfoEXT reference to const.
 * @relates CreateSpatialDiscoverySnapshotCompletionInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCreateSpatialDiscoverySnapshotCompletionInfoEXT const* get(
    CreateSpatialDiscoverySnapshotCompletionInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CreateSpatialDiscoverySnapshotCompletionInfoEXT as the address of a raw
 * XrCreateSpatialDiscoverySnapshotCompletionInfoEXT
 * @relates CreateSpatialDiscoverySnapshotCompletionInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCreateSpatialDiscoverySnapshotCompletionInfoEXT* put(
    CreateSpatialDiscoverySnapshotCompletionInfoEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrCreateSpatialDiscoverySnapshotCompletionEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCreateSpatialDiscoverySnapshotCompletionEXT>
 * @xrentity{XrCreateSpatialDiscoverySnapshotCompletionEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CreateSpatialDiscoverySnapshotCompletionEXT
    : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  CreateSpatialDiscoverySnapshotCompletionEXT(void* next_ = nullptr)

      : Parent(StructureType::CreateSpatialDiscoverySnapshotCompletionEXT, {}, next_) {}

  //! Default copy constructor
  CreateSpatialDiscoverySnapshotCompletionEXT(
      const CreateSpatialDiscoverySnapshotCompletionEXT& rhs) = default;
  //! Default copy assignment
  CreateSpatialDiscoverySnapshotCompletionEXT& operator=(
      const CreateSpatialDiscoverySnapshotCompletionEXT& rhs) = default;
  //! Copy construct from raw
  CreateSpatialDiscoverySnapshotCompletionEXT(
      const XrCreateSpatialDiscoverySnapshotCompletionEXT& rhs)
      : CreateSpatialDiscoverySnapshotCompletionEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CreateSpatialDiscoverySnapshotCompletionEXT& operator=(
      const XrCreateSpatialDiscoverySnapshotCompletionEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCreateSpatialDiscoverySnapshotCompletionEXT&() const {
    return *reinterpret_cast<const XrCreateSpatialDiscoverySnapshotCompletionEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCreateSpatialDiscoverySnapshotCompletionEXT&() {
    return *reinterpret_cast<XrCreateSpatialDiscoverySnapshotCompletionEXT*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrCreateSpatialDiscoverySnapshotCompletionEXT
  XrCreateSpatialDiscoverySnapshotCompletionEXT const* get() const noexcept {
    return reinterpret_cast<XrCreateSpatialDiscoverySnapshotCompletionEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCreateSpatialDiscoverySnapshotCompletionEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCreateSpatialDiscoverySnapshotCompletionEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CreateSpatialDiscoverySnapshotCompletionEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrCreateSpatialDiscoverySnapshotCompletionEXT*>(this);
  }
  SpatialSnapshotEXT snapshot;
};
static_assert(sizeof(XrCreateSpatialDiscoverySnapshotCompletionEXT) ==
                  sizeof(CreateSpatialDiscoverySnapshotCompletionEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCreateSpatialDiscoverySnapshotCompletionEXT pointer to
 * const from a CreateSpatialDiscoverySnapshotCompletionEXT reference to const.
 * @relates CreateSpatialDiscoverySnapshotCompletionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCreateSpatialDiscoverySnapshotCompletionEXT const* get(
    CreateSpatialDiscoverySnapshotCompletionEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CreateSpatialDiscoverySnapshotCompletionEXT as the address of a raw
 * XrCreateSpatialDiscoverySnapshotCompletionEXT
 * @relates CreateSpatialDiscoverySnapshotCompletionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCreateSpatialDiscoverySnapshotCompletionEXT* put(
    CreateSpatialDiscoverySnapshotCompletionEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const
 * CreateSpatialDiscoverySnapshotCompletionEXT as a raw, pointer to const
 * XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates CreateSpatialDiscoverySnapshotCompletionEXT
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    CreateSpatialDiscoverySnapshotCompletionEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialComponentDataQueryConditionEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentDataQueryConditionEXT>
 * @xrentity{XrSpatialComponentDataQueryConditionEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentDataQueryConditionEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialComponentDataQueryConditionEXT(uint32_t componentTypeCount_,
                                        const SpatialComponentTypeEXT* componentTypes_,
                                        const void* next_ = nullptr)
      : Parent(StructureType::SpatialComponentDataQueryConditionEXT, next_),
        componentTypeCount{componentTypeCount_},
        componentTypes{componentTypes_} {}

  //! Default/empty constructor
  SpatialComponentDataQueryConditionEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentDataQueryConditionEXT, next_),
        componentTypeCount{0},
        componentTypes{nullptr} {}

  //! Default copy constructor
  SpatialComponentDataQueryConditionEXT(const SpatialComponentDataQueryConditionEXT& rhs) = default;
  //! Default copy assignment
  SpatialComponentDataQueryConditionEXT& operator=(
      const SpatialComponentDataQueryConditionEXT& rhs) = default;
  //! Copy construct from raw
  SpatialComponentDataQueryConditionEXT(const XrSpatialComponentDataQueryConditionEXT& rhs)
      : SpatialComponentDataQueryConditionEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentDataQueryConditionEXT& operator=(
      const XrSpatialComponentDataQueryConditionEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentDataQueryConditionEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentDataQueryConditionEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentDataQueryConditionEXT&() {
    return *reinterpret_cast<XrSpatialComponentDataQueryConditionEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentDataQueryConditionEXT
  XrSpatialComponentDataQueryConditionEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentDataQueryConditionEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentDataQueryConditionEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentDataQueryConditionEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentDataQueryConditionEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentDataQueryConditionEXT*>(this);
  }
  uint32_t componentTypeCount;
  const SpatialComponentTypeEXT* componentTypes;
};
static_assert(sizeof(XrSpatialComponentDataQueryConditionEXT) ==
                  sizeof(SpatialComponentDataQueryConditionEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentDataQueryConditionEXT pointer to const
 * from a SpatialComponentDataQueryConditionEXT reference to const.
 * @relates SpatialComponentDataQueryConditionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentDataQueryConditionEXT const* get(
    SpatialComponentDataQueryConditionEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialComponentDataQueryConditionEXT as the address of a raw
 * XrSpatialComponentDataQueryConditionEXT
 * @relates SpatialComponentDataQueryConditionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentDataQueryConditionEXT* put(
    SpatialComponentDataQueryConditionEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialComponentDataQueryResultEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentDataQueryResultEXT>
 * @xrentity{XrSpatialComponentDataQueryResultEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentDataQueryResultEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialComponentDataQueryResultEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentDataQueryResultEXT, next_) {}

  //! Default copy constructor
  SpatialComponentDataQueryResultEXT(const SpatialComponentDataQueryResultEXT& rhs) = default;
  //! Default copy assignment
  SpatialComponentDataQueryResultEXT& operator=(const SpatialComponentDataQueryResultEXT& rhs) =
      default;
  //! Copy construct from raw
  SpatialComponentDataQueryResultEXT(const XrSpatialComponentDataQueryResultEXT& rhs)
      : SpatialComponentDataQueryResultEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentDataQueryResultEXT& operator=(const XrSpatialComponentDataQueryResultEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentDataQueryResultEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentDataQueryResultEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentDataQueryResultEXT&() {
    return *reinterpret_cast<XrSpatialComponentDataQueryResultEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentDataQueryResultEXT
  XrSpatialComponentDataQueryResultEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentDataQueryResultEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentDataQueryResultEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentDataQueryResultEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentDataQueryResultEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentDataQueryResultEXT*>(this);
  }
  uint32_t entityIdCapacityInput;
  uint32_t entityIdCountOutput;
  SpatialEntityIdEXT* entityIds;
  uint32_t entityStateCapacityInput;
  uint32_t entityStateCountOutput;
  SpatialEntityTrackingStateEXT* entityStates;
};
static_assert(sizeof(XrSpatialComponentDataQueryResultEXT) ==
                  sizeof(SpatialComponentDataQueryResultEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentDataQueryResultEXT pointer to const from
 * a SpatialComponentDataQueryResultEXT reference to const.
 * @relates SpatialComponentDataQueryResultEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentDataQueryResultEXT const* get(
    SpatialComponentDataQueryResultEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialComponentDataQueryResultEXT as the address of a raw XrSpatialComponentDataQueryResultEXT
 * @relates SpatialComponentDataQueryResultEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentDataQueryResultEXT* put(
    SpatialComponentDataQueryResultEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialBufferEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialBufferEXT>
 * @xrentity{XrSpatialBufferEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpatialBufferEXT {
public:
  //! Constructor initializing all members.
  SpatialBufferEXT(const SpatialBufferIdEXT& bufferId_, const SpatialBufferTypeEXT& bufferType_)
      : bufferId{bufferId_}, bufferType{bufferType_} {}

  //! Default/empty constructor
  SpatialBufferEXT()

      : bufferId{}, bufferType{} {}

  //! Default copy constructor
  SpatialBufferEXT(const SpatialBufferEXT& rhs) = default;
  //! Default copy assignment
  SpatialBufferEXT& operator=(const SpatialBufferEXT& rhs) = default;
  //! Copy construct from raw
  SpatialBufferEXT(const XrSpatialBufferEXT& rhs) : SpatialBufferEXT() { *put() = rhs; }
  //! Copy assign from raw
  SpatialBufferEXT& operator=(const XrSpatialBufferEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialBufferEXT&() const {
    return *reinterpret_cast<const XrSpatialBufferEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialBufferEXT&() { return *reinterpret_cast<XrSpatialBufferEXT*>(this); }

  //! Accessor for this as the address of a raw XrSpatialBufferEXT
  XrSpatialBufferEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialBufferEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpatialBufferEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpatialBufferEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpatialBufferEXT{};
    }
    return reinterpret_cast<XrSpatialBufferEXT*>(this);
  }
  SpatialBufferIdEXT bufferId;
  SpatialBufferTypeEXT bufferType;
};
static_assert(sizeof(XrSpatialBufferEXT) == sizeof(SpatialBufferEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialBufferEXT pointer to const from a
 * SpatialBufferEXT reference to const.
 * @relates SpatialBufferEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialBufferEXT const* get(SpatialBufferEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialBufferEXT as the
 * address of a raw XrSpatialBufferEXT
 * @relates SpatialBufferEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialBufferEXT* put(SpatialBufferEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialBufferGetInfoEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialBufferGetInfoEXT>
 * @xrentity{XrSpatialBufferGetInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialBufferGetInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialBufferGetInfoEXT(const SpatialBufferIdEXT& bufferId_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialBufferGetInfoEXT, next_), bufferId{bufferId_} {}

  //! Default/empty constructor
  SpatialBufferGetInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialBufferGetInfoEXT, next_), bufferId{} {}

  //! Default copy constructor
  SpatialBufferGetInfoEXT(const SpatialBufferGetInfoEXT& rhs) = default;
  //! Default copy assignment
  SpatialBufferGetInfoEXT& operator=(const SpatialBufferGetInfoEXT& rhs) = default;
  //! Copy construct from raw
  SpatialBufferGetInfoEXT(const XrSpatialBufferGetInfoEXT& rhs) : SpatialBufferGetInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialBufferGetInfoEXT& operator=(const XrSpatialBufferGetInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialBufferGetInfoEXT&() const {
    return *reinterpret_cast<const XrSpatialBufferGetInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialBufferGetInfoEXT&() {
    return *reinterpret_cast<XrSpatialBufferGetInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialBufferGetInfoEXT
  XrSpatialBufferGetInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialBufferGetInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialBufferGetInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialBufferGetInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialBufferGetInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialBufferGetInfoEXT*>(this);
  }
  SpatialBufferIdEXT bufferId;
};
static_assert(sizeof(XrSpatialBufferGetInfoEXT) == sizeof(SpatialBufferGetInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialBufferGetInfoEXT pointer to const from a
 * SpatialBufferGetInfoEXT reference to const.
 * @relates SpatialBufferGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialBufferGetInfoEXT const* get(SpatialBufferGetInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialBufferGetInfoEXT as
 * the address of a raw XrSpatialBufferGetInfoEXT
 * @relates SpatialBufferGetInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialBufferGetInfoEXT* put(SpatialBufferGetInfoEXT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialBounded2DDataEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialBounded2DDataEXT>
 * @xrentity{XrSpatialBounded2DDataEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpatialBounded2DDataEXT {
public:
  //! Constructor initializing all members.
  SpatialBounded2DDataEXT(const Posef& center_, const Extent2Df& extents_)
      : center{center_}, extents{extents_} {}

  //! Default/empty constructor
  SpatialBounded2DDataEXT()

      : center{}, extents{} {}

  //! Default copy constructor
  SpatialBounded2DDataEXT(const SpatialBounded2DDataEXT& rhs) = default;
  //! Default copy assignment
  SpatialBounded2DDataEXT& operator=(const SpatialBounded2DDataEXT& rhs) = default;
  //! Copy construct from raw
  SpatialBounded2DDataEXT(const XrSpatialBounded2DDataEXT& rhs) : SpatialBounded2DDataEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialBounded2DDataEXT& operator=(const XrSpatialBounded2DDataEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialBounded2DDataEXT&() const {
    return *reinterpret_cast<const XrSpatialBounded2DDataEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialBounded2DDataEXT&() {
    return *reinterpret_cast<XrSpatialBounded2DDataEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialBounded2DDataEXT
  XrSpatialBounded2DDataEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialBounded2DDataEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialBounded2DDataEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpatialBounded2DDataEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpatialBounded2DDataEXT{};
    }
    return reinterpret_cast<XrSpatialBounded2DDataEXT*>(this);
  }
  Posef center;
  Extent2Df extents;
};
static_assert(sizeof(XrSpatialBounded2DDataEXT) == sizeof(SpatialBounded2DDataEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialBounded2DDataEXT pointer to const from a
 * SpatialBounded2DDataEXT reference to const.
 * @relates SpatialBounded2DDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialBounded2DDataEXT const* get(SpatialBounded2DDataEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialBounded2DDataEXT as
 * the address of a raw XrSpatialBounded2DDataEXT
 * @relates SpatialBounded2DDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialBounded2DDataEXT* put(SpatialBounded2DDataEXT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialComponentBounded2DListEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentBounded2DListEXT>
 * @xrentity{XrSpatialComponentBounded2DListEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentBounded2DListEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialComponentBounded2DListEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentBounded2DListEXT, next_) {}

  //! Default copy constructor
  SpatialComponentBounded2DListEXT(const SpatialComponentBounded2DListEXT& rhs) = default;
  //! Default copy assignment
  SpatialComponentBounded2DListEXT& operator=(const SpatialComponentBounded2DListEXT& rhs) =
      default;
  //! Copy construct from raw
  SpatialComponentBounded2DListEXT(const XrSpatialComponentBounded2DListEXT& rhs)
      : SpatialComponentBounded2DListEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentBounded2DListEXT& operator=(const XrSpatialComponentBounded2DListEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentBounded2DListEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentBounded2DListEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentBounded2DListEXT&() {
    return *reinterpret_cast<XrSpatialComponentBounded2DListEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentBounded2DListEXT
  XrSpatialComponentBounded2DListEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentBounded2DListEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentBounded2DListEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentBounded2DListEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentBounded2DListEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentBounded2DListEXT*>(this);
  }
  uint32_t boundCount;
  SpatialBounded2DDataEXT* bounds;
};
static_assert(sizeof(XrSpatialComponentBounded2DListEXT) ==
                  sizeof(SpatialComponentBounded2DListEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentBounded2DListEXT pointer to const from a
 * SpatialComponentBounded2DListEXT reference to const.
 * @relates SpatialComponentBounded2DListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentBounded2DListEXT const* get(
    SpatialComponentBounded2DListEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialComponentBounded2DListEXT as the address of a raw XrSpatialComponentBounded2DListEXT
 * @relates SpatialComponentBounded2DListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentBounded2DListEXT* put(
    SpatialComponentBounded2DListEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialComponentBounded3DListEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentBounded3DListEXT>
 * @xrentity{XrSpatialComponentBounded3DListEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentBounded3DListEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialComponentBounded3DListEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentBounded3DListEXT, next_) {}

  //! Default copy constructor
  SpatialComponentBounded3DListEXT(const SpatialComponentBounded3DListEXT& rhs) = default;
  //! Default copy assignment
  SpatialComponentBounded3DListEXT& operator=(const SpatialComponentBounded3DListEXT& rhs) =
      default;
  //! Copy construct from raw
  SpatialComponentBounded3DListEXT(const XrSpatialComponentBounded3DListEXT& rhs)
      : SpatialComponentBounded3DListEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentBounded3DListEXT& operator=(const XrSpatialComponentBounded3DListEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentBounded3DListEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentBounded3DListEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentBounded3DListEXT&() {
    return *reinterpret_cast<XrSpatialComponentBounded3DListEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentBounded3DListEXT
  XrSpatialComponentBounded3DListEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentBounded3DListEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentBounded3DListEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentBounded3DListEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentBounded3DListEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentBounded3DListEXT*>(this);
  }
  uint32_t boundCount;
  Boxf* bounds;
};
static_assert(sizeof(XrSpatialComponentBounded3DListEXT) ==
                  sizeof(SpatialComponentBounded3DListEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentBounded3DListEXT pointer to const from a
 * SpatialComponentBounded3DListEXT reference to const.
 * @relates SpatialComponentBounded3DListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentBounded3DListEXT const* get(
    SpatialComponentBounded3DListEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialComponentBounded3DListEXT as the address of a raw XrSpatialComponentBounded3DListEXT
 * @relates SpatialComponentBounded3DListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentBounded3DListEXT* put(
    SpatialComponentBounded3DListEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialComponentParentListEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentParentListEXT>
 * @xrentity{XrSpatialComponentParentListEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentParentListEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialComponentParentListEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentParentListEXT, next_) {}

  //! Default copy constructor
  SpatialComponentParentListEXT(const SpatialComponentParentListEXT& rhs) = default;
  //! Default copy assignment
  SpatialComponentParentListEXT& operator=(const SpatialComponentParentListEXT& rhs) = default;
  //! Copy construct from raw
  SpatialComponentParentListEXT(const XrSpatialComponentParentListEXT& rhs)
      : SpatialComponentParentListEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentParentListEXT& operator=(const XrSpatialComponentParentListEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentParentListEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentParentListEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentParentListEXT&() {
    return *reinterpret_cast<XrSpatialComponentParentListEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentParentListEXT
  XrSpatialComponentParentListEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentParentListEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentParentListEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentParentListEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentParentListEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentParentListEXT*>(this);
  }
  uint32_t parentCount;
  SpatialEntityIdEXT* parents;
};
static_assert(sizeof(XrSpatialComponentParentListEXT) == sizeof(SpatialComponentParentListEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentParentListEXT pointer to const from a
 * SpatialComponentParentListEXT reference to const.
 * @relates SpatialComponentParentListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentParentListEXT const* get(
    SpatialComponentParentListEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialComponentParentListEXT
 * as the address of a raw XrSpatialComponentParentListEXT
 * @relates SpatialComponentParentListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentParentListEXT* put(SpatialComponentParentListEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialMeshDataEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialMeshDataEXT>
 * @xrentity{XrSpatialMeshDataEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpatialMeshDataEXT {
public:
  //! Constructor initializing all members.
  SpatialMeshDataEXT(const Posef& origin_, const SpatialBufferEXT& vertexBuffer_,
                     const SpatialBufferEXT& indexBuffer_)
      : origin{origin_}, vertexBuffer{vertexBuffer_}, indexBuffer{indexBuffer_} {}

  //! Default/empty constructor
  SpatialMeshDataEXT()

      : origin{}, vertexBuffer{}, indexBuffer{} {}

  //! Default copy constructor
  SpatialMeshDataEXT(const SpatialMeshDataEXT& rhs) = default;
  //! Default copy assignment
  SpatialMeshDataEXT& operator=(const SpatialMeshDataEXT& rhs) = default;
  //! Copy construct from raw
  SpatialMeshDataEXT(const XrSpatialMeshDataEXT& rhs) : SpatialMeshDataEXT() { *put() = rhs; }
  //! Copy assign from raw
  SpatialMeshDataEXT& operator=(const XrSpatialMeshDataEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialMeshDataEXT&() const {
    return *reinterpret_cast<const XrSpatialMeshDataEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialMeshDataEXT&() { return *reinterpret_cast<XrSpatialMeshDataEXT*>(this); }

  //! Accessor for this as the address of a raw XrSpatialMeshDataEXT
  XrSpatialMeshDataEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialMeshDataEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpatialMeshDataEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpatialMeshDataEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpatialMeshDataEXT{};
    }
    return reinterpret_cast<XrSpatialMeshDataEXT*>(this);
  }
  Posef origin;
  SpatialBufferEXT vertexBuffer;
  SpatialBufferEXT indexBuffer;
};
static_assert(sizeof(XrSpatialMeshDataEXT) == sizeof(SpatialMeshDataEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialMeshDataEXT pointer to const from a
 * SpatialMeshDataEXT reference to const.
 * @relates SpatialMeshDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialMeshDataEXT const* get(SpatialMeshDataEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialMeshDataEXT as the
 * address of a raw XrSpatialMeshDataEXT
 * @relates SpatialMeshDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialMeshDataEXT* put(SpatialMeshDataEXT& s,
                                                   bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialComponentMesh3DListEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentMesh3DListEXT>
 * @xrentity{XrSpatialComponentMesh3DListEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentMesh3DListEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialComponentMesh3DListEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentMesh3DListEXT, next_) {}

  //! Default copy constructor
  SpatialComponentMesh3DListEXT(const SpatialComponentMesh3DListEXT& rhs) = default;
  //! Default copy assignment
  SpatialComponentMesh3DListEXT& operator=(const SpatialComponentMesh3DListEXT& rhs) = default;
  //! Copy construct from raw
  SpatialComponentMesh3DListEXT(const XrSpatialComponentMesh3DListEXT& rhs)
      : SpatialComponentMesh3DListEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentMesh3DListEXT& operator=(const XrSpatialComponentMesh3DListEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentMesh3DListEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentMesh3DListEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentMesh3DListEXT&() {
    return *reinterpret_cast<XrSpatialComponentMesh3DListEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentMesh3DListEXT
  XrSpatialComponentMesh3DListEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentMesh3DListEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentMesh3DListEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentMesh3DListEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentMesh3DListEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentMesh3DListEXT*>(this);
  }
  uint32_t meshCount;
  SpatialMeshDataEXT* meshes;
};
static_assert(sizeof(XrSpatialComponentMesh3DListEXT) == sizeof(SpatialComponentMesh3DListEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentMesh3DListEXT pointer to const from a
 * SpatialComponentMesh3DListEXT reference to const.
 * @relates SpatialComponentMesh3DListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentMesh3DListEXT const* get(
    SpatialComponentMesh3DListEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialComponentMesh3DListEXT
 * as the address of a raw XrSpatialComponentMesh3DListEXT
 * @relates SpatialComponentMesh3DListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentMesh3DListEXT* put(SpatialComponentMesh3DListEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialEntityFromIdCreateInfoEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityFromIdCreateInfoEXT>
 * @xrentity{XrSpatialEntityFromIdCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityFromIdCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialEntityFromIdCreateInfoEXT(const SpatialEntityIdEXT& entityId_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialEntityFromIdCreateInfoEXT, next_), entityId{entityId_} {}

  //! Default/empty constructor
  SpatialEntityFromIdCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityFromIdCreateInfoEXT, next_), entityId{} {}

  //! Default copy constructor
  SpatialEntityFromIdCreateInfoEXT(const SpatialEntityFromIdCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  SpatialEntityFromIdCreateInfoEXT& operator=(const SpatialEntityFromIdCreateInfoEXT& rhs) =
      default;
  //! Copy construct from raw
  SpatialEntityFromIdCreateInfoEXT(const XrSpatialEntityFromIdCreateInfoEXT& rhs)
      : SpatialEntityFromIdCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityFromIdCreateInfoEXT& operator=(const XrSpatialEntityFromIdCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityFromIdCreateInfoEXT&() const {
    return *reinterpret_cast<const XrSpatialEntityFromIdCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityFromIdCreateInfoEXT&() {
    return *reinterpret_cast<XrSpatialEntityFromIdCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityFromIdCreateInfoEXT
  XrSpatialEntityFromIdCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityFromIdCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityFromIdCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityFromIdCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityFromIdCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityFromIdCreateInfoEXT*>(this);
  }
  SpatialEntityIdEXT entityId;
};
static_assert(sizeof(XrSpatialEntityFromIdCreateInfoEXT) ==
                  sizeof(SpatialEntityFromIdCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityFromIdCreateInfoEXT pointer to const from a
 * SpatialEntityFromIdCreateInfoEXT reference to const.
 * @relates SpatialEntityFromIdCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityFromIdCreateInfoEXT const* get(
    SpatialEntityFromIdCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialEntityFromIdCreateInfoEXT as the address of a raw XrSpatialEntityFromIdCreateInfoEXT
 * @relates SpatialEntityFromIdCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityFromIdCreateInfoEXT* put(
    SpatialEntityFromIdCreateInfoEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialUpdateSnapshotCreateInfoEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialUpdateSnapshotCreateInfoEXT>
 * @xrentity{XrSpatialUpdateSnapshotCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialUpdateSnapshotCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialUpdateSnapshotCreateInfoEXT(uint32_t entityCount_, const SpatialEntityEXT* entities_,
                                     uint32_t componentTypeCount_,
                                     const SpatialComponentTypeEXT* componentTypes_,
                                     const Space& baseSpace_, const Time& time_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::SpatialUpdateSnapshotCreateInfoEXT, next_),
        entityCount{entityCount_},
        entities{entities_},
        componentTypeCount{componentTypeCount_},
        componentTypes{componentTypes_},
        baseSpace{baseSpace_},
        time{time_} {}

  //! Default/empty constructor
  SpatialUpdateSnapshotCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialUpdateSnapshotCreateInfoEXT, next_),
        entityCount{0},
        entities{nullptr},
        componentTypeCount{0},
        componentTypes{nullptr},
        baseSpace{},
        time{} {}

  //! Default copy constructor
  SpatialUpdateSnapshotCreateInfoEXT(const SpatialUpdateSnapshotCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  SpatialUpdateSnapshotCreateInfoEXT& operator=(const SpatialUpdateSnapshotCreateInfoEXT& rhs) =
      default;
  //! Copy construct from raw
  SpatialUpdateSnapshotCreateInfoEXT(const XrSpatialUpdateSnapshotCreateInfoEXT& rhs)
      : SpatialUpdateSnapshotCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialUpdateSnapshotCreateInfoEXT& operator=(const XrSpatialUpdateSnapshotCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialUpdateSnapshotCreateInfoEXT&() const {
    return *reinterpret_cast<const XrSpatialUpdateSnapshotCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialUpdateSnapshotCreateInfoEXT&() {
    return *reinterpret_cast<XrSpatialUpdateSnapshotCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialUpdateSnapshotCreateInfoEXT
  XrSpatialUpdateSnapshotCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialUpdateSnapshotCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialUpdateSnapshotCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialUpdateSnapshotCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialUpdateSnapshotCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialUpdateSnapshotCreateInfoEXT*>(this);
  }
  uint32_t entityCount;
  const SpatialEntityEXT* entities;
  uint32_t componentTypeCount;
  const SpatialComponentTypeEXT* componentTypes;
  Space baseSpace;
  Time time;
};
static_assert(sizeof(XrSpatialUpdateSnapshotCreateInfoEXT) ==
                  sizeof(SpatialUpdateSnapshotCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialUpdateSnapshotCreateInfoEXT pointer to const from
 * a SpatialUpdateSnapshotCreateInfoEXT reference to const.
 * @relates SpatialUpdateSnapshotCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialUpdateSnapshotCreateInfoEXT const* get(
    SpatialUpdateSnapshotCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialUpdateSnapshotCreateInfoEXT as the address of a raw XrSpatialUpdateSnapshotCreateInfoEXT
 * @relates SpatialUpdateSnapshotCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialUpdateSnapshotCreateInfoEXT* put(
    SpatialUpdateSnapshotCreateInfoEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrEventDataSpatialDiscoveryRecommendedEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEventDataSpatialDiscoveryRecommendedEXT>
 * @xrentity{XrEventDataSpatialDiscoveryRecommendedEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS EventDataSpatialDiscoveryRecommendedEXT : public EventDataBaseHeader {
private:
  using Parent = EventDataBaseHeader;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  EventDataSpatialDiscoveryRecommendedEXT(void* next_ = nullptr)

      : Parent(StructureType::EventDataSpatialDiscoveryRecommendedEXT, next_) {}

  //! Default copy constructor
  EventDataSpatialDiscoveryRecommendedEXT(const EventDataSpatialDiscoveryRecommendedEXT& rhs) =
      default;
  //! Default copy assignment
  EventDataSpatialDiscoveryRecommendedEXT& operator=(
      const EventDataSpatialDiscoveryRecommendedEXT& rhs) = default;
  //! Copy construct from raw
  EventDataSpatialDiscoveryRecommendedEXT(const XrEventDataSpatialDiscoveryRecommendedEXT& rhs)
      : EventDataSpatialDiscoveryRecommendedEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  EventDataSpatialDiscoveryRecommendedEXT& operator=(
      const XrEventDataSpatialDiscoveryRecommendedEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrEventDataSpatialDiscoveryRecommendedEXT&() const {
    return *reinterpret_cast<const XrEventDataSpatialDiscoveryRecommendedEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrEventDataSpatialDiscoveryRecommendedEXT&() {
    return *reinterpret_cast<XrEventDataSpatialDiscoveryRecommendedEXT*>(this);
  }

  //! Accessor for this as a raw, base XrEventDataBaseHeader const pointer
  XrEventDataBaseHeader const* get_base() const noexcept {
    return reinterpret_cast<XrEventDataBaseHeader const*>(this);
  }
  //! Accessor for this as the address of a raw XrEventDataSpatialDiscoveryRecommendedEXT
  XrEventDataSpatialDiscoveryRecommendedEXT const* get() const noexcept {
    return reinterpret_cast<XrEventDataSpatialDiscoveryRecommendedEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrEventDataSpatialDiscoveryRecommendedEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrEventDataSpatialDiscoveryRecommendedEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = EventDataSpatialDiscoveryRecommendedEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrEventDataSpatialDiscoveryRecommendedEXT*>(this);
  }
  SpatialContextEXT spatialContext;
};
static_assert(sizeof(XrEventDataSpatialDiscoveryRecommendedEXT) ==
                  sizeof(EventDataSpatialDiscoveryRecommendedEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrEventDataSpatialDiscoveryRecommendedEXT pointer to const
 * from a EventDataSpatialDiscoveryRecommendedEXT reference to const.
 * @relates EventDataSpatialDiscoveryRecommendedEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpatialDiscoveryRecommendedEXT const* get(
    EventDataSpatialDiscoveryRecommendedEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * EventDataSpatialDiscoveryRecommendedEXT as the address of a raw
 * XrEventDataSpatialDiscoveryRecommendedEXT
 * @relates EventDataSpatialDiscoveryRecommendedEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataSpatialDiscoveryRecommendedEXT* put(
    EventDataSpatialDiscoveryRecommendedEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const EventDataSpatialDiscoveryRecommendedEXT as
 * a raw, pointer to const XrEventDataBaseHeader (the base type)
 * @relates EventDataSpatialDiscoveryRecommendedEXT
 * @relatesalso EventDataBaseHeader
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrEventDataBaseHeader const* get_base(
    EventDataSpatialDiscoveryRecommendedEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity
/*!
 * C++ projection of XrSpatialFilterTrackingStateEXT
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialFilterTrackingStateEXT>
 * @xrentity{XrSpatialFilterTrackingStateEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialFilterTrackingStateEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialFilterTrackingStateEXT(const SpatialEntityTrackingStateEXT& trackingState_,
                                const void* next_ = nullptr)
      : Parent(StructureType::SpatialFilterTrackingStateEXT, next_),
        trackingState{trackingState_} {}

  //! Default/empty constructor
  SpatialFilterTrackingStateEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialFilterTrackingStateEXT, next_), trackingState{} {}

  //! Default copy constructor
  SpatialFilterTrackingStateEXT(const SpatialFilterTrackingStateEXT& rhs) = default;
  //! Default copy assignment
  SpatialFilterTrackingStateEXT& operator=(const SpatialFilterTrackingStateEXT& rhs) = default;
  //! Copy construct from raw
  SpatialFilterTrackingStateEXT(const XrSpatialFilterTrackingStateEXT& rhs)
      : SpatialFilterTrackingStateEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialFilterTrackingStateEXT& operator=(const XrSpatialFilterTrackingStateEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialFilterTrackingStateEXT&() const {
    return *reinterpret_cast<const XrSpatialFilterTrackingStateEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialFilterTrackingStateEXT&() {
    return *reinterpret_cast<XrSpatialFilterTrackingStateEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialFilterTrackingStateEXT
  XrSpatialFilterTrackingStateEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialFilterTrackingStateEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialFilterTrackingStateEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialFilterTrackingStateEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialFilterTrackingStateEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialFilterTrackingStateEXT*>(this);
  }
  SpatialEntityTrackingStateEXT trackingState;
};
static_assert(sizeof(XrSpatialFilterTrackingStateEXT) == sizeof(SpatialFilterTrackingStateEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialFilterTrackingStateEXT pointer to const from a
 * SpatialFilterTrackingStateEXT reference to const.
 * @relates SpatialFilterTrackingStateEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialFilterTrackingStateEXT const* get(
    SpatialFilterTrackingStateEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialFilterTrackingStateEXT
 * as the address of a raw XrSpatialFilterTrackingStateEXT
 * @relates SpatialFilterTrackingStateEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialFilterTrackingStateEXT* put(SpatialFilterTrackingStateEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_plane_tracking
/*!
 * C++ projection of XrSpatialCapabilityConfigurationPlaneTrackingEXT
 *
 * Provided by the `XR_EXT_spatial_plane_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialCapabilityConfigurationPlaneTrackingEXT>
 * @xrentity{XrSpatialCapabilityConfigurationPlaneTrackingEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialCapabilityConfigurationPlaneTrackingEXT
    : public SpatialCapabilityConfigurationBaseHeaderEXT {
private:
  using Parent = SpatialCapabilityConfigurationBaseHeaderEXT;

public:
  //! Constructor initializing all members.
  SpatialCapabilityConfigurationPlaneTrackingEXT(const SpatialCapabilityEXT& capability_,
                                                 uint32_t enabledComponentCount_,
                                                 const SpatialComponentTypeEXT* enabledComponents_,
                                                 const void* next_ = nullptr)
      : Parent(StructureType::SpatialCapabilityConfigurationPlaneTrackingEXT, capability_,
               enabledComponentCount_, enabledComponents_, next_) {}

  //! Default/empty constructor
  SpatialCapabilityConfigurationPlaneTrackingEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialCapabilityConfigurationPlaneTrackingEXT, {}, {}, {}, next_) {}

  //! Default copy constructor
  SpatialCapabilityConfigurationPlaneTrackingEXT(
      const SpatialCapabilityConfigurationPlaneTrackingEXT& rhs) = default;
  //! Default copy assignment
  SpatialCapabilityConfigurationPlaneTrackingEXT& operator=(
      const SpatialCapabilityConfigurationPlaneTrackingEXT& rhs) = default;
  //! Copy construct from raw
  SpatialCapabilityConfigurationPlaneTrackingEXT(
      const XrSpatialCapabilityConfigurationPlaneTrackingEXT& rhs)
      : SpatialCapabilityConfigurationPlaneTrackingEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialCapabilityConfigurationPlaneTrackingEXT& operator=(
      const XrSpatialCapabilityConfigurationPlaneTrackingEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialCapabilityConfigurationPlaneTrackingEXT&() const {
    return *reinterpret_cast<const XrSpatialCapabilityConfigurationPlaneTrackingEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialCapabilityConfigurationPlaneTrackingEXT&() {
    return *reinterpret_cast<XrSpatialCapabilityConfigurationPlaneTrackingEXT*>(this);
  }

  //! Accessor for this as a raw, base XrSpatialCapabilityConfigurationBaseHeaderEXT const pointer
  XrSpatialCapabilityConfigurationBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialCapabilityConfigurationPlaneTrackingEXT
  XrSpatialCapabilityConfigurationPlaneTrackingEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationPlaneTrackingEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialCapabilityConfigurationPlaneTrackingEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialCapabilityConfigurationPlaneTrackingEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialCapabilityConfigurationPlaneTrackingEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialCapabilityConfigurationPlaneTrackingEXT*>(this);
  }
};
static_assert(sizeof(XrSpatialCapabilityConfigurationPlaneTrackingEXT) ==
                  sizeof(SpatialCapabilityConfigurationPlaneTrackingEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialCapabilityConfigurationPlaneTrackingEXT pointer
 * to const from a SpatialCapabilityConfigurationPlaneTrackingEXT reference to const.
 * @relates SpatialCapabilityConfigurationPlaneTrackingEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationPlaneTrackingEXT const* get(
    SpatialCapabilityConfigurationPlaneTrackingEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialCapabilityConfigurationPlaneTrackingEXT as the address of a raw
 * XrSpatialCapabilityConfigurationPlaneTrackingEXT
 * @relates SpatialCapabilityConfigurationPlaneTrackingEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationPlaneTrackingEXT* put(
    SpatialCapabilityConfigurationPlaneTrackingEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const
 * SpatialCapabilityConfigurationPlaneTrackingEXT as a raw, pointer to const
 * XrSpatialCapabilityConfigurationBaseHeaderEXT (the base type)
 * @relates SpatialCapabilityConfigurationPlaneTrackingEXT
 * @relatesalso SpatialCapabilityConfigurationBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationBaseHeaderEXT const* get_base(
    SpatialCapabilityConfigurationPlaneTrackingEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_spatial_plane_tracking

#ifdef XR_EXT_spatial_plane_tracking
/*!
 * C++ projection of XrSpatialComponentPlaneAlignmentListEXT
 *
 * Provided by the `XR_EXT_spatial_plane_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentPlaneAlignmentListEXT>
 * @xrentity{XrSpatialComponentPlaneAlignmentListEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentPlaneAlignmentListEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialComponentPlaneAlignmentListEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentPlaneAlignmentListEXT, next_) {}

  //! Default copy constructor
  SpatialComponentPlaneAlignmentListEXT(const SpatialComponentPlaneAlignmentListEXT& rhs) = default;
  //! Default copy assignment
  SpatialComponentPlaneAlignmentListEXT& operator=(
      const SpatialComponentPlaneAlignmentListEXT& rhs) = default;
  //! Copy construct from raw
  SpatialComponentPlaneAlignmentListEXT(const XrSpatialComponentPlaneAlignmentListEXT& rhs)
      : SpatialComponentPlaneAlignmentListEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentPlaneAlignmentListEXT& operator=(
      const XrSpatialComponentPlaneAlignmentListEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentPlaneAlignmentListEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentPlaneAlignmentListEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentPlaneAlignmentListEXT&() {
    return *reinterpret_cast<XrSpatialComponentPlaneAlignmentListEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentPlaneAlignmentListEXT
  XrSpatialComponentPlaneAlignmentListEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentPlaneAlignmentListEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentPlaneAlignmentListEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentPlaneAlignmentListEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentPlaneAlignmentListEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentPlaneAlignmentListEXT*>(this);
  }
  uint32_t planeAlignmentCount;
  SpatialPlaneAlignmentEXT* planeAlignments;
};
static_assert(sizeof(XrSpatialComponentPlaneAlignmentListEXT) ==
                  sizeof(SpatialComponentPlaneAlignmentListEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentPlaneAlignmentListEXT pointer to const
 * from a SpatialComponentPlaneAlignmentListEXT reference to const.
 * @relates SpatialComponentPlaneAlignmentListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentPlaneAlignmentListEXT const* get(
    SpatialComponentPlaneAlignmentListEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialComponentPlaneAlignmentListEXT as the address of a raw
 * XrSpatialComponentPlaneAlignmentListEXT
 * @relates SpatialComponentPlaneAlignmentListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentPlaneAlignmentListEXT* put(
    SpatialComponentPlaneAlignmentListEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_plane_tracking

#ifdef XR_EXT_spatial_plane_tracking
/*!
 * C++ projection of XrSpatialComponentMesh2DListEXT
 *
 * Provided by the `XR_EXT_spatial_plane_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentMesh2DListEXT>
 * @xrentity{XrSpatialComponentMesh2DListEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentMesh2DListEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialComponentMesh2DListEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentMesh2DListEXT, next_) {}

  //! Default copy constructor
  SpatialComponentMesh2DListEXT(const SpatialComponentMesh2DListEXT& rhs) = default;
  //! Default copy assignment
  SpatialComponentMesh2DListEXT& operator=(const SpatialComponentMesh2DListEXT& rhs) = default;
  //! Copy construct from raw
  SpatialComponentMesh2DListEXT(const XrSpatialComponentMesh2DListEXT& rhs)
      : SpatialComponentMesh2DListEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentMesh2DListEXT& operator=(const XrSpatialComponentMesh2DListEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentMesh2DListEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentMesh2DListEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentMesh2DListEXT&() {
    return *reinterpret_cast<XrSpatialComponentMesh2DListEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentMesh2DListEXT
  XrSpatialComponentMesh2DListEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentMesh2DListEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentMesh2DListEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentMesh2DListEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentMesh2DListEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentMesh2DListEXT*>(this);
  }
  uint32_t meshCount;
  SpatialMeshDataEXT* meshes;
};
static_assert(sizeof(XrSpatialComponentMesh2DListEXT) == sizeof(SpatialComponentMesh2DListEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentMesh2DListEXT pointer to const from a
 * SpatialComponentMesh2DListEXT reference to const.
 * @relates SpatialComponentMesh2DListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentMesh2DListEXT const* get(
    SpatialComponentMesh2DListEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialComponentMesh2DListEXT
 * as the address of a raw XrSpatialComponentMesh2DListEXT
 * @relates SpatialComponentMesh2DListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentMesh2DListEXT* put(SpatialComponentMesh2DListEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_plane_tracking

#ifdef XR_EXT_spatial_plane_tracking
/*!
 * C++ projection of XrSpatialPolygon2DDataEXT
 *
 * Provided by the `XR_EXT_spatial_plane_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialPolygon2DDataEXT>
 * @xrentity{XrSpatialPolygon2DDataEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpatialPolygon2DDataEXT {
public:
  //! Constructor initializing all members.
  SpatialPolygon2DDataEXT(const Posef& origin_, const SpatialBufferEXT& vertexBuffer_)
      : origin{origin_}, vertexBuffer{vertexBuffer_} {}

  //! Default/empty constructor
  SpatialPolygon2DDataEXT()

      : origin{}, vertexBuffer{} {}

  //! Default copy constructor
  SpatialPolygon2DDataEXT(const SpatialPolygon2DDataEXT& rhs) = default;
  //! Default copy assignment
  SpatialPolygon2DDataEXT& operator=(const SpatialPolygon2DDataEXT& rhs) = default;
  //! Copy construct from raw
  SpatialPolygon2DDataEXT(const XrSpatialPolygon2DDataEXT& rhs) : SpatialPolygon2DDataEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialPolygon2DDataEXT& operator=(const XrSpatialPolygon2DDataEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialPolygon2DDataEXT&() const {
    return *reinterpret_cast<const XrSpatialPolygon2DDataEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialPolygon2DDataEXT&() {
    return *reinterpret_cast<XrSpatialPolygon2DDataEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialPolygon2DDataEXT
  XrSpatialPolygon2DDataEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialPolygon2DDataEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialPolygon2DDataEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpatialPolygon2DDataEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpatialPolygon2DDataEXT{};
    }
    return reinterpret_cast<XrSpatialPolygon2DDataEXT*>(this);
  }
  Posef origin;
  SpatialBufferEXT vertexBuffer;
};
static_assert(sizeof(XrSpatialPolygon2DDataEXT) == sizeof(SpatialPolygon2DDataEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialPolygon2DDataEXT pointer to const from a
 * SpatialPolygon2DDataEXT reference to const.
 * @relates SpatialPolygon2DDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialPolygon2DDataEXT const* get(SpatialPolygon2DDataEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialPolygon2DDataEXT as
 * the address of a raw XrSpatialPolygon2DDataEXT
 * @relates SpatialPolygon2DDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialPolygon2DDataEXT* put(SpatialPolygon2DDataEXT& s,
                                                        bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_plane_tracking

#ifdef XR_EXT_spatial_plane_tracking
/*!
 * C++ projection of XrSpatialComponentPolygon2DListEXT
 *
 * Provided by the `XR_EXT_spatial_plane_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentPolygon2DListEXT>
 * @xrentity{XrSpatialComponentPolygon2DListEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentPolygon2DListEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialComponentPolygon2DListEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentPolygon2DListEXT, next_) {}

  //! Default copy constructor
  SpatialComponentPolygon2DListEXT(const SpatialComponentPolygon2DListEXT& rhs) = default;
  //! Default copy assignment
  SpatialComponentPolygon2DListEXT& operator=(const SpatialComponentPolygon2DListEXT& rhs) =
      default;
  //! Copy construct from raw
  SpatialComponentPolygon2DListEXT(const XrSpatialComponentPolygon2DListEXT& rhs)
      : SpatialComponentPolygon2DListEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentPolygon2DListEXT& operator=(const XrSpatialComponentPolygon2DListEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentPolygon2DListEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentPolygon2DListEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentPolygon2DListEXT&() {
    return *reinterpret_cast<XrSpatialComponentPolygon2DListEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentPolygon2DListEXT
  XrSpatialComponentPolygon2DListEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentPolygon2DListEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentPolygon2DListEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentPolygon2DListEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentPolygon2DListEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentPolygon2DListEXT*>(this);
  }
  uint32_t polygonCount;
  SpatialPolygon2DDataEXT* polygons;
};
static_assert(sizeof(XrSpatialComponentPolygon2DListEXT) ==
                  sizeof(SpatialComponentPolygon2DListEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentPolygon2DListEXT pointer to const from a
 * SpatialComponentPolygon2DListEXT reference to const.
 * @relates SpatialComponentPolygon2DListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentPolygon2DListEXT const* get(
    SpatialComponentPolygon2DListEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialComponentPolygon2DListEXT as the address of a raw XrSpatialComponentPolygon2DListEXT
 * @relates SpatialComponentPolygon2DListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentPolygon2DListEXT* put(
    SpatialComponentPolygon2DListEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_plane_tracking

#ifdef XR_EXT_spatial_plane_tracking
/*!
 * C++ projection of XrSpatialComponentPlaneSemanticLabelListEXT
 *
 * Provided by the `XR_EXT_spatial_plane_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentPlaneSemanticLabelListEXT>
 * @xrentity{XrSpatialComponentPlaneSemanticLabelListEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentPlaneSemanticLabelListEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialComponentPlaneSemanticLabelListEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentPlaneSemanticLabelListEXT, next_) {}

  //! Default copy constructor
  SpatialComponentPlaneSemanticLabelListEXT(const SpatialComponentPlaneSemanticLabelListEXT& rhs) =
      default;
  //! Default copy assignment
  SpatialComponentPlaneSemanticLabelListEXT& operator=(
      const SpatialComponentPlaneSemanticLabelListEXT& rhs) = default;
  //! Copy construct from raw
  SpatialComponentPlaneSemanticLabelListEXT(const XrSpatialComponentPlaneSemanticLabelListEXT& rhs)
      : SpatialComponentPlaneSemanticLabelListEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentPlaneSemanticLabelListEXT& operator=(
      const XrSpatialComponentPlaneSemanticLabelListEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentPlaneSemanticLabelListEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentPlaneSemanticLabelListEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentPlaneSemanticLabelListEXT&() {
    return *reinterpret_cast<XrSpatialComponentPlaneSemanticLabelListEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentPlaneSemanticLabelListEXT
  XrSpatialComponentPlaneSemanticLabelListEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentPlaneSemanticLabelListEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentPlaneSemanticLabelListEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentPlaneSemanticLabelListEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentPlaneSemanticLabelListEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentPlaneSemanticLabelListEXT*>(this);
  }
  uint32_t semanticLabelCount;
  SpatialPlaneSemanticLabelEXT* semanticLabels;
};
static_assert(sizeof(XrSpatialComponentPlaneSemanticLabelListEXT) ==
                  sizeof(SpatialComponentPlaneSemanticLabelListEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentPlaneSemanticLabelListEXT pointer to
 * const from a SpatialComponentPlaneSemanticLabelListEXT reference to const.
 * @relates SpatialComponentPlaneSemanticLabelListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentPlaneSemanticLabelListEXT const* get(
    SpatialComponentPlaneSemanticLabelListEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialComponentPlaneSemanticLabelListEXT as the address of a raw
 * XrSpatialComponentPlaneSemanticLabelListEXT
 * @relates SpatialComponentPlaneSemanticLabelListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentPlaneSemanticLabelListEXT* put(
    SpatialComponentPlaneSemanticLabelListEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_plane_tracking

#ifdef XR_EXT_spatial_marker_tracking
/*!
 * C++ projection of XrSpatialCapabilityConfigurationQrCodeEXT
 *
 * Provided by the `XR_EXT_spatial_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialCapabilityConfigurationQrCodeEXT>
 * @xrentity{XrSpatialCapabilityConfigurationQrCodeEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialCapabilityConfigurationQrCodeEXT
    : public SpatialCapabilityConfigurationBaseHeaderEXT {
private:
  using Parent = SpatialCapabilityConfigurationBaseHeaderEXT;

public:
  //! Constructor initializing all members.
  SpatialCapabilityConfigurationQrCodeEXT(const SpatialCapabilityEXT& capability_,
                                          uint32_t enabledComponentCount_,
                                          const SpatialComponentTypeEXT* enabledComponents_,
                                          const void* next_ = nullptr)
      : Parent(StructureType::SpatialCapabilityConfigurationQrCodeEXT, capability_,
               enabledComponentCount_, enabledComponents_, next_) {}

  //! Default/empty constructor
  SpatialCapabilityConfigurationQrCodeEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialCapabilityConfigurationQrCodeEXT, {}, {}, {}, next_) {}

  //! Default copy constructor
  SpatialCapabilityConfigurationQrCodeEXT(const SpatialCapabilityConfigurationQrCodeEXT& rhs) =
      default;
  //! Default copy assignment
  SpatialCapabilityConfigurationQrCodeEXT& operator=(
      const SpatialCapabilityConfigurationQrCodeEXT& rhs) = default;
  //! Copy construct from raw
  SpatialCapabilityConfigurationQrCodeEXT(const XrSpatialCapabilityConfigurationQrCodeEXT& rhs)
      : SpatialCapabilityConfigurationQrCodeEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialCapabilityConfigurationQrCodeEXT& operator=(
      const XrSpatialCapabilityConfigurationQrCodeEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialCapabilityConfigurationQrCodeEXT&() const {
    return *reinterpret_cast<const XrSpatialCapabilityConfigurationQrCodeEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialCapabilityConfigurationQrCodeEXT&() {
    return *reinterpret_cast<XrSpatialCapabilityConfigurationQrCodeEXT*>(this);
  }

  //! Accessor for this as a raw, base XrSpatialCapabilityConfigurationBaseHeaderEXT const pointer
  XrSpatialCapabilityConfigurationBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialCapabilityConfigurationQrCodeEXT
  XrSpatialCapabilityConfigurationQrCodeEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationQrCodeEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialCapabilityConfigurationQrCodeEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialCapabilityConfigurationQrCodeEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialCapabilityConfigurationQrCodeEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialCapabilityConfigurationQrCodeEXT*>(this);
  }
};
static_assert(sizeof(XrSpatialCapabilityConfigurationQrCodeEXT) ==
                  sizeof(SpatialCapabilityConfigurationQrCodeEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialCapabilityConfigurationQrCodeEXT pointer to const
 * from a SpatialCapabilityConfigurationQrCodeEXT reference to const.
 * @relates SpatialCapabilityConfigurationQrCodeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationQrCodeEXT const* get(
    SpatialCapabilityConfigurationQrCodeEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialCapabilityConfigurationQrCodeEXT as the address of a raw
 * XrSpatialCapabilityConfigurationQrCodeEXT
 * @relates SpatialCapabilityConfigurationQrCodeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationQrCodeEXT* put(
    SpatialCapabilityConfigurationQrCodeEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpatialCapabilityConfigurationQrCodeEXT as
 * a raw, pointer to const XrSpatialCapabilityConfigurationBaseHeaderEXT (the base type)
 * @relates SpatialCapabilityConfigurationQrCodeEXT
 * @relatesalso SpatialCapabilityConfigurationBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationBaseHeaderEXT const* get_base(
    SpatialCapabilityConfigurationQrCodeEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_spatial_marker_tracking

#ifdef XR_EXT_spatial_marker_tracking
/*!
 * C++ projection of XrSpatialCapabilityConfigurationMicroQrCodeEXT
 *
 * Provided by the `XR_EXT_spatial_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialCapabilityConfigurationMicroQrCodeEXT>
 * @xrentity{XrSpatialCapabilityConfigurationMicroQrCodeEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialCapabilityConfigurationMicroQrCodeEXT
    : public SpatialCapabilityConfigurationBaseHeaderEXT {
private:
  using Parent = SpatialCapabilityConfigurationBaseHeaderEXT;

public:
  //! Constructor initializing all members.
  SpatialCapabilityConfigurationMicroQrCodeEXT(const SpatialCapabilityEXT& capability_,
                                               uint32_t enabledComponentCount_,
                                               const SpatialComponentTypeEXT* enabledComponents_,
                                               const void* next_ = nullptr)
      : Parent(StructureType::SpatialCapabilityConfigurationMicroQrCodeEXT, capability_,
               enabledComponentCount_, enabledComponents_, next_) {}

  //! Default/empty constructor
  SpatialCapabilityConfigurationMicroQrCodeEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialCapabilityConfigurationMicroQrCodeEXT, {}, {}, {}, next_) {}

  //! Default copy constructor
  SpatialCapabilityConfigurationMicroQrCodeEXT(
      const SpatialCapabilityConfigurationMicroQrCodeEXT& rhs) = default;
  //! Default copy assignment
  SpatialCapabilityConfigurationMicroQrCodeEXT& operator=(
      const SpatialCapabilityConfigurationMicroQrCodeEXT& rhs) = default;
  //! Copy construct from raw
  SpatialCapabilityConfigurationMicroQrCodeEXT(
      const XrSpatialCapabilityConfigurationMicroQrCodeEXT& rhs)
      : SpatialCapabilityConfigurationMicroQrCodeEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialCapabilityConfigurationMicroQrCodeEXT& operator=(
      const XrSpatialCapabilityConfigurationMicroQrCodeEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialCapabilityConfigurationMicroQrCodeEXT&() const {
    return *reinterpret_cast<const XrSpatialCapabilityConfigurationMicroQrCodeEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialCapabilityConfigurationMicroQrCodeEXT&() {
    return *reinterpret_cast<XrSpatialCapabilityConfigurationMicroQrCodeEXT*>(this);
  }

  //! Accessor for this as a raw, base XrSpatialCapabilityConfigurationBaseHeaderEXT const pointer
  XrSpatialCapabilityConfigurationBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialCapabilityConfigurationMicroQrCodeEXT
  XrSpatialCapabilityConfigurationMicroQrCodeEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationMicroQrCodeEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialCapabilityConfigurationMicroQrCodeEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialCapabilityConfigurationMicroQrCodeEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialCapabilityConfigurationMicroQrCodeEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialCapabilityConfigurationMicroQrCodeEXT*>(this);
  }
};
static_assert(sizeof(XrSpatialCapabilityConfigurationMicroQrCodeEXT) ==
                  sizeof(SpatialCapabilityConfigurationMicroQrCodeEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialCapabilityConfigurationMicroQrCodeEXT pointer to
 * const from a SpatialCapabilityConfigurationMicroQrCodeEXT reference to const.
 * @relates SpatialCapabilityConfigurationMicroQrCodeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationMicroQrCodeEXT const* get(
    SpatialCapabilityConfigurationMicroQrCodeEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialCapabilityConfigurationMicroQrCodeEXT as the address of a raw
 * XrSpatialCapabilityConfigurationMicroQrCodeEXT
 * @relates SpatialCapabilityConfigurationMicroQrCodeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationMicroQrCodeEXT* put(
    SpatialCapabilityConfigurationMicroQrCodeEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const
 * SpatialCapabilityConfigurationMicroQrCodeEXT as a raw, pointer to const
 * XrSpatialCapabilityConfigurationBaseHeaderEXT (the base type)
 * @relates SpatialCapabilityConfigurationMicroQrCodeEXT
 * @relatesalso SpatialCapabilityConfigurationBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationBaseHeaderEXT const* get_base(
    SpatialCapabilityConfigurationMicroQrCodeEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_spatial_marker_tracking

#ifdef XR_EXT_spatial_marker_tracking
/*!
 * C++ projection of XrSpatialCapabilityConfigurationArucoMarkerEXT
 *
 * Provided by the `XR_EXT_spatial_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialCapabilityConfigurationArucoMarkerEXT>
 * @xrentity{XrSpatialCapabilityConfigurationArucoMarkerEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialCapabilityConfigurationArucoMarkerEXT
    : public SpatialCapabilityConfigurationBaseHeaderEXT {
private:
  using Parent = SpatialCapabilityConfigurationBaseHeaderEXT;

public:
  //! Constructor initializing all members.
  SpatialCapabilityConfigurationArucoMarkerEXT(const SpatialCapabilityEXT& capability_,
                                               uint32_t enabledComponentCount_,
                                               const SpatialComponentTypeEXT* enabledComponents_,
                                               const SpatialMarkerArucoDictEXT& arUcoDict_,
                                               const void* next_ = nullptr)
      : Parent(StructureType::SpatialCapabilityConfigurationArucoMarkerEXT, capability_,
               enabledComponentCount_, enabledComponents_, next_),
        arUcoDict{arUcoDict_} {}

  //! Default/empty constructor
  SpatialCapabilityConfigurationArucoMarkerEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialCapabilityConfigurationArucoMarkerEXT, {}, {}, {}, next_),
        arUcoDict{} {}

  //! Default copy constructor
  SpatialCapabilityConfigurationArucoMarkerEXT(
      const SpatialCapabilityConfigurationArucoMarkerEXT& rhs) = default;
  //! Default copy assignment
  SpatialCapabilityConfigurationArucoMarkerEXT& operator=(
      const SpatialCapabilityConfigurationArucoMarkerEXT& rhs) = default;
  //! Copy construct from raw
  SpatialCapabilityConfigurationArucoMarkerEXT(
      const XrSpatialCapabilityConfigurationArucoMarkerEXT& rhs)
      : SpatialCapabilityConfigurationArucoMarkerEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialCapabilityConfigurationArucoMarkerEXT& operator=(
      const XrSpatialCapabilityConfigurationArucoMarkerEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialCapabilityConfigurationArucoMarkerEXT&() const {
    return *reinterpret_cast<const XrSpatialCapabilityConfigurationArucoMarkerEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialCapabilityConfigurationArucoMarkerEXT&() {
    return *reinterpret_cast<XrSpatialCapabilityConfigurationArucoMarkerEXT*>(this);
  }

  //! Accessor for this as a raw, base XrSpatialCapabilityConfigurationBaseHeaderEXT const pointer
  XrSpatialCapabilityConfigurationBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialCapabilityConfigurationArucoMarkerEXT
  XrSpatialCapabilityConfigurationArucoMarkerEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationArucoMarkerEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialCapabilityConfigurationArucoMarkerEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialCapabilityConfigurationArucoMarkerEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialCapabilityConfigurationArucoMarkerEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialCapabilityConfigurationArucoMarkerEXT*>(this);
  }
  SpatialMarkerArucoDictEXT arUcoDict;
};
static_assert(sizeof(XrSpatialCapabilityConfigurationArucoMarkerEXT) ==
                  sizeof(SpatialCapabilityConfigurationArucoMarkerEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialCapabilityConfigurationArucoMarkerEXT pointer to
 * const from a SpatialCapabilityConfigurationArucoMarkerEXT reference to const.
 * @relates SpatialCapabilityConfigurationArucoMarkerEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationArucoMarkerEXT const* get(
    SpatialCapabilityConfigurationArucoMarkerEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialCapabilityConfigurationArucoMarkerEXT as the address of a raw
 * XrSpatialCapabilityConfigurationArucoMarkerEXT
 * @relates SpatialCapabilityConfigurationArucoMarkerEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationArucoMarkerEXT* put(
    SpatialCapabilityConfigurationArucoMarkerEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const
 * SpatialCapabilityConfigurationArucoMarkerEXT as a raw, pointer to const
 * XrSpatialCapabilityConfigurationBaseHeaderEXT (the base type)
 * @relates SpatialCapabilityConfigurationArucoMarkerEXT
 * @relatesalso SpatialCapabilityConfigurationBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationBaseHeaderEXT const* get_base(
    SpatialCapabilityConfigurationArucoMarkerEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_spatial_marker_tracking

#ifdef XR_EXT_spatial_marker_tracking
/*!
 * C++ projection of XrSpatialCapabilityConfigurationAprilTagEXT
 *
 * Provided by the `XR_EXT_spatial_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialCapabilityConfigurationAprilTagEXT>
 * @xrentity{XrSpatialCapabilityConfigurationAprilTagEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialCapabilityConfigurationAprilTagEXT
    : public SpatialCapabilityConfigurationBaseHeaderEXT {
private:
  using Parent = SpatialCapabilityConfigurationBaseHeaderEXT;

public:
  //! Constructor initializing all members.
  SpatialCapabilityConfigurationAprilTagEXT(const SpatialCapabilityEXT& capability_,
                                            uint32_t enabledComponentCount_,
                                            const SpatialComponentTypeEXT* enabledComponents_,
                                            const SpatialMarkerAprilTagDictEXT& aprilDict_,
                                            const void* next_ = nullptr)
      : Parent(StructureType::SpatialCapabilityConfigurationAprilTagEXT, capability_,
               enabledComponentCount_, enabledComponents_, next_),
        aprilDict{aprilDict_} {}

  //! Default/empty constructor
  SpatialCapabilityConfigurationAprilTagEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialCapabilityConfigurationAprilTagEXT, {}, {}, {}, next_),
        aprilDict{} {}

  //! Default copy constructor
  SpatialCapabilityConfigurationAprilTagEXT(const SpatialCapabilityConfigurationAprilTagEXT& rhs) =
      default;
  //! Default copy assignment
  SpatialCapabilityConfigurationAprilTagEXT& operator=(
      const SpatialCapabilityConfigurationAprilTagEXT& rhs) = default;
  //! Copy construct from raw
  SpatialCapabilityConfigurationAprilTagEXT(const XrSpatialCapabilityConfigurationAprilTagEXT& rhs)
      : SpatialCapabilityConfigurationAprilTagEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialCapabilityConfigurationAprilTagEXT& operator=(
      const XrSpatialCapabilityConfigurationAprilTagEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialCapabilityConfigurationAprilTagEXT&() const {
    return *reinterpret_cast<const XrSpatialCapabilityConfigurationAprilTagEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialCapabilityConfigurationAprilTagEXT&() {
    return *reinterpret_cast<XrSpatialCapabilityConfigurationAprilTagEXT*>(this);
  }

  //! Accessor for this as a raw, base XrSpatialCapabilityConfigurationBaseHeaderEXT const pointer
  XrSpatialCapabilityConfigurationBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrSpatialCapabilityConfigurationAprilTagEXT
  XrSpatialCapabilityConfigurationAprilTagEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationAprilTagEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialCapabilityConfigurationAprilTagEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialCapabilityConfigurationAprilTagEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialCapabilityConfigurationAprilTagEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialCapabilityConfigurationAprilTagEXT*>(this);
  }
  SpatialMarkerAprilTagDictEXT aprilDict;
};
static_assert(sizeof(XrSpatialCapabilityConfigurationAprilTagEXT) ==
                  sizeof(SpatialCapabilityConfigurationAprilTagEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialCapabilityConfigurationAprilTagEXT pointer to
 * const from a SpatialCapabilityConfigurationAprilTagEXT reference to const.
 * @relates SpatialCapabilityConfigurationAprilTagEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationAprilTagEXT const* get(
    SpatialCapabilityConfigurationAprilTagEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialCapabilityConfigurationAprilTagEXT as the address of a raw
 * XrSpatialCapabilityConfigurationAprilTagEXT
 * @relates SpatialCapabilityConfigurationAprilTagEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationAprilTagEXT* put(
    SpatialCapabilityConfigurationAprilTagEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const SpatialCapabilityConfigurationAprilTagEXT
 * as a raw, pointer to const XrSpatialCapabilityConfigurationBaseHeaderEXT (the base type)
 * @relates SpatialCapabilityConfigurationAprilTagEXT
 * @relatesalso SpatialCapabilityConfigurationBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationBaseHeaderEXT const* get_base(
    SpatialCapabilityConfigurationAprilTagEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_spatial_marker_tracking

#ifdef XR_EXT_spatial_marker_tracking
/*!
 * C++ projection of XrSpatialMarkerSizeEXT
 *
 * Provided by the `XR_EXT_spatial_marker_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialMarkerSizeEXT>
 * @xrentity{XrSpatialMarkerSizeEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialMarkerSizeEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialMarkerSizeEXT(float markerSideLength_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialMarkerSizeEXT, next_), markerSideLength{markerSideLength_} {}

  //! Default/empty constructor
  SpatialMarkerSizeEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialMarkerSizeEXT, next_), markerSideLength{0.0f} {}

  //! Default copy constructor
  SpatialMarkerSizeEXT(const SpatialMarkerSizeEXT& rhs) = default;
  //! Default copy assignment
  SpatialMarkerSizeEXT& operator=(const SpatialMarkerSizeEXT& rhs) = default;
  //! Copy construct from raw
  SpatialMarkerSizeEXT(const XrSpatialMarkerSizeEXT& rhs) : SpatialMarkerSizeEXT() { *put() = rhs; }
  //! Copy assign from raw
  SpatialMarkerSizeEXT& operator=(const XrSpatialMarkerSizeEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialMarkerSizeEXT&() const {
    return *reinterpret_cast<const XrSpatialMarkerSizeEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialMarkerSizeEXT&() { return *reinterpret_cast<XrSpatialMarkerSizeEXT*>(this); }

  //! Accessor for this as the address of a raw XrSpatialMarkerSizeEXT
  XrSpatialMarkerSizeEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialMarkerSizeEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpatialMarkerSizeEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialMarkerSizeEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialMarkerSizeEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialMarkerSizeEXT*>(this);
  }
  float markerSideLength;
};
static_assert(sizeof(XrSpatialMarkerSizeEXT) == sizeof(SpatialMarkerSizeEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialMarkerSizeEXT pointer to const from a
 * SpatialMarkerSizeEXT reference to const.
 * @relates SpatialMarkerSizeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialMarkerSizeEXT const* get(SpatialMarkerSizeEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialMarkerSizeEXT as the
 * address of a raw XrSpatialMarkerSizeEXT
 * @relates SpatialMarkerSizeEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialMarkerSizeEXT* put(SpatialMarkerSizeEXT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_marker_tracking

#ifdef XR_EXT_spatial_marker_tracking
/*!
 * C++ projection of XrSpatialMarkerStaticOptimizationEXT
 *
 * Provided by the `XR_EXT_spatial_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialMarkerStaticOptimizationEXT>
 * @xrentity{XrSpatialMarkerStaticOptimizationEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialMarkerStaticOptimizationEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialMarkerStaticOptimizationEXT(const Bool32& optimizeForStaticMarker_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::SpatialMarkerStaticOptimizationEXT, next_),
        optimizeForStaticMarker{optimizeForStaticMarker_} {}

  //! Default/empty constructor
  SpatialMarkerStaticOptimizationEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialMarkerStaticOptimizationEXT, next_),
        optimizeForStaticMarker{false} {}

  //! Default copy constructor
  SpatialMarkerStaticOptimizationEXT(const SpatialMarkerStaticOptimizationEXT& rhs) = default;
  //! Default copy assignment
  SpatialMarkerStaticOptimizationEXT& operator=(const SpatialMarkerStaticOptimizationEXT& rhs) =
      default;
  //! Copy construct from raw
  SpatialMarkerStaticOptimizationEXT(const XrSpatialMarkerStaticOptimizationEXT& rhs)
      : SpatialMarkerStaticOptimizationEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialMarkerStaticOptimizationEXT& operator=(const XrSpatialMarkerStaticOptimizationEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialMarkerStaticOptimizationEXT&() const {
    return *reinterpret_cast<const XrSpatialMarkerStaticOptimizationEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialMarkerStaticOptimizationEXT&() {
    return *reinterpret_cast<XrSpatialMarkerStaticOptimizationEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialMarkerStaticOptimizationEXT
  XrSpatialMarkerStaticOptimizationEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialMarkerStaticOptimizationEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialMarkerStaticOptimizationEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialMarkerStaticOptimizationEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialMarkerStaticOptimizationEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialMarkerStaticOptimizationEXT*>(this);
  }
  Bool32 optimizeForStaticMarker;
};
static_assert(sizeof(XrSpatialMarkerStaticOptimizationEXT) ==
                  sizeof(SpatialMarkerStaticOptimizationEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialMarkerStaticOptimizationEXT pointer to const from
 * a SpatialMarkerStaticOptimizationEXT reference to const.
 * @relates SpatialMarkerStaticOptimizationEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialMarkerStaticOptimizationEXT const* get(
    SpatialMarkerStaticOptimizationEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialMarkerStaticOptimizationEXT as the address of a raw XrSpatialMarkerStaticOptimizationEXT
 * @relates SpatialMarkerStaticOptimizationEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialMarkerStaticOptimizationEXT* put(
    SpatialMarkerStaticOptimizationEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_marker_tracking

#ifdef XR_EXT_spatial_marker_tracking
/*!
 * C++ projection of XrSpatialMarkerDataEXT
 *
 * Provided by the `XR_EXT_spatial_marker_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialMarkerDataEXT>
 * @xrentity{XrSpatialMarkerDataEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpatialMarkerDataEXT {
public:
  //! Constructor initializing all members.
  SpatialMarkerDataEXT(const SpatialCapabilityEXT& capability_, uint32_t markerId_,
                       const SpatialBufferEXT& data_)
      : capability{capability_}, markerId{markerId_}, data{data_} {}

  //! Default/empty constructor
  SpatialMarkerDataEXT()

      : capability{}, markerId{0}, data{} {}

  //! Default copy constructor
  SpatialMarkerDataEXT(const SpatialMarkerDataEXT& rhs) = default;
  //! Default copy assignment
  SpatialMarkerDataEXT& operator=(const SpatialMarkerDataEXT& rhs) = default;
  //! Copy construct from raw
  SpatialMarkerDataEXT(const XrSpatialMarkerDataEXT& rhs) : SpatialMarkerDataEXT() { *put() = rhs; }
  //! Copy assign from raw
  SpatialMarkerDataEXT& operator=(const XrSpatialMarkerDataEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialMarkerDataEXT&() const {
    return *reinterpret_cast<const XrSpatialMarkerDataEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialMarkerDataEXT&() { return *reinterpret_cast<XrSpatialMarkerDataEXT*>(this); }

  //! Accessor for this as the address of a raw XrSpatialMarkerDataEXT
  XrSpatialMarkerDataEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialMarkerDataEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw XrSpatialMarkerDataEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpatialMarkerDataEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpatialMarkerDataEXT{};
    }
    return reinterpret_cast<XrSpatialMarkerDataEXT*>(this);
  }
  SpatialCapabilityEXT capability;
  uint32_t markerId;
  SpatialBufferEXT data;
};
static_assert(sizeof(XrSpatialMarkerDataEXT) == sizeof(SpatialMarkerDataEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialMarkerDataEXT pointer to const from a
 * SpatialMarkerDataEXT reference to const.
 * @relates SpatialMarkerDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialMarkerDataEXT const* get(SpatialMarkerDataEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialMarkerDataEXT as the
 * address of a raw XrSpatialMarkerDataEXT
 * @relates SpatialMarkerDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialMarkerDataEXT* put(SpatialMarkerDataEXT& s,
                                                     bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_marker_tracking

#ifdef XR_EXT_spatial_marker_tracking
/*!
 * C++ projection of XrSpatialComponentMarkerListEXT
 *
 * Provided by the `XR_EXT_spatial_marker_tracking` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentMarkerListEXT>
 * @xrentity{XrSpatialComponentMarkerListEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentMarkerListEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialComponentMarkerListEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentMarkerListEXT, next_) {}

  //! Default copy constructor
  SpatialComponentMarkerListEXT(const SpatialComponentMarkerListEXT& rhs) = default;
  //! Default copy assignment
  SpatialComponentMarkerListEXT& operator=(const SpatialComponentMarkerListEXT& rhs) = default;
  //! Copy construct from raw
  SpatialComponentMarkerListEXT(const XrSpatialComponentMarkerListEXT& rhs)
      : SpatialComponentMarkerListEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentMarkerListEXT& operator=(const XrSpatialComponentMarkerListEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentMarkerListEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentMarkerListEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentMarkerListEXT&() {
    return *reinterpret_cast<XrSpatialComponentMarkerListEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentMarkerListEXT
  XrSpatialComponentMarkerListEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentMarkerListEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentMarkerListEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentMarkerListEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentMarkerListEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentMarkerListEXT*>(this);
  }
  uint32_t markerCount;
  SpatialMarkerDataEXT* markers;
};
static_assert(sizeof(XrSpatialComponentMarkerListEXT) == sizeof(SpatialComponentMarkerListEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentMarkerListEXT pointer to const from a
 * SpatialComponentMarkerListEXT reference to const.
 * @relates SpatialComponentMarkerListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentMarkerListEXT const* get(
    SpatialComponentMarkerListEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialComponentMarkerListEXT
 * as the address of a raw XrSpatialComponentMarkerListEXT
 * @relates SpatialComponentMarkerListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentMarkerListEXT* put(SpatialComponentMarkerListEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_marker_tracking

#ifdef XR_EXT_spatial_anchor
/*!
 * C++ projection of XrSpatialCapabilityConfigurationAnchorEXT
 *
 * Provided by the `XR_EXT_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialCapabilityConfigurationAnchorEXT>
 * @xrentity{XrSpatialCapabilityConfigurationAnchorEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialCapabilityConfigurationAnchorEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialCapabilityConfigurationAnchorEXT(const SpatialCapabilityEXT& capability_,
                                          uint32_t enabledComponentCount_,
                                          const SpatialComponentTypeEXT* enabledComponents_,
                                          const void* next_ = nullptr)
      : Parent(StructureType::SpatialCapabilityConfigurationAnchorEXT, next_),
        capability{capability_},
        enabledComponentCount{enabledComponentCount_},
        enabledComponents{enabledComponents_} {}

  //! Default/empty constructor
  SpatialCapabilityConfigurationAnchorEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialCapabilityConfigurationAnchorEXT, next_),
        capability{},
        enabledComponentCount{0},
        enabledComponents{nullptr} {}

  //! Default copy constructor
  SpatialCapabilityConfigurationAnchorEXT(const SpatialCapabilityConfigurationAnchorEXT& rhs) =
      default;
  //! Default copy assignment
  SpatialCapabilityConfigurationAnchorEXT& operator=(
      const SpatialCapabilityConfigurationAnchorEXT& rhs) = default;
  //! Copy construct from raw
  SpatialCapabilityConfigurationAnchorEXT(const XrSpatialCapabilityConfigurationAnchorEXT& rhs)
      : SpatialCapabilityConfigurationAnchorEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialCapabilityConfigurationAnchorEXT& operator=(
      const XrSpatialCapabilityConfigurationAnchorEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialCapabilityConfigurationAnchorEXT&() const {
    return *reinterpret_cast<const XrSpatialCapabilityConfigurationAnchorEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialCapabilityConfigurationAnchorEXT&() {
    return *reinterpret_cast<XrSpatialCapabilityConfigurationAnchorEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialCapabilityConfigurationAnchorEXT
  XrSpatialCapabilityConfigurationAnchorEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialCapabilityConfigurationAnchorEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialCapabilityConfigurationAnchorEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialCapabilityConfigurationAnchorEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialCapabilityConfigurationAnchorEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialCapabilityConfigurationAnchorEXT*>(this);
  }
  SpatialCapabilityEXT capability;
  uint32_t enabledComponentCount;
  const SpatialComponentTypeEXT* enabledComponents;
};
static_assert(sizeof(XrSpatialCapabilityConfigurationAnchorEXT) ==
                  sizeof(SpatialCapabilityConfigurationAnchorEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialCapabilityConfigurationAnchorEXT pointer to const
 * from a SpatialCapabilityConfigurationAnchorEXT reference to const.
 * @relates SpatialCapabilityConfigurationAnchorEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationAnchorEXT const* get(
    SpatialCapabilityConfigurationAnchorEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialCapabilityConfigurationAnchorEXT as the address of a raw
 * XrSpatialCapabilityConfigurationAnchorEXT
 * @relates SpatialCapabilityConfigurationAnchorEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialCapabilityConfigurationAnchorEXT* put(
    SpatialCapabilityConfigurationAnchorEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_anchor

#ifdef XR_EXT_spatial_anchor
/*!
 * C++ projection of XrSpatialComponentAnchorListEXT
 *
 * Provided by the `XR_EXT_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentAnchorListEXT>
 * @xrentity{XrSpatialComponentAnchorListEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentAnchorListEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialComponentAnchorListEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentAnchorListEXT, next_) {}

  //! Default copy constructor
  SpatialComponentAnchorListEXT(const SpatialComponentAnchorListEXT& rhs) = default;
  //! Default copy assignment
  SpatialComponentAnchorListEXT& operator=(const SpatialComponentAnchorListEXT& rhs) = default;
  //! Copy construct from raw
  SpatialComponentAnchorListEXT(const XrSpatialComponentAnchorListEXT& rhs)
      : SpatialComponentAnchorListEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentAnchorListEXT& operator=(const XrSpatialComponentAnchorListEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentAnchorListEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentAnchorListEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentAnchorListEXT&() {
    return *reinterpret_cast<XrSpatialComponentAnchorListEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentAnchorListEXT
  XrSpatialComponentAnchorListEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentAnchorListEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentAnchorListEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentAnchorListEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentAnchorListEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentAnchorListEXT*>(this);
  }
  uint32_t locationCount;
  Posef* locations;
};
static_assert(sizeof(XrSpatialComponentAnchorListEXT) == sizeof(SpatialComponentAnchorListEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentAnchorListEXT pointer to const from a
 * SpatialComponentAnchorListEXT reference to const.
 * @relates SpatialComponentAnchorListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentAnchorListEXT const* get(
    SpatialComponentAnchorListEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialComponentAnchorListEXT
 * as the address of a raw XrSpatialComponentAnchorListEXT
 * @relates SpatialComponentAnchorListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentAnchorListEXT* put(SpatialComponentAnchorListEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_anchor

#ifdef XR_EXT_spatial_anchor
/*!
 * C++ projection of XrSpatialAnchorCreateInfoEXT
 *
 * Provided by the `XR_EXT_spatial_anchor` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorCreateInfoEXT>
 * @xrentity{XrSpatialAnchorCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialAnchorCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialAnchorCreateInfoEXT(const Space& baseSpace_, const Time& time_, const Posef& pose_,
                             const void* next_ = nullptr)
      : Parent(StructureType::SpatialAnchorCreateInfoEXT, next_),
        baseSpace{baseSpace_},
        time{time_},
        pose{pose_} {}

  //! Default/empty constructor
  SpatialAnchorCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialAnchorCreateInfoEXT, next_), baseSpace{}, time{}, pose{} {}

  //! Default copy constructor
  SpatialAnchorCreateInfoEXT(const SpatialAnchorCreateInfoEXT& rhs) = default;
  //! Default copy assignment
  SpatialAnchorCreateInfoEXT& operator=(const SpatialAnchorCreateInfoEXT& rhs) = default;
  //! Copy construct from raw
  SpatialAnchorCreateInfoEXT(const XrSpatialAnchorCreateInfoEXT& rhs)
      : SpatialAnchorCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialAnchorCreateInfoEXT& operator=(const XrSpatialAnchorCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialAnchorCreateInfoEXT&() const {
    return *reinterpret_cast<const XrSpatialAnchorCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialAnchorCreateInfoEXT&() {
    return *reinterpret_cast<XrSpatialAnchorCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialAnchorCreateInfoEXT
  XrSpatialAnchorCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialAnchorCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialAnchorCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialAnchorCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialAnchorCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialAnchorCreateInfoEXT*>(this);
  }
  Space baseSpace;
  Time time;
  Posef pose;
};
static_assert(sizeof(XrSpatialAnchorCreateInfoEXT) == sizeof(SpatialAnchorCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialAnchorCreateInfoEXT pointer to const from a
 * SpatialAnchorCreateInfoEXT reference to const.
 * @relates SpatialAnchorCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoEXT const* get(
    SpatialAnchorCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialAnchorCreateInfoEXT as
 * the address of a raw XrSpatialAnchorCreateInfoEXT
 * @relates SpatialAnchorCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialAnchorCreateInfoEXT* put(SpatialAnchorCreateInfoEXT& s,
                                                           bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_anchor

#ifdef XR_EXT_spatial_persistence
/*!
 * C++ projection of XrSpatialPersistenceContextCreateInfoEXT
 *
 * Provided by the `XR_EXT_spatial_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialPersistenceContextCreateInfoEXT>
 * @xrentity{XrSpatialPersistenceContextCreateInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialPersistenceContextCreateInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialPersistenceContextCreateInfoEXT(const SpatialPersistenceScopeEXT& scope_,
                                         const void* next_ = nullptr)
      : Parent(StructureType::SpatialPersistenceContextCreateInfoEXT, next_), scope{scope_} {}

  //! Default/empty constructor
  SpatialPersistenceContextCreateInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialPersistenceContextCreateInfoEXT, next_), scope{} {}

  //! Default copy constructor
  SpatialPersistenceContextCreateInfoEXT(const SpatialPersistenceContextCreateInfoEXT& rhs) =
      default;
  //! Default copy assignment
  SpatialPersistenceContextCreateInfoEXT& operator=(
      const SpatialPersistenceContextCreateInfoEXT& rhs) = default;
  //! Copy construct from raw
  SpatialPersistenceContextCreateInfoEXT(const XrSpatialPersistenceContextCreateInfoEXT& rhs)
      : SpatialPersistenceContextCreateInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialPersistenceContextCreateInfoEXT& operator=(
      const XrSpatialPersistenceContextCreateInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialPersistenceContextCreateInfoEXT&() const {
    return *reinterpret_cast<const XrSpatialPersistenceContextCreateInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialPersistenceContextCreateInfoEXT&() {
    return *reinterpret_cast<XrSpatialPersistenceContextCreateInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialPersistenceContextCreateInfoEXT
  XrSpatialPersistenceContextCreateInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialPersistenceContextCreateInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialPersistenceContextCreateInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialPersistenceContextCreateInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialPersistenceContextCreateInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialPersistenceContextCreateInfoEXT*>(this);
  }
  SpatialPersistenceScopeEXT scope;
};
static_assert(sizeof(XrSpatialPersistenceContextCreateInfoEXT) ==
                  sizeof(SpatialPersistenceContextCreateInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialPersistenceContextCreateInfoEXT pointer to const
 * from a SpatialPersistenceContextCreateInfoEXT reference to const.
 * @relates SpatialPersistenceContextCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialPersistenceContextCreateInfoEXT const* get(
    SpatialPersistenceContextCreateInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialPersistenceContextCreateInfoEXT as the address of a raw
 * XrSpatialPersistenceContextCreateInfoEXT
 * @relates SpatialPersistenceContextCreateInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialPersistenceContextCreateInfoEXT* put(
    SpatialPersistenceContextCreateInfoEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_persistence

#ifdef XR_EXT_spatial_persistence
/*!
 * C++ projection of XrCreateSpatialPersistenceContextCompletionEXT
 *
 * Provided by the `XR_EXT_spatial_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrCreateSpatialPersistenceContextCompletionEXT>
 * @xrentity{XrCreateSpatialPersistenceContextCompletionEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS CreateSpatialPersistenceContextCompletionEXT
    : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  CreateSpatialPersistenceContextCompletionEXT(void* next_ = nullptr)

      : Parent(StructureType::CreateSpatialPersistenceContextCompletionEXT, {}, next_) {}

  //! Default copy constructor
  CreateSpatialPersistenceContextCompletionEXT(
      const CreateSpatialPersistenceContextCompletionEXT& rhs) = default;
  //! Default copy assignment
  CreateSpatialPersistenceContextCompletionEXT& operator=(
      const CreateSpatialPersistenceContextCompletionEXT& rhs) = default;
  //! Copy construct from raw
  CreateSpatialPersistenceContextCompletionEXT(
      const XrCreateSpatialPersistenceContextCompletionEXT& rhs)
      : CreateSpatialPersistenceContextCompletionEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  CreateSpatialPersistenceContextCompletionEXT& operator=(
      const XrCreateSpatialPersistenceContextCompletionEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrCreateSpatialPersistenceContextCompletionEXT&() const {
    return *reinterpret_cast<const XrCreateSpatialPersistenceContextCompletionEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrCreateSpatialPersistenceContextCompletionEXT&() {
    return *reinterpret_cast<XrCreateSpatialPersistenceContextCompletionEXT*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrCreateSpatialPersistenceContextCompletionEXT
  XrCreateSpatialPersistenceContextCompletionEXT const* get() const noexcept {
    return reinterpret_cast<XrCreateSpatialPersistenceContextCompletionEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrCreateSpatialPersistenceContextCompletionEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrCreateSpatialPersistenceContextCompletionEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = CreateSpatialPersistenceContextCompletionEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrCreateSpatialPersistenceContextCompletionEXT*>(this);
  }
  SpatialPersistenceContextResultEXT createResult;
  SpatialPersistenceContextEXT persistenceContext;
};
static_assert(sizeof(XrCreateSpatialPersistenceContextCompletionEXT) ==
                  sizeof(CreateSpatialPersistenceContextCompletionEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrCreateSpatialPersistenceContextCompletionEXT pointer to
 * const from a CreateSpatialPersistenceContextCompletionEXT reference to const.
 * @relates CreateSpatialPersistenceContextCompletionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCreateSpatialPersistenceContextCompletionEXT const* get(
    CreateSpatialPersistenceContextCompletionEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * CreateSpatialPersistenceContextCompletionEXT as the address of a raw
 * XrCreateSpatialPersistenceContextCompletionEXT
 * @relates CreateSpatialPersistenceContextCompletionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrCreateSpatialPersistenceContextCompletionEXT* put(
    CreateSpatialPersistenceContextCompletionEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const
 * CreateSpatialPersistenceContextCompletionEXT as a raw, pointer to const
 * XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates CreateSpatialPersistenceContextCompletionEXT
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    CreateSpatialPersistenceContextCompletionEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_spatial_persistence

#ifdef XR_EXT_spatial_persistence
/*!
 * C++ projection of XrSpatialContextPersistenceConfigEXT
 *
 * Provided by the `XR_EXT_spatial_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialContextPersistenceConfigEXT>
 * @xrentity{XrSpatialContextPersistenceConfigEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialContextPersistenceConfigEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialContextPersistenceConfigEXT(uint32_t persistenceContextCount_,
                                     const SpatialPersistenceContextEXT* persistenceContexts_,
                                     const void* next_ = nullptr)
      : Parent(StructureType::SpatialContextPersistenceConfigEXT, next_),
        persistenceContextCount{persistenceContextCount_},
        persistenceContexts{persistenceContexts_} {}

  //! Default/empty constructor
  SpatialContextPersistenceConfigEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialContextPersistenceConfigEXT, next_),
        persistenceContextCount{0},
        persistenceContexts{nullptr} {}

  //! Default copy constructor
  SpatialContextPersistenceConfigEXT(const SpatialContextPersistenceConfigEXT& rhs) = default;
  //! Default copy assignment
  SpatialContextPersistenceConfigEXT& operator=(const SpatialContextPersistenceConfigEXT& rhs) =
      default;
  //! Copy construct from raw
  SpatialContextPersistenceConfigEXT(const XrSpatialContextPersistenceConfigEXT& rhs)
      : SpatialContextPersistenceConfigEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialContextPersistenceConfigEXT& operator=(const XrSpatialContextPersistenceConfigEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialContextPersistenceConfigEXT&() const {
    return *reinterpret_cast<const XrSpatialContextPersistenceConfigEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialContextPersistenceConfigEXT&() {
    return *reinterpret_cast<XrSpatialContextPersistenceConfigEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialContextPersistenceConfigEXT
  XrSpatialContextPersistenceConfigEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialContextPersistenceConfigEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialContextPersistenceConfigEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialContextPersistenceConfigEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialContextPersistenceConfigEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialContextPersistenceConfigEXT*>(this);
  }
  uint32_t persistenceContextCount;
  const SpatialPersistenceContextEXT* persistenceContexts;
};
static_assert(sizeof(XrSpatialContextPersistenceConfigEXT) ==
                  sizeof(SpatialContextPersistenceConfigEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialContextPersistenceConfigEXT pointer to const from
 * a SpatialContextPersistenceConfigEXT reference to const.
 * @relates SpatialContextPersistenceConfigEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialContextPersistenceConfigEXT const* get(
    SpatialContextPersistenceConfigEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialContextPersistenceConfigEXT as the address of a raw XrSpatialContextPersistenceConfigEXT
 * @relates SpatialContextPersistenceConfigEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialContextPersistenceConfigEXT* put(
    SpatialContextPersistenceConfigEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_persistence

#ifdef XR_EXT_spatial_persistence
/*!
 * C++ projection of XrSpatialDiscoveryPersistenceUuidFilterEXT
 *
 * Provided by the `XR_EXT_spatial_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialDiscoveryPersistenceUuidFilterEXT>
 * @xrentity{XrSpatialDiscoveryPersistenceUuidFilterEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialDiscoveryPersistenceUuidFilterEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialDiscoveryPersistenceUuidFilterEXT(uint32_t persistedUuidCount_,
                                           const Uuid* persistedUuids_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialDiscoveryPersistenceUuidFilterEXT, next_),
        persistedUuidCount{persistedUuidCount_},
        persistedUuids{persistedUuids_} {}

  //! Default/empty constructor
  SpatialDiscoveryPersistenceUuidFilterEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialDiscoveryPersistenceUuidFilterEXT, next_),
        persistedUuidCount{0},
        persistedUuids{nullptr} {}

  //! Default copy constructor
  SpatialDiscoveryPersistenceUuidFilterEXT(const SpatialDiscoveryPersistenceUuidFilterEXT& rhs) =
      default;
  //! Default copy assignment
  SpatialDiscoveryPersistenceUuidFilterEXT& operator=(
      const SpatialDiscoveryPersistenceUuidFilterEXT& rhs) = default;
  //! Copy construct from raw
  SpatialDiscoveryPersistenceUuidFilterEXT(const XrSpatialDiscoveryPersistenceUuidFilterEXT& rhs)
      : SpatialDiscoveryPersistenceUuidFilterEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialDiscoveryPersistenceUuidFilterEXT& operator=(
      const XrSpatialDiscoveryPersistenceUuidFilterEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialDiscoveryPersistenceUuidFilterEXT&() const {
    return *reinterpret_cast<const XrSpatialDiscoveryPersistenceUuidFilterEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialDiscoveryPersistenceUuidFilterEXT&() {
    return *reinterpret_cast<XrSpatialDiscoveryPersistenceUuidFilterEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialDiscoveryPersistenceUuidFilterEXT
  XrSpatialDiscoveryPersistenceUuidFilterEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialDiscoveryPersistenceUuidFilterEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialDiscoveryPersistenceUuidFilterEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialDiscoveryPersistenceUuidFilterEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialDiscoveryPersistenceUuidFilterEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialDiscoveryPersistenceUuidFilterEXT*>(this);
  }
  uint32_t persistedUuidCount;
  const Uuid* persistedUuids;
};
static_assert(sizeof(XrSpatialDiscoveryPersistenceUuidFilterEXT) ==
                  sizeof(SpatialDiscoveryPersistenceUuidFilterEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialDiscoveryPersistenceUuidFilterEXT pointer to
 * const from a SpatialDiscoveryPersistenceUuidFilterEXT reference to const.
 * @relates SpatialDiscoveryPersistenceUuidFilterEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialDiscoveryPersistenceUuidFilterEXT const* get(
    SpatialDiscoveryPersistenceUuidFilterEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialDiscoveryPersistenceUuidFilterEXT as the address of a raw
 * XrSpatialDiscoveryPersistenceUuidFilterEXT
 * @relates SpatialDiscoveryPersistenceUuidFilterEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialDiscoveryPersistenceUuidFilterEXT* put(
    SpatialDiscoveryPersistenceUuidFilterEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_persistence

#ifdef XR_EXT_spatial_persistence
/*!
 * C++ projection of XrSpatialPersistenceDataEXT
 *
 * Provided by the `XR_EXT_spatial_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialPersistenceDataEXT>
 * @xrentity{XrSpatialPersistenceDataEXT}
 * @ingroup structs
 */
struct XR_MAY_ALIAS SpatialPersistenceDataEXT {
public:
  //! Constructor initializing all members.
  SpatialPersistenceDataEXT(const Uuid& persistUuid_,
                            const SpatialPersistenceStateEXT& persistState_)
      : persistUuid{persistUuid_}, persistState{persistState_} {}

  //! Default/empty constructor
  SpatialPersistenceDataEXT()

      : persistUuid{}, persistState{} {}

  //! Default copy constructor
  SpatialPersistenceDataEXT(const SpatialPersistenceDataEXT& rhs) = default;
  //! Default copy assignment
  SpatialPersistenceDataEXT& operator=(const SpatialPersistenceDataEXT& rhs) = default;
  //! Copy construct from raw
  SpatialPersistenceDataEXT(const XrSpatialPersistenceDataEXT& rhs) : SpatialPersistenceDataEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialPersistenceDataEXT& operator=(const XrSpatialPersistenceDataEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialPersistenceDataEXT&() const {
    return *reinterpret_cast<const XrSpatialPersistenceDataEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialPersistenceDataEXT&() {
    return *reinterpret_cast<XrSpatialPersistenceDataEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialPersistenceDataEXT
  XrSpatialPersistenceDataEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialPersistenceDataEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialPersistenceDataEXT.
   *
   * Pass false for the optional argument to skip clearing.
   */
  XrSpatialPersistenceDataEXT* put(bool clear = true) noexcept {
    if (clear) {
      *this = SpatialPersistenceDataEXT{};
    }
    return reinterpret_cast<XrSpatialPersistenceDataEXT*>(this);
  }
  Uuid persistUuid;
  SpatialPersistenceStateEXT persistState;
};
static_assert(sizeof(XrSpatialPersistenceDataEXT) == sizeof(SpatialPersistenceDataEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialPersistenceDataEXT pointer to const from a
 * SpatialPersistenceDataEXT reference to const.
 * @relates SpatialPersistenceDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialPersistenceDataEXT const* get(
    SpatialPersistenceDataEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialPersistenceDataEXT as
 * the address of a raw XrSpatialPersistenceDataEXT
 * @relates SpatialPersistenceDataEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialPersistenceDataEXT* put(SpatialPersistenceDataEXT& s,
                                                          bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_persistence

#ifdef XR_EXT_spatial_persistence
/*!
 * C++ projection of XrSpatialComponentPersistenceListEXT
 *
 * Provided by the `XR_EXT_spatial_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialComponentPersistenceListEXT>
 * @xrentity{XrSpatialComponentPersistenceListEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialComponentPersistenceListEXT : public impl::OutputStructBase {
private:
  using Parent = impl::OutputStructBase;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  SpatialComponentPersistenceListEXT(void* next_ = nullptr)

      : Parent(StructureType::SpatialComponentPersistenceListEXT, next_) {}

  //! Default copy constructor
  SpatialComponentPersistenceListEXT(const SpatialComponentPersistenceListEXT& rhs) = default;
  //! Default copy assignment
  SpatialComponentPersistenceListEXT& operator=(const SpatialComponentPersistenceListEXT& rhs) =
      default;
  //! Copy construct from raw
  SpatialComponentPersistenceListEXT(const XrSpatialComponentPersistenceListEXT& rhs)
      : SpatialComponentPersistenceListEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialComponentPersistenceListEXT& operator=(const XrSpatialComponentPersistenceListEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialComponentPersistenceListEXT&() const {
    return *reinterpret_cast<const XrSpatialComponentPersistenceListEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialComponentPersistenceListEXT&() {
    return *reinterpret_cast<XrSpatialComponentPersistenceListEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialComponentPersistenceListEXT
  XrSpatialComponentPersistenceListEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialComponentPersistenceListEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialComponentPersistenceListEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialComponentPersistenceListEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialComponentPersistenceListEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialComponentPersistenceListEXT*>(this);
  }
  uint32_t persistDataCount;
  SpatialPersistenceDataEXT* persistData;
};
static_assert(sizeof(XrSpatialComponentPersistenceListEXT) ==
                  sizeof(SpatialComponentPersistenceListEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialComponentPersistenceListEXT pointer to const from
 * a SpatialComponentPersistenceListEXT reference to const.
 * @relates SpatialComponentPersistenceListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentPersistenceListEXT const* get(
    SpatialComponentPersistenceListEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * SpatialComponentPersistenceListEXT as the address of a raw XrSpatialComponentPersistenceListEXT
 * @relates SpatialComponentPersistenceListEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialComponentPersistenceListEXT* put(
    SpatialComponentPersistenceListEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_persistence

#ifdef XR_EXT_spatial_persistence_operations
/*!
 * C++ projection of XrSpatialEntityPersistInfoEXT
 *
 * Provided by the `XR_EXT_spatial_persistence_operations` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityPersistInfoEXT>
 * @xrentity{XrSpatialEntityPersistInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityPersistInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialEntityPersistInfoEXT(const SpatialContextEXT& spatialContext_,
                              const SpatialEntityIdEXT& spatialEntityId_,
                              const void* next_ = nullptr)
      : Parent(StructureType::SpatialEntityPersistInfoEXT, next_),
        spatialContext{spatialContext_},
        spatialEntityId{spatialEntityId_} {}

  //! Default/empty constructor
  SpatialEntityPersistInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityPersistInfoEXT, next_),
        spatialContext{},
        spatialEntityId{} {}

  //! Default copy constructor
  SpatialEntityPersistInfoEXT(const SpatialEntityPersistInfoEXT& rhs) = default;
  //! Default copy assignment
  SpatialEntityPersistInfoEXT& operator=(const SpatialEntityPersistInfoEXT& rhs) = default;
  //! Copy construct from raw
  SpatialEntityPersistInfoEXT(const XrSpatialEntityPersistInfoEXT& rhs)
      : SpatialEntityPersistInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityPersistInfoEXT& operator=(const XrSpatialEntityPersistInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityPersistInfoEXT&() const {
    return *reinterpret_cast<const XrSpatialEntityPersistInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityPersistInfoEXT&() {
    return *reinterpret_cast<XrSpatialEntityPersistInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityPersistInfoEXT
  XrSpatialEntityPersistInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityPersistInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityPersistInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityPersistInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityPersistInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityPersistInfoEXT*>(this);
  }
  SpatialContextEXT spatialContext;
  SpatialEntityIdEXT spatialEntityId;
};
static_assert(sizeof(XrSpatialEntityPersistInfoEXT) == sizeof(SpatialEntityPersistInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityPersistInfoEXT pointer to const from a
 * SpatialEntityPersistInfoEXT reference to const.
 * @relates SpatialEntityPersistInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityPersistInfoEXT const* get(
    SpatialEntityPersistInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialEntityPersistInfoEXT
 * as the address of a raw XrSpatialEntityPersistInfoEXT
 * @relates SpatialEntityPersistInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityPersistInfoEXT* put(SpatialEntityPersistInfoEXT& s,
                                                            bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_persistence_operations

#ifdef XR_EXT_spatial_persistence_operations
/*!
 * C++ projection of XrPersistSpatialEntityCompletionEXT
 *
 * Provided by the `XR_EXT_spatial_persistence_operations` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPersistSpatialEntityCompletionEXT>
 * @xrentity{XrPersistSpatialEntityCompletionEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS PersistSpatialEntityCompletionEXT : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  PersistSpatialEntityCompletionEXT(void* next_ = nullptr)

      : Parent(StructureType::PersistSpatialEntityCompletionEXT, {}, next_) {}

  //! Default copy constructor
  PersistSpatialEntityCompletionEXT(const PersistSpatialEntityCompletionEXT& rhs) = default;
  //! Default copy assignment
  PersistSpatialEntityCompletionEXT& operator=(const PersistSpatialEntityCompletionEXT& rhs) =
      default;
  //! Copy construct from raw
  PersistSpatialEntityCompletionEXT(const XrPersistSpatialEntityCompletionEXT& rhs)
      : PersistSpatialEntityCompletionEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  PersistSpatialEntityCompletionEXT& operator=(const XrPersistSpatialEntityCompletionEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrPersistSpatialEntityCompletionEXT&() const {
    return *reinterpret_cast<const XrPersistSpatialEntityCompletionEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrPersistSpatialEntityCompletionEXT&() {
    return *reinterpret_cast<XrPersistSpatialEntityCompletionEXT*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrPersistSpatialEntityCompletionEXT
  XrPersistSpatialEntityCompletionEXT const* get() const noexcept {
    return reinterpret_cast<XrPersistSpatialEntityCompletionEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrPersistSpatialEntityCompletionEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrPersistSpatialEntityCompletionEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = PersistSpatialEntityCompletionEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrPersistSpatialEntityCompletionEXT*>(this);
  }
  SpatialPersistenceContextResultEXT persistResult;
  Uuid persistUuid;
};
static_assert(sizeof(XrPersistSpatialEntityCompletionEXT) ==
                  sizeof(PersistSpatialEntityCompletionEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrPersistSpatialEntityCompletionEXT pointer to const from
 * a PersistSpatialEntityCompletionEXT reference to const.
 * @relates PersistSpatialEntityCompletionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPersistSpatialEntityCompletionEXT const* get(
    PersistSpatialEntityCompletionEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * PersistSpatialEntityCompletionEXT as the address of a raw XrPersistSpatialEntityCompletionEXT
 * @relates PersistSpatialEntityCompletionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrPersistSpatialEntityCompletionEXT* put(
    PersistSpatialEntityCompletionEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const PersistSpatialEntityCompletionEXT as a
 * raw, pointer to const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates PersistSpatialEntityCompletionEXT
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    PersistSpatialEntityCompletionEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_spatial_persistence_operations

#ifdef XR_EXT_spatial_persistence_operations
/*!
 * C++ projection of XrSpatialEntityUnpersistInfoEXT
 *
 * Provided by the `XR_EXT_spatial_persistence_operations` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityUnpersistInfoEXT>
 * @xrentity{XrSpatialEntityUnpersistInfoEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS SpatialEntityUnpersistInfoEXT : public impl::InputStructBase {
private:
  using Parent = impl::InputStructBase;

public:
  //! Constructor initializing all members.
  SpatialEntityUnpersistInfoEXT(const Uuid& persistUuid_, const void* next_ = nullptr)
      : Parent(StructureType::SpatialEntityUnpersistInfoEXT, next_), persistUuid{persistUuid_} {}

  //! Default/empty constructor
  SpatialEntityUnpersistInfoEXT(const void* next_ = nullptr)

      : Parent(StructureType::SpatialEntityUnpersistInfoEXT, next_), persistUuid{} {}

  //! Default copy constructor
  SpatialEntityUnpersistInfoEXT(const SpatialEntityUnpersistInfoEXT& rhs) = default;
  //! Default copy assignment
  SpatialEntityUnpersistInfoEXT& operator=(const SpatialEntityUnpersistInfoEXT& rhs) = default;
  //! Copy construct from raw
  SpatialEntityUnpersistInfoEXT(const XrSpatialEntityUnpersistInfoEXT& rhs)
      : SpatialEntityUnpersistInfoEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  SpatialEntityUnpersistInfoEXT& operator=(const XrSpatialEntityUnpersistInfoEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrSpatialEntityUnpersistInfoEXT&() const {
    return *reinterpret_cast<const XrSpatialEntityUnpersistInfoEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrSpatialEntityUnpersistInfoEXT&() {
    return *reinterpret_cast<XrSpatialEntityUnpersistInfoEXT*>(this);
  }

  //! Accessor for this as the address of a raw XrSpatialEntityUnpersistInfoEXT
  XrSpatialEntityUnpersistInfoEXT const* get() const noexcept {
    return reinterpret_cast<XrSpatialEntityUnpersistInfoEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrSpatialEntityUnpersistInfoEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrSpatialEntityUnpersistInfoEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = SpatialEntityUnpersistInfoEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrSpatialEntityUnpersistInfoEXT*>(this);
  }
  Uuid persistUuid;
};
static_assert(sizeof(XrSpatialEntityUnpersistInfoEXT) == sizeof(SpatialEntityUnpersistInfoEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrSpatialEntityUnpersistInfoEXT pointer to const from a
 * SpatialEntityUnpersistInfoEXT reference to const.
 * @relates SpatialEntityUnpersistInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityUnpersistInfoEXT const* get(
    SpatialEntityUnpersistInfoEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing SpatialEntityUnpersistInfoEXT
 * as the address of a raw XrSpatialEntityUnpersistInfoEXT
 * @relates SpatialEntityUnpersistInfoEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrSpatialEntityUnpersistInfoEXT* put(SpatialEntityUnpersistInfoEXT& s,
                                                              bool clear = true) noexcept {
  return s.put(clear);
}
#endif  // XR_EXT_spatial_persistence_operations

#ifdef XR_EXT_spatial_persistence_operations
/*!
 * C++ projection of XrUnpersistSpatialEntityCompletionEXT
 *
 * Provided by the `XR_EXT_spatial_persistence_operations` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrUnpersistSpatialEntityCompletionEXT>
 * @xrentity{XrUnpersistSpatialEntityCompletionEXT}
 * @ingroup typedstructs
 */
struct XR_MAY_ALIAS UnpersistSpatialEntityCompletionEXT : public FutureCompletionBaseHeaderEXT {
private:
  using Parent = FutureCompletionBaseHeaderEXT;

public:
  //! Empty constructor for a type that is marked as "returnonly"
  UnpersistSpatialEntityCompletionEXT(void* next_ = nullptr)

      : Parent(StructureType::UnpersistSpatialEntityCompletionEXT, {}, next_) {}

  //! Default copy constructor
  UnpersistSpatialEntityCompletionEXT(const UnpersistSpatialEntityCompletionEXT& rhs) = default;
  //! Default copy assignment
  UnpersistSpatialEntityCompletionEXT& operator=(const UnpersistSpatialEntityCompletionEXT& rhs) =
      default;
  //! Copy construct from raw
  UnpersistSpatialEntityCompletionEXT(const XrUnpersistSpatialEntityCompletionEXT& rhs)
      : UnpersistSpatialEntityCompletionEXT() {
    *put() = rhs;
  }
  //! Copy assign from raw
  UnpersistSpatialEntityCompletionEXT& operator=(const XrUnpersistSpatialEntityCompletionEXT& rhs) {
    if ((const void*)this == (const void*)&rhs) return *this;
    *put() = rhs;
    return *this;
  }
  //! Conversion operator to a reference to const of the original OpenXR type.
  operator const XrUnpersistSpatialEntityCompletionEXT&() const {
    return *reinterpret_cast<const XrUnpersistSpatialEntityCompletionEXT*>(this);
  }

  //! Conversion operator to a reference to the original OpenXR type.
  operator XrUnpersistSpatialEntityCompletionEXT&() {
    return *reinterpret_cast<XrUnpersistSpatialEntityCompletionEXT*>(this);
  }

  //! Accessor for this as a raw, base XrFutureCompletionBaseHeaderEXT const pointer
  XrFutureCompletionBaseHeaderEXT const* get_base() const noexcept {
    return reinterpret_cast<XrFutureCompletionBaseHeaderEXT const*>(this);
  }
  //! Accessor for this as the address of a raw XrUnpersistSpatialEntityCompletionEXT
  XrUnpersistSpatialEntityCompletionEXT const* get() const noexcept {
    return reinterpret_cast<XrUnpersistSpatialEntityCompletionEXT const*>(this);
  }

  /*!
   * @brief Accessor for clearing and passing this as the address of a raw
   * XrUnpersistSpatialEntityCompletionEXT.
   *
   * Only the value of `next` is preserved by default. Pass false for the optional argument to skip
   * clearing.
   */
  XrUnpersistSpatialEntityCompletionEXT* put(bool clear = true) noexcept {
    if (clear) {
      auto oldNext = next;
      *this = UnpersistSpatialEntityCompletionEXT{};
      next = oldNext;
    }
    return reinterpret_cast<XrUnpersistSpatialEntityCompletionEXT*>(this);
  }
  SpatialPersistenceContextResultEXT unpersistResult;
};
static_assert(sizeof(XrUnpersistSpatialEntityCompletionEXT) ==
                  sizeof(UnpersistSpatialEntityCompletionEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting a raw XrUnpersistSpatialEntityCompletionEXT pointer to const
 * from a UnpersistSpatialEntityCompletionEXT reference to const.
 * @relates UnpersistSpatialEntityCompletionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrUnpersistSpatialEntityCompletionEXT const* get(
    UnpersistSpatialEntityCompletionEXT const& s) {
  return s.get();
}

/*!
 * @brief Free function accessor for clearing (by default) and passing
 * UnpersistSpatialEntityCompletionEXT as the address of a raw XrUnpersistSpatialEntityCompletionEXT
 * @relates UnpersistSpatialEntityCompletionEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrUnpersistSpatialEntityCompletionEXT* put(
    UnpersistSpatialEntityCompletionEXT& s, bool clear = true) noexcept {
  return s.put(clear);
}
/*!
 * @brief Free function accessor for a reference to const UnpersistSpatialEntityCompletionEXT as a
 * raw, pointer to const XrFutureCompletionBaseHeaderEXT (the base type)
 * @relates UnpersistSpatialEntityCompletionEXT
 * @relatesalso FutureCompletionBaseHeaderEXT
 * @ingroup utility_accessors
 */
static OPENXR_HPP_INLINE XrFutureCompletionBaseHeaderEXT const* get_base(
    UnpersistSpatialEntityCompletionEXT const& h) {
  return h.get_base();
}
#endif  // XR_EXT_spatial_persistence_operations
}  // namespace OPENXR_HPP_NAMESPACE

#endif  // ifndef OPENXR_STRUCTS_HPP_
