// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************

/*
** Copyright (c) 2017-2023 The Khronos Group Inc.
** Copyright (c) 2019-2023 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_HANDLES_HPP_
#define OPENXR_HANDLES_HPP_
/**
 * @file
 * @brief Declares wrappers for OpenXR handle types, with function calls transformed into methods,
 * as well as free functions for those few that do not take a handle as their first argument.
 *
 * Does not include the implementations of the functions: for that, see @ref openxr_method_impls.hpp
 * @ingroup handles
 * @ingroup api_free_functions
 */

#include "openxr_atoms.hpp"
#include "openxr_enums.hpp"
#include "openxr_exceptions.hpp"
#include "openxr_flags.hpp"
#include "openxr_handles_forward.hpp"
#include "openxr_structs_forward.hpp"
#include "openxr_time.hpp"
#include "openxr_bool.hpp"
#include "openxr_dispatch_traits.hpp"

#include <openxr/openxr.h>

#ifdef OPENXR_HPP_DOXYGEN
#include <openxr/openxr_platform.h>
#endif

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#include <vector>
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#if !defined(OPENXR_HPP_INLINE)
#if defined(__clang___)
#if __has_attribute(always_inline)
#define OPENXR_HPP_INLINE __attribute__((always_inline)) __inline__
#else
#define OPENXR_HPP_INLINE inline
#endif
#elif defined(__GNUC__)
#define OPENXR_HPP_INLINE __attribute__((always_inline)) __inline__
#elif defined(_MSC_VER)
#define OPENXR_HPP_INLINE inline
#else
#define OPENXR_HPP_INLINE inline
#endif
#endif  // !OPENXR_HPP_INLINE

#if !defined(OPENXR_HPP_CONSTEXPR)
#if defined(_MSC_VER) && (_MSC_VER <= 1800)
#define OPENXR_HPP_CONSTEXPR
#else
#define OPENXR_HPP_CONSTEXPR constexpr
#endif
#endif  // !OPENXR_HPP_CONSTEXPR

#if !defined(OPENXR_HPP_SWITCH_CONSTEXPR)
//! @todo set this to constexpr in c++14
#define OPENXR_HPP_SWITCH_CONSTEXPR
#endif  // !OPENXR_HPP_SWITCH_CONSTEXPR

// 32-bit OpenXR is not typesafe for handles, so don't allow copy constructors
// on this platform by default. To enable this feature on 32-bit platforms
// please define OPENXR_HPP_TYPESAFE_CONVERSION
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__)) || \
    defined(_M_X64) || defined(__ia64) || defined(_M_IA64) || defined(__aarch64__) ||       \
    defined(__powerpc64__)
#if !defined(OPENXR_HPP_TYPESAFE_CONVERSION)
#define OPENXR_HPP_TYPESAFE_CONVERSION
#endif
#endif

#if !defined(OPENXR_HPP_NAMESPACE)
#define OPENXR_HPP_NAMESPACE xr
#endif  // !OPENXR_HPP_NAMESPACE
#if !defined(OPENXR_HPP_TYPESAFE_EXPLICIT)
#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
#define OPENXR_HPP_TYPESAFE_EXPLICIT
#else
#define OPENXR_HPP_TYPESAFE_EXPLICIT explicit
#endif
#endif  // !OPENXR_HPP_TYPESAFE_EXPLICIT

#ifdef OPENXR_HPP_DOXYGEN
#define OPENXR_HPP_NO_DEFAULT_DISPATCH
#define OPENXR_HPP_NO_SMART_HANDLE
#undef OPENXR_HPP_NO_SMART_HANDLE
#define OPENXR_HPP_DEFAULT_CORE_DISPATCHER DispatchLoaderStatic()
#undef OPENXR_HPP_DEFAULT_CORE_DISPATCHER
#define OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER
#undef OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER
#endif

/*!
 * @def OPENXR_HPP_TYPESAFE_CONVERSION
 * @brief Whether to force conversion/implicit constructors.
 *
 * Enabled by default on 64-bit platforms.
 * 32-bit OpenXR is not typesafe for handles, so this is disabled on such platforms by default.
 * To enable this feature on 32-bit platforms please define `OPENXR_HPP_TYPESAFE_CONVERSION`
 *
 * @ingroup config
 */
/*!
 * @defgroup config_dispatch Default dispatch configuration
 * @ingroup config
 */
/*!
 * @def OPENXR_HPP_NO_DEFAULT_DISPATCH
 * @brief Define to disable default dispatch arguments.
 * @see OPENXR_HPP_DEFAULT_CORE_DISPATCHER, OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE
 * @ingroup config_dispatch
 */
/*!
 * @def OPENXR_HPP_DEFAULT_CORE_DISPATCHER
 * @brief Define to the expression you'd like to use as the default dispatcher for core API
 * functions.
 *
 * Defaults to `DispatchLoaderStatic()` unless `OPENXR_HPP_NO_DEFAULT_DISPATCH` is defined.
 *
 * If both this and `OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE` are defined (by you, or by default if
 * `OPENXR_HPP_NO_DEFAULT_DISPATCH` is not defined), `OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG` will be
 * defined to `= OPENXR_HPP_DEFAULT_CORE_DISPATCHER`.
 *
 * @see DispatchLoaderStatic, OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE,
 * OPENXR_HPP_NO_DEFAULT_DISPATCH
 * @ingroup config_dispatch
 */
/*!
 * @def OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE
 * @brief Define to the type of the expression you'd like to use as the default dispatcher for core
 * API functions.
 *
 * This will be used as the default type parameter in functions where
 * `OPENXR_HPP_DEFAULT_CORE_DISPATCHER` will be the default argument.
 *
 * Defaults to `DispatchLoaderStatic` unless `OPENXR_HPP_NO_DEFAULT_DISPATCH` is defined.
 *
 * If both this and `OPENXR_HPP_DEFAULT_CORE_DISPATCHER` are defined (by you, or by default if
 * `OPENXR_HPP_NO_DEFAULT_DISPATCH` is not defined), `OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG`
 * will be defined to `= OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE`.
 *
 * @see DispatchLoaderStatic, OPENXR_HPP_DEFAULT_CORE_DISPATCHER, OPENXR_HPP_NO_DEFAULT_DISPATCH
 * @ingroup config_dispatch
 */
/*!
 * @def OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER
 * @brief Define to the expression you'd like to use as the default dispatcher for extension API
 * functions.
 *
 * This has no default value: by default, you need to provide a dispatcher explicitly for extension
 * functions. If you define this and `OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER_TYPE`, however,
 * `OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG` will be set to `=` and your definition.
 *
 * A globally-accessible instance of xr::DispatchLoaderDynamic would be suitable.
 *
 * @ingroup config_dispatch
 */

/*!
 * @def OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER_TYPE
 * @brief Define to the type expression you'd like to use as the type of the default dispatcher for
 * extension API functions.
 *
 * This has no default value: by default, you need to provide a dispatcher explicitly for extension
 * functions. If you define this and `OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER`, however,
 * `OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG` will be set to `=` and your definition.
 *
 * xr::DispatchLoaderDynamic would be suitable.
 *
 * @ingroup config_dispatch
 */
/*!
 * @def OPENXR_HPP_DISABLE_ENHANCED_MODE
 * @brief Define in order to disable the more complete C++ projections of OpenXR methods, leaving
 * only the most C-like prototypes behind.
 *
 * This will disable returning of output parameters (directly and through ReturnType pairs),
 * wrapping of two-call-idiom methods, functions creating `Unique` handles with ownership, etc.
 * It slightly reduces the number of files included.
 *
 * @ingroup config
 */

/*!
 * @def OPENXR_HPP_NO_SMART_HANDLE
 * @brief Define in order to disable the UniqueHandle-creating C++ method projections.
 *
 * Enhanced mode creation calls by default include a projection that returns a smart handle
 * representing unique ownership. Defining this macro will hide those methods.
 *
 * @see OPENXR_HPP_DISABLE_ENHANCED_MODE
 *
 * @ingroup config
 */

#ifndef OPENXR_HPP_NO_DEFAULT_DISPATCH

#if !defined(XR_NO_PROTOTYPES) && !defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER) && \
    !defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE)
#define OPENXR_HPP_DEFAULT_CORE_DISPATCHER DispatchLoaderStatic()
#define OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE DispatchLoaderStatic
#include "openxr_dispatch_static.hpp"
#endif  // !defined(XR_NO_PROTOTYPES) && !defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER)

#endif  // !OPENXR_HPP_NO_DEFAULT_DISPATCH

#if defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER) && defined(OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE)
#define OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG = OPENXR_HPP_DEFAULT_CORE_DISPATCHER
#define OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG = OPENXR_HPP_DEFAULT_CORE_DISPATCHER_TYPE
#endif

#if defined(OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER) && \
    defined(OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER_TYPE)
#define OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG = OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER
#define OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG = OPENXR_HPP_DEFAULT_EXTENSION_DISPATCHER_TYPE
#endif

#ifndef OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG
#define OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG
#endif
#ifndef OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG
#define OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG
#endif
#ifndef OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG
#define OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG
#endif
#ifndef OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG
#define OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG
#endif

namespace OPENXR_HPP_NAMESPACE {

/*!
 * @defgroup return_results Returning results
 * @brief Types used by API call wrappers to return output in a friendly, C++ manner.
 */

/*!
 * @brief Contains a Result enumerant and a returned value.
 *
 * Implicitly convertible to std::tuple<> so you can do `std::tie(result, value)
 * = callThatReturnsResultValue()`
 *
 * @ingroup return_results
 */
template <typename T>
struct ResultValue {
  ResultValue(Result r, T const& v) : result(r), value(v) {}

  ResultValue(Result r, T&& v) : result(r), value(std::move(v)) {}

  Result result;
  T value;

  operator std::tuple<Result&, T&>() { return std::tuple<Result&, T&>(result, value); }
  operator std::tuple<Result const&, T const&>() const {
    return std::tuple<Result const&, T const&>(result, value);
  }
};

}  // namespace OPENXR_HPP_NAMESPACE
namespace OPENXR_HPP_NAMESPACE {

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
// The generalization of std::string with user-specifiable allocator types.
template <typename Allocator = std::allocator<char>>
using string_with_allocator = std::basic_string<char, std::char_traits<char>, Allocator>;
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

/*!
 * @brief Handle class - wrapping XrInstance without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrInstance>
 *
 * @xrentity{XrInstance}
 * @ingroup handles
 */
class Instance {
public:
  using Type = Instance;
  using RawHandleType = XrInstance;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Instance() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrInstance type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Instance(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Instance(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrInstance
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrInstance type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Instance value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Instance value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrInstance manipulation
   * @{
   */
  //! Gets the raw XrInstance value.
  OPENXR_HPP_CONSTEXPR XrInstance get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Instance yourHandle;
   * auto result = d.xrCreateInstance(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Instance&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetInstanceProcAddr wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProcAddr>
   *
   * @xrentity{xrGetInstanceProcAddr}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getInstanceProcAddr(const char* name, PFN_xrVoidFunction* function,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetInstanceProcAddr enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProcAddr>
   *
   * @xrentity{xrGetInstanceProcAddr}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getInstanceProcAddr(const char* name, PFN_xrVoidFunction* function,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetInstanceProcAddr enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProcAddr>
   *
   * @xrentity{xrGetInstanceProcAddr}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getInstanceProcAddr(const char* name, PFN_xrVoidFunction* function,
                           Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyInstance wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyInstance>
   *
   * @xrentity{xrDestroyInstance}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyInstance enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyInstance>
   *
   * @xrentity{xrDestroyInstance}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyInstance enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyInstance>
   *
   * @xrentity{xrDestroyInstance}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetInstanceProperties wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProperties>
   *
   * @xrentity{xrGetInstanceProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getInstanceProperties(InstanceProperties& instanceProperties,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetInstanceProperties enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type InstanceProperties
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProperties>
   *
   * @xrentity{xrGetInstanceProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<InstanceProperties> getInstanceProperties(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetInstanceProperties enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type InstanceProperties
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInstanceProperties>
   *
   * @xrentity{xrGetInstanceProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  InstanceProperties getInstanceProperties(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPollEvent wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPollEvent>
   *
   * @xrentity{xrPollEvent}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result pollEvent(EventDataBuffer& eventData,
                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPollEvent enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::EventUnavailable, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPollEvent>
   *
   * @xrentity{xrPollEvent}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result pollEvent(EventDataBuffer& eventData,
                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrResultToString wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrResultToString>
   *
   * @xrentity{xrResultToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result resultToString(Result value, char buffer[XR_MAX_RESULT_STRING_SIZE],
                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrResultToString enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrResultToString>
   *
   * @xrentity{xrResultToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result resultToString(Result value, char buffer[XR_MAX_RESULT_STRING_SIZE],
                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrResultToString enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrResultToString>
   *
   * @xrentity{xrResultToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void resultToString(Result value, char buffer[XR_MAX_RESULT_STRING_SIZE],
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrStructureTypeToString wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStructureTypeToString>
   *
   * @xrentity{xrStructureTypeToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result structureTypeToString(StructureType value, char buffer[XR_MAX_STRUCTURE_NAME_SIZE],
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStructureTypeToString enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStructureTypeToString>
   *
   * @xrentity{xrStructureTypeToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result structureTypeToString(StructureType value, char buffer[XR_MAX_STRUCTURE_NAME_SIZE],
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStructureTypeToString enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStructureTypeToString>
   *
   * @xrentity{xrStructureTypeToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void structureTypeToString(StructureType value, char buffer[XR_MAX_STRUCTURE_NAME_SIZE],
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSystem wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystem>
   *
   * @xrentity{xrGetSystem}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSystem(const SystemGetInfo& getInfo, SystemId& systemId,
                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSystem enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SystemId
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystem>
   *
   * @xrentity{xrGetSystem}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SystemId> getSystem(const SystemGetInfo& getInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSystem enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SystemId
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystem>
   *
   * @xrentity{xrGetSystem}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SystemId getSystem(const SystemGetInfo& getInfo,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSystemProperties wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystemProperties>
   *
   * @xrentity{xrGetSystemProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSystemProperties(SystemId systemId, SystemProperties& properties,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSystemProperties enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SystemProperties
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystemProperties>
   *
   * @xrentity{xrGetSystemProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SystemProperties> getSystemProperties(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSystemProperties enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SystemProperties
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSystemProperties>
   *
   * @xrentity{xrGetSystemProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SystemProperties getSystemProperties(SystemId systemId,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateEnvironmentBlendModes wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateEnvironmentBlendModes(SystemId systemId,
                                        ViewConfigurationType viewConfigurationType,
                                        uint32_t environmentBlendModeCapacityInput,
                                        uint32_t& environmentBlendModeCountOutput,
                                        EnvironmentBlendMode* environmentBlendModes,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateEnvironmentBlendModes enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<EnvironmentBlendMode, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Allocator = std::allocator<EnvironmentBlendMode>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<EnvironmentBlendMode, Allocator>> enumerateEnvironmentBlendModesToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateEnvironmentBlendModes enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<EnvironmentBlendMode, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Allocator = std::allocator<EnvironmentBlendMode>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<EnvironmentBlendMode, Allocator>> enumerateEnvironmentBlendModesToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateEnvironmentBlendModes enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<EnvironmentBlendMode, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Allocator = std::allocator<EnvironmentBlendMode>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<EnvironmentBlendMode, Allocator> enumerateEnvironmentBlendModesToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateEnvironmentBlendModes enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<EnvironmentBlendMode, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentBlendModes>
   *
   * @xrentity{xrEnumerateEnvironmentBlendModes}
   */
  template <typename Allocator = std::allocator<EnvironmentBlendMode>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<EnvironmentBlendMode, Allocator> enumerateEnvironmentBlendModesToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSession(const SessionCreateInfo& createInfo, Session& session,
                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSession enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Session
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Session> createSession(const SessionCreateInfo& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSession enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Session
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Session createSession(const SessionCreateInfo& createInfo,
                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSession wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Session
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Session, impl::RemoveRefConst<Dispatch>>> createSessionUnique(
      const SessionCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSession wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Session
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSession>
   *
   * @xrentity{xrCreateSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Session, impl::RemoveRefConst<Dispatch>> createSessionUnique(
      const SessionCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateViewConfigurations wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateViewConfigurations(SystemId systemId, uint32_t viewConfigurationTypeCapacityInput,
                                     uint32_t& viewConfigurationTypeCountOutput,
                                     ViewConfigurationType* viewConfigurationTypes,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateViewConfigurations enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViewConfigurationType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Allocator = std::allocator<ViewConfigurationType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViewConfigurationType, Allocator>> enumerateViewConfigurationsToVector(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViewConfigurations enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViewConfigurationType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Allocator = std::allocator<ViewConfigurationType>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViewConfigurationType, Allocator>> enumerateViewConfigurationsToVector(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateViewConfigurations enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ViewConfigurationType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Allocator = std::allocator<ViewConfigurationType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViewConfigurationType, Allocator> enumerateViewConfigurationsToVector(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViewConfigurations enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ViewConfigurationType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurations>
   *
   * @xrentity{xrEnumerateViewConfigurations}
   */
  template <typename Allocator = std::allocator<ViewConfigurationType>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViewConfigurationType, Allocator> enumerateViewConfigurationsToVector(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetViewConfigurationProperties wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetViewConfigurationProperties>
   *
   * @xrentity{xrGetViewConfigurationProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getViewConfigurationProperties(SystemId systemId,
                                        ViewConfigurationType viewConfigurationType,
                                        ViewConfigurationProperties& configurationProperties,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetViewConfigurationProperties enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ViewConfigurationProperties
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetViewConfigurationProperties>
   *
   * @xrentity{xrGetViewConfigurationProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ViewConfigurationProperties> getViewConfigurationProperties(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetViewConfigurationProperties enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ViewConfigurationProperties
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetViewConfigurationProperties>
   *
   * @xrentity{xrGetViewConfigurationProperties}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ViewConfigurationProperties getViewConfigurationProperties(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateViewConfigurationViews wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateViewConfigurationViews(SystemId systemId,
                                         ViewConfigurationType viewConfigurationType,
                                         uint32_t viewCapacityInput, uint32_t& viewCountOutput,
                                         ViewConfigurationView* views,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateViewConfigurationViews enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViewConfigurationView, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Allocator = std::allocator<ViewConfigurationView>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViewConfigurationView, Allocator>>
  enumerateViewConfigurationViewsToVector(SystemId systemId,
                                          ViewConfigurationType viewConfigurationType,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViewConfigurationViews enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViewConfigurationView, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Allocator = std::allocator<ViewConfigurationView>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViewConfigurationView, Allocator>>
  enumerateViewConfigurationViewsToVector(SystemId systemId,
                                          ViewConfigurationType viewConfigurationType,
                                          Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateViewConfigurationViews enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ViewConfigurationView, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Allocator = std::allocator<ViewConfigurationView>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViewConfigurationView, Allocator> enumerateViewConfigurationViewsToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViewConfigurationViews enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ViewConfigurationView, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViewConfigurationViews>
   *
   * @xrentity{xrEnumerateViewConfigurationViews}
   */
  template <typename Allocator = std::allocator<ViewConfigurationView>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViewConfigurationView, Allocator> enumerateViewConfigurationViewsToVector(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrStringToPath wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStringToPath>
   *
   * @xrentity{xrStringToPath}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stringToPath(const char* pathString, Path& path,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStringToPath enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Path
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStringToPath>
   *
   * @xrentity{xrStringToPath}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Path> stringToPath(const char* pathString,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStringToPath enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Path
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStringToPath>
   *
   * @xrentity{xrStringToPath}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Path stringToPath(const char* pathString,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrPathToString wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result pathToString(Path path, uint32_t bufferCapacityInput, uint32_t& bufferCountOutput,
                      char* buffer, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPathToString enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> pathToString(
      Path path, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrPathToString enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> pathToString(Path path,
                                                             Allocator const& vectorAllocator,
                                                             Dispatch&& d) const;

#else
  /*!
   * @brief xrPathToString enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> pathToString(
      Path path, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrPathToString enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPathToString>
   *
   * @xrentity{xrPathToString}
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> pathToString(Path path, Allocator const& vectorAllocator,
                                                Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateActionSet wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createActionSet(const ActionSetCreateInfo& createInfo, ActionSet& actionSet,
                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateActionSet enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionSet
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionSet> createActionSet(const ActionSetCreateInfo& createInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateActionSet enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionSet
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionSet createActionSet(const ActionSetCreateInfo& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateActionSet wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a ActionSet
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>>> createActionSetUnique(
      const ActionSetCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateActionSet wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a ActionSet
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSet>
   *
   * @xrentity{xrCreateActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<ActionSet, impl::RemoveRefConst<Dispatch>> createActionSetUnique(
      const ActionSetCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSuggestInteractionProfileBindings wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSuggestInteractionProfileBindings>
   *
   * @xrentity{xrSuggestInteractionProfileBindings}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result suggestInteractionProfileBindings(
      const InteractionProfileSuggestedBinding& suggestedBindings,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSuggestInteractionProfileBindings enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSuggestInteractionProfileBindings>
   *
   * @xrentity{xrSuggestInteractionProfileBindings}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result suggestInteractionProfileBindings(
      const InteractionProfileSuggestedBinding& suggestedBindings,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSuggestInteractionProfileBindings enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSuggestInteractionProfileBindings>
   *
   * @xrentity{xrSuggestInteractionProfileBindings}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void suggestInteractionProfileBindings(
      const InteractionProfileSuggestedBinding& suggestedBindings,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_KHR_opengl_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL)

  /*!
   * @brief xrGetOpenGLGraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getOpenGLGraphicsRequirementsKHR(SystemId systemId,
                                          GraphicsRequirementsOpenGLKHR& graphicsRequirements,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetOpenGLGraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsOpenGLKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsOpenGLKHR> getOpenGLGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetOpenGLGraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsOpenGLKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsOpenGLKHR getOpenGLGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_OPENGL)
#endif  // XR_KHR_opengl_enable

#ifdef XR_KHR_opengl_es_enable
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)

  /*!
   * @brief xrGetOpenGLESGraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLESGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLESGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getOpenGLESGraphicsRequirementsKHR(SystemId systemId,
                                            GraphicsRequirementsOpenGLESKHR& graphicsRequirements,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetOpenGLESGraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsOpenGLESKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLESGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLESGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsOpenGLESKHR> getOpenGLESGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetOpenGLESGraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsOpenGLESKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetOpenGLESGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetOpenGLESGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsOpenGLESKHR getOpenGLESGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#endif  // XR_KHR_opengl_es_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanInstanceExtensionsKHR(SystemId systemId, uint32_t bufferCapacityInput,
                                        uint32_t& bufferCountOutput, char* buffer,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getVulkanInstanceExtensionsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getVulkanInstanceExtensionsKHR(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getVulkanInstanceExtensionsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVulkanInstanceExtensionsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanInstanceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanInstanceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getVulkanInstanceExtensionsKHR(SystemId systemId,
                                                                  Allocator const& vectorAllocator,
                                                                  Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanDeviceExtensionsKHR(SystemId systemId, uint32_t bufferCapacityInput,
                                      uint32_t& bufferCountOutput, char* buffer,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getVulkanDeviceExtensionsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getVulkanDeviceExtensionsKHR(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getVulkanDeviceExtensionsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVulkanDeviceExtensionsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanDeviceExtensionsKHR>
   *
   * @xrentity{xrGetVulkanDeviceExtensionsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getVulkanDeviceExtensionsKHR(SystemId systemId,
                                                                Allocator const& vectorAllocator,
                                                                Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanGraphicsDeviceKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDeviceKHR>
   *
   * @xrentity{xrGetVulkanGraphicsDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanGraphicsDeviceKHR(SystemId systemId, VkInstance vkInstance,
                                    VkPhysicalDevice* vkPhysicalDevice,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanGraphicsDeviceKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type VkPhysicalDevice
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDeviceKHR>
   *
   * @xrentity{xrGetVulkanGraphicsDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<VkPhysicalDevice> getVulkanGraphicsDeviceKHR(
      SystemId systemId, VkInstance vkInstance,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVulkanGraphicsDeviceKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type VkPhysicalDevice
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDeviceKHR>
   *
   * @xrentity{xrGetVulkanGraphicsDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  VkPhysicalDevice getVulkanGraphicsDeviceKHR(SystemId systemId, VkInstance vkInstance,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_vulkan_enable
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanGraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanGraphicsRequirementsKHR(SystemId systemId,
                                          GraphicsRequirementsVulkanKHR& graphicsRequirements,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanGraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsVulkanKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsVulkanKHR> getVulkanGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVulkanGraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsVulkanKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsVulkanKHR getVulkanGraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable

#ifdef XR_KHR_D3D11_enable
#if defined(XR_USE_GRAPHICS_API_D3D11)

  /*!
   * @brief xrGetD3D11GraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D11GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D11GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getD3D11GraphicsRequirementsKHR(SystemId systemId,
                                         GraphicsRequirementsD3D11KHR& graphicsRequirements,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetD3D11GraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsD3D11KHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D11GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D11GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsD3D11KHR> getD3D11GraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetD3D11GraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsD3D11KHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D11GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D11GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsD3D11KHR getD3D11GraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_D3D11)
#endif  // XR_KHR_D3D11_enable

#ifdef XR_KHR_D3D12_enable
#if defined(XR_USE_GRAPHICS_API_D3D12)

  /*!
   * @brief xrGetD3D12GraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D12GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D12GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getD3D12GraphicsRequirementsKHR(SystemId systemId,
                                         GraphicsRequirementsD3D12KHR& graphicsRequirements,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetD3D12GraphicsRequirementsKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsD3D12KHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D12GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D12GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsD3D12KHR> getD3D12GraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetD3D12GraphicsRequirementsKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsD3D12KHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetD3D12GraphicsRequirementsKHR>
   *
   * @xrentity{xrGetD3D12GraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsD3D12KHR getD3D12GraphicsRequirementsKHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_D3D12)
#endif  // XR_KHR_D3D12_enable

#ifdef XR_KHR_metal_enable
#if defined(XR_USE_GRAPHICS_API_METAL)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetMetalGraphicsRequirementsKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMetalGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetMetalGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getMetalGraphicsRequirementsKHR(SystemId systemId,
                                         GraphicsRequirementsMetalKHR& graphicsRequirements,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetMetalGraphicsRequirementsKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMetalGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetMetalGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getMetalGraphicsRequirementsKHR(SystemId systemId,
                                         GraphicsRequirementsMetalKHR& graphicsRequirements,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetMetalGraphicsRequirementsKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMetalGraphicsRequirementsKHR>
   *
   * @xrentity{xrGetMetalGraphicsRequirementsKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getMetalGraphicsRequirementsKHR(SystemId systemId,
                                       GraphicsRequirementsMetalKHR& graphicsRequirements,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_METAL)
#endif  // XR_KHR_metal_enable

#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

  /*!
   * @brief xrConvertWin32PerformanceCounterToTimeKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertWin32PerformanceCounterToTimeKHR>
   *
   * @xrentity{xrConvertWin32PerformanceCounterToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result convertWin32PerformanceCounterToTimeKHR(
      const LARGE_INTEGER* performanceCounter, Time& time,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrConvertWin32PerformanceCounterToTimeKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Time
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertWin32PerformanceCounterToTimeKHR>
   *
   * @xrentity{xrConvertWin32PerformanceCounterToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Time> convertWin32PerformanceCounterToTimeKHR(
      const LARGE_INTEGER* performanceCounter,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrConvertWin32PerformanceCounterToTimeKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Time
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertWin32PerformanceCounterToTimeKHR>
   *
   * @xrentity{xrConvertWin32PerformanceCounterToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Time convertWin32PerformanceCounterToTimeKHR(const LARGE_INTEGER* performanceCounter,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time

#ifdef XR_KHR_win32_convert_performance_counter_time
#if defined(XR_USE_PLATFORM_WIN32)

  /*!
   * @brief xrConvertTimeToWin32PerformanceCounterKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToWin32PerformanceCounterKHR>
   *
   * @xrentity{xrConvertTimeToWin32PerformanceCounterKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result convertTimeToWin32PerformanceCounterKHR(Time time, LARGE_INTEGER* performanceCounter,
                                                 Dispatch&& d
                                                     OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrConvertTimeToWin32PerformanceCounterKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type LARGE_INTEGER
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToWin32PerformanceCounterKHR>
   *
   * @xrentity{xrConvertTimeToWin32PerformanceCounterKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<LARGE_INTEGER> convertTimeToWin32PerformanceCounterKHR(
      Time time, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrConvertTimeToWin32PerformanceCounterKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type LARGE_INTEGER
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToWin32PerformanceCounterKHR>
   *
   * @xrentity{xrConvertTimeToWin32PerformanceCounterKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  LARGE_INTEGER convertTimeToWin32PerformanceCounterKHR(
      Time time, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_KHR_win32_convert_performance_counter_time

#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

  /*!
   * @brief xrConvertTimespecTimeToTimeKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimespecTimeToTimeKHR>
   *
   * @xrentity{xrConvertTimespecTimeToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result convertTimespecTimeToTimeKHR(const struct timespec* timespecTime, Time& time,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrConvertTimespecTimeToTimeKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Time
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimespecTimeToTimeKHR>
   *
   * @xrentity{xrConvertTimespecTimeToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Time> convertTimespecTimeToTimeKHR(
      const struct timespec* timespecTime, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrConvertTimespecTimeToTimeKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Time
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimespecTimeToTimeKHR>
   *
   * @xrentity{xrConvertTimespecTimeToTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Time convertTimespecTimeToTimeKHR(const struct timespec* timespecTime,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time

#ifdef XR_KHR_convert_timespec_time
#if defined(XR_USE_TIMESPEC)

  /*!
   * @brief xrConvertTimeToTimespecTimeKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToTimespecTimeKHR>
   *
   * @xrentity{xrConvertTimeToTimespecTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result convertTimeToTimespecTimeKHR(Time time, struct timespec* timespecTime,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrConvertTimeToTimespecTimeKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type timespec
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToTimespecTimeKHR>
   *
   * @xrentity{xrConvertTimeToTimespecTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<timespec> convertTimeToTimespecTimeKHR(
      Time time, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrConvertTimeToTimespecTimeKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type timespec
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrConvertTimeToTimespecTimeKHR>
   *
   * @xrentity{xrConvertTimeToTimespecTimeKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  timespec convertTimeToTimespecTimeKHR(Time time,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_TIMESPEC)
#endif  // XR_KHR_convert_timespec_time

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrCreateVulkanInstanceKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanInstanceKHR>
   *
   * @xrentity{xrCreateVulkanInstanceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVulkanInstanceKHR(const VulkanInstanceCreateInfoKHR& createInfo,
                                 VkInstance* vulkanInstance, VkResult* vulkanResult,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateVulkanInstanceKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanInstanceKHR>
   *
   * @xrentity{xrCreateVulkanInstanceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVulkanInstanceKHR(const VulkanInstanceCreateInfoKHR& createInfo,
                                 VkInstance* vulkanInstance, VkResult* vulkanResult,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateVulkanInstanceKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanInstanceKHR>
   *
   * @xrentity{xrCreateVulkanInstanceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void createVulkanInstanceKHR(const VulkanInstanceCreateInfoKHR& createInfo,
                               VkInstance* vulkanInstance, VkResult* vulkanResult,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrCreateVulkanDeviceKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanDeviceKHR>
   *
   * @xrentity{xrCreateVulkanDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVulkanDeviceKHR(const VulkanDeviceCreateInfoKHR& createInfo, VkDevice* vulkanDevice,
                               VkResult* vulkanResult,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateVulkanDeviceKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanDeviceKHR>
   *
   * @xrentity{xrCreateVulkanDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVulkanDeviceKHR(const VulkanDeviceCreateInfoKHR& createInfo, VkDevice* vulkanDevice,
                               VkResult* vulkanResult,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateVulkanDeviceKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVulkanDeviceKHR>
   *
   * @xrentity{xrCreateVulkanDeviceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void createVulkanDeviceKHR(const VulkanDeviceCreateInfoKHR& createInfo, VkDevice* vulkanDevice,
                             VkResult* vulkanResult,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanGraphicsDevice2KHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDevice2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsDevice2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanGraphicsDevice2KHR(const VulkanGraphicsDeviceGetInfoKHR& getInfo,
                                     VkPhysicalDevice* vulkanPhysicalDevice,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanGraphicsDevice2KHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type VkPhysicalDevice
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDevice2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsDevice2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<VkPhysicalDevice> getVulkanGraphicsDevice2KHR(
      const VulkanGraphicsDeviceGetInfoKHR& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVulkanGraphicsDevice2KHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type VkPhysicalDevice
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsDevice2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsDevice2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  VkPhysicalDevice getVulkanGraphicsDevice2KHR(const VulkanGraphicsDeviceGetInfoKHR& getInfo,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_vulkan_enable2
#if defined(XR_USE_GRAPHICS_API_VULKAN)

  /*!
   * @brief xrGetVulkanGraphicsRequirements2KHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirements2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirements2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVulkanGraphicsRequirements2KHR(SystemId systemId,
                                           GraphicsRequirementsVulkanKHR& graphicsRequirements,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVulkanGraphicsRequirements2KHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GraphicsRequirementsVulkanKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirements2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirements2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GraphicsRequirementsVulkanKHR> getVulkanGraphicsRequirements2KHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVulkanGraphicsRequirements2KHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GraphicsRequirementsVulkanKHR
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVulkanGraphicsRequirements2KHR>
   *
   * @xrentity{xrGetVulkanGraphicsRequirements2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GraphicsRequirementsVulkanKHR getVulkanGraphicsRequirements2KHR(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_GRAPHICS_API_VULKAN)
#endif  // XR_KHR_vulkan_enable2

#ifdef XR_KHR_extended_struct_name_lengths

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrStructureTypeToString2KHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStructureTypeToString2KHR>
   *
   * @xrentity{xrStructureTypeToString2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result structureTypeToString2KHR(StructureType value,
                                   char buffer[XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR],
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStructureTypeToString2KHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStructureTypeToString2KHR>
   *
   * @xrentity{xrStructureTypeToString2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result structureTypeToString2KHR(StructureType value,
                                   char buffer[XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR],
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStructureTypeToString2KHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStructureTypeToString2KHR>
   *
   * @xrentity{xrStructureTypeToString2KHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void structureTypeToString2KHR(StructureType value,
                                 char buffer[XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR],
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_KHR_extended_struct_name_lengths

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetDebugUtilsObjectNameEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDebugUtilsObjectNameEXT>
   *
   * @xrentity{xrSetDebugUtilsObjectNameEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setDebugUtilsObjectNameEXT(const DebugUtilsObjectNameInfoEXT& nameInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetDebugUtilsObjectNameEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDebugUtilsObjectNameEXT>
   *
   * @xrentity{xrSetDebugUtilsObjectNameEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setDebugUtilsObjectNameEXT(const DebugUtilsObjectNameInfoEXT& nameInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetDebugUtilsObjectNameEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDebugUtilsObjectNameEXT>
   *
   * @xrentity{xrSetDebugUtilsObjectNameEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setDebugUtilsObjectNameEXT(const DebugUtilsObjectNameInfoEXT& nameInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

  /*!
   * @brief xrCreateDebugUtilsMessengerEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createDebugUtilsMessengerEXT(const DebugUtilsMessengerCreateInfoEXT& createInfo,
                                      DebugUtilsMessengerEXT& messenger,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateDebugUtilsMessengerEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type DebugUtilsMessengerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<DebugUtilsMessengerEXT> createDebugUtilsMessengerEXT(
      const DebugUtilsMessengerCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateDebugUtilsMessengerEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type DebugUtilsMessengerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  DebugUtilsMessengerEXT createDebugUtilsMessengerEXT(
      const DebugUtilsMessengerCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateDebugUtilsMessengerEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a DebugUtilsMessengerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>>
  createDebugUtilsMessengerUniqueEXT(const DebugUtilsMessengerCreateInfoEXT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateDebugUtilsMessengerEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a DebugUtilsMessengerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateDebugUtilsMessengerEXT>
   *
   * @xrentity{xrCreateDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<DebugUtilsMessengerEXT, impl::RemoveRefConst<Dispatch>>
  createDebugUtilsMessengerUniqueEXT(const DebugUtilsMessengerCreateInfoEXT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSubmitDebugUtilsMessageEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSubmitDebugUtilsMessageEXT>
   *
   * @xrentity{xrSubmitDebugUtilsMessageEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result submitDebugUtilsMessageEXT(XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
                                    XrDebugUtilsMessageTypeFlagsEXT messageTypes,
                                    const DebugUtilsMessengerCallbackDataEXT& callbackData,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSubmitDebugUtilsMessageEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSubmitDebugUtilsMessageEXT>
   *
   * @xrentity{xrSubmitDebugUtilsMessageEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result submitDebugUtilsMessageEXT(XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
                                    XrDebugUtilsMessageTypeFlagsEXT messageTypes,
                                    const DebugUtilsMessengerCallbackDataEXT& callbackData,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSubmitDebugUtilsMessageEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSubmitDebugUtilsMessageEXT>
   *
   * @xrentity{xrSubmitDebugUtilsMessageEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void submitDebugUtilsMessageEXT(XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
                                  XrDebugUtilsMessageTypeFlagsEXT messageTypes,
                                  const DebugUtilsMessengerCallbackDataEXT& callbackData,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_MSFT_composition_layer_reprojection

  /*!
   * @brief xrEnumerateReprojectionModesMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReprojectionModesMSFT>
   *
   * @xrentity{xrEnumerateReprojectionModesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateReprojectionModesMSFT(SystemId systemId,
                                        ViewConfigurationType viewConfigurationType,
                                        uint32_t modeCapacityInput, uint32_t& modeCountOutput,
                                        ReprojectionModeMSFT* modes,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateReprojectionModesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ReprojectionModeMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReprojectionModesMSFT>
   *
   * @xrentity{xrEnumerateReprojectionModesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ReprojectionModeMSFT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ReprojectionModeMSFT, Allocator>> enumerateReprojectionModesToVectorMSFT(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateReprojectionModesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ReprojectionModeMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReprojectionModesMSFT>
   *
   * @xrentity{xrEnumerateReprojectionModesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ReprojectionModeMSFT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ReprojectionModeMSFT, Allocator>> enumerateReprojectionModesToVectorMSFT(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateReprojectionModesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ReprojectionModeMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReprojectionModesMSFT>
   *
   * @xrentity{xrEnumerateReprojectionModesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ReprojectionModeMSFT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ReprojectionModeMSFT, Allocator> enumerateReprojectionModesToVectorMSFT(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateReprojectionModesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ReprojectionModeMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReprojectionModesMSFT>
   *
   * @xrentity{xrEnumerateReprojectionModesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ReprojectionModeMSFT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ReprojectionModeMSFT, Allocator> enumerateReprojectionModesToVectorMSFT(
      SystemId systemId, ViewConfigurationType viewConfigurationType,
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_composition_layer_reprojection

#ifdef XR_MSFT_scene_understanding

  /*!
   * @brief xrEnumerateSceneComputeFeaturesMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSceneComputeFeaturesMSFT>
   *
   * @xrentity{xrEnumerateSceneComputeFeaturesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSceneComputeFeaturesMSFT(SystemId systemId, uint32_t featureCapacityInput,
                                           uint32_t& featureCountOutput,
                                           SceneComputeFeatureMSFT* features,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSceneComputeFeaturesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SceneComputeFeatureMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSceneComputeFeaturesMSFT>
   *
   * @xrentity{xrEnumerateSceneComputeFeaturesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SceneComputeFeatureMSFT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SceneComputeFeatureMSFT, Allocator>>
  enumerateSceneComputeFeaturesToVectorMSFT(SystemId systemId,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSceneComputeFeaturesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SceneComputeFeatureMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSceneComputeFeaturesMSFT>
   *
   * @xrentity{xrEnumerateSceneComputeFeaturesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SceneComputeFeatureMSFT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SceneComputeFeatureMSFT, Allocator>>
  enumerateSceneComputeFeaturesToVectorMSFT(SystemId systemId, Allocator const& vectorAllocator,
                                            Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateSceneComputeFeaturesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<SceneComputeFeatureMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSceneComputeFeaturesMSFT>
   *
   * @xrentity{xrEnumerateSceneComputeFeaturesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SceneComputeFeatureMSFT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SceneComputeFeatureMSFT, Allocator> enumerateSceneComputeFeaturesToVectorMSFT(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSceneComputeFeaturesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<SceneComputeFeatureMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSceneComputeFeaturesMSFT>
   *
   * @xrentity{xrEnumerateSceneComputeFeaturesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SceneComputeFeatureMSFT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SceneComputeFeatureMSFT, Allocator> enumerateSceneComputeFeaturesToVectorMSFT(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_scene_understanding

#ifdef XR_HTCX_vive_tracker_interaction

  /*!
   * @brief xrEnumerateViveTrackerPathsHTCX wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViveTrackerPathsHTCX>
   *
   * @xrentity{xrEnumerateViveTrackerPathsHTCX}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateViveTrackerPathsHTCX(uint32_t pathCapacityInput, uint32_t& pathCountOutput,
                                       ViveTrackerPathsHTCX* paths,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateViveTrackerPathsHTCX enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViveTrackerPathsHTCX, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViveTrackerPathsHTCX>
   *
   * @xrentity{xrEnumerateViveTrackerPathsHTCX}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ViveTrackerPathsHTCX>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViveTrackerPathsHTCX, Allocator>> enumerateViveTrackerPathsToVectorHTCX(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViveTrackerPathsHTCX enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ViveTrackerPathsHTCX, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViveTrackerPathsHTCX>
   *
   * @xrentity{xrEnumerateViveTrackerPathsHTCX}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ViveTrackerPathsHTCX>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ViveTrackerPathsHTCX, Allocator>> enumerateViveTrackerPathsToVectorHTCX(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateViveTrackerPathsHTCX enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ViveTrackerPathsHTCX, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViveTrackerPathsHTCX>
   *
   * @xrentity{xrEnumerateViveTrackerPathsHTCX}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ViveTrackerPathsHTCX>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViveTrackerPathsHTCX, Allocator> enumerateViveTrackerPathsToVectorHTCX(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateViveTrackerPathsHTCX enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ViveTrackerPathsHTCX, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateViveTrackerPathsHTCX>
   *
   * @xrentity{xrEnumerateViveTrackerPathsHTCX}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ViveTrackerPathsHTCX>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ViveTrackerPathsHTCX, Allocator> enumerateViveTrackerPathsToVectorHTCX(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_HTCX_vive_tracker_interaction

#ifdef XR_OCULUS_audio_device_guid
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetAudioOutputDeviceGuidOculus wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAudioOutputDeviceGuidOculus>
   *
   * @xrentity{xrGetAudioOutputDeviceGuidOculus}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getAudioOutputDeviceGuidOculus(wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS],
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetAudioOutputDeviceGuidOculus enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAudioOutputDeviceGuidOculus>
   *
   * @xrentity{xrGetAudioOutputDeviceGuidOculus}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getAudioOutputDeviceGuidOculus(wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS],
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetAudioOutputDeviceGuidOculus enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAudioOutputDeviceGuidOculus>
   *
   * @xrentity{xrGetAudioOutputDeviceGuidOculus}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getAudioOutputDeviceGuidOculus(wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS],
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_OCULUS_audio_device_guid

#ifdef XR_OCULUS_audio_device_guid
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetAudioInputDeviceGuidOculus wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAudioInputDeviceGuidOculus>
   *
   * @xrentity{xrGetAudioInputDeviceGuidOculus}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getAudioInputDeviceGuidOculus(wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS],
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetAudioInputDeviceGuidOculus enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAudioInputDeviceGuidOculus>
   *
   * @xrentity{xrGetAudioInputDeviceGuidOculus}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getAudioInputDeviceGuidOculus(wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS],
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetAudioInputDeviceGuidOculus enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAudioInputDeviceGuidOculus>
   *
   * @xrentity{xrGetAudioInputDeviceGuidOculus}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getAudioInputDeviceGuidOculus(wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS],
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_OCULUS_audio_device_guid

#ifdef XR_META_performance_metrics

  /*!
   * @brief xrEnumeratePerformanceMetricsCounterPathsMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePerformanceMetricsCounterPathsMETA>
   *
   * @xrentity{xrEnumeratePerformanceMetricsCounterPathsMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumeratePerformanceMetricsCounterPathsMETA(
      uint32_t counterPathCapacityInput, uint32_t& counterPathCountOutput, Path* counterPaths,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumeratePerformanceMetricsCounterPathsMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePerformanceMetricsCounterPathsMETA>
   *
   * @xrentity{xrEnumeratePerformanceMetricsCounterPathsMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Path>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Path, Allocator>> enumeratePerformanceMetricsCounterPathsToVectorMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumeratePerformanceMetricsCounterPathsMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePerformanceMetricsCounterPathsMETA>
   *
   * @xrentity{xrEnumeratePerformanceMetricsCounterPathsMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Path>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Path, Allocator>> enumeratePerformanceMetricsCounterPathsToVectorMETA(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumeratePerformanceMetricsCounterPathsMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePerformanceMetricsCounterPathsMETA>
   *
   * @xrentity{xrEnumeratePerformanceMetricsCounterPathsMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Path>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Path, Allocator> enumeratePerformanceMetricsCounterPathsToVectorMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumeratePerformanceMetricsCounterPathsMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePerformanceMetricsCounterPathsMETA>
   *
   * @xrentity{xrEnumeratePerformanceMetricsCounterPathsMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Path>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Path, Allocator> enumeratePerformanceMetricsCounterPathsToVectorMETA(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_performance_metrics

#ifdef XR_EXT_future

  /*!
   * @brief xrPollFutureEXT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPollFutureEXT>
   *
   * @xrentity{xrPollFutureEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result pollFutureEXT(const FuturePollInfoEXT& pollInfo, FuturePollResultEXT& pollResult,
                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPollFutureEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FuturePollResultEXT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPollFutureEXT>
   *
   * @xrentity{xrPollFutureEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FuturePollResultEXT> pollFutureEXT(
      const FuturePollInfoEXT& pollInfo, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPollFutureEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FuturePollResultEXT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPollFutureEXT>
   *
   * @xrentity{xrPollFutureEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FuturePollResultEXT pollFutureEXT(const FuturePollInfoEXT& pollInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_future

#ifdef XR_EXT_future

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrCancelFutureEXT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCancelFutureEXT>
   *
   * @xrentity{xrCancelFutureEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result cancelFutureEXT(const FutureCancelInfoEXT& cancelInfo,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCancelFutureEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCancelFutureEXT>
   *
   * @xrentity{xrCancelFutureEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result cancelFutureEXT(const FutureCancelInfoEXT& cancelInfo,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCancelFutureEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCancelFutureEXT>
   *
   * @xrentity{xrCancelFutureEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void cancelFutureEXT(const FutureCancelInfoEXT& cancelInfo,
                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_future

#ifdef XR_ML_user_calibration

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrEnableUserCalibrationEventsML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnableUserCalibrationEventsML>
   *
   * @xrentity{xrEnableUserCalibrationEventsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enableUserCalibrationEventsML(const UserCalibrationEnableEventsInfoML& enableInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnableUserCalibrationEventsML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnableUserCalibrationEventsML>
   *
   * @xrentity{xrEnableUserCalibrationEventsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enableUserCalibrationEventsML(const UserCalibrationEnableEventsInfoML& enableInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrEnableUserCalibrationEventsML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnableUserCalibrationEventsML>
   *
   * @xrentity{xrEnableUserCalibrationEventsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void enableUserCalibrationEventsML(const UserCalibrationEnableEventsInfoML& enableInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_user_calibration

#ifdef XR_ML_system_notifications

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetSystemNotificationsML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetSystemNotificationsML>
   *
   * @xrentity{xrSetSystemNotificationsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setSystemNotificationsML(const SystemNotificationsSetInfoML& info,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetSystemNotificationsML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetSystemNotificationsML>
   *
   * @xrentity{xrSetSystemNotificationsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setSystemNotificationsML(const SystemNotificationsSetInfoML& info,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetSystemNotificationsML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetSystemNotificationsML>
   *
   * @xrentity{xrSetSystemNotificationsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setSystemNotificationsML(const SystemNotificationsSetInfoML& info,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_system_notifications

#ifdef XR_EXT_spatial_entity

  /*!
   * @brief xrEnumerateSpatialCapabilitiesEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilitiesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilitiesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSpatialCapabilitiesEXT(SystemId systemId, uint32_t capabilityCapacityInput,
                                         uint32_t& capabilityCountOutput,
                                         SpatialCapabilityEXT* capabilities,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSpatialCapabilitiesEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpatialCapabilityEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilitiesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilitiesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialCapabilityEXT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpatialCapabilityEXT, Allocator>> enumerateSpatialCapabilitiesToVectorEXT(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSpatialCapabilitiesEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpatialCapabilityEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilitiesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilitiesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialCapabilityEXT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpatialCapabilityEXT, Allocator>> enumerateSpatialCapabilitiesToVectorEXT(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateSpatialCapabilitiesEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<SpatialCapabilityEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilitiesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilitiesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialCapabilityEXT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpatialCapabilityEXT, Allocator> enumerateSpatialCapabilitiesToVectorEXT(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSpatialCapabilitiesEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<SpatialCapabilityEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilitiesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilitiesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialCapabilityEXT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpatialCapabilityEXT, Allocator> enumerateSpatialCapabilitiesToVectorEXT(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrEnumerateSpatialCapabilityComponentTypesEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilityComponentTypesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilityComponentTypesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSpatialCapabilityComponentTypesEXT(
      SystemId systemId, SpatialCapabilityEXT capability,
      SpatialCapabilityComponentTypesEXT& capabilityComponents,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSpatialCapabilityComponentTypesEXT enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilityComponentTypesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilityComponentTypesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSpatialCapabilityComponentTypesEXT(
      SystemId systemId, SpatialCapabilityEXT capability,
      SpatialCapabilityComponentTypesEXT& capabilityComponents,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrEnumerateSpatialCapabilityComponentTypesEXT enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilityComponentTypesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilityComponentTypesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void enumerateSpatialCapabilityComponentTypesEXT(
      SystemId systemId, SpatialCapabilityEXT capability,
      SpatialCapabilityComponentTypesEXT& capabilityComponents,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity

  /*!
   * @brief xrEnumerateSpatialCapabilityFeaturesEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilityFeaturesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilityFeaturesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSpatialCapabilityFeaturesEXT(
      SystemId systemId, SpatialCapabilityEXT capability, uint32_t capabilityFeatureCapacityInput,
      uint32_t& capabilityFeatureCountOutput, SpatialCapabilityFeatureEXT* capabilityFeatures,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSpatialCapabilityFeaturesEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpatialCapabilityFeatureEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilityFeaturesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilityFeaturesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialCapabilityFeatureEXT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpatialCapabilityFeatureEXT, Allocator>>
  enumerateSpatialCapabilityFeaturesToVectorEXT(SystemId systemId, SpatialCapabilityEXT capability,
                                                Dispatch&& d
                                                    OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSpatialCapabilityFeaturesEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpatialCapabilityFeatureEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilityFeaturesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilityFeaturesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialCapabilityFeatureEXT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpatialCapabilityFeatureEXT, Allocator>>
  enumerateSpatialCapabilityFeaturesToVectorEXT(SystemId systemId, SpatialCapabilityEXT capability,
                                                Allocator const& vectorAllocator,
                                                Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateSpatialCapabilityFeaturesEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<SpatialCapabilityFeatureEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilityFeaturesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilityFeaturesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialCapabilityFeatureEXT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpatialCapabilityFeatureEXT, Allocator> enumerateSpatialCapabilityFeaturesToVectorEXT(
      SystemId systemId, SpatialCapabilityEXT capability,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSpatialCapabilityFeaturesEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<SpatialCapabilityFeatureEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialCapabilityFeaturesEXT>
   *
   * @xrentity{xrEnumerateSpatialCapabilityFeaturesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialCapabilityFeatureEXT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpatialCapabilityFeatureEXT, Allocator> enumerateSpatialCapabilityFeaturesToVectorEXT(
      SystemId systemId, SpatialCapabilityEXT capability, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_persistence

  /*!
   * @brief xrEnumerateSpatialPersistenceScopesEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialPersistenceScopesEXT>
   *
   * @xrentity{xrEnumerateSpatialPersistenceScopesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSpatialPersistenceScopesEXT(
      SystemId systemId, uint32_t persistenceScopeCapacityInput,
      uint32_t& persistenceScopeCountOutput, SpatialPersistenceScopeEXT* persistenceScopes,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSpatialPersistenceScopesEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpatialPersistenceScopeEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialPersistenceScopesEXT>
   *
   * @xrentity{xrEnumerateSpatialPersistenceScopesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialPersistenceScopeEXT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpatialPersistenceScopeEXT, Allocator>>
  enumerateSpatialPersistenceScopesToVectorEXT(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSpatialPersistenceScopesEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpatialPersistenceScopeEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialPersistenceScopesEXT>
   *
   * @xrentity{xrEnumerateSpatialPersistenceScopesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialPersistenceScopeEXT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpatialPersistenceScopeEXT, Allocator>>
  enumerateSpatialPersistenceScopesToVectorEXT(SystemId systemId, Allocator const& vectorAllocator,
                                               Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateSpatialPersistenceScopesEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<SpatialPersistenceScopeEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialPersistenceScopesEXT>
   *
   * @xrentity{xrEnumerateSpatialPersistenceScopesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialPersistenceScopeEXT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpatialPersistenceScopeEXT, Allocator> enumerateSpatialPersistenceScopesToVectorEXT(
      SystemId systemId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSpatialPersistenceScopesEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<SpatialPersistenceScopeEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialPersistenceScopesEXT>
   *
   * @xrentity{xrEnumerateSpatialPersistenceScopesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialPersistenceScopeEXT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpatialPersistenceScopeEXT, Allocator> enumerateSpatialPersistenceScopesToVectorEXT(
      SystemId systemId, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_persistence

  //! @}
private:
  XrInstance val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrInstance) == sizeof(Instance),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrInstance from an Instance value.
 *
 * @found_by_adl
 * @see Instance::get()
 * @relates Instance
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrInstance get(Instance const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrInstance handle in a Instance (by reference).
 *
 * e.g.
 * ```
 * Instance yourHandle;
 * auto result = d.xrCreateInstance(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Instance
 */
static OPENXR_HPP_INLINE XrInstance* put(Instance& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Instance const& lhs,
                                                      Instance const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Instance const& lhs,
                                                      Instance const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Instance const& lhs,
                                                       Instance const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Instance const& lhs,
                                                       Instance const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Instance const& lhs,
                                                       Instance const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Instance values.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Instance const& lhs,
                                                       Instance const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Instance const& lhs,
                                                      XrInstance rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrInstance lhs,
                                                      Instance const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Instance const& lhs,
                                                      XrInstance rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrInstance lhs,
                                                      Instance const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Instance const& lhs,
                                                       XrInstance rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrInstance lhs,
                                                       Instance const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Instance const& lhs,
                                                       XrInstance rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrInstance lhs,
                                                       Instance const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Instance const& lhs,
                                                       XrInstance rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrInstance lhs,
                                                       Instance const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Instance and raw XrInstance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Instance const& lhs,
                                                       XrInstance rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrInstance and Instance.
//! @relates Instance
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrInstance lhs,
                                                       Instance const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Instance and nullptr: true if the handle is null.
 * @relates Instance
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Instance const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Instance: true if the handle is null.
 * @relates Instance
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Instance const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Instance and nullptr: true if the handle is not null.
 * @relates Instance
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Instance const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Instance: true if the handle is not null.
 * @relates Instance
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Instance const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrSession without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSession>
 *
 * @xrentity{XrSession}
 * @ingroup handles
 */
class Session {
public:
  using Type = Session;
  using RawHandleType = XrSession;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Session() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSession type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Session(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Session(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSession
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSession type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Session value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Session value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSession manipulation
   * @{
   */
  //! Gets the raw XrSession value.
  OPENXR_HPP_CONSTEXPR XrSession get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Session yourHandle;
   * auto result = d.xrCreateSession(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Session&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySession>
   *
   * @xrentity{xrDestroySession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySession>
   *
   * @xrentity{xrDestroySession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySession>
   *
   * @xrentity{xrDestroySession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateReferenceSpaces wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateReferenceSpaces(uint32_t spaceCapacityInput, uint32_t& spaceCountOutput,
                                  ReferenceSpaceType* spaces,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateReferenceSpaces enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ReferenceSpaceType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Allocator = std::allocator<ReferenceSpaceType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ReferenceSpaceType, Allocator>> enumerateReferenceSpacesToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateReferenceSpaces enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ReferenceSpaceType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Allocator = std::allocator<ReferenceSpaceType>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ReferenceSpaceType, Allocator>> enumerateReferenceSpacesToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateReferenceSpaces enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ReferenceSpaceType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Allocator = std::allocator<ReferenceSpaceType>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ReferenceSpaceType, Allocator> enumerateReferenceSpacesToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateReferenceSpaces enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ReferenceSpaceType, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateReferenceSpaces>
   *
   * @xrentity{xrEnumerateReferenceSpaces}
   */
  template <typename Allocator = std::allocator<ReferenceSpaceType>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ReferenceSpaceType, Allocator> enumerateReferenceSpacesToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateReferenceSpace wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createReferenceSpace(const ReferenceSpaceCreateInfo& createInfo, Space& space,
                              Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateReferenceSpace enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createReferenceSpace(const ReferenceSpaceCreateInfo& createInfo,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateReferenceSpace enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createReferenceSpace(const ReferenceSpaceCreateInfo& createInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateReferenceSpace wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createReferenceSpaceUnique(
      const ReferenceSpaceCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateReferenceSpace wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateReferenceSpace>
   *
   * @xrentity{xrCreateReferenceSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createReferenceSpaceUnique(
      const ReferenceSpaceCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetReferenceSpaceBoundsRect wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetReferenceSpaceBoundsRect>
   *
   * @xrentity{xrGetReferenceSpaceBoundsRect}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getReferenceSpaceBoundsRect(ReferenceSpaceType referenceSpaceType, Extent2Df& bounds,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetReferenceSpaceBoundsRect enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::SpaceBoundsUnavailable, or an error code
   * if asserts are not active and exceptions are disabled)
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetReferenceSpaceBoundsRect>
   *
   * @xrentity{xrGetReferenceSpaceBoundsRect}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getReferenceSpaceBoundsRect(ReferenceSpaceType referenceSpaceType, Extent2Df& bounds,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateActionSpace wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createActionSpace(const ActionSpaceCreateInfo& createInfo, Space& space,
                           Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateActionSpace enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createActionSpace(const ActionSpaceCreateInfo& createInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateActionSpace enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createActionSpace(const ActionSpaceCreateInfo& createInfo,
                          Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateActionSpace wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createActionSpaceUnique(
      const ActionSpaceCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateActionSpace wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateActionSpace>
   *
   * @xrentity{xrCreateActionSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createActionSpaceUnique(
      const ActionSpaceCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateSwapchainFormats wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSwapchainFormats(uint32_t formatCapacityInput, uint32_t& formatCountOutput,
                                   int64_t* formats,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSwapchainFormats enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<int64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Allocator = std::allocator<int64_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<int64_t, Allocator>> enumerateSwapchainFormatsToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSwapchainFormats enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<int64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Allocator = std::allocator<int64_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<int64_t, Allocator>> enumerateSwapchainFormatsToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateSwapchainFormats enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<int64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Allocator = std::allocator<int64_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<int64_t, Allocator> enumerateSwapchainFormatsToVector(
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSwapchainFormats enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<int64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainFormats>
   *
   * @xrentity{xrEnumerateSwapchainFormats}
   */
  template <typename Allocator = std::allocator<int64_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<int64_t, Allocator> enumerateSwapchainFormatsToVector(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSwapchain wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSwapchain(const SwapchainCreateInfo& createInfo, Swapchain& swapchain,
                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSwapchain enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Swapchain
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Swapchain> createSwapchain(const SwapchainCreateInfo& createInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSwapchain enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Swapchain
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Swapchain createSwapchain(const SwapchainCreateInfo& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSwapchain wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Swapchain
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>> createSwapchainUnique(
      const SwapchainCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSwapchain wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Swapchain
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchain>
   *
   * @xrentity{xrCreateSwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>> createSwapchainUnique(
      const SwapchainCreateInfo& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrBeginSession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginSession>
   *
   * @xrentity{xrBeginSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginSession(const SessionBeginInfo& beginInfo,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrBeginSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginSession>
   *
   * @xrentity{xrBeginSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginSession(const SessionBeginInfo& beginInfo,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrBeginSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginSession>
   *
   * @xrentity{xrBeginSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void beginSession(const SessionBeginInfo& beginInfo,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrEndSession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndSession>
   *
   * @xrentity{xrEndSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result endSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEndSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndSession>
   *
   * @xrentity{xrEndSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result endSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrEndSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndSession>
   *
   * @xrentity{xrEndSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void endSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrRequestExitSession wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestExitSession>
   *
   * @xrentity{xrRequestExitSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestExitSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRequestExitSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestExitSession>
   *
   * @xrentity{xrRequestExitSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestExitSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRequestExitSession enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestExitSession>
   *
   * @xrentity{xrRequestExitSession}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void requestExitSession(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrWaitFrame wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitFrame>
   *
   * @xrentity{xrWaitFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result waitFrame(const FrameWaitInfo& frameWaitInfo, FrameState& frameState,
                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrWaitFrame enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FrameState
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitFrame>
   *
   * @xrentity{xrWaitFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FrameState> waitFrame(const FrameWaitInfo& frameWaitInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrWaitFrame enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FrameState
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitFrame>
   *
   * @xrentity{xrWaitFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FrameState waitFrame(const FrameWaitInfo& frameWaitInfo,
                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrBeginFrame wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginFrame>
   *
   * @xrentity{xrBeginFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginFrame(const FrameBeginInfo& frameBeginInfo,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrBeginFrame enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::FrameDiscarded, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginFrame>
   *
   * @xrentity{xrBeginFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginFrame(const FrameBeginInfo& frameBeginInfo,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrEndFrame wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndFrame>
   *
   * @xrentity{xrEndFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result endFrame(const FrameEndInfo& frameEndInfo,
                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEndFrame enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndFrame>
   *
   * @xrentity{xrEndFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result endFrame(const FrameEndInfo& frameEndInfo,
                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrEndFrame enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEndFrame>
   *
   * @xrentity{xrEndFrame}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void endFrame(const FrameEndInfo& frameEndInfo,
                Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrLocateViews wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateViews(const ViewLocateInfo& viewLocateInfo, ViewState& viewState,
                     uint32_t viewCapacityInput, uint32_t& viewCountOutput, View* views,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateViews enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<View, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Allocator = std::allocator<View>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<View, Allocator>> locateViewsToVector(
      const ViewLocateInfo& viewLocateInfo, ViewState& viewState,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrLocateViews enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<View, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Allocator = std::allocator<View>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<View, Allocator>> locateViewsToVector(
      const ViewLocateInfo& viewLocateInfo, ViewState& viewState, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#else
  /*!
   * @brief xrLocateViews enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<View, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Allocator = std::allocator<View>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<View, Allocator> locateViewsToVector(
      const ViewLocateInfo& viewLocateInfo, ViewState& viewState,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrLocateViews enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<View, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateViews>
   *
   * @xrentity{xrLocateViews}
   */
  template <typename Allocator = std::allocator<View>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<View, Allocator> locateViewsToVector(const ViewLocateInfo& viewLocateInfo,
                                                   ViewState& viewState,
                                                   Allocator const& vectorAllocator,
                                                   Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrAttachSessionActionSets wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAttachSessionActionSets>
   *
   * @xrentity{xrAttachSessionActionSets}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result attachSessionActionSets(const SessionActionSetsAttachInfo& attachInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrAttachSessionActionSets enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAttachSessionActionSets>
   *
   * @xrentity{xrAttachSessionActionSets}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result attachSessionActionSets(const SessionActionSetsAttachInfo& attachInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrAttachSessionActionSets enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAttachSessionActionSets>
   *
   * @xrentity{xrAttachSessionActionSets}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void attachSessionActionSets(const SessionActionSetsAttachInfo& attachInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetCurrentInteractionProfile wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetCurrentInteractionProfile>
   *
   * @xrentity{xrGetCurrentInteractionProfile}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getCurrentInteractionProfile(Path topLevelUserPath,
                                      InteractionProfileState& interactionProfile,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetCurrentInteractionProfile enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type InteractionProfileState
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetCurrentInteractionProfile>
   *
   * @xrentity{xrGetCurrentInteractionProfile}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<InteractionProfileState> getCurrentInteractionProfile(
      Path topLevelUserPath, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetCurrentInteractionProfile enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type InteractionProfileState
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetCurrentInteractionProfile>
   *
   * @xrentity{xrGetCurrentInteractionProfile}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  InteractionProfileState getCurrentInteractionProfile(
      Path topLevelUserPath, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetActionStateBoolean wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateBoolean>
   *
   * @xrentity{xrGetActionStateBoolean}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getActionStateBoolean(const ActionStateGetInfo& getInfo, ActionStateBoolean& state,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetActionStateBoolean enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionStateBoolean
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateBoolean>
   *
   * @xrentity{xrGetActionStateBoolean}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionStateBoolean> getActionStateBoolean(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetActionStateBoolean enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionStateBoolean
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateBoolean>
   *
   * @xrentity{xrGetActionStateBoolean}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionStateBoolean getActionStateBoolean(const ActionStateGetInfo& getInfo,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetActionStateFloat wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateFloat>
   *
   * @xrentity{xrGetActionStateFloat}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getActionStateFloat(const ActionStateGetInfo& getInfo, ActionStateFloat& state,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetActionStateFloat enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionStateFloat
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateFloat>
   *
   * @xrentity{xrGetActionStateFloat}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionStateFloat> getActionStateFloat(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetActionStateFloat enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionStateFloat
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateFloat>
   *
   * @xrentity{xrGetActionStateFloat}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionStateFloat getActionStateFloat(const ActionStateGetInfo& getInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetActionStateVector2f wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateVector2f>
   *
   * @xrentity{xrGetActionStateVector2f}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getActionStateVector2f(const ActionStateGetInfo& getInfo, ActionStateVector2f& state,
                                Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetActionStateVector2f enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionStateVector2f
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateVector2f>
   *
   * @xrentity{xrGetActionStateVector2f}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionStateVector2f> getActionStateVector2f(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetActionStateVector2f enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionStateVector2f
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStateVector2f>
   *
   * @xrentity{xrGetActionStateVector2f}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionStateVector2f getActionStateVector2f(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetActionStatePose wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStatePose>
   *
   * @xrentity{xrGetActionStatePose}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getActionStatePose(const ActionStateGetInfo& getInfo, ActionStatePose& state,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetActionStatePose enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ActionStatePose
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStatePose>
   *
   * @xrentity{xrGetActionStatePose}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ActionStatePose> getActionStatePose(
      const ActionStateGetInfo& getInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetActionStatePose enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ActionStatePose
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetActionStatePose>
   *
   * @xrentity{xrGetActionStatePose}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ActionStatePose getActionStatePose(const ActionStateGetInfo& getInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSyncActions wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSyncActions>
   *
   * @xrentity{xrSyncActions}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result syncActions(const ActionsSyncInfo& syncInfo,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSyncActions enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::SessionNotFocused, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSyncActions>
   *
   * @xrentity{xrSyncActions}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result syncActions(const ActionsSyncInfo& syncInfo,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumerateBoundSourcesForAction wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateBoundSourcesForAction(const BoundSourcesForActionEnumerateInfo& enumerateInfo,
                                        uint32_t sourceCapacityInput, uint32_t& sourceCountOutput,
                                        Path* sources,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateBoundSourcesForAction enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Allocator = std::allocator<Path>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Path, Allocator>> enumerateBoundSourcesForActionToVector(
      const BoundSourcesForActionEnumerateInfo& enumerateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateBoundSourcesForAction enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Allocator = std::allocator<Path>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Path, Allocator>> enumerateBoundSourcesForActionToVector(
      const BoundSourcesForActionEnumerateInfo& enumerateInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateBoundSourcesForAction enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Allocator = std::allocator<Path>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Path, Allocator> enumerateBoundSourcesForActionToVector(
      const BoundSourcesForActionEnumerateInfo& enumerateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateBoundSourcesForAction enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateBoundSourcesForAction>
   *
   * @xrentity{xrEnumerateBoundSourcesForAction}
   */
  template <typename Allocator = std::allocator<Path>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Path, Allocator> enumerateBoundSourcesForActionToVector(
      const BoundSourcesForActionEnumerateInfo& enumerateInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetInputSourceLocalizedName wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getInputSourceLocalizedName(const InputSourceLocalizedNameGetInfo& getInfo,
                                     uint32_t bufferCapacityInput, uint32_t& bufferCountOutput,
                                     char* buffer,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetInputSourceLocalizedName enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getInputSourceLocalizedName(
      const InputSourceLocalizedNameGetInfo& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrGetInputSourceLocalizedName enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getInputSourceLocalizedName(
      const InputSourceLocalizedNameGetInfo& getInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#else
  /*!
   * @brief xrGetInputSourceLocalizedName enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getInputSourceLocalizedName(
      const InputSourceLocalizedNameGetInfo& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;
  /*!
   * @brief xrGetInputSourceLocalizedName enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetInputSourceLocalizedName>
   *
   * @xrentity{xrGetInputSourceLocalizedName}
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getInputSourceLocalizedName(
      const InputSourceLocalizedNameGetInfo& getInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrApplyHapticFeedback wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrApplyHapticFeedback>
   *
   * @xrentity{xrApplyHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result applyHapticFeedback(const HapticActionInfo& hapticActionInfo,
                             const HapticBaseHeader& hapticFeedback,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrApplyHapticFeedback enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::SessionNotFocused, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrApplyHapticFeedback>
   *
   * @xrentity{xrApplyHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result applyHapticFeedback(const HapticActionInfo& hapticActionInfo,
                             const HapticBaseHeader& hapticFeedback,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrStopHapticFeedback wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopHapticFeedback>
   *
   * @xrentity{xrStopHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stopHapticFeedback(const HapticActionInfo& hapticActionInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrStopHapticFeedback enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::SessionNotFocused, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopHapticFeedback>
   *
   * @xrentity{xrStopHapticFeedback}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stopHapticFeedback(const HapticActionInfo& hapticActionInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrLocateSpaces wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpaces>
   *
   * @xrentity{xrLocateSpaces}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateSpaces(const SpacesLocateInfo& locateInfo, SpaceLocations& spaceLocations,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateSpaces enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpaces>
   *
   * @xrentity{xrLocateSpaces}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateSpaces(const SpacesLocateInfo& locateInfo, SpaceLocations& spaceLocations,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateSpaces enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpaces>
   *
   * @xrentity{xrLocateSpaces}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void locateSpaces(const SpacesLocateInfo& locateInfo, SpaceLocations& spaceLocations,
                    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_KHR_android_thread_settings
#if defined(XR_USE_PLATFORM_ANDROID)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetAndroidApplicationThreadKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetAndroidApplicationThreadKHR>
   *
   * @xrentity{xrSetAndroidApplicationThreadKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setAndroidApplicationThreadKHR(AndroidThreadTypeKHR threadType, uint32_t threadId,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetAndroidApplicationThreadKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetAndroidApplicationThreadKHR>
   *
   * @xrentity{xrSetAndroidApplicationThreadKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setAndroidApplicationThreadKHR(AndroidThreadTypeKHR threadType, uint32_t threadId,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetAndroidApplicationThreadKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetAndroidApplicationThreadKHR>
   *
   * @xrentity{xrSetAndroidApplicationThreadKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setAndroidApplicationThreadKHR(AndroidThreadTypeKHR threadType, uint32_t threadId,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_thread_settings

#ifdef XR_KHR_android_surface_swapchain
#if defined(XR_USE_PLATFORM_ANDROID)

  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSwapchainAndroidSurfaceKHR(const SwapchainCreateInfo& info, Swapchain& swapchain,
                                          jobject* surface,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Swapchain
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Swapchain> createSwapchainAndroidSurfaceKHR(
      const SwapchainCreateInfo& info, jobject* surface,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Swapchain
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Swapchain createSwapchainAndroidSurfaceKHR(const SwapchainCreateInfo& info, jobject* surface,
                                             Dispatch&& d
                                                 OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Swapchain
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>>>
  createSwapchainAndroidSurfaceUniqueKHR(const SwapchainCreateInfo& info, jobject* surface,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSwapchainAndroidSurfaceKHR wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Swapchain
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSwapchainAndroidSurfaceKHR>
   *
   * @xrentity{xrCreateSwapchainAndroidSurfaceKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Swapchain, impl::RemoveRefConst<Dispatch>> createSwapchainAndroidSurfaceUniqueKHR(
      const SwapchainCreateInfo& info, jobject* surface,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_ANDROID)
#endif  // XR_KHR_android_surface_swapchain

#ifdef XR_KHR_visibility_mask

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetVisibilityMaskKHR wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVisibilityMaskKHR>
   *
   * @xrentity{xrGetVisibilityMaskKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVisibilityMaskKHR(ViewConfigurationType viewConfigurationType, uint32_t viewIndex,
                              VisibilityMaskTypeKHR visibilityMaskType,
                              VisibilityMaskKHR& visibilityMask,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVisibilityMaskKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVisibilityMaskKHR>
   *
   * @xrentity{xrGetVisibilityMaskKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVisibilityMaskKHR(ViewConfigurationType viewConfigurationType, uint32_t viewIndex,
                              VisibilityMaskTypeKHR visibilityMaskType,
                              VisibilityMaskKHR& visibilityMask,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVisibilityMaskKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVisibilityMaskKHR>
   *
   * @xrentity{xrGetVisibilityMaskKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getVisibilityMaskKHR(ViewConfigurationType viewConfigurationType, uint32_t viewIndex,
                            VisibilityMaskTypeKHR visibilityMaskType,
                            VisibilityMaskKHR& visibilityMask,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_KHR_visibility_mask

#ifdef XR_KHR_locate_spaces

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrLocateSpacesKHR wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpacesKHR>
   *
   * @xrentity{xrLocateSpacesKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateSpacesKHR(const SpacesLocateInfo& locateInfo, SpaceLocations& spaceLocations,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateSpacesKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpacesKHR>
   *
   * @xrentity{xrLocateSpacesKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateSpacesKHR(const SpacesLocateInfo& locateInfo, SpaceLocations& spaceLocations,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateSpacesKHR enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpacesKHR>
   *
   * @xrentity{xrLocateSpacesKHR}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void locateSpacesKHR(const SpacesLocateInfo& locateInfo, SpaceLocations& spaceLocations,
                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_KHR_locate_spaces

#ifdef XR_EXT_performance_settings

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPerfSettingsSetPerformanceLevelEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPerfSettingsSetPerformanceLevelEXT>
   *
   * @xrentity{xrPerfSettingsSetPerformanceLevelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result perfSettingsSetPerformanceLevelEXT(PerfSettingsDomainEXT domain,
                                            PerfSettingsLevelEXT level,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPerfSettingsSetPerformanceLevelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPerfSettingsSetPerformanceLevelEXT>
   *
   * @xrentity{xrPerfSettingsSetPerformanceLevelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result perfSettingsSetPerformanceLevelEXT(PerfSettingsDomainEXT domain,
                                            PerfSettingsLevelEXT level,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPerfSettingsSetPerformanceLevelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPerfSettingsSetPerformanceLevelEXT>
   *
   * @xrentity{xrPerfSettingsSetPerformanceLevelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void perfSettingsSetPerformanceLevelEXT(PerfSettingsDomainEXT domain, PerfSettingsLevelEXT level,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_performance_settings

#ifdef XR_EXT_thermal_query

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrThermalGetTemperatureTrendEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrThermalGetTemperatureTrendEXT>
   *
   * @xrentity{xrThermalGetTemperatureTrendEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result thermalGetTemperatureTrendEXT(PerfSettingsDomainEXT domain,
                                       PerfSettingsNotificationLevelEXT& notificationLevel,
                                       float& tempHeadroom, float& tempSlope,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrThermalGetTemperatureTrendEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrThermalGetTemperatureTrendEXT>
   *
   * @xrentity{xrThermalGetTemperatureTrendEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result thermalGetTemperatureTrendEXT(PerfSettingsDomainEXT domain,
                                       PerfSettingsNotificationLevelEXT& notificationLevel,
                                       float& tempHeadroom, float& tempSlope,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrThermalGetTemperatureTrendEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrThermalGetTemperatureTrendEXT>
   *
   * @xrentity{xrThermalGetTemperatureTrendEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void thermalGetTemperatureTrendEXT(PerfSettingsDomainEXT domain,
                                     PerfSettingsNotificationLevelEXT& notificationLevel,
                                     float& tempHeadroom, float& tempSlope,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_thermal_query

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSessionBeginDebugUtilsLabelRegionEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionBeginDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionBeginDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionBeginDebugUtilsLabelRegionEXT(
      const DebugUtilsLabelEXT& labelInfo, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSessionBeginDebugUtilsLabelRegionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionBeginDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionBeginDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionBeginDebugUtilsLabelRegionEXT(
      const DebugUtilsLabelEXT& labelInfo, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSessionBeginDebugUtilsLabelRegionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionBeginDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionBeginDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void sessionBeginDebugUtilsLabelRegionEXT(const DebugUtilsLabelEXT& labelInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSessionEndDebugUtilsLabelRegionEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionEndDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionEndDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionEndDebugUtilsLabelRegionEXT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSessionEndDebugUtilsLabelRegionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionEndDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionEndDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionEndDebugUtilsLabelRegionEXT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSessionEndDebugUtilsLabelRegionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionEndDebugUtilsLabelRegionEXT>
   *
   * @xrentity{xrSessionEndDebugUtilsLabelRegionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void sessionEndDebugUtilsLabelRegionEXT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_EXT_debug_utils

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSessionInsertDebugUtilsLabelEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionInsertDebugUtilsLabelEXT>
   *
   * @xrentity{xrSessionInsertDebugUtilsLabelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionInsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSessionInsertDebugUtilsLabelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionInsertDebugUtilsLabelEXT>
   *
   * @xrentity{xrSessionInsertDebugUtilsLabelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sessionInsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSessionInsertDebugUtilsLabelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSessionInsertDebugUtilsLabelEXT>
   *
   * @xrentity{xrSessionInsertDebugUtilsLabelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void sessionInsertDebugUtilsLabelEXT(const DebugUtilsLabelEXT& labelInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_debug_utils

#ifdef XR_MSFT_spatial_anchor

  /*!
   * @brief xrCreateSpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorMSFT(const SpatialAnchorCreateInfoMSFT& createInfo,
                                 SpatialAnchorMSFT& anchor,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorMSFT> createSpatialAnchorMSFT(
      const SpatialAnchorCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorMSFT createSpatialAnchorMSFT(const SpatialAnchorCreateInfoMSFT& createInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorUniqueMSFT(const SpatialAnchorCreateInfoMSFT& createInfo,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>> createSpatialAnchorUniqueMSFT(
      const SpatialAnchorCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_anchor

#ifdef XR_MSFT_spatial_anchor

  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorSpaceMSFT(const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
                                      Space& space,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createSpatialAnchorSpaceMSFT(
      const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createSpatialAnchorSpaceMSFT(const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorSpaceUniqueMSFT(const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorSpaceMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createSpatialAnchorSpaceUniqueMSFT(
      const SpatialAnchorSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_anchor

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceActiveEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceActiveEXT>
   *
   * @xrentity{xrSetInputDeviceActiveEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceActiveEXT(Path interactionProfile, Path topLevelPath, Bool32 isActive,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceActiveEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceActiveEXT>
   *
   * @xrentity{xrSetInputDeviceActiveEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceActiveEXT(Path interactionProfile, Path topLevelPath, Bool32 isActive,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceActiveEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceActiveEXT>
   *
   * @xrentity{xrSetInputDeviceActiveEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceActiveEXT(Path interactionProfile, Path topLevelPath, Bool32 isActive,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceStateBoolEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateBoolEXT>
   *
   * @xrentity{xrSetInputDeviceStateBoolEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateBoolEXT(Path topLevelPath, Path inputSourcePath, Bool32 state,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceStateBoolEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateBoolEXT>
   *
   * @xrentity{xrSetInputDeviceStateBoolEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateBoolEXT(Path topLevelPath, Path inputSourcePath, Bool32 state,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceStateBoolEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateBoolEXT>
   *
   * @xrentity{xrSetInputDeviceStateBoolEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceStateBoolEXT(Path topLevelPath, Path inputSourcePath, Bool32 state,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceStateFloatEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateFloatEXT>
   *
   * @xrentity{xrSetInputDeviceStateFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateFloatEXT(Path topLevelPath, Path inputSourcePath, float state,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceStateFloatEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateFloatEXT>
   *
   * @xrentity{xrSetInputDeviceStateFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateFloatEXT(Path topLevelPath, Path inputSourcePath, float state,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceStateFloatEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateFloatEXT>
   *
   * @xrentity{xrSetInputDeviceStateFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceStateFloatEXT(Path topLevelPath, Path inputSourcePath, float state,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceStateVector2fEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateVector2fEXT>
   *
   * @xrentity{xrSetInputDeviceStateVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateVector2fEXT(Path topLevelPath, Path inputSourcePath, Vector2f state,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceStateVector2fEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateVector2fEXT>
   *
   * @xrentity{xrSetInputDeviceStateVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceStateVector2fEXT(Path topLevelPath, Path inputSourcePath, Vector2f state,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceStateVector2fEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceStateVector2fEXT>
   *
   * @xrentity{xrSetInputDeviceStateVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceStateVector2fEXT(Path topLevelPath, Path inputSourcePath, Vector2f state,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_EXT_conformance_automation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetInputDeviceLocationEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceLocationEXT>
   *
   * @xrentity{xrSetInputDeviceLocationEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceLocationEXT(Path topLevelPath, Path inputSourcePath, Space space, Posef pose,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetInputDeviceLocationEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceLocationEXT>
   *
   * @xrentity{xrSetInputDeviceLocationEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setInputDeviceLocationEXT(Path topLevelPath, Path inputSourcePath, Space space, Posef pose,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetInputDeviceLocationEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetInputDeviceLocationEXT>
   *
   * @xrentity{xrSetInputDeviceLocationEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setInputDeviceLocationEXT(Path topLevelPath, Path inputSourcePath, Space space, Posef pose,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_conformance_automation

#ifdef XR_MSFT_spatial_graph_bridge

  /*!
   * @brief xrCreateSpatialGraphNodeSpaceMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialGraphNodeSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialGraphNodeSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialGraphNodeSpaceMSFT(const SpatialGraphNodeSpaceCreateInfoMSFT& createInfo,
                                         Space& space,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialGraphNodeSpaceMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialGraphNodeSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialGraphNodeSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createSpatialGraphNodeSpaceMSFT(
      const SpatialGraphNodeSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialGraphNodeSpaceMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialGraphNodeSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialGraphNodeSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createSpatialGraphNodeSpaceMSFT(const SpatialGraphNodeSpaceCreateInfoMSFT& createInfo,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialGraphNodeSpaceMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialGraphNodeSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialGraphNodeSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>>
  createSpatialGraphNodeSpaceUniqueMSFT(const SpatialGraphNodeSpaceCreateInfoMSFT& createInfo,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialGraphNodeSpaceMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialGraphNodeSpaceMSFT>
   *
   * @xrentity{xrCreateSpatialGraphNodeSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createSpatialGraphNodeSpaceUniqueMSFT(
      const SpatialGraphNodeSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_graph_bridge

#ifdef XR_MSFT_spatial_graph_bridge

  /*!
   * @brief xrTryCreateSpatialGraphStaticNodeBindingMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryCreateSpatialGraphStaticNodeBindingMSFT>
   *
   * @xrentity{xrTryCreateSpatialGraphStaticNodeBindingMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result tryCreateSpatialGraphStaticNodeBindingMSFT(
      const SpatialGraphStaticNodeBindingCreateInfoMSFT& createInfo,
      SpatialGraphNodeBindingMSFT& nodeBinding,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTryCreateSpatialGraphStaticNodeBindingMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialGraphNodeBindingMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryCreateSpatialGraphStaticNodeBindingMSFT>
   *
   * @xrentity{xrTryCreateSpatialGraphStaticNodeBindingMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialGraphNodeBindingMSFT> tryCreateSpatialGraphStaticNodeBindingMSFT(
      const SpatialGraphStaticNodeBindingCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTryCreateSpatialGraphStaticNodeBindingMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialGraphNodeBindingMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryCreateSpatialGraphStaticNodeBindingMSFT>
   *
   * @xrentity{xrTryCreateSpatialGraphStaticNodeBindingMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialGraphNodeBindingMSFT tryCreateSpatialGraphStaticNodeBindingMSFT(
      const SpatialGraphStaticNodeBindingCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTryCreateSpatialGraphStaticNodeBindingMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialGraphNodeBindingMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryCreateSpatialGraphStaticNodeBindingMSFT>
   *
   * @xrentity{xrTryCreateSpatialGraphStaticNodeBindingMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialGraphNodeBindingMSFT, impl::RemoveRefConst<Dispatch>>>
  tryCreateSpatialGraphStaticNodeBindingUniqueMSFT(
      const SpatialGraphStaticNodeBindingCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTryCreateSpatialGraphStaticNodeBindingMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialGraphNodeBindingMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryCreateSpatialGraphStaticNodeBindingMSFT>
   *
   * @xrentity{xrTryCreateSpatialGraphStaticNodeBindingMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialGraphNodeBindingMSFT, impl::RemoveRefConst<Dispatch>>
  tryCreateSpatialGraphStaticNodeBindingUniqueMSFT(
      const SpatialGraphStaticNodeBindingCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_graph_bridge

#ifdef XR_EXT_hand_tracking

  /*!
   * @brief xrCreateHandTrackerEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createHandTrackerEXT(const HandTrackerCreateInfoEXT& createInfo,
                              HandTrackerEXT& handTracker,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateHandTrackerEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type HandTrackerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<HandTrackerEXT> createHandTrackerEXT(const HandTrackerCreateInfoEXT& createInfo,
                                                   Dispatch&& d
                                                       OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateHandTrackerEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type HandTrackerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  HandTrackerEXT createHandTrackerEXT(const HandTrackerCreateInfoEXT& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateHandTrackerEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a HandTrackerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>>>
  createHandTrackerUniqueEXT(const HandTrackerCreateInfoEXT& createInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateHandTrackerEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a HandTrackerEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandTrackerEXT>
   *
   * @xrentity{xrCreateHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<HandTrackerEXT, impl::RemoveRefConst<Dispatch>> createHandTrackerUniqueEXT(
      const HandTrackerCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_hand_tracking

#ifdef XR_MSFT_controller_model

  /*!
   * @brief xrGetControllerModelKeyMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetControllerModelKeyMSFT>
   *
   * @xrentity{xrGetControllerModelKeyMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getControllerModelKeyMSFT(Path topLevelUserPath,
                                   ControllerModelKeyStateMSFT& controllerModelKeyState,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetControllerModelKeyMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ControllerModelKeyStateMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetControllerModelKeyMSFT>
   *
   * @xrentity{xrGetControllerModelKeyMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ControllerModelKeyStateMSFT> getControllerModelKeyMSFT(
      Path topLevelUserPath, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetControllerModelKeyMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ControllerModelKeyStateMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetControllerModelKeyMSFT>
   *
   * @xrentity{xrGetControllerModelKeyMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ControllerModelKeyStateMSFT getControllerModelKeyMSFT(
      Path topLevelUserPath, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_controller_model

#ifdef XR_MSFT_controller_model

  /*!
   * @brief xrLoadControllerModelMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLoadControllerModelMSFT>
   *
   * @xrentity{xrLoadControllerModelMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result loadControllerModelMSFT(ControllerModelKeyMSFT modelKey, uint32_t bufferCapacityInput,
                                 uint32_t& bufferCountOutput, uint8_t* buffer,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLoadControllerModelMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<uint8_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLoadControllerModelMSFT>
   *
   * @xrentity{xrLoadControllerModelMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint8_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<uint8_t, Allocator>> loadControllerModelToVectorMSFT(
      ControllerModelKeyMSFT modelKey, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrLoadControllerModelMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<uint8_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLoadControllerModelMSFT>
   *
   * @xrentity{xrLoadControllerModelMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint8_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<uint8_t, Allocator>> loadControllerModelToVectorMSFT(
      ControllerModelKeyMSFT modelKey, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrLoadControllerModelMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<uint8_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLoadControllerModelMSFT>
   *
   * @xrentity{xrLoadControllerModelMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint8_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<uint8_t, Allocator> loadControllerModelToVectorMSFT(
      ControllerModelKeyMSFT modelKey, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrLoadControllerModelMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<uint8_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLoadControllerModelMSFT>
   *
   * @xrentity{xrLoadControllerModelMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint8_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<uint8_t, Allocator> loadControllerModelToVectorMSFT(ControllerModelKeyMSFT modelKey,
                                                                  Allocator const& vectorAllocator,
                                                                  Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_controller_model

#ifdef XR_MSFT_controller_model

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetControllerModelPropertiesMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetControllerModelPropertiesMSFT>
   *
   * @xrentity{xrGetControllerModelPropertiesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getControllerModelPropertiesMSFT(ControllerModelKeyMSFT modelKey,
                                          ControllerModelPropertiesMSFT& properties,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetControllerModelPropertiesMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetControllerModelPropertiesMSFT>
   *
   * @xrentity{xrGetControllerModelPropertiesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getControllerModelPropertiesMSFT(ControllerModelKeyMSFT modelKey,
                                          ControllerModelPropertiesMSFT& properties,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetControllerModelPropertiesMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetControllerModelPropertiesMSFT>
   *
   * @xrentity{xrGetControllerModelPropertiesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getControllerModelPropertiesMSFT(ControllerModelKeyMSFT modelKey,
                                        ControllerModelPropertiesMSFT& properties,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_controller_model

#ifdef XR_MSFT_controller_model

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetControllerModelStateMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetControllerModelStateMSFT>
   *
   * @xrentity{xrGetControllerModelStateMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getControllerModelStateMSFT(ControllerModelKeyMSFT modelKey,
                                     ControllerModelStateMSFT& state,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetControllerModelStateMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetControllerModelStateMSFT>
   *
   * @xrentity{xrGetControllerModelStateMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getControllerModelStateMSFT(ControllerModelKeyMSFT modelKey,
                                     ControllerModelStateMSFT& state,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetControllerModelStateMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetControllerModelStateMSFT>
   *
   * @xrentity{xrGetControllerModelStateMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getControllerModelStateMSFT(ControllerModelKeyMSFT modelKey, ControllerModelStateMSFT& state,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_controller_model

#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorFromPerceptionAnchorMSFT(
      IUnknown* perceptionAnchor, SpatialAnchorMSFT& anchor,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorMSFT> createSpatialAnchorFromPerceptionAnchorMSFT(
      IUnknown* perceptionAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorMSFT createSpatialAnchorFromPerceptionAnchorMSFT(
      IUnknown* perceptionAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorFromPerceptionAnchorUniqueMSFT(
      IUnknown* perceptionAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorFromPerceptionAnchorMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPerceptionAnchorMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPerceptionAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>
  createSpatialAnchorFromPerceptionAnchorUniqueMSFT(
      IUnknown* perceptionAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop

#ifdef XR_MSFT_perception_anchor_interop
#if defined(XR_USE_PLATFORM_WIN32)

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTryGetPerceptionAnchorFromSpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryGetPerceptionAnchorFromSpatialAnchorMSFT>
   *
   * @xrentity{xrTryGetPerceptionAnchorFromSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result tryGetPerceptionAnchorFromSpatialAnchorMSFT(
      SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTryGetPerceptionAnchorFromSpatialAnchorMSFT enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryGetPerceptionAnchorFromSpatialAnchorMSFT>
   *
   * @xrentity{xrTryGetPerceptionAnchorFromSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result tryGetPerceptionAnchorFromSpatialAnchorMSFT(
      SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTryGetPerceptionAnchorFromSpatialAnchorMSFT enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTryGetPerceptionAnchorFromSpatialAnchorMSFT>
   *
   * @xrentity{xrTryGetPerceptionAnchorFromSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void tryGetPerceptionAnchorFromSpatialAnchorMSFT(
      SpatialAnchorMSFT anchor, IUnknown** perceptionAnchor,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_WIN32)
#endif  // XR_MSFT_perception_anchor_interop

#ifdef XR_FB_body_tracking

  /*!
   * @brief xrCreateBodyTrackerFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerFB>
   *
   * @xrentity{xrCreateBodyTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createBodyTrackerFB(const BodyTrackerCreateInfoFB& createInfo, BodyTrackerFB& bodyTracker,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateBodyTrackerFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type BodyTrackerFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerFB>
   *
   * @xrentity{xrCreateBodyTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<BodyTrackerFB> createBodyTrackerFB(const BodyTrackerCreateInfoFB& createInfo,
                                                 Dispatch&& d
                                                     OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateBodyTrackerFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type BodyTrackerFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerFB>
   *
   * @xrentity{xrCreateBodyTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  BodyTrackerFB createBodyTrackerFB(const BodyTrackerCreateInfoFB& createInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateBodyTrackerFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a BodyTrackerFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerFB>
   *
   * @xrentity{xrCreateBodyTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<BodyTrackerFB, impl::RemoveRefConst<Dispatch>>>
  createBodyTrackerUniqueFB(const BodyTrackerCreateInfoFB& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateBodyTrackerFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a BodyTrackerFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerFB>
   *
   * @xrentity{xrCreateBodyTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<BodyTrackerFB, impl::RemoveRefConst<Dispatch>> createBodyTrackerUniqueFB(
      const BodyTrackerCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_body_tracking

#ifdef XR_MSFT_scene_understanding

  /*!
   * @brief xrCreateSceneObserverMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneObserverMSFT>
   *
   * @xrentity{xrCreateSceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSceneObserverMSFT(const SceneObserverCreateInfoMSFT& createInfo,
                                 SceneObserverMSFT& sceneObserver,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSceneObserverMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SceneObserverMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneObserverMSFT>
   *
   * @xrentity{xrCreateSceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SceneObserverMSFT> createSceneObserverMSFT(
      const SceneObserverCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSceneObserverMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SceneObserverMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneObserverMSFT>
   *
   * @xrentity{xrCreateSceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SceneObserverMSFT createSceneObserverMSFT(const SceneObserverCreateInfoMSFT& createInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSceneObserverMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SceneObserverMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneObserverMSFT>
   *
   * @xrentity{xrCreateSceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SceneObserverMSFT, impl::RemoveRefConst<Dispatch>>>
  createSceneObserverUniqueMSFT(const SceneObserverCreateInfoMSFT& createInfo,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSceneObserverMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SceneObserverMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneObserverMSFT>
   *
   * @xrentity{xrCreateSceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SceneObserverMSFT, impl::RemoveRefConst<Dispatch>> createSceneObserverUniqueMSFT(
      const SceneObserverCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_scene_understanding

#ifdef XR_FB_display_refresh_rate

  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateDisplayRefreshRatesFB(uint32_t displayRefreshRateCapacityInput,
                                        uint32_t& displayRefreshRateCountOutput,
                                        float* displayRefreshRates,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<float, Allocator>> enumerateDisplayRefreshRatesToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<float, Allocator>> enumerateDisplayRefreshRatesToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<float, Allocator> enumerateDisplayRefreshRatesToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateDisplayRefreshRatesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateDisplayRefreshRatesFB>
   *
   * @xrentity{xrEnumerateDisplayRefreshRatesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<float, Allocator> enumerateDisplayRefreshRatesToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_display_refresh_rate

#ifdef XR_FB_display_refresh_rate

  /*!
   * @brief xrGetDisplayRefreshRateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetDisplayRefreshRateFB>
   *
   * @xrentity{xrGetDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getDisplayRefreshRateFB(float& displayRefreshRate,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetDisplayRefreshRateFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type float
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetDisplayRefreshRateFB>
   *
   * @xrentity{xrGetDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<float> getDisplayRefreshRateFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetDisplayRefreshRateFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type float
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetDisplayRefreshRateFB>
   *
   * @xrentity{xrGetDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  float getDisplayRefreshRateFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_display_refresh_rate

#ifdef XR_FB_display_refresh_rate

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrRequestDisplayRefreshRateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestDisplayRefreshRateFB>
   *
   * @xrentity{xrRequestDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestDisplayRefreshRateFB(float displayRefreshRate,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRequestDisplayRefreshRateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestDisplayRefreshRateFB>
   *
   * @xrentity{xrRequestDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestDisplayRefreshRateFB(float displayRefreshRate,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRequestDisplayRefreshRateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestDisplayRefreshRateFB>
   *
   * @xrentity{xrRequestDisplayRefreshRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void requestDisplayRefreshRateFB(float displayRefreshRate,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_display_refresh_rate

#ifdef XR_HTC_facial_tracking

  /*!
   * @brief xrCreateFacialTrackerHTC wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialTrackerHTC>
   *
   * @xrentity{xrCreateFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createFacialTrackerHTC(const FacialTrackerCreateInfoHTC& createInfo,
                                FacialTrackerHTC& facialTracker,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFacialTrackerHTC enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FacialTrackerHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialTrackerHTC>
   *
   * @xrentity{xrCreateFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FacialTrackerHTC> createFacialTrackerHTC(
      const FacialTrackerCreateInfoHTC& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFacialTrackerHTC enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FacialTrackerHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialTrackerHTC>
   *
   * @xrentity{xrCreateFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FacialTrackerHTC createFacialTrackerHTC(const FacialTrackerCreateInfoHTC& createInfo,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFacialTrackerHTC wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a FacialTrackerHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialTrackerHTC>
   *
   * @xrentity{xrCreateFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<FacialTrackerHTC, impl::RemoveRefConst<Dispatch>>>
  createFacialTrackerUniqueHTC(const FacialTrackerCreateInfoHTC& createInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFacialTrackerHTC wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a FacialTrackerHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialTrackerHTC>
   *
   * @xrentity{xrCreateFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<FacialTrackerHTC, impl::RemoveRefConst<Dispatch>> createFacialTrackerUniqueHTC(
      const FacialTrackerCreateInfoHTC& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_HTC_facial_tracking

#ifdef XR_FB_color_space

  /*!
   * @brief xrEnumerateColorSpacesFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateColorSpacesFB(uint32_t colorSpaceCapacityInput, uint32_t& colorSpaceCountOutput,
                                ColorSpaceFB* colorSpaces,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateColorSpacesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ColorSpaceFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ColorSpaceFB>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ColorSpaceFB, Allocator>> enumerateColorSpacesToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateColorSpacesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ColorSpaceFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ColorSpaceFB>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ColorSpaceFB, Allocator>> enumerateColorSpacesToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateColorSpacesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ColorSpaceFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ColorSpaceFB>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ColorSpaceFB, Allocator> enumerateColorSpacesToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateColorSpacesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ColorSpaceFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateColorSpacesFB>
   *
   * @xrentity{xrEnumerateColorSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ColorSpaceFB>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ColorSpaceFB, Allocator> enumerateColorSpacesToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_color_space

#ifdef XR_FB_color_space

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetColorSpaceFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetColorSpaceFB>
   *
   * @xrentity{xrSetColorSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setColorSpaceFB(ColorSpaceFB colorSpace,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetColorSpaceFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetColorSpaceFB>
   *
   * @xrentity{xrSetColorSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setColorSpaceFB(ColorSpaceFB colorSpace,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetColorSpaceFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetColorSpaceFB>
   *
   * @xrentity{xrSetColorSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setColorSpaceFB(ColorSpaceFB colorSpace,
                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_color_space

#ifdef XR_FB_spatial_entity

  /*!
   * @brief xrCreateSpatialAnchorFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFB>
   *
   * @xrentity{xrCreateSpatialAnchorFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorFB(const SpatialAnchorCreateInfoFB& info, AsyncRequestIdFB& requestId,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFB>
   *
   * @xrentity{xrCreateSpatialAnchorFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> createSpatialAnchorFB(
      const SpatialAnchorCreateInfoFB& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFB>
   *
   * @xrentity{xrCreateSpatialAnchorFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB createSpatialAnchorFB(const SpatialAnchorCreateInfoFB& info,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity

#ifdef XR_FB_foveation

  /*!
   * @brief xrCreateFoveationProfileFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFoveationProfileFB>
   *
   * @xrentity{xrCreateFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createFoveationProfileFB(const FoveationProfileCreateInfoFB& createInfo,
                                  FoveationProfileFB& profile,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFoveationProfileFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FoveationProfileFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFoveationProfileFB>
   *
   * @xrentity{xrCreateFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FoveationProfileFB> createFoveationProfileFB(
      const FoveationProfileCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFoveationProfileFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FoveationProfileFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFoveationProfileFB>
   *
   * @xrentity{xrCreateFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FoveationProfileFB createFoveationProfileFB(const FoveationProfileCreateInfoFB& createInfo,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFoveationProfileFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a FoveationProfileFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFoveationProfileFB>
   *
   * @xrentity{xrCreateFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<FoveationProfileFB, impl::RemoveRefConst<Dispatch>>>
  createFoveationProfileUniqueFB(const FoveationProfileCreateInfoFB& createInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFoveationProfileFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a FoveationProfileFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFoveationProfileFB>
   *
   * @xrentity{xrCreateFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<FoveationProfileFB, impl::RemoveRefConst<Dispatch>> createFoveationProfileUniqueFB(
      const FoveationProfileCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_foveation

#ifdef XR_FB_keyboard_tracking

  /*!
   * @brief xrQuerySystemTrackedKeyboardFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySystemTrackedKeyboardFB>
   *
   * @xrentity{xrQuerySystemTrackedKeyboardFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result querySystemTrackedKeyboardFB(const KeyboardTrackingQueryFB& queryInfo,
                                      KeyboardTrackingDescriptionFB& keyboard,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrQuerySystemTrackedKeyboardFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type KeyboardTrackingDescriptionFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySystemTrackedKeyboardFB>
   *
   * @xrentity{xrQuerySystemTrackedKeyboardFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<KeyboardTrackingDescriptionFB> querySystemTrackedKeyboardFB(
      const KeyboardTrackingQueryFB& queryInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrQuerySystemTrackedKeyboardFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type KeyboardTrackingDescriptionFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySystemTrackedKeyboardFB>
   *
   * @xrentity{xrQuerySystemTrackedKeyboardFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  KeyboardTrackingDescriptionFB querySystemTrackedKeyboardFB(
      const KeyboardTrackingQueryFB& queryInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_keyboard_tracking

  /*!
   * @brief xrCreateKeyboardSpaceFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateKeyboardSpaceFB>
   *
   * @xrentity{xrCreateKeyboardSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createKeyboardSpaceFB(const KeyboardSpaceCreateInfoFB& createInfo, Space& keyboardSpace,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateKeyboardSpaceFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateKeyboardSpaceFB>
   *
   * @xrentity{xrCreateKeyboardSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createKeyboardSpaceFB(const KeyboardSpaceCreateInfoFB& createInfo,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateKeyboardSpaceFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateKeyboardSpaceFB>
   *
   * @xrentity{xrCreateKeyboardSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createKeyboardSpaceFB(const KeyboardSpaceCreateInfoFB& createInfo,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateKeyboardSpaceFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateKeyboardSpaceFB>
   *
   * @xrentity{xrCreateKeyboardSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createKeyboardSpaceUniqueFB(
      const KeyboardSpaceCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateKeyboardSpaceFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateKeyboardSpaceFB>
   *
   * @xrentity{xrCreateKeyboardSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createKeyboardSpaceUniqueFB(
      const KeyboardSpaceCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_keyboard_tracking

#ifdef XR_FB_triangle_mesh

  /*!
   * @brief xrCreateTriangleMeshFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateTriangleMeshFB>
   *
   * @xrentity{xrCreateTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createTriangleMeshFB(const TriangleMeshCreateInfoFB& createInfo,
                              TriangleMeshFB& outTriangleMesh,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateTriangleMeshFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type TriangleMeshFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateTriangleMeshFB>
   *
   * @xrentity{xrCreateTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<TriangleMeshFB> createTriangleMeshFB(const TriangleMeshCreateInfoFB& createInfo,
                                                   Dispatch&& d
                                                       OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateTriangleMeshFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type TriangleMeshFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateTriangleMeshFB>
   *
   * @xrentity{xrCreateTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  TriangleMeshFB createTriangleMeshFB(const TriangleMeshCreateInfoFB& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateTriangleMeshFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a TriangleMeshFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateTriangleMeshFB>
   *
   * @xrentity{xrCreateTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<TriangleMeshFB, impl::RemoveRefConst<Dispatch>>>
  createTriangleMeshUniqueFB(const TriangleMeshCreateInfoFB& createInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateTriangleMeshFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a TriangleMeshFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateTriangleMeshFB>
   *
   * @xrentity{xrCreateTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<TriangleMeshFB, impl::RemoveRefConst<Dispatch>> createTriangleMeshUniqueFB(
      const TriangleMeshCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_passthrough

  /*!
   * @brief xrCreatePassthroughFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughFB>
   *
   * @xrentity{xrCreatePassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createPassthroughFB(const PassthroughCreateInfoFB& createInfo,
                             PassthroughFB& outPassthrough,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePassthroughFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type PassthroughFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughFB>
   *
   * @xrentity{xrCreatePassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<PassthroughFB> createPassthroughFB(const PassthroughCreateInfoFB& createInfo,
                                                 Dispatch&& d
                                                     OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePassthroughFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type PassthroughFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughFB>
   *
   * @xrentity{xrCreatePassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  PassthroughFB createPassthroughFB(const PassthroughCreateInfoFB& createInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePassthroughFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a PassthroughFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughFB>
   *
   * @xrentity{xrCreatePassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<PassthroughFB, impl::RemoveRefConst<Dispatch>>>
  createPassthroughUniqueFB(const PassthroughCreateInfoFB& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePassthroughFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a PassthroughFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughFB>
   *
   * @xrentity{xrCreatePassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<PassthroughFB, impl::RemoveRefConst<Dispatch>> createPassthroughUniqueFB(
      const PassthroughCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

  /*!
   * @brief xrCreatePassthroughLayerFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughLayerFB>
   *
   * @xrentity{xrCreatePassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createPassthroughLayerFB(const PassthroughLayerCreateInfoFB& createInfo,
                                  PassthroughLayerFB& outLayer,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePassthroughLayerFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type PassthroughLayerFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughLayerFB>
   *
   * @xrentity{xrCreatePassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<PassthroughLayerFB> createPassthroughLayerFB(
      const PassthroughLayerCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePassthroughLayerFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type PassthroughLayerFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughLayerFB>
   *
   * @xrentity{xrCreatePassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  PassthroughLayerFB createPassthroughLayerFB(const PassthroughLayerCreateInfoFB& createInfo,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePassthroughLayerFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a PassthroughLayerFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughLayerFB>
   *
   * @xrentity{xrCreatePassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<PassthroughLayerFB, impl::RemoveRefConst<Dispatch>>>
  createPassthroughLayerUniqueFB(const PassthroughLayerCreateInfoFB& createInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePassthroughLayerFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a PassthroughLayerFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughLayerFB>
   *
   * @xrentity{xrCreatePassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<PassthroughLayerFB, impl::RemoveRefConst<Dispatch>> createPassthroughLayerUniqueFB(
      const PassthroughLayerCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

  /*!
   * @brief xrCreateGeometryInstanceFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateGeometryInstanceFB>
   *
   * @xrentity{xrCreateGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createGeometryInstanceFB(const GeometryInstanceCreateInfoFB& createInfo,
                                  GeometryInstanceFB& outGeometryInstance,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateGeometryInstanceFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type GeometryInstanceFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateGeometryInstanceFB>
   *
   * @xrentity{xrCreateGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<GeometryInstanceFB> createGeometryInstanceFB(
      const GeometryInstanceCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateGeometryInstanceFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type GeometryInstanceFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateGeometryInstanceFB>
   *
   * @xrentity{xrCreateGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  GeometryInstanceFB createGeometryInstanceFB(const GeometryInstanceCreateInfoFB& createInfo,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateGeometryInstanceFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a GeometryInstanceFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateGeometryInstanceFB>
   *
   * @xrentity{xrCreateGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<GeometryInstanceFB, impl::RemoveRefConst<Dispatch>>>
  createGeometryInstanceUniqueFB(const GeometryInstanceCreateInfoFB& createInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateGeometryInstanceFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a GeometryInstanceFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateGeometryInstanceFB>
   *
   * @xrentity{xrCreateGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<GeometryInstanceFB, impl::RemoveRefConst<Dispatch>> createGeometryInstanceUniqueFB(
      const GeometryInstanceCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_passthrough

#ifdef XR_FB_render_model

  /*!
   * @brief xrEnumerateRenderModelPathsFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelPathsFB>
   *
   * @xrentity{xrEnumerateRenderModelPathsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateRenderModelPathsFB(uint32_t pathCapacityInput, uint32_t& pathCountOutput,
                                     RenderModelPathInfoFB* paths,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateRenderModelPathsFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<RenderModelPathInfoFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelPathsFB>
   *
   * @xrentity{xrEnumerateRenderModelPathsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<RenderModelPathInfoFB>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<RenderModelPathInfoFB, Allocator>> enumerateRenderModelPathsToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateRenderModelPathsFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<RenderModelPathInfoFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelPathsFB>
   *
   * @xrentity{xrEnumerateRenderModelPathsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<RenderModelPathInfoFB>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<RenderModelPathInfoFB, Allocator>> enumerateRenderModelPathsToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateRenderModelPathsFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<RenderModelPathInfoFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelPathsFB>
   *
   * @xrentity{xrEnumerateRenderModelPathsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<RenderModelPathInfoFB>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<RenderModelPathInfoFB, Allocator> enumerateRenderModelPathsToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateRenderModelPathsFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<RenderModelPathInfoFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelPathsFB>
   *
   * @xrentity{xrEnumerateRenderModelPathsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<RenderModelPathInfoFB>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<RenderModelPathInfoFB, Allocator> enumerateRenderModelPathsToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_render_model

#ifdef XR_FB_render_model

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetRenderModelPropertiesFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelPropertiesFB>
   *
   * @xrentity{xrGetRenderModelPropertiesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRenderModelPropertiesFB(Path path, RenderModelPropertiesFB& properties,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetRenderModelPropertiesFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::RenderModelUnavailableFB, or an error
   * code if asserts are not active and exceptions are disabled)
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelPropertiesFB>
   *
   * @xrentity{xrGetRenderModelPropertiesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRenderModelPropertiesFB(Path path, RenderModelPropertiesFB& properties,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_render_model

#ifdef XR_FB_render_model

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrLoadRenderModelFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLoadRenderModelFB>
   *
   * @xrentity{xrLoadRenderModelFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result loadRenderModelFB(const RenderModelLoadInfoFB& info, RenderModelBufferFB& buffer,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrLoadRenderModelFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::RenderModelUnavailableFB, or an error
   * code if asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLoadRenderModelFB>
   *
   * @xrentity{xrLoadRenderModelFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result loadRenderModelFB(const RenderModelLoadInfoFB& info, RenderModelBufferFB& buffer,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_render_model

#ifdef XR_VARJO_environment_depth_estimation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetEnvironmentDepthEstimationVARJO wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetEnvironmentDepthEstimationVARJO>
   *
   * @xrentity{xrSetEnvironmentDepthEstimationVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setEnvironmentDepthEstimationVARJO(Bool32 enabled,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetEnvironmentDepthEstimationVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetEnvironmentDepthEstimationVARJO>
   *
   * @xrentity{xrSetEnvironmentDepthEstimationVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setEnvironmentDepthEstimationVARJO(Bool32 enabled,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetEnvironmentDepthEstimationVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetEnvironmentDepthEstimationVARJO>
   *
   * @xrentity{xrSetEnvironmentDepthEstimationVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setEnvironmentDepthEstimationVARJO(Bool32 enabled,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_environment_depth_estimation

#ifdef XR_VARJO_marker_tracking

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetMarkerTrackingVARJO wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingVARJO>
   *
   * @xrentity{xrSetMarkerTrackingVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setMarkerTrackingVARJO(Bool32 enabled,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetMarkerTrackingVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingVARJO>
   *
   * @xrentity{xrSetMarkerTrackingVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setMarkerTrackingVARJO(Bool32 enabled,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetMarkerTrackingVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingVARJO>
   *
   * @xrentity{xrSetMarkerTrackingVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setMarkerTrackingVARJO(Bool32 enabled,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetMarkerTrackingTimeoutVARJO wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingTimeoutVARJO>
   *
   * @xrentity{xrSetMarkerTrackingTimeoutVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setMarkerTrackingTimeoutVARJO(uint64_t markerId, Duration timeout,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetMarkerTrackingTimeoutVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingTimeoutVARJO>
   *
   * @xrentity{xrSetMarkerTrackingTimeoutVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setMarkerTrackingTimeoutVARJO(uint64_t markerId, Duration timeout,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetMarkerTrackingTimeoutVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingTimeoutVARJO>
   *
   * @xrentity{xrSetMarkerTrackingTimeoutVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setMarkerTrackingTimeoutVARJO(uint64_t markerId, Duration timeout,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetMarkerTrackingPredictionVARJO wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingPredictionVARJO>
   *
   * @xrentity{xrSetMarkerTrackingPredictionVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setMarkerTrackingPredictionVARJO(uint64_t markerId, Bool32 enable,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetMarkerTrackingPredictionVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingPredictionVARJO>
   *
   * @xrentity{xrSetMarkerTrackingPredictionVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setMarkerTrackingPredictionVARJO(uint64_t markerId, Bool32 enable,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetMarkerTrackingPredictionVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetMarkerTrackingPredictionVARJO>
   *
   * @xrentity{xrSetMarkerTrackingPredictionVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setMarkerTrackingPredictionVARJO(uint64_t markerId, Bool32 enable,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking

  /*!
   * @brief xrGetMarkerSizeVARJO wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerSizeVARJO>
   *
   * @xrentity{xrGetMarkerSizeVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getMarkerSizeVARJO(uint64_t markerId, Extent2Df& size,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetMarkerSizeVARJO enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Extent2Df
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerSizeVARJO>
   *
   * @xrentity{xrGetMarkerSizeVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Extent2Df> getMarkerSizeVARJO(uint64_t markerId,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetMarkerSizeVARJO enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Extent2Df
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerSizeVARJO>
   *
   * @xrentity{xrGetMarkerSizeVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Extent2Df getMarkerSizeVARJO(uint64_t markerId,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_marker_tracking

  /*!
   * @brief xrCreateMarkerSpaceVARJO wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceVARJO>
   *
   * @xrentity{xrCreateMarkerSpaceVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createMarkerSpaceVARJO(const MarkerSpaceCreateInfoVARJO& createInfo, Space& space,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateMarkerSpaceVARJO enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceVARJO>
   *
   * @xrentity{xrCreateMarkerSpaceVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createMarkerSpaceVARJO(const MarkerSpaceCreateInfoVARJO& createInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateMarkerSpaceVARJO enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceVARJO>
   *
   * @xrentity{xrCreateMarkerSpaceVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createMarkerSpaceVARJO(const MarkerSpaceCreateInfoVARJO& createInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateMarkerSpaceVARJO wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceVARJO>
   *
   * @xrentity{xrCreateMarkerSpaceVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createMarkerSpaceUniqueVARJO(
      const MarkerSpaceCreateInfoVARJO& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateMarkerSpaceVARJO wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceVARJO>
   *
   * @xrentity{xrCreateMarkerSpaceVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createMarkerSpaceUniqueVARJO(
      const MarkerSpaceCreateInfoVARJO& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_marker_tracking

#ifdef XR_VARJO_view_offset

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetViewOffsetVARJO wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetViewOffsetVARJO>
   *
   * @xrentity{xrSetViewOffsetVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setViewOffsetVARJO(float offset, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetViewOffsetVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetViewOffsetVARJO>
   *
   * @xrentity{xrSetViewOffsetVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setViewOffsetVARJO(float offset, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetViewOffsetVARJO enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetViewOffsetVARJO>
   *
   * @xrentity{xrSetViewOffsetVARJO}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setViewOffsetVARJO(float offset, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_VARJO_view_offset

#ifdef XR_ML_compat
#if defined(XR_USE_PLATFORM_ML)

  /*!
   * @brief xrCreateSpaceFromCoordinateFrameUIDML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpaceFromCoordinateFrameUIDML>
   *
   * @xrentity{xrCreateSpaceFromCoordinateFrameUIDML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpaceFromCoordinateFrameUIDML(
      const CoordinateSpaceCreateInfoML& createInfo, Space& space,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpaceFromCoordinateFrameUIDML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpaceFromCoordinateFrameUIDML>
   *
   * @xrentity{xrCreateSpaceFromCoordinateFrameUIDML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createSpaceFromCoordinateFrameUIDML(
      const CoordinateSpaceCreateInfoML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpaceFromCoordinateFrameUIDML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpaceFromCoordinateFrameUIDML>
   *
   * @xrentity{xrCreateSpaceFromCoordinateFrameUIDML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createSpaceFromCoordinateFrameUIDML(const CoordinateSpaceCreateInfoML& createInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpaceFromCoordinateFrameUIDML wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpaceFromCoordinateFrameUIDML>
   *
   * @xrentity{xrCreateSpaceFromCoordinateFrameUIDML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>>
  createSpaceFromCoordinateFrameUIDUniqueML(const CoordinateSpaceCreateInfoML& createInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpaceFromCoordinateFrameUIDML wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpaceFromCoordinateFrameUIDML>
   *
   * @xrentity{xrCreateSpaceFromCoordinateFrameUIDML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createSpaceFromCoordinateFrameUIDUniqueML(
      const CoordinateSpaceCreateInfoML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // defined(XR_USE_PLATFORM_ML)
#endif  // XR_ML_compat

#ifdef XR_ML_marker_understanding

  /*!
   * @brief xrCreateMarkerDetectorML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerDetectorML>
   *
   * @xrentity{xrCreateMarkerDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createMarkerDetectorML(const MarkerDetectorCreateInfoML& createInfo,
                                MarkerDetectorML& markerDetector,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateMarkerDetectorML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type MarkerDetectorML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerDetectorML>
   *
   * @xrentity{xrCreateMarkerDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<MarkerDetectorML> createMarkerDetectorML(
      const MarkerDetectorCreateInfoML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateMarkerDetectorML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type MarkerDetectorML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerDetectorML>
   *
   * @xrentity{xrCreateMarkerDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  MarkerDetectorML createMarkerDetectorML(const MarkerDetectorCreateInfoML& createInfo,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateMarkerDetectorML wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a MarkerDetectorML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerDetectorML>
   *
   * @xrentity{xrCreateMarkerDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<MarkerDetectorML, impl::RemoveRefConst<Dispatch>>>
  createMarkerDetectorUniqueML(const MarkerDetectorCreateInfoML& createInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateMarkerDetectorML wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a MarkerDetectorML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerDetectorML>
   *
   * @xrentity{xrCreateMarkerDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<MarkerDetectorML, impl::RemoveRefConst<Dispatch>> createMarkerDetectorUniqueML(
      const MarkerDetectorCreateInfoML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_marker_understanding

#ifdef XR_ML_marker_understanding

  /*!
   * @brief xrCreateMarkerSpaceML wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceML>
   *
   * @xrentity{xrCreateMarkerSpaceML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createMarkerSpaceML(const MarkerSpaceCreateInfoML& createInfo, Space& space,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateMarkerSpaceML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceML>
   *
   * @xrentity{xrCreateMarkerSpaceML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createMarkerSpaceML(const MarkerSpaceCreateInfoML& createInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateMarkerSpaceML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceML>
   *
   * @xrentity{xrCreateMarkerSpaceML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createMarkerSpaceML(const MarkerSpaceCreateInfoML& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateMarkerSpaceML wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceML>
   *
   * @xrentity{xrCreateMarkerSpaceML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createMarkerSpaceUniqueML(
      const MarkerSpaceCreateInfoML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateMarkerSpaceML wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateMarkerSpaceML>
   *
   * @xrentity{xrCreateMarkerSpaceML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createMarkerSpaceUniqueML(
      const MarkerSpaceCreateInfoML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_marker_understanding

#ifdef XR_ML_localization_map

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrEnableLocalizationEventsML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnableLocalizationEventsML>
   *
   * @xrentity{xrEnableLocalizationEventsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enableLocalizationEventsML(const LocalizationEnableEventsInfoML& info,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnableLocalizationEventsML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnableLocalizationEventsML>
   *
   * @xrentity{xrEnableLocalizationEventsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enableLocalizationEventsML(const LocalizationEnableEventsInfoML& info,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrEnableLocalizationEventsML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnableLocalizationEventsML>
   *
   * @xrentity{xrEnableLocalizationEventsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void enableLocalizationEventsML(const LocalizationEnableEventsInfoML& info,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_localization_map

#ifdef XR_ML_localization_map

  /*!
   * @brief xrQueryLocalizationMapsML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQueryLocalizationMapsML>
   *
   * @xrentity{xrQueryLocalizationMapsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result queryLocalizationMapsML(const LocalizationMapQueryInfoBaseHeaderML& queryInfo,
                                 uint32_t mapCapacityInput, uint32_t& mapCountOutput,
                                 LocalizationMapML* maps,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrQueryLocalizationMapsML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<LocalizationMapML, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQueryLocalizationMapsML>
   *
   * @xrentity{xrQueryLocalizationMapsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<LocalizationMapML>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<LocalizationMapML, Allocator>> queryLocalizationMapsToVectorML(
      const LocalizationMapQueryInfoBaseHeaderML& queryInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrQueryLocalizationMapsML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<LocalizationMapML, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQueryLocalizationMapsML>
   *
   * @xrentity{xrQueryLocalizationMapsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<LocalizationMapML>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<LocalizationMapML, Allocator>> queryLocalizationMapsToVectorML(
      const LocalizationMapQueryInfoBaseHeaderML& queryInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#else
  /*!
   * @brief xrQueryLocalizationMapsML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<LocalizationMapML, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQueryLocalizationMapsML>
   *
   * @xrentity{xrQueryLocalizationMapsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<LocalizationMapML>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<LocalizationMapML, Allocator> queryLocalizationMapsToVectorML(
      const LocalizationMapQueryInfoBaseHeaderML& queryInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrQueryLocalizationMapsML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<LocalizationMapML, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQueryLocalizationMapsML>
   *
   * @xrentity{xrQueryLocalizationMapsML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<LocalizationMapML>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<LocalizationMapML, Allocator> queryLocalizationMapsToVectorML(
      const LocalizationMapQueryInfoBaseHeaderML& queryInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_localization_map

#ifdef XR_ML_localization_map

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrRequestMapLocalizationML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestMapLocalizationML>
   *
   * @xrentity{xrRequestMapLocalizationML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestMapLocalizationML(const MapLocalizationRequestInfoML& requestInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRequestMapLocalizationML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestMapLocalizationML>
   *
   * @xrentity{xrRequestMapLocalizationML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestMapLocalizationML(const MapLocalizationRequestInfoML& requestInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRequestMapLocalizationML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestMapLocalizationML>
   *
   * @xrentity{xrRequestMapLocalizationML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void requestMapLocalizationML(const MapLocalizationRequestInfoML& requestInfo,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_localization_map

#ifdef XR_ML_localization_map

  /*!
   * @brief xrImportLocalizationMapML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrImportLocalizationMapML>
   *
   * @xrentity{xrImportLocalizationMapML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result importLocalizationMapML(const LocalizationMapImportInfoML& importInfo, XrUuidEXT* mapUuid,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrImportLocalizationMapML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type UuidEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrImportLocalizationMapML>
   *
   * @xrentity{xrImportLocalizationMapML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UuidEXT> importLocalizationMapML(const LocalizationMapImportInfoML& importInfo,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrImportLocalizationMapML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type UuidEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrImportLocalizationMapML>
   *
   * @xrentity{xrImportLocalizationMapML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UuidEXT importLocalizationMapML(const LocalizationMapImportInfoML& importInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_localization_map

#ifdef XR_ML_localization_map

  /*!
   * @brief xrCreateExportedLocalizationMapML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateExportedLocalizationMapML>
   *
   * @xrentity{xrCreateExportedLocalizationMapML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createExportedLocalizationMapML(const XrUuidEXT* mapUuid, ExportedLocalizationMapML& map,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateExportedLocalizationMapML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type ExportedLocalizationMapML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateExportedLocalizationMapML>
   *
   * @xrentity{xrCreateExportedLocalizationMapML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<ExportedLocalizationMapML> createExportedLocalizationMapML(
      const XrUuidEXT* mapUuid, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateExportedLocalizationMapML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type ExportedLocalizationMapML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateExportedLocalizationMapML>
   *
   * @xrentity{xrCreateExportedLocalizationMapML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ExportedLocalizationMapML createExportedLocalizationMapML(
      const XrUuidEXT* mapUuid, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateExportedLocalizationMapML wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a ExportedLocalizationMapML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateExportedLocalizationMapML>
   *
   * @xrentity{xrCreateExportedLocalizationMapML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<ExportedLocalizationMapML, impl::RemoveRefConst<Dispatch>>>
  createExportedLocalizationMapUniqueML(const XrUuidEXT* mapUuid,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateExportedLocalizationMapML wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a ExportedLocalizationMapML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateExportedLocalizationMapML>
   *
   * @xrentity{xrCreateExportedLocalizationMapML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<ExportedLocalizationMapML, impl::RemoveRefConst<Dispatch>>
  createExportedLocalizationMapUniqueML(const XrUuidEXT* mapUuid,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_localization_map

#ifdef XR_ML_spatial_anchors

  /*!
   * @brief xrCreateSpatialAnchorsAsyncML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorsAsyncML>
   *
   * @xrentity{xrCreateSpatialAnchorsAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorsAsyncML(const SpatialAnchorsCreateInfoBaseHeaderML& createInfo,
                                     FutureEXT& future,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorsAsyncML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorsAsyncML>
   *
   * @xrentity{xrCreateSpatialAnchorsAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> createSpatialAnchorsAsyncML(
      const SpatialAnchorsCreateInfoBaseHeaderML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorsAsyncML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorsAsyncML>
   *
   * @xrentity{xrCreateSpatialAnchorsAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT createSpatialAnchorsAsyncML(const SpatialAnchorsCreateInfoBaseHeaderML& createInfo,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_spatial_anchors

#ifdef XR_ML_spatial_anchors

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrCreateSpatialAnchorsCompleteML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorsCompleteML>
   *
   * @xrentity{xrCreateSpatialAnchorsCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorsCompleteML(FutureEXT future,
                                        CreateSpatialAnchorsCompletionML& completion,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorsCompleteML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorsCompleteML>
   *
   * @xrentity{xrCreateSpatialAnchorsCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorsCompleteML(FutureEXT future,
                                        CreateSpatialAnchorsCompletionML& completion,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorsCompleteML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorsCompleteML>
   *
   * @xrentity{xrCreateSpatialAnchorsCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void createSpatialAnchorsCompleteML(FutureEXT future,
                                      CreateSpatialAnchorsCompletionML& completion,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_spatial_anchors

#ifdef XR_ML_spatial_anchors_storage

  /*!
   * @brief xrCreateSpatialAnchorsStorageML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorsStorageML>
   *
   * @xrentity{xrCreateSpatialAnchorsStorageML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorsStorageML(const SpatialAnchorsCreateStorageInfoML& createInfo,
                                       SpatialAnchorsStorageML& storage,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorsStorageML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorsStorageML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorsStorageML>
   *
   * @xrentity{xrCreateSpatialAnchorsStorageML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorsStorageML> createSpatialAnchorsStorageML(
      const SpatialAnchorsCreateStorageInfoML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorsStorageML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorsStorageML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorsStorageML>
   *
   * @xrentity{xrCreateSpatialAnchorsStorageML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorsStorageML createSpatialAnchorsStorageML(
      const SpatialAnchorsCreateStorageInfoML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorsStorageML wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialAnchorsStorageML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorsStorageML>
   *
   * @xrentity{xrCreateSpatialAnchorsStorageML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialAnchorsStorageML, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorsStorageUniqueML(const SpatialAnchorsCreateStorageInfoML& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorsStorageML wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialAnchorsStorageML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorsStorageML>
   *
   * @xrentity{xrCreateSpatialAnchorsStorageML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialAnchorsStorageML, impl::RemoveRefConst<Dispatch>>
  createSpatialAnchorsStorageUniqueML(const SpatialAnchorsCreateStorageInfoML& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_MSFT_spatial_anchor_persistence

  /*!
   * @brief xrCreateSpatialAnchorStoreConnectionMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorStoreConnectionMSFT(
      SpatialAnchorStoreConnectionMSFT& spatialAnchorStore,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorStoreConnectionMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorStoreConnectionMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorStoreConnectionMSFT> createSpatialAnchorStoreConnectionMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorStoreConnectionMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorStoreConnectionMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorStoreConnectionMSFT createSpatialAnchorStoreConnectionMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorStoreConnectionMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialAnchorStoreConnectionMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialAnchorStoreConnectionMSFT, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorStoreConnectionUniqueMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorStoreConnectionMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialAnchorStoreConnectionMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialAnchorStoreConnectionMSFT, impl::RemoveRefConst<Dispatch>>
  createSpatialAnchorStoreConnectionUniqueMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_MSFT_spatial_anchor_persistence

  /*!
   * @brief xrCreateSpatialAnchorFromPersistedNameMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPersistedNameMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPersistedNameMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorFromPersistedNameMSFT(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
      SpatialAnchorMSFT& spatialAnchor, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorFromPersistedNameMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPersistedNameMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPersistedNameMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorMSFT> createSpatialAnchorFromPersistedNameMSFT(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorFromPersistedNameMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPersistedNameMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPersistedNameMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorMSFT createSpatialAnchorFromPersistedNameMSFT(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorFromPersistedNameMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPersistedNameMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPersistedNameMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorFromPersistedNameUniqueMSFT(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorFromPersistedNameMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialAnchorMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorFromPersistedNameMSFT>
   *
   * @xrentity{xrCreateSpatialAnchorFromPersistedNameMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialAnchorMSFT, impl::RemoveRefConst<Dispatch>>
  createSpatialAnchorFromPersistedNameUniqueMSFT(
      const SpatialAnchorFromPersistedAnchorCreateInfoMSFT& spatialAnchorCreateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_FB_spatial_entity_query

  /*!
   * @brief xrQuerySpacesFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySpacesFB>
   *
   * @xrentity{xrQuerySpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result querySpacesFB(const SpaceQueryInfoBaseHeaderFB& info, AsyncRequestIdFB& requestId,
                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrQuerySpacesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySpacesFB>
   *
   * @xrentity{xrQuerySpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> querySpacesFB(const SpaceQueryInfoBaseHeaderFB& info,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrQuerySpacesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySpacesFB>
   *
   * @xrentity{xrQuerySpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB querySpacesFB(const SpaceQueryInfoBaseHeaderFB& info,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_query

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrRetrieveSpaceQueryResultsFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRetrieveSpaceQueryResultsFB>
   *
   * @xrentity{xrRetrieveSpaceQueryResultsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result retrieveSpaceQueryResultsFB(AsyncRequestIdFB requestId, SpaceQueryResultsFB& results,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRetrieveSpaceQueryResultsFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRetrieveSpaceQueryResultsFB>
   *
   * @xrentity{xrRetrieveSpaceQueryResultsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result retrieveSpaceQueryResultsFB(AsyncRequestIdFB requestId, SpaceQueryResultsFB& results,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRetrieveSpaceQueryResultsFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRetrieveSpaceQueryResultsFB>
   *
   * @xrentity{xrRetrieveSpaceQueryResultsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void retrieveSpaceQueryResultsFB(AsyncRequestIdFB requestId, SpaceQueryResultsFB& results,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity_query

#ifdef XR_FB_spatial_entity_storage

  /*!
   * @brief xrSaveSpaceFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSaveSpaceFB>
   *
   * @xrentity{xrSaveSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result saveSpaceFB(const SpaceSaveInfoFB& info, AsyncRequestIdFB& requestId,
                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSaveSpaceFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSaveSpaceFB>
   *
   * @xrentity{xrSaveSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> saveSpaceFB(const SpaceSaveInfoFB& info,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSaveSpaceFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSaveSpaceFB>
   *
   * @xrentity{xrSaveSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB saveSpaceFB(const SpaceSaveInfoFB& info,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity_storage

#ifdef XR_FB_spatial_entity_storage

  /*!
   * @brief xrEraseSpaceFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEraseSpaceFB>
   *
   * @xrentity{xrEraseSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result eraseSpaceFB(const SpaceEraseInfoFB& info, AsyncRequestIdFB& requestId,
                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEraseSpaceFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEraseSpaceFB>
   *
   * @xrentity{xrEraseSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> eraseSpaceFB(
      const SpaceEraseInfoFB& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrEraseSpaceFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEraseSpaceFB>
   *
   * @xrentity{xrEraseSpaceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB eraseSpaceFB(const SpaceEraseInfoFB& info,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity_storage

#ifdef XR_FB_spatial_entity_sharing

  /*!
   * @brief xrShareSpacesFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrShareSpacesFB>
   *
   * @xrentity{xrShareSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result shareSpacesFB(const SpaceShareInfoFB& info, AsyncRequestIdFB& requestId,
                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrShareSpacesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrShareSpacesFB>
   *
   * @xrentity{xrShareSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> shareSpacesFB(
      const SpaceShareInfoFB& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrShareSpacesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrShareSpacesFB>
   *
   * @xrentity{xrShareSpacesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB shareSpacesFB(const SpaceShareInfoFB& info,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity_sharing

#ifdef XR_FB_scene

  /*!
   * @brief xrGetSpaceBoundingBox2DFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceBoundingBox2DFB>
   *
   * @xrentity{xrGetSpaceBoundingBox2DFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceBoundingBox2DFB(Space space, Rect2Df& boundingBox2DOutput,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpaceBoundingBox2DFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Rect2Df
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceBoundingBox2DFB>
   *
   * @xrentity{xrGetSpaceBoundingBox2DFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Rect2Df> getSpaceBoundingBox2DFB(
      Space space, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpaceBoundingBox2DFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Rect2Df
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceBoundingBox2DFB>
   *
   * @xrentity{xrGetSpaceBoundingBox2DFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Rect2Df getSpaceBoundingBox2DFB(Space space,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_scene

#ifdef XR_FB_scene

  /*!
   * @brief xrGetSpaceBoundingBox3DFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceBoundingBox3DFB>
   *
   * @xrentity{xrGetSpaceBoundingBox3DFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceBoundingBox3DFB(Space space, Rect3DfFB& boundingBox3DOutput,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpaceBoundingBox3DFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Rect3DfFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceBoundingBox3DFB>
   *
   * @xrentity{xrGetSpaceBoundingBox3DFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Rect3DfFB> getSpaceBoundingBox3DFB(
      Space space, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpaceBoundingBox3DFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Rect3DfFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceBoundingBox3DFB>
   *
   * @xrentity{xrGetSpaceBoundingBox3DFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Rect3DfFB getSpaceBoundingBox3DFB(Space space,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_scene

#ifdef XR_FB_scene

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetSpaceSemanticLabelsFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceSemanticLabelsFB>
   *
   * @xrentity{xrGetSpaceSemanticLabelsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceSemanticLabelsFB(Space space, SemanticLabelsFB& semanticLabelsOutput,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpaceSemanticLabelsFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceSemanticLabelsFB>
   *
   * @xrentity{xrGetSpaceSemanticLabelsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceSemanticLabelsFB(Space space, SemanticLabelsFB& semanticLabelsOutput,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpaceSemanticLabelsFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceSemanticLabelsFB>
   *
   * @xrentity{xrGetSpaceSemanticLabelsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getSpaceSemanticLabelsFB(Space space, SemanticLabelsFB& semanticLabelsOutput,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_scene

#ifdef XR_FB_scene

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetSpaceBoundary2DFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceBoundary2DFB>
   *
   * @xrentity{xrGetSpaceBoundary2DFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceBoundary2DFB(Space space, Boundary2DFB& boundary2DOutput,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpaceBoundary2DFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceBoundary2DFB>
   *
   * @xrentity{xrGetSpaceBoundary2DFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceBoundary2DFB(Space space, Boundary2DFB& boundary2DOutput,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpaceBoundary2DFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceBoundary2DFB>
   *
   * @xrentity{xrGetSpaceBoundary2DFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getSpaceBoundary2DFB(Space space, Boundary2DFB& boundary2DOutput,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_scene

#ifdef XR_FB_scene

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetSpaceRoomLayoutFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceRoomLayoutFB>
   *
   * @xrentity{xrGetSpaceRoomLayoutFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceRoomLayoutFB(Space space, RoomLayoutFB& roomLayoutOutput,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpaceRoomLayoutFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceRoomLayoutFB>
   *
   * @xrentity{xrGetSpaceRoomLayoutFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceRoomLayoutFB(Space space, RoomLayoutFB& roomLayoutOutput,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpaceRoomLayoutFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceRoomLayoutFB>
   *
   * @xrentity{xrGetSpaceRoomLayoutFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getSpaceRoomLayoutFB(Space space, RoomLayoutFB& roomLayoutOutput,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_scene

#ifdef XR_ALMALENCE_digital_lens_control

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetDigitalLensControlALMALENCE wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDigitalLensControlALMALENCE>
   *
   * @xrentity{xrSetDigitalLensControlALMALENCE}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setDigitalLensControlALMALENCE(const DigitalLensControlALMALENCE& digitalLensControl,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetDigitalLensControlALMALENCE enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDigitalLensControlALMALENCE>
   *
   * @xrentity{xrSetDigitalLensControlALMALENCE}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setDigitalLensControlALMALENCE(const DigitalLensControlALMALENCE& digitalLensControl,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetDigitalLensControlALMALENCE enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetDigitalLensControlALMALENCE>
   *
   * @xrentity{xrSetDigitalLensControlALMALENCE}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setDigitalLensControlALMALENCE(const DigitalLensControlALMALENCE& digitalLensControl,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ALMALENCE_digital_lens_control

#ifdef XR_FB_scene_capture

  /*!
   * @brief xrRequestSceneCaptureFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestSceneCaptureFB>
   *
   * @xrentity{xrRequestSceneCaptureFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestSceneCaptureFB(const SceneCaptureRequestInfoFB& info, AsyncRequestIdFB& requestId,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRequestSceneCaptureFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestSceneCaptureFB>
   *
   * @xrentity{xrRequestSceneCaptureFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> requestSceneCaptureFB(
      const SceneCaptureRequestInfoFB& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRequestSceneCaptureFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestSceneCaptureFB>
   *
   * @xrentity{xrRequestSceneCaptureFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB requestSceneCaptureFB(const SceneCaptureRequestInfoFB& info,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_scene_capture

#ifdef XR_FB_spatial_entity_container

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetSpaceContainerFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceContainerFB>
   *
   * @xrentity{xrGetSpaceContainerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceContainerFB(Space space, SpaceContainerFB& spaceContainerOutput,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpaceContainerFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceContainerFB>
   *
   * @xrentity{xrGetSpaceContainerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceContainerFB(Space space, SpaceContainerFB& spaceContainerOutput,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpaceContainerFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceContainerFB>
   *
   * @xrentity{xrGetSpaceContainerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getSpaceContainerFB(Space space, SpaceContainerFB& spaceContainerOutput,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity_container

#ifdef XR_META_foveation_eye_tracked

  /*!
   * @brief xrGetFoveationEyeTrackedStateMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFoveationEyeTrackedStateMETA>
   *
   * @xrentity{xrGetFoveationEyeTrackedStateMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getFoveationEyeTrackedStateMETA(FoveationEyeTrackedStateMETA& foveationState,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetFoveationEyeTrackedStateMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FoveationEyeTrackedStateMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFoveationEyeTrackedStateMETA>
   *
   * @xrentity{xrGetFoveationEyeTrackedStateMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FoveationEyeTrackedStateMETA> getFoveationEyeTrackedStateMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetFoveationEyeTrackedStateMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FoveationEyeTrackedStateMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFoveationEyeTrackedStateMETA>
   *
   * @xrentity{xrGetFoveationEyeTrackedStateMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FoveationEyeTrackedStateMETA getFoveationEyeTrackedStateMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_foveation_eye_tracked

#ifdef XR_FB_face_tracking

  /*!
   * @brief xrCreateFaceTrackerFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFaceTrackerFB>
   *
   * @xrentity{xrCreateFaceTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createFaceTrackerFB(const FaceTrackerCreateInfoFB& createInfo, FaceTrackerFB& faceTracker,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFaceTrackerFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FaceTrackerFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFaceTrackerFB>
   *
   * @xrentity{xrCreateFaceTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FaceTrackerFB> createFaceTrackerFB(const FaceTrackerCreateInfoFB& createInfo,
                                                 Dispatch&& d
                                                     OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFaceTrackerFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FaceTrackerFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFaceTrackerFB>
   *
   * @xrentity{xrCreateFaceTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FaceTrackerFB createFaceTrackerFB(const FaceTrackerCreateInfoFB& createInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFaceTrackerFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a FaceTrackerFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFaceTrackerFB>
   *
   * @xrentity{xrCreateFaceTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<FaceTrackerFB, impl::RemoveRefConst<Dispatch>>>
  createFaceTrackerUniqueFB(const FaceTrackerCreateInfoFB& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFaceTrackerFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a FaceTrackerFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFaceTrackerFB>
   *
   * @xrentity{xrCreateFaceTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<FaceTrackerFB, impl::RemoveRefConst<Dispatch>> createFaceTrackerUniqueFB(
      const FaceTrackerCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_face_tracking

#ifdef XR_FB_eye_tracking_social

  /*!
   * @brief xrCreateEyeTrackerFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEyeTrackerFB>
   *
   * @xrentity{xrCreateEyeTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createEyeTrackerFB(const EyeTrackerCreateInfoFB& createInfo, EyeTrackerFB& eyeTracker,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateEyeTrackerFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type EyeTrackerFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEyeTrackerFB>
   *
   * @xrentity{xrCreateEyeTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<EyeTrackerFB> createEyeTrackerFB(const EyeTrackerCreateInfoFB& createInfo,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateEyeTrackerFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type EyeTrackerFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEyeTrackerFB>
   *
   * @xrentity{xrCreateEyeTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  EyeTrackerFB createEyeTrackerFB(const EyeTrackerCreateInfoFB& createInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateEyeTrackerFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a EyeTrackerFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEyeTrackerFB>
   *
   * @xrentity{xrCreateEyeTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<EyeTrackerFB, impl::RemoveRefConst<Dispatch>>> createEyeTrackerUniqueFB(
      const EyeTrackerCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateEyeTrackerFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a EyeTrackerFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEyeTrackerFB>
   *
   * @xrentity{xrCreateEyeTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<EyeTrackerFB, impl::RemoveRefConst<Dispatch>> createEyeTrackerUniqueFB(
      const EyeTrackerCreateInfoFB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_eye_tracking_social

#ifdef XR_FB_haptic_pcm

  /*!
   * @brief xrGetDeviceSampleRateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetDeviceSampleRateFB>
   *
   * @xrentity{xrGetDeviceSampleRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getDeviceSampleRateFB(const HapticActionInfo& hapticActionInfo,
                               XrDevicePcmSampleRateGetInfoFB* deviceSampleRate,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetDeviceSampleRateFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type DevicePcmSampleRateGetInfoFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetDeviceSampleRateFB>
   *
   * @xrentity{xrGetDeviceSampleRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<DevicePcmSampleRateGetInfoFB> getDeviceSampleRateFB(
      const HapticActionInfo& hapticActionInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetDeviceSampleRateFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type DevicePcmSampleRateGetInfoFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetDeviceSampleRateFB>
   *
   * @xrentity{xrGetDeviceSampleRateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  DevicePcmSampleRateGetInfoFB getDeviceSampleRateFB(const HapticActionInfo& hapticActionInfo,
                                                     Dispatch&& d
                                                         OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_haptic_pcm

#ifdef XR_META_passthrough_preferences

  /*!
   * @brief xrGetPassthroughPreferencesMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPassthroughPreferencesMETA>
   *
   * @xrentity{xrGetPassthroughPreferencesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getPassthroughPreferencesMETA(PassthroughPreferencesMETA& preferences,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetPassthroughPreferencesMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type PassthroughPreferencesMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPassthroughPreferencesMETA>
   *
   * @xrentity{xrGetPassthroughPreferencesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<PassthroughPreferencesMETA> getPassthroughPreferencesMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetPassthroughPreferencesMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type PassthroughPreferencesMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPassthroughPreferencesMETA>
   *
   * @xrentity{xrGetPassthroughPreferencesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  PassthroughPreferencesMETA getPassthroughPreferencesMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_passthrough_preferences

#ifdef XR_META_virtual_keyboard

  /*!
   * @brief xrCreateVirtualKeyboardMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVirtualKeyboardMETA>
   *
   * @xrentity{xrCreateVirtualKeyboardMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVirtualKeyboardMETA(const VirtualKeyboardCreateInfoMETA& createInfo,
                                   VirtualKeyboardMETA& keyboard,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateVirtualKeyboardMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type VirtualKeyboardMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVirtualKeyboardMETA>
   *
   * @xrentity{xrCreateVirtualKeyboardMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<VirtualKeyboardMETA> createVirtualKeyboardMETA(
      const VirtualKeyboardCreateInfoMETA& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateVirtualKeyboardMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type VirtualKeyboardMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVirtualKeyboardMETA>
   *
   * @xrentity{xrCreateVirtualKeyboardMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  VirtualKeyboardMETA createVirtualKeyboardMETA(const VirtualKeyboardCreateInfoMETA& createInfo,
                                                Dispatch&& d
                                                    OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateVirtualKeyboardMETA wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a VirtualKeyboardMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVirtualKeyboardMETA>
   *
   * @xrentity{xrCreateVirtualKeyboardMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<VirtualKeyboardMETA, impl::RemoveRefConst<Dispatch>>>
  createVirtualKeyboardUniqueMETA(const VirtualKeyboardCreateInfoMETA& createInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateVirtualKeyboardMETA wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a VirtualKeyboardMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVirtualKeyboardMETA>
   *
   * @xrentity{xrCreateVirtualKeyboardMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<VirtualKeyboardMETA, impl::RemoveRefConst<Dispatch>> createVirtualKeyboardUniqueMETA(
      const VirtualKeyboardCreateInfoMETA& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_virtual_keyboard

#ifdef XR_META_virtual_keyboard

  /*!
   * @brief xrCreateVirtualKeyboardSpaceMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVirtualKeyboardSpaceMETA>
   *
   * @xrentity{xrCreateVirtualKeyboardSpaceMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createVirtualKeyboardSpaceMETA(VirtualKeyboardMETA keyboard,
                                        const VirtualKeyboardSpaceCreateInfoMETA& createInfo,
                                        Space& keyboardSpace,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateVirtualKeyboardSpaceMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVirtualKeyboardSpaceMETA>
   *
   * @xrentity{xrCreateVirtualKeyboardSpaceMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createVirtualKeyboardSpaceMETA(
      VirtualKeyboardMETA keyboard, const VirtualKeyboardSpaceCreateInfoMETA& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateVirtualKeyboardSpaceMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVirtualKeyboardSpaceMETA>
   *
   * @xrentity{xrCreateVirtualKeyboardSpaceMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createVirtualKeyboardSpaceMETA(VirtualKeyboardMETA keyboard,
                                       const VirtualKeyboardSpaceCreateInfoMETA& createInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateVirtualKeyboardSpaceMETA wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVirtualKeyboardSpaceMETA>
   *
   * @xrentity{xrCreateVirtualKeyboardSpaceMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>>
  createVirtualKeyboardSpaceUniqueMETA(VirtualKeyboardMETA keyboard,
                                       const VirtualKeyboardSpaceCreateInfoMETA& createInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateVirtualKeyboardSpaceMETA wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateVirtualKeyboardSpaceMETA>
   *
   * @xrentity{xrCreateVirtualKeyboardSpaceMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createVirtualKeyboardSpaceUniqueMETA(
      VirtualKeyboardMETA keyboard, const VirtualKeyboardSpaceCreateInfoMETA& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_virtual_keyboard

#ifdef XR_OCULUS_external_camera

  /*!
   * @brief xrEnumerateExternalCamerasOCULUS wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateExternalCamerasOCULUS>
   *
   * @xrentity{xrEnumerateExternalCamerasOCULUS}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateExternalCamerasOCULUS(uint32_t cameraCapacityInput, uint32_t& cameraCountOutput,
                                        ExternalCameraOCULUS* cameras,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateExternalCamerasOCULUS enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ExternalCameraOCULUS, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateExternalCamerasOCULUS>
   *
   * @xrentity{xrEnumerateExternalCamerasOCULUS}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ExternalCameraOCULUS>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ExternalCameraOCULUS, Allocator>> enumerateExternalCamerasToVectorOCULUS(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateExternalCamerasOCULUS enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<ExternalCameraOCULUS, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateExternalCamerasOCULUS>
   *
   * @xrentity{xrEnumerateExternalCamerasOCULUS}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ExternalCameraOCULUS>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<ExternalCameraOCULUS, Allocator>> enumerateExternalCamerasToVectorOCULUS(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateExternalCamerasOCULUS enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<ExternalCameraOCULUS, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateExternalCamerasOCULUS>
   *
   * @xrentity{xrEnumerateExternalCamerasOCULUS}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ExternalCameraOCULUS>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ExternalCameraOCULUS, Allocator> enumerateExternalCamerasToVectorOCULUS(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateExternalCamerasOCULUS enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<ExternalCameraOCULUS, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateExternalCamerasOCULUS>
   *
   * @xrentity{xrEnumerateExternalCamerasOCULUS}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<ExternalCameraOCULUS>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<ExternalCameraOCULUS, Allocator> enumerateExternalCamerasToVectorOCULUS(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_OCULUS_external_camera

#ifdef XR_META_performance_metrics

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetPerformanceMetricsStateMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetPerformanceMetricsStateMETA>
   *
   * @xrentity{xrSetPerformanceMetricsStateMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setPerformanceMetricsStateMETA(const PerformanceMetricsStateMETA& state,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetPerformanceMetricsStateMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetPerformanceMetricsStateMETA>
   *
   * @xrentity{xrSetPerformanceMetricsStateMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setPerformanceMetricsStateMETA(const PerformanceMetricsStateMETA& state,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetPerformanceMetricsStateMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetPerformanceMetricsStateMETA>
   *
   * @xrentity{xrSetPerformanceMetricsStateMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setPerformanceMetricsStateMETA(const PerformanceMetricsStateMETA& state,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_performance_metrics

#ifdef XR_META_performance_metrics

  /*!
   * @brief xrGetPerformanceMetricsStateMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPerformanceMetricsStateMETA>
   *
   * @xrentity{xrGetPerformanceMetricsStateMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getPerformanceMetricsStateMETA(PerformanceMetricsStateMETA& state,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetPerformanceMetricsStateMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type PerformanceMetricsStateMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPerformanceMetricsStateMETA>
   *
   * @xrentity{xrGetPerformanceMetricsStateMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<PerformanceMetricsStateMETA> getPerformanceMetricsStateMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetPerformanceMetricsStateMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type PerformanceMetricsStateMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPerformanceMetricsStateMETA>
   *
   * @xrentity{xrGetPerformanceMetricsStateMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  PerformanceMetricsStateMETA getPerformanceMetricsStateMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_performance_metrics

#ifdef XR_META_performance_metrics

  /*!
   * @brief xrQueryPerformanceMetricsCounterMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQueryPerformanceMetricsCounterMETA>
   *
   * @xrentity{xrQueryPerformanceMetricsCounterMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result queryPerformanceMetricsCounterMETA(Path counterPath,
                                            PerformanceMetricsCounterMETA& counter,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrQueryPerformanceMetricsCounterMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type PerformanceMetricsCounterMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQueryPerformanceMetricsCounterMETA>
   *
   * @xrentity{xrQueryPerformanceMetricsCounterMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<PerformanceMetricsCounterMETA> queryPerformanceMetricsCounterMETA(
      Path counterPath, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrQueryPerformanceMetricsCounterMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type PerformanceMetricsCounterMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQueryPerformanceMetricsCounterMETA>
   *
   * @xrentity{xrQueryPerformanceMetricsCounterMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  PerformanceMetricsCounterMETA queryPerformanceMetricsCounterMETA(
      Path counterPath, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_performance_metrics

#ifdef XR_FB_spatial_entity_storage_batch

  /*!
   * @brief xrSaveSpaceListFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSaveSpaceListFB>
   *
   * @xrentity{xrSaveSpaceListFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result saveSpaceListFB(const SpaceListSaveInfoFB& info, AsyncRequestIdFB& requestId,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSaveSpaceListFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSaveSpaceListFB>
   *
   * @xrentity{xrSaveSpaceListFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> saveSpaceListFB(
      const SpaceListSaveInfoFB& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSaveSpaceListFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSaveSpaceListFB>
   *
   * @xrentity{xrSaveSpaceListFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB saveSpaceListFB(const SpaceListSaveInfoFB& info,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity_storage_batch

#ifdef XR_FB_spatial_entity_user

  /*!
   * @brief xrCreateSpaceUserFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpaceUserFB>
   *
   * @xrentity{xrCreateSpaceUserFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpaceUserFB(const SpaceUserCreateInfoFB& info, SpaceUserFB& user,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpaceUserFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpaceUserFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpaceUserFB>
   *
   * @xrentity{xrCreateSpaceUserFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpaceUserFB> createSpaceUserFB(
      const SpaceUserCreateInfoFB& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpaceUserFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpaceUserFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpaceUserFB>
   *
   * @xrentity{xrCreateSpaceUserFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpaceUserFB createSpaceUserFB(const SpaceUserCreateInfoFB& info,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpaceUserFB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpaceUserFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpaceUserFB>
   *
   * @xrentity{xrCreateSpaceUserFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpaceUserFB, impl::RemoveRefConst<Dispatch>>> createSpaceUserUniqueFB(
      const SpaceUserCreateInfoFB& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpaceUserFB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpaceUserFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpaceUserFB>
   *
   * @xrentity{xrCreateSpaceUserFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpaceUserFB, impl::RemoveRefConst<Dispatch>> createSpaceUserUniqueFB(
      const SpaceUserCreateInfoFB& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity_user

#ifdef XR_META_recommended_layer_resolution

  /*!
   * @brief xrGetRecommendedLayerResolutionMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRecommendedLayerResolutionMETA>
   *
   * @xrentity{xrGetRecommendedLayerResolutionMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRecommendedLayerResolutionMETA(const RecommendedLayerResolutionGetInfoMETA& info,
                                           RecommendedLayerResolutionMETA& resolution,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetRecommendedLayerResolutionMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type RecommendedLayerResolutionMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRecommendedLayerResolutionMETA>
   *
   * @xrentity{xrGetRecommendedLayerResolutionMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<RecommendedLayerResolutionMETA> getRecommendedLayerResolutionMETA(
      const RecommendedLayerResolutionGetInfoMETA& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetRecommendedLayerResolutionMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type RecommendedLayerResolutionMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRecommendedLayerResolutionMETA>
   *
   * @xrentity{xrGetRecommendedLayerResolutionMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  RecommendedLayerResolutionMETA getRecommendedLayerResolutionMETA(
      const RecommendedLayerResolutionGetInfoMETA& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_recommended_layer_resolution

#ifdef XR_FB_face_tracking2

  /*!
   * @brief xrCreateFaceTracker2FB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFaceTracker2FB>
   *
   * @xrentity{xrCreateFaceTracker2FB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createFaceTracker2FB(const FaceTrackerCreateInfo2FB& createInfo,
                              FaceTracker2FB& faceTracker,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFaceTracker2FB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FaceTracker2FB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFaceTracker2FB>
   *
   * @xrentity{xrCreateFaceTracker2FB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FaceTracker2FB> createFaceTracker2FB(const FaceTrackerCreateInfo2FB& createInfo,
                                                   Dispatch&& d
                                                       OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFaceTracker2FB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FaceTracker2FB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFaceTracker2FB>
   *
   * @xrentity{xrCreateFaceTracker2FB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FaceTracker2FB createFaceTracker2FB(const FaceTrackerCreateInfo2FB& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFaceTracker2FB wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a FaceTracker2FB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFaceTracker2FB>
   *
   * @xrentity{xrCreateFaceTracker2FB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<FaceTracker2FB, impl::RemoveRefConst<Dispatch>>>
  createFaceTracker2UniqueFB(const FaceTrackerCreateInfo2FB& createInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFaceTracker2FB wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a FaceTracker2FB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFaceTracker2FB>
   *
   * @xrentity{xrCreateFaceTracker2FB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<FaceTracker2FB, impl::RemoveRefConst<Dispatch>> createFaceTracker2UniqueFB(
      const FaceTrackerCreateInfo2FB& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_face_tracking2

#ifdef XR_META_spatial_entity_sharing

  /*!
   * @brief xrShareSpacesMETA wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrShareSpacesMETA>
   *
   * @xrentity{xrShareSpacesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result shareSpacesMETA(const ShareSpacesInfoMETA& info, AsyncRequestIdFB& requestId,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrShareSpacesMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrShareSpacesMETA>
   *
   * @xrentity{xrShareSpacesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> shareSpacesMETA(
      const ShareSpacesInfoMETA& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrShareSpacesMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrShareSpacesMETA>
   *
   * @xrentity{xrShareSpacesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB shareSpacesMETA(const ShareSpacesInfoMETA& info,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_spatial_entity_sharing

#ifdef XR_META_environment_depth

  /*!
   * @brief xrCreateEnvironmentDepthProviderMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrCreateEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createEnvironmentDepthProviderMETA(
      const EnvironmentDepthProviderCreateInfoMETA& createInfo,
      EnvironmentDepthProviderMETA& environmentDepthProvider,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateEnvironmentDepthProviderMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type EnvironmentDepthProviderMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrCreateEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<EnvironmentDepthProviderMETA> createEnvironmentDepthProviderMETA(
      const EnvironmentDepthProviderCreateInfoMETA& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateEnvironmentDepthProviderMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type EnvironmentDepthProviderMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrCreateEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  EnvironmentDepthProviderMETA createEnvironmentDepthProviderMETA(
      const EnvironmentDepthProviderCreateInfoMETA& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateEnvironmentDepthProviderMETA wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a EnvironmentDepthProviderMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrCreateEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<EnvironmentDepthProviderMETA, impl::RemoveRefConst<Dispatch>>>
  createEnvironmentDepthProviderUniqueMETA(const EnvironmentDepthProviderCreateInfoMETA& createInfo,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateEnvironmentDepthProviderMETA wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a EnvironmentDepthProviderMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrCreateEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<EnvironmentDepthProviderMETA, impl::RemoveRefConst<Dispatch>>
  createEnvironmentDepthProviderUniqueMETA(const EnvironmentDepthProviderCreateInfoMETA& createInfo,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_environment_depth

#ifdef XR_EXT_render_model

  /*!
   * @brief xrCreateRenderModelEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelEXT>
   *
   * @xrentity{xrCreateRenderModelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createRenderModelEXT(const RenderModelCreateInfoEXT& createInfo,
                              RenderModelEXT& renderModel,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateRenderModelEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type RenderModelEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelEXT>
   *
   * @xrentity{xrCreateRenderModelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<RenderModelEXT> createRenderModelEXT(const RenderModelCreateInfoEXT& createInfo,
                                                   Dispatch&& d
                                                       OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateRenderModelEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type RenderModelEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelEXT>
   *
   * @xrentity{xrCreateRenderModelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  RenderModelEXT createRenderModelEXT(const RenderModelCreateInfoEXT& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateRenderModelEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a RenderModelEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelEXT>
   *
   * @xrentity{xrCreateRenderModelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<RenderModelEXT, impl::RemoveRefConst<Dispatch>>>
  createRenderModelUniqueEXT(const RenderModelCreateInfoEXT& createInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateRenderModelEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a RenderModelEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelEXT>
   *
   * @xrentity{xrCreateRenderModelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<RenderModelEXT, impl::RemoveRefConst<Dispatch>> createRenderModelUniqueEXT(
      const RenderModelCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model

  /*!
   * @brief xrCreateRenderModelSpaceEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelSpaceEXT>
   *
   * @xrentity{xrCreateRenderModelSpaceEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createRenderModelSpaceEXT(const RenderModelSpaceCreateInfoEXT& createInfo, Space& space,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateRenderModelSpaceEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelSpaceEXT>
   *
   * @xrentity{xrCreateRenderModelSpaceEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createRenderModelSpaceEXT(const RenderModelSpaceCreateInfoEXT& createInfo,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateRenderModelSpaceEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelSpaceEXT>
   *
   * @xrentity{xrCreateRenderModelSpaceEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createRenderModelSpaceEXT(const RenderModelSpaceCreateInfoEXT& createInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateRenderModelSpaceEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelSpaceEXT>
   *
   * @xrentity{xrCreateRenderModelSpaceEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createRenderModelSpaceUniqueEXT(
      const RenderModelSpaceCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateRenderModelSpaceEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelSpaceEXT>
   *
   * @xrentity{xrCreateRenderModelSpaceEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createRenderModelSpaceUniqueEXT(
      const RenderModelSpaceCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model

  /*!
   * @brief xrCreateRenderModelAssetEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelAssetEXT>
   *
   * @xrentity{xrCreateRenderModelAssetEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createRenderModelAssetEXT(const RenderModelAssetCreateInfoEXT& createInfo,
                                   RenderModelAssetEXT& asset,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateRenderModelAssetEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type RenderModelAssetEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelAssetEXT>
   *
   * @xrentity{xrCreateRenderModelAssetEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<RenderModelAssetEXT> createRenderModelAssetEXT(
      const RenderModelAssetCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateRenderModelAssetEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type RenderModelAssetEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelAssetEXT>
   *
   * @xrentity{xrCreateRenderModelAssetEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  RenderModelAssetEXT createRenderModelAssetEXT(const RenderModelAssetCreateInfoEXT& createInfo,
                                                Dispatch&& d
                                                    OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateRenderModelAssetEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a RenderModelAssetEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelAssetEXT>
   *
   * @xrentity{xrCreateRenderModelAssetEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<RenderModelAssetEXT, impl::RemoveRefConst<Dispatch>>>
  createRenderModelAssetUniqueEXT(const RenderModelAssetCreateInfoEXT& createInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateRenderModelAssetEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a RenderModelAssetEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateRenderModelAssetEXT>
   *
   * @xrentity{xrCreateRenderModelAssetEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<RenderModelAssetEXT, impl::RemoveRefConst<Dispatch>> createRenderModelAssetUniqueEXT(
      const RenderModelAssetCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_render_model

#ifdef XR_EXT_interaction_render_model

  /*!
   * @brief xrEnumerateInteractionRenderModelIdsEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInteractionRenderModelIdsEXT>
   *
   * @xrentity{xrEnumerateInteractionRenderModelIdsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateInteractionRenderModelIdsEXT(
      const InteractionRenderModelIdsEnumerateInfoEXT& getInfo, uint32_t renderModelIdCapacityInput,
      uint32_t& renderModelIdCountOutput, RenderModelIdEXT* renderModelIds,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateInteractionRenderModelIdsEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<RenderModelIdEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInteractionRenderModelIdsEXT>
   *
   * @xrentity{xrEnumerateInteractionRenderModelIdsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<RenderModelIdEXT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<RenderModelIdEXT, Allocator>>
  enumerateInteractionRenderModelIdsToVectorEXT(
      const InteractionRenderModelIdsEnumerateInfoEXT& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateInteractionRenderModelIdsEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<RenderModelIdEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInteractionRenderModelIdsEXT>
   *
   * @xrentity{xrEnumerateInteractionRenderModelIdsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<RenderModelIdEXT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<RenderModelIdEXT, Allocator>>
  enumerateInteractionRenderModelIdsToVectorEXT(
      const InteractionRenderModelIdsEnumerateInfoEXT& getInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateInteractionRenderModelIdsEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<RenderModelIdEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInteractionRenderModelIdsEXT>
   *
   * @xrentity{xrEnumerateInteractionRenderModelIdsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<RenderModelIdEXT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<RenderModelIdEXT, Allocator> enumerateInteractionRenderModelIdsToVectorEXT(
      const InteractionRenderModelIdsEnumerateInfoEXT& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateInteractionRenderModelIdsEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<RenderModelIdEXT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInteractionRenderModelIdsEXT>
   *
   * @xrentity{xrEnumerateInteractionRenderModelIdsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<RenderModelIdEXT>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<RenderModelIdEXT, Allocator> enumerateInteractionRenderModelIdsToVectorEXT(
      const InteractionRenderModelIdsEnumerateInfoEXT& getInfo, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_interaction_render_model

#ifdef XR_QCOM_tracking_optimization_settings

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetTrackingOptimizationSettingsHintQCOM wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetTrackingOptimizationSettingsHintQCOM>
   *
   * @xrentity{xrSetTrackingOptimizationSettingsHintQCOM}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setTrackingOptimizationSettingsHintQCOM(
      TrackingOptimizationSettingsDomainQCOM domain, TrackingOptimizationSettingsHintQCOM hint,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetTrackingOptimizationSettingsHintQCOM enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetTrackingOptimizationSettingsHintQCOM>
   *
   * @xrentity{xrSetTrackingOptimizationSettingsHintQCOM}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setTrackingOptimizationSettingsHintQCOM(
      TrackingOptimizationSettingsDomainQCOM domain, TrackingOptimizationSettingsHintQCOM hint,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetTrackingOptimizationSettingsHintQCOM enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetTrackingOptimizationSettingsHintQCOM>
   *
   * @xrentity{xrSetTrackingOptimizationSettingsHintQCOM}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setTrackingOptimizationSettingsHintQCOM(
      TrackingOptimizationSettingsDomainQCOM domain, TrackingOptimizationSettingsHintQCOM hint,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_QCOM_tracking_optimization_settings

#ifdef XR_HTC_passthrough

  /*!
   * @brief xrCreatePassthroughHTC wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughHTC>
   *
   * @xrentity{xrCreatePassthroughHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createPassthroughHTC(const PassthroughCreateInfoHTC& createInfo,
                              PassthroughHTC& passthrough,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePassthroughHTC enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type PassthroughHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughHTC>
   *
   * @xrentity{xrCreatePassthroughHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<PassthroughHTC> createPassthroughHTC(const PassthroughCreateInfoHTC& createInfo,
                                                   Dispatch&& d
                                                       OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePassthroughHTC enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type PassthroughHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughHTC>
   *
   * @xrentity{xrCreatePassthroughHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  PassthroughHTC createPassthroughHTC(const PassthroughCreateInfoHTC& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePassthroughHTC wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a PassthroughHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughHTC>
   *
   * @xrentity{xrCreatePassthroughHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<PassthroughHTC, impl::RemoveRefConst<Dispatch>>>
  createPassthroughUniqueHTC(const PassthroughCreateInfoHTC& createInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePassthroughHTC wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a PassthroughHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughHTC>
   *
   * @xrentity{xrCreatePassthroughHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<PassthroughHTC, impl::RemoveRefConst<Dispatch>> createPassthroughUniqueHTC(
      const PassthroughCreateInfoHTC& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_HTC_passthrough

#ifdef XR_HTC_foveation

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrApplyFoveationHTC wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrApplyFoveationHTC>
   *
   * @xrentity{xrApplyFoveationHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result applyFoveationHTC(const FoveationApplyInfoHTC& applyInfo,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrApplyFoveationHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrApplyFoveationHTC>
   *
   * @xrentity{xrApplyFoveationHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result applyFoveationHTC(const FoveationApplyInfoHTC& applyInfo,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrApplyFoveationHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrApplyFoveationHTC>
   *
   * @xrentity{xrApplyFoveationHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void applyFoveationHTC(const FoveationApplyInfoHTC& applyInfo,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_HTC_foveation

#ifdef XR_HTC_anchor

  /*!
   * @brief xrCreateSpatialAnchorHTC wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorHTC>
   *
   * @xrentity{xrCreateSpatialAnchorHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorHTC(const SpatialAnchorCreateInfoHTC& createInfo, Space& anchor,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorHTC enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorHTC>
   *
   * @xrentity{xrCreateSpatialAnchorHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createSpatialAnchorHTC(const SpatialAnchorCreateInfoHTC& createInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorHTC enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorHTC>
   *
   * @xrentity{xrCreateSpatialAnchorHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createSpatialAnchorHTC(const SpatialAnchorCreateInfoHTC& createInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorHTC wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorHTC>
   *
   * @xrentity{xrCreateSpatialAnchorHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createSpatialAnchorUniqueHTC(
      const SpatialAnchorCreateInfoHTC& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorHTC wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorHTC>
   *
   * @xrentity{xrCreateSpatialAnchorHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createSpatialAnchorUniqueHTC(
      const SpatialAnchorCreateInfoHTC& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_HTC_anchor

#ifdef XR_HTC_body_tracking

  /*!
   * @brief xrCreateBodyTrackerHTC wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerHTC>
   *
   * @xrentity{xrCreateBodyTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createBodyTrackerHTC(const BodyTrackerCreateInfoHTC& createInfo,
                              BodyTrackerHTC& bodyTracker,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateBodyTrackerHTC enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type BodyTrackerHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerHTC>
   *
   * @xrentity{xrCreateBodyTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<BodyTrackerHTC> createBodyTrackerHTC(const BodyTrackerCreateInfoHTC& createInfo,
                                                   Dispatch&& d
                                                       OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateBodyTrackerHTC enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type BodyTrackerHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerHTC>
   *
   * @xrentity{xrCreateBodyTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  BodyTrackerHTC createBodyTrackerHTC(const BodyTrackerCreateInfoHTC& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateBodyTrackerHTC wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a BodyTrackerHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerHTC>
   *
   * @xrentity{xrCreateBodyTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<BodyTrackerHTC, impl::RemoveRefConst<Dispatch>>>
  createBodyTrackerUniqueHTC(const BodyTrackerCreateInfoHTC& createInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateBodyTrackerHTC wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a BodyTrackerHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerHTC>
   *
   * @xrentity{xrCreateBodyTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<BodyTrackerHTC, impl::RemoveRefConst<Dispatch>> createBodyTrackerUniqueHTC(
      const BodyTrackerCreateInfoHTC& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_HTC_body_tracking

#ifdef XR_BD_body_tracking

  /*!
   * @brief xrCreateBodyTrackerBD wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerBD>
   *
   * @xrentity{xrCreateBodyTrackerBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createBodyTrackerBD(const BodyTrackerCreateInfoBD& createInfo, BodyTrackerBD& bodyTracker,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateBodyTrackerBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type BodyTrackerBD
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerBD>
   *
   * @xrentity{xrCreateBodyTrackerBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<BodyTrackerBD> createBodyTrackerBD(const BodyTrackerCreateInfoBD& createInfo,
                                                 Dispatch&& d
                                                     OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateBodyTrackerBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type BodyTrackerBD
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerBD>
   *
   * @xrentity{xrCreateBodyTrackerBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  BodyTrackerBD createBodyTrackerBD(const BodyTrackerCreateInfoBD& createInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateBodyTrackerBD wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a BodyTrackerBD
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerBD>
   *
   * @xrentity{xrCreateBodyTrackerBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<BodyTrackerBD, impl::RemoveRefConst<Dispatch>>>
  createBodyTrackerUniqueBD(const BodyTrackerCreateInfoBD& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateBodyTrackerBD wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a BodyTrackerBD
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateBodyTrackerBD>
   *
   * @xrentity{xrCreateBodyTrackerBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<BodyTrackerBD, impl::RemoveRefConst<Dispatch>> createBodyTrackerUniqueBD(
      const BodyTrackerCreateInfoBD& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_body_tracking

#ifdef XR_BD_spatial_sensing

  /*!
   * @brief xrCreateSenseDataProviderBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSenseDataProviderBD>
   *
   * @xrentity{xrCreateSenseDataProviderBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSenseDataProviderBD(const SenseDataProviderCreateInfoBD& createInfo,
                                   SenseDataProviderBD& provider,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSenseDataProviderBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SenseDataProviderBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSenseDataProviderBD>
   *
   * @xrentity{xrCreateSenseDataProviderBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SenseDataProviderBD> createSenseDataProviderBD(
      const SenseDataProviderCreateInfoBD& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSenseDataProviderBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SenseDataProviderBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSenseDataProviderBD>
   *
   * @xrentity{xrCreateSenseDataProviderBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SenseDataProviderBD createSenseDataProviderBD(const SenseDataProviderCreateInfoBD& createInfo,
                                                Dispatch&& d
                                                    OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSenseDataProviderBD wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SenseDataProviderBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSenseDataProviderBD>
   *
   * @xrentity{xrCreateSenseDataProviderBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SenseDataProviderBD, impl::RemoveRefConst<Dispatch>>>
  createSenseDataProviderUniqueBD(const SenseDataProviderCreateInfoBD& createInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSenseDataProviderBD wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SenseDataProviderBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSenseDataProviderBD>
   *
   * @xrentity{xrCreateSenseDataProviderBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SenseDataProviderBD, impl::RemoveRefConst<Dispatch>> createSenseDataProviderUniqueBD(
      const SenseDataProviderCreateInfoBD& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing

  /*!
   * @brief xrStartSenseDataProviderCompleteBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartSenseDataProviderCompleteBD>
   *
   * @xrentity{xrStartSenseDataProviderCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result startSenseDataProviderCompleteBD(FutureEXT future, FutureCompletionEXT& completion,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStartSenseDataProviderCompleteBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartSenseDataProviderCompleteBD>
   *
   * @xrentity{xrStartSenseDataProviderCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureCompletionEXT> startSenseDataProviderCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStartSenseDataProviderCompleteBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartSenseDataProviderCompleteBD>
   *
   * @xrentity{xrStartSenseDataProviderCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureCompletionEXT startSenseDataProviderCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing

  /*!
   * @brief xrCreateAnchorSpaceBD wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAnchorSpaceBD>
   *
   * @xrentity{xrCreateAnchorSpaceBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createAnchorSpaceBD(const AnchorSpaceCreateInfoBD& createInfo, Space& space,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateAnchorSpaceBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAnchorSpaceBD>
   *
   * @xrentity{xrCreateAnchorSpaceBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createAnchorSpaceBD(const AnchorSpaceCreateInfoBD& createInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateAnchorSpaceBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAnchorSpaceBD>
   *
   * @xrentity{xrCreateAnchorSpaceBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createAnchorSpaceBD(const AnchorSpaceCreateInfoBD& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateAnchorSpaceBD wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAnchorSpaceBD>
   *
   * @xrentity{xrCreateAnchorSpaceBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createAnchorSpaceUniqueBD(
      const AnchorSpaceCreateInfoBD& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateAnchorSpaceBD wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAnchorSpaceBD>
   *
   * @xrentity{xrCreateAnchorSpaceBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createAnchorSpaceUniqueBD(
      const AnchorSpaceCreateInfoBD& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_sensing

#ifdef XR_EXT_plane_detection

  /*!
   * @brief xrCreatePlaneDetectorEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePlaneDetectorEXT>
   *
   * @xrentity{xrCreatePlaneDetectorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createPlaneDetectorEXT(const PlaneDetectorCreateInfoEXT& createInfo,
                                PlaneDetectorEXT& planeDetector,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePlaneDetectorEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type PlaneDetectorEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePlaneDetectorEXT>
   *
   * @xrentity{xrCreatePlaneDetectorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<PlaneDetectorEXT> createPlaneDetectorEXT(
      const PlaneDetectorCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePlaneDetectorEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type PlaneDetectorEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePlaneDetectorEXT>
   *
   * @xrentity{xrCreatePlaneDetectorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  PlaneDetectorEXT createPlaneDetectorEXT(const PlaneDetectorCreateInfoEXT& createInfo,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePlaneDetectorEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a PlaneDetectorEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePlaneDetectorEXT>
   *
   * @xrentity{xrCreatePlaneDetectorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<PlaneDetectorEXT, impl::RemoveRefConst<Dispatch>>>
  createPlaneDetectorUniqueEXT(const PlaneDetectorCreateInfoEXT& createInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePlaneDetectorEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a PlaneDetectorEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePlaneDetectorEXT>
   *
   * @xrentity{xrCreatePlaneDetectorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<PlaneDetectorEXT, impl::RemoveRefConst<Dispatch>> createPlaneDetectorUniqueEXT(
      const PlaneDetectorCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_plane_detection

#ifdef XR_ML_world_mesh_detection

  /*!
   * @brief xrCreateWorldMeshDetectorML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateWorldMeshDetectorML>
   *
   * @xrentity{xrCreateWorldMeshDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createWorldMeshDetectorML(const WorldMeshDetectorCreateInfoML& createInfo,
                                   WorldMeshDetectorML& detector,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateWorldMeshDetectorML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type WorldMeshDetectorML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateWorldMeshDetectorML>
   *
   * @xrentity{xrCreateWorldMeshDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<WorldMeshDetectorML> createWorldMeshDetectorML(
      const WorldMeshDetectorCreateInfoML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateWorldMeshDetectorML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type WorldMeshDetectorML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateWorldMeshDetectorML>
   *
   * @xrentity{xrCreateWorldMeshDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  WorldMeshDetectorML createWorldMeshDetectorML(const WorldMeshDetectorCreateInfoML& createInfo,
                                                Dispatch&& d
                                                    OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateWorldMeshDetectorML wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a WorldMeshDetectorML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateWorldMeshDetectorML>
   *
   * @xrentity{xrCreateWorldMeshDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<WorldMeshDetectorML, impl::RemoveRefConst<Dispatch>>>
  createWorldMeshDetectorUniqueML(const WorldMeshDetectorCreateInfoML& createInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateWorldMeshDetectorML wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a WorldMeshDetectorML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateWorldMeshDetectorML>
   *
   * @xrentity{xrCreateWorldMeshDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<WorldMeshDetectorML, impl::RemoveRefConst<Dispatch>> createWorldMeshDetectorUniqueML(
      const WorldMeshDetectorCreateInfoML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_facial_expression

  /*!
   * @brief xrCreateFacialExpressionClientML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialExpressionClientML>
   *
   * @xrentity{xrCreateFacialExpressionClientML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createFacialExpressionClientML(const FacialExpressionClientCreateInfoML& createInfo,
                                        FacialExpressionClientML& facialExpressionClient,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFacialExpressionClientML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FacialExpressionClientML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialExpressionClientML>
   *
   * @xrentity{xrCreateFacialExpressionClientML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FacialExpressionClientML> createFacialExpressionClientML(
      const FacialExpressionClientCreateInfoML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFacialExpressionClientML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FacialExpressionClientML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialExpressionClientML>
   *
   * @xrentity{xrCreateFacialExpressionClientML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FacialExpressionClientML createFacialExpressionClientML(
      const FacialExpressionClientCreateInfoML& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateFacialExpressionClientML wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a FacialExpressionClientML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialExpressionClientML>
   *
   * @xrentity{xrCreateFacialExpressionClientML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<FacialExpressionClientML, impl::RemoveRefConst<Dispatch>>>
  createFacialExpressionClientUniqueML(const FacialExpressionClientCreateInfoML& createInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateFacialExpressionClientML wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a FacialExpressionClientML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateFacialExpressionClientML>
   *
   * @xrentity{xrCreateFacialExpressionClientML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<FacialExpressionClientML, impl::RemoveRefConst<Dispatch>>
  createFacialExpressionClientUniqueML(const FacialExpressionClientCreateInfoML& createInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_facial_expression

#ifdef XR_META_simultaneous_hands_and_controllers

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrResumeSimultaneousHandsAndControllersTrackingMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrResumeSimultaneousHandsAndControllersTrackingMETA>
   *
   * @xrentity{xrResumeSimultaneousHandsAndControllersTrackingMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result resumeSimultaneousHandsAndControllersTrackingMETA(
      const SimultaneousHandsAndControllersTrackingResumeInfoMETA& resumeInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrResumeSimultaneousHandsAndControllersTrackingMETA enhanced wrapper (hides basic
   * wrapper unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrResumeSimultaneousHandsAndControllersTrackingMETA>
   *
   * @xrentity{xrResumeSimultaneousHandsAndControllersTrackingMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result resumeSimultaneousHandsAndControllersTrackingMETA(
      const SimultaneousHandsAndControllersTrackingResumeInfoMETA& resumeInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrResumeSimultaneousHandsAndControllersTrackingMETA enhanced wrapper (hides basic
   * wrapper unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrResumeSimultaneousHandsAndControllersTrackingMETA>
   *
   * @xrentity{xrResumeSimultaneousHandsAndControllersTrackingMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void resumeSimultaneousHandsAndControllersTrackingMETA(
      const SimultaneousHandsAndControllersTrackingResumeInfoMETA& resumeInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_simultaneous_hands_and_controllers

#ifdef XR_META_simultaneous_hands_and_controllers

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPauseSimultaneousHandsAndControllersTrackingMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPauseSimultaneousHandsAndControllersTrackingMETA>
   *
   * @xrentity{xrPauseSimultaneousHandsAndControllersTrackingMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result pauseSimultaneousHandsAndControllersTrackingMETA(
      const SimultaneousHandsAndControllersTrackingPauseInfoMETA& pauseInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPauseSimultaneousHandsAndControllersTrackingMETA enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPauseSimultaneousHandsAndControllersTrackingMETA>
   *
   * @xrentity{xrPauseSimultaneousHandsAndControllersTrackingMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result pauseSimultaneousHandsAndControllersTrackingMETA(
      const SimultaneousHandsAndControllersTrackingPauseInfoMETA& pauseInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPauseSimultaneousHandsAndControllersTrackingMETA enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPauseSimultaneousHandsAndControllersTrackingMETA>
   *
   * @xrentity{xrPauseSimultaneousHandsAndControllersTrackingMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void pauseSimultaneousHandsAndControllersTrackingMETA(
      const SimultaneousHandsAndControllersTrackingPauseInfoMETA& pauseInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_simultaneous_hands_and_controllers

#ifdef XR_META_colocation_discovery

  /*!
   * @brief xrStartColocationDiscoveryMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartColocationDiscoveryMETA>
   *
   * @xrentity{xrStartColocationDiscoveryMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result startColocationDiscoveryMETA(const ColocationDiscoveryStartInfoMETA& info,
                                      AsyncRequestIdFB& discoveryRequestId,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStartColocationDiscoveryMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartColocationDiscoveryMETA>
   *
   * @xrentity{xrStartColocationDiscoveryMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> startColocationDiscoveryMETA(
      const ColocationDiscoveryStartInfoMETA& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStartColocationDiscoveryMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartColocationDiscoveryMETA>
   *
   * @xrentity{xrStartColocationDiscoveryMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB startColocationDiscoveryMETA(const ColocationDiscoveryStartInfoMETA& info,
                                                Dispatch&& d
                                                    OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery

  /*!
   * @brief xrStopColocationDiscoveryMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopColocationDiscoveryMETA>
   *
   * @xrentity{xrStopColocationDiscoveryMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stopColocationDiscoveryMETA(const ColocationDiscoveryStopInfoMETA& info,
                                     AsyncRequestIdFB& requestId,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStopColocationDiscoveryMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopColocationDiscoveryMETA>
   *
   * @xrentity{xrStopColocationDiscoveryMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> stopColocationDiscoveryMETA(
      const ColocationDiscoveryStopInfoMETA& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStopColocationDiscoveryMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopColocationDiscoveryMETA>
   *
   * @xrentity{xrStopColocationDiscoveryMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB stopColocationDiscoveryMETA(const ColocationDiscoveryStopInfoMETA& info,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery

  /*!
   * @brief xrStartColocationAdvertisementMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartColocationAdvertisementMETA>
   *
   * @xrentity{xrStartColocationAdvertisementMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result startColocationAdvertisementMETA(const ColocationAdvertisementStartInfoMETA& info,
                                          AsyncRequestIdFB& advertisementRequestId,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStartColocationAdvertisementMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartColocationAdvertisementMETA>
   *
   * @xrentity{xrStartColocationAdvertisementMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> startColocationAdvertisementMETA(
      const ColocationAdvertisementStartInfoMETA& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStartColocationAdvertisementMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartColocationAdvertisementMETA>
   *
   * @xrentity{xrStartColocationAdvertisementMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB startColocationAdvertisementMETA(
      const ColocationAdvertisementStartInfoMETA& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_colocation_discovery

#ifdef XR_META_colocation_discovery

  /*!
   * @brief xrStopColocationAdvertisementMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopColocationAdvertisementMETA>
   *
   * @xrentity{xrStopColocationAdvertisementMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stopColocationAdvertisementMETA(const ColocationAdvertisementStopInfoMETA& info,
                                         AsyncRequestIdFB& requestId,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStopColocationAdvertisementMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopColocationAdvertisementMETA>
   *
   * @xrentity{xrStopColocationAdvertisementMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> stopColocationAdvertisementMETA(
      const ColocationAdvertisementStopInfoMETA& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStopColocationAdvertisementMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopColocationAdvertisementMETA>
   *
   * @xrentity{xrStopColocationAdvertisementMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB stopColocationAdvertisementMETA(const ColocationAdvertisementStopInfoMETA& info,
                                                   Dispatch&& d
                                                       OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_colocation_discovery

#ifdef XR_EXT_spatial_entity

  /*!
   * @brief xrCreateSpatialContextAsyncEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialContextAsyncEXT>
   *
   * @xrentity{xrCreateSpatialContextAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialContextAsyncEXT(const SpatialContextCreateInfoEXT& createInfo,
                                      FutureEXT& future,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialContextAsyncEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialContextAsyncEXT>
   *
   * @xrentity{xrCreateSpatialContextAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> createSpatialContextAsyncEXT(
      const SpatialContextCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialContextAsyncEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialContextAsyncEXT>
   *
   * @xrentity{xrCreateSpatialContextAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT createSpatialContextAsyncEXT(const SpatialContextCreateInfoEXT& createInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity

  /*!
   * @brief xrCreateSpatialContextCompleteEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialContextCompleteEXT>
   *
   * @xrentity{xrCreateSpatialContextCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialContextCompleteEXT(FutureEXT future,
                                         CreateSpatialContextCompletionEXT& completion,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialContextCompleteEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type CreateSpatialContextCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialContextCompleteEXT>
   *
   * @xrentity{xrCreateSpatialContextCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<CreateSpatialContextCompletionEXT> createSpatialContextCompleteEXT(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialContextCompleteEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type CreateSpatialContextCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialContextCompleteEXT>
   *
   * @xrentity{xrCreateSpatialContextCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  CreateSpatialContextCompletionEXT createSpatialContextCompleteEXT(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_persistence

  /*!
   * @brief xrCreateSpatialPersistenceContextAsyncEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialPersistenceContextAsyncEXT>
   *
   * @xrentity{xrCreateSpatialPersistenceContextAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialPersistenceContextAsyncEXT(
      const SpatialPersistenceContextCreateInfoEXT& createInfo, FutureEXT& future,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialPersistenceContextAsyncEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialPersistenceContextAsyncEXT>
   *
   * @xrentity{xrCreateSpatialPersistenceContextAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> createSpatialPersistenceContextAsyncEXT(
      const SpatialPersistenceContextCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialPersistenceContextAsyncEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialPersistenceContextAsyncEXT>
   *
   * @xrentity{xrCreateSpatialPersistenceContextAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT createSpatialPersistenceContextAsyncEXT(
      const SpatialPersistenceContextCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_persistence

#ifdef XR_EXT_spatial_persistence

  /*!
   * @brief xrCreateSpatialPersistenceContextCompleteEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialPersistenceContextCompleteEXT>
   *
   * @xrentity{xrCreateSpatialPersistenceContextCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialPersistenceContextCompleteEXT(
      FutureEXT future, CreateSpatialPersistenceContextCompletionEXT& completion,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialPersistenceContextCompleteEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type CreateSpatialPersistenceContextCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialPersistenceContextCompleteEXT>
   *
   * @xrentity{xrCreateSpatialPersistenceContextCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<CreateSpatialPersistenceContextCompletionEXT>
  createSpatialPersistenceContextCompleteEXT(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialPersistenceContextCompleteEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type CreateSpatialPersistenceContextCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialPersistenceContextCompleteEXT>
   *
   * @xrentity{xrCreateSpatialPersistenceContextCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  CreateSpatialPersistenceContextCompletionEXT createSpatialPersistenceContextCompleteEXT(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_persistence

  //! @}
private:
  XrSession val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSession) == sizeof(Session),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSession from an Session value.
 *
 * @found_by_adl
 * @see Session::get()
 * @relates Session
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSession get(Session const& v) noexcept { return v.get(); }
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw XrSession
 * handle in a Session (by reference).
 *
 * e.g.
 * ```
 * Session yourHandle;
 * auto result = d.xrCreateSession(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Session
 */
static OPENXR_HPP_INLINE XrSession* put(Session& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Session const& lhs,
                                                      Session const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Session const& lhs,
                                                      Session const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Session const& lhs,
                                                       Session const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Session const& lhs,
                                                       Session const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Session const& lhs,
                                                       Session const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Session values.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Session const& lhs,
                                                       Session const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSession lhs, Session const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSession lhs, Session const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSession lhs, Session const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSession lhs, Session const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSession lhs, Session const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Session and raw XrSession.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Session const& lhs, XrSession rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSession and Session.
//! @relates Session
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSession lhs, Session const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Session and nullptr: true if the handle is null.
 * @relates Session
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Session const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Session: true if the handle is null.
 * @relates Session
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Session const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Session and nullptr: true if the handle is not null.
 * @relates Session
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Session const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Session: true if the handle is not null.
 * @relates Session
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Session const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrSpace without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpace>
 *
 * @xrentity{XrSpace}
 * @ingroup handles
 */
class Space {
public:
  using Type = Space;
  using RawHandleType = XrSpace;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Space() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpace type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Space(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Space(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpace
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpace type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Space value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Space value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpace manipulation
   * @{
   */
  //! Gets the raw XrSpace value.
  OPENXR_HPP_CONSTEXPR XrSpace get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Space yourHandle;
   * auto result = d.xrCreateSpace(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Space&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

  /*!
   * @brief xrLocateSpace wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpace>
   *
   * @xrentity{xrLocateSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateSpace(Space baseSpace, Time time, SpaceLocation& location,
                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateSpace enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpaceLocation
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpace>
   *
   * @xrentity{xrLocateSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpaceLocation> locateSpace(Space baseSpace, Time time,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateSpace enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpaceLocation
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSpace>
   *
   * @xrentity{xrLocateSpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpaceLocation locateSpace(Space baseSpace, Time time,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpace wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpace>
   *
   * @xrentity{xrDestroySpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpace enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpace>
   *
   * @xrentity{xrDestroySpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpace enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpace>
   *
   * @xrentity{xrDestroySpace}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_FB_spatial_entity

  /*!
   * @brief xrGetSpaceUuidFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceUuidFB>
   *
   * @xrentity{xrGetSpaceUuidFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceUuidFB(XrUuidEXT* uuid, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpaceUuidFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type UuidEXT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceUuidFB>
   *
   * @xrentity{xrGetSpaceUuidFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UuidEXT> getSpaceUuidFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpaceUuidFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type UuidEXT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceUuidFB>
   *
   * @xrentity{xrGetSpaceUuidFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UuidEXT getSpaceUuidFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity

#ifdef XR_FB_spatial_entity

  /*!
   * @brief xrEnumerateSpaceSupportedComponentsFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpaceSupportedComponentsFB>
   *
   * @xrentity{xrEnumerateSpaceSupportedComponentsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSpaceSupportedComponentsFB(
      uint32_t componentTypeCapacityInput, uint32_t& componentTypeCountOutput,
      SpaceComponentTypeFB* componentTypes, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSpaceSupportedComponentsFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpaceComponentTypeFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpaceSupportedComponentsFB>
   *
   * @xrentity{xrEnumerateSpaceSupportedComponentsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpaceComponentTypeFB>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpaceComponentTypeFB, Allocator>>
  enumerateSpaceSupportedComponentsToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSpaceSupportedComponentsFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpaceComponentTypeFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpaceSupportedComponentsFB>
   *
   * @xrentity{xrEnumerateSpaceSupportedComponentsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpaceComponentTypeFB>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpaceComponentTypeFB, Allocator>>
  enumerateSpaceSupportedComponentsToVectorFB(Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateSpaceSupportedComponentsFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<SpaceComponentTypeFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpaceSupportedComponentsFB>
   *
   * @xrentity{xrEnumerateSpaceSupportedComponentsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpaceComponentTypeFB>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpaceComponentTypeFB, Allocator> enumerateSpaceSupportedComponentsToVectorFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSpaceSupportedComponentsFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<SpaceComponentTypeFB, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpaceSupportedComponentsFB>
   *
   * @xrentity{xrEnumerateSpaceSupportedComponentsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpaceComponentTypeFB>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpaceComponentTypeFB, Allocator> enumerateSpaceSupportedComponentsToVectorFB(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity

#ifdef XR_FB_spatial_entity

  /*!
   * @brief xrSetSpaceComponentStatusFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetSpaceComponentStatusFB>
   *
   * @xrentity{xrSetSpaceComponentStatusFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setSpaceComponentStatusFB(const SpaceComponentStatusSetInfoFB& info,
                                   AsyncRequestIdFB& requestId,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetSpaceComponentStatusFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetSpaceComponentStatusFB>
   *
   * @xrentity{xrSetSpaceComponentStatusFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AsyncRequestIdFB> setSpaceComponentStatusFB(
      const SpaceComponentStatusSetInfoFB& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetSpaceComponentStatusFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AsyncRequestIdFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetSpaceComponentStatusFB>
   *
   * @xrentity{xrSetSpaceComponentStatusFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AsyncRequestIdFB setSpaceComponentStatusFB(const SpaceComponentStatusSetInfoFB& info,
                                             Dispatch&& d
                                                 OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity

#ifdef XR_FB_spatial_entity

  /*!
   * @brief xrGetSpaceComponentStatusFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceComponentStatusFB>
   *
   * @xrentity{xrGetSpaceComponentStatusFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceComponentStatusFB(SpaceComponentTypeFB componentType,
                                   SpaceComponentStatusFB& status,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpaceComponentStatusFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpaceComponentStatusFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceComponentStatusFB>
   *
   * @xrentity{xrGetSpaceComponentStatusFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpaceComponentStatusFB> getSpaceComponentStatusFB(
      SpaceComponentTypeFB componentType, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpaceComponentStatusFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpaceComponentStatusFB
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceComponentStatusFB>
   *
   * @xrentity{xrGetSpaceComponentStatusFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpaceComponentStatusFB getSpaceComponentStatusFB(
      SpaceComponentTypeFB componentType, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity

#ifdef XR_ML_spatial_anchors

  /*!
   * @brief xrGetSpatialAnchorStateML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialAnchorStateML>
   *
   * @xrentity{xrGetSpatialAnchorStateML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialAnchorStateML(SpatialAnchorStateML& state,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpatialAnchorStateML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorStateML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialAnchorStateML>
   *
   * @xrentity{xrGetSpatialAnchorStateML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorStateML> getSpatialAnchorStateML(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpatialAnchorStateML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorStateML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialAnchorStateML>
   *
   * @xrentity{xrGetSpatialAnchorStateML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorStateML getSpatialAnchorStateML(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_ML_spatial_anchors

#ifdef XR_META_spatial_entity_mesh

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetSpaceTriangleMeshMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceTriangleMeshMETA>
   *
   * @xrentity{xrGetSpaceTriangleMeshMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceTriangleMeshMETA(const SpaceTriangleMeshGetInfoMETA& getInfo,
                                  SpaceTriangleMeshMETA& triangleMeshOutput,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpaceTriangleMeshMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceTriangleMeshMETA>
   *
   * @xrentity{xrGetSpaceTriangleMeshMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceTriangleMeshMETA(const SpaceTriangleMeshGetInfoMETA& getInfo,
                                  SpaceTriangleMeshMETA& triangleMeshOutput,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpaceTriangleMeshMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceTriangleMeshMETA>
   *
   * @xrentity{xrGetSpaceTriangleMeshMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getSpaceTriangleMeshMETA(const SpaceTriangleMeshGetInfoMETA& getInfo,
                                SpaceTriangleMeshMETA& triangleMeshOutput,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_spatial_entity_mesh

#ifdef XR_HTC_anchor

  /*!
   * @brief xrGetSpatialAnchorNameHTC wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialAnchorNameHTC>
   *
   * @xrentity{xrGetSpatialAnchorNameHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialAnchorNameHTC(SpatialAnchorNameHTC& name,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpatialAnchorNameHTC enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorNameHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialAnchorNameHTC>
   *
   * @xrentity{xrGetSpatialAnchorNameHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorNameHTC> getSpatialAnchorNameHTC(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpatialAnchorNameHTC enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorNameHTC
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialAnchorNameHTC>
   *
   * @xrentity{xrGetSpatialAnchorNameHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorNameHTC getSpatialAnchorNameHTC(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_HTC_anchor

  //! @}
private:
  XrSpace val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpace) == sizeof(Space), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpace from an Space value.
 *
 * @found_by_adl
 * @see Space::get()
 * @relates Space
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpace get(Space const& v) noexcept { return v.get(); }
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw XrSpace
 * handle in a Space (by reference).
 *
 * e.g.
 * ```
 * Space yourHandle;
 * auto result = d.xrCreateSpace(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Space
 */
static OPENXR_HPP_INLINE XrSpace* put(Space& h, bool clear = true) noexcept { return h.put(clear); }

//! @brief `<` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Space const& lhs, Space const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Space const& lhs, Space const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Space const& lhs,
                                                       Space const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Space const& lhs,
                                                       Space const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Space const& lhs,
                                                       Space const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Space values.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Space const& lhs,
                                                       Space const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSpace lhs, Space const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSpace lhs, Space const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSpace lhs, Space const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSpace lhs, Space const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSpace lhs, Space const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Space and raw XrSpace.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Space const& lhs, XrSpace rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpace and Space.
//! @relates Space
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSpace lhs, Space const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Space and nullptr: true if the handle is null.
 * @relates Space
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Space const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Space: true if the handle is null.
 * @relates Space
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Space const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Space and nullptr: true if the handle is not null.
 * @relates Space
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Space const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Space: true if the handle is not null.
 * @relates Space
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Space const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrAction without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrAction>
 *
 * @xrentity{XrAction}
 * @ingroup handles
 */
class Action {
public:
  using Type = Action;
  using RawHandleType = XrAction;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Action() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrAction type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Action(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Action(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrAction
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrAction type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Action value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Action value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrAction manipulation
   * @{
   */
  //! Gets the raw XrAction value.
  OPENXR_HPP_CONSTEXPR XrAction get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Action yourHandle;
   * auto result = d.xrCreateAction(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Action&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyAction wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyAction>
   *
   * @xrentity{xrDestroyAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyAction enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyAction>
   *
   * @xrentity{xrDestroyAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyAction enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyAction>
   *
   * @xrentity{xrDestroyAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrAction val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrAction) == sizeof(Action), "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrAction from an Action value.
 *
 * @found_by_adl
 * @see Action::get()
 * @relates Action
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrAction get(Action const& v) noexcept { return v.get(); }
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw XrAction
 * handle in a Action (by reference).
 *
 * e.g.
 * ```
 * Action yourHandle;
 * auto result = d.xrCreateAction(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Action
 */
static OPENXR_HPP_INLINE XrAction* put(Action& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Action const& lhs,
                                                      Action const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Action const& lhs,
                                                      Action const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Action const& lhs,
                                                       Action const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Action const& lhs,
                                                       Action const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Action const& lhs,
                                                       Action const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Action values.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Action const& lhs,
                                                       Action const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrAction lhs, Action const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrAction lhs, Action const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrAction lhs, Action const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrAction lhs, Action const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrAction lhs, Action const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Action and raw XrAction.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Action const& lhs, XrAction rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrAction and Action.
//! @relates Action
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrAction lhs, Action const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Action and nullptr: true if the handle is null.
 * @relates Action
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Action const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Action: true if the handle is null.
 * @relates Action
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Action const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Action and nullptr: true if the handle is not null.
 * @relates Action
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Action const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Action: true if the handle is not null.
 * @relates Action
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Action const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrSwapchain without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSwapchain>
 *
 * @xrentity{XrSwapchain}
 * @ingroup handles
 */
class Swapchain {
public:
  using Type = Swapchain;
  using RawHandleType = XrSwapchain;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR Swapchain() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSwapchain type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT Swapchain(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR Swapchain(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSwapchain
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSwapchain type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this Swapchain value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this Swapchain value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSwapchain manipulation
   * @{
   */
  //! Gets the raw XrSwapchain value.
  OPENXR_HPP_CONSTEXPR XrSwapchain get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * Swapchain yourHandle;
   * auto result = d.xrCreateSwapchain(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(Swapchain&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySwapchain wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySwapchain>
   *
   * @xrentity{xrDestroySwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySwapchain enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySwapchain>
   *
   * @xrentity{xrDestroySwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySwapchain enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySwapchain>
   *
   * @xrentity{xrDestroySwapchain}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrEnumerateSwapchainImages wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSwapchainImages(uint32_t imageCapacityInput, uint32_t& imageCountOutput,
                                  SwapchainImageBaseHeader* images,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSwapchainImages enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSwapchainImages(uint32_t imageCapacityInput, uint32_t& imageCountOutput,
                                  SwapchainImageBaseHeader* images,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrEnumerateSwapchainImages enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSwapchainImages>
   *
   * @xrentity{xrEnumerateSwapchainImages}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void enumerateSwapchainImages(uint32_t imageCapacityInput, uint32_t& imageCountOutput,
                                SwapchainImageBaseHeader* images,
                                Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrAcquireSwapchainImage wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAcquireSwapchainImage>
   *
   * @xrentity{xrAcquireSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result acquireSwapchainImage(const SwapchainImageAcquireInfo& acquireInfo, uint32_t& index,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrAcquireSwapchainImage enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type uint32_t
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAcquireSwapchainImage>
   *
   * @xrentity{xrAcquireSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<uint32_t> acquireSwapchainImage(const SwapchainImageAcquireInfo& acquireInfo,
                                              Dispatch&& d
                                                  OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrAcquireSwapchainImage enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type uint32_t
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAcquireSwapchainImage>
   *
   * @xrentity{xrAcquireSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  uint32_t acquireSwapchainImage(const SwapchainImageAcquireInfo& acquireInfo,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrWaitSwapchainImage wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitSwapchainImage>
   *
   * @xrentity{xrWaitSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result waitSwapchainImage(const SwapchainImageWaitInfo& waitInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrWaitSwapchainImage enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::TimeoutExpired, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrWaitSwapchainImage>
   *
   * @xrentity{xrWaitSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result waitSwapchainImage(const SwapchainImageWaitInfo& waitInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrReleaseSwapchainImage wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrReleaseSwapchainImage>
   *
   * @xrentity{xrReleaseSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result releaseSwapchainImage(const SwapchainImageReleaseInfo& releaseInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrReleaseSwapchainImage enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrReleaseSwapchainImage>
   *
   * @xrentity{xrReleaseSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result releaseSwapchainImage(const SwapchainImageReleaseInfo& releaseInfo,
                               Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrReleaseSwapchainImage enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrReleaseSwapchainImage>
   *
   * @xrentity{xrReleaseSwapchainImage}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void releaseSwapchainImage(const SwapchainImageReleaseInfo& releaseInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_FB_swapchain_update_state

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrUpdateSwapchainFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateSwapchainFB>
   *
   * @xrentity{xrUpdateSwapchainFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result updateSwapchainFB(const SwapchainStateBaseHeaderFB& state,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUpdateSwapchainFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateSwapchainFB>
   *
   * @xrentity{xrUpdateSwapchainFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result updateSwapchainFB(const SwapchainStateBaseHeaderFB& state,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUpdateSwapchainFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateSwapchainFB>
   *
   * @xrentity{xrUpdateSwapchainFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void updateSwapchainFB(const SwapchainStateBaseHeaderFB& state,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_swapchain_update_state

#ifdef XR_FB_swapchain_update_state

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetSwapchainStateFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSwapchainStateFB>
   *
   * @xrentity{xrGetSwapchainStateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSwapchainStateFB(SwapchainStateBaseHeaderFB& state,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSwapchainStateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSwapchainStateFB>
   *
   * @xrentity{xrGetSwapchainStateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSwapchainStateFB(SwapchainStateBaseHeaderFB& state,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSwapchainStateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSwapchainStateFB>
   *
   * @xrentity{xrGetSwapchainStateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getSwapchainStateFB(SwapchainStateBaseHeaderFB& state,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_swapchain_update_state

  //! @}
private:
  XrSwapchain val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSwapchain) == sizeof(Swapchain),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSwapchain from an Swapchain value.
 *
 * @found_by_adl
 * @see Swapchain::get()
 * @relates Swapchain
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSwapchain get(Swapchain const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSwapchain handle in a Swapchain (by reference).
 *
 * e.g.
 * ```
 * Swapchain yourHandle;
 * auto result = d.xrCreateSwapchain(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates Swapchain
 */
static OPENXR_HPP_INLINE XrSwapchain* put(Swapchain& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Swapchain const& lhs,
                                                      Swapchain const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Swapchain const& lhs,
                                                      Swapchain const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Swapchain const& lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Swapchain const& lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Swapchain const& lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between Swapchain values.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Swapchain const& lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(Swapchain const& lhs,
                                                      XrSwapchain rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSwapchain lhs,
                                                      Swapchain const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(Swapchain const& lhs,
                                                      XrSwapchain rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSwapchain lhs,
                                                      Swapchain const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(Swapchain const& lhs,
                                                       XrSwapchain rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSwapchain lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(Swapchain const& lhs,
                                                       XrSwapchain rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSwapchain lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Swapchain const& lhs,
                                                       XrSwapchain rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSwapchain lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between Swapchain and raw XrSwapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Swapchain const& lhs,
                                                       XrSwapchain rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSwapchain and Swapchain.
//! @relates Swapchain
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSwapchain lhs,
                                                       Swapchain const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between Swapchain and nullptr: true if the handle is null.
 * @relates Swapchain
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(Swapchain const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and Swapchain: true if the handle is null.
 * @relates Swapchain
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       Swapchain const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between Swapchain and nullptr: true if the handle is not null.
 * @relates Swapchain
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(Swapchain const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and Swapchain: true if the handle is not null.
 * @relates Swapchain
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       Swapchain const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

/*!
 * @brief Handle class - wrapping XrActionSet without indicating ownership.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrActionSet>
 *
 * @xrentity{XrActionSet}
 * @ingroup handles
 */
class ActionSet {
public:
  using Type = ActionSet;
  using RawHandleType = XrActionSet;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR ActionSet() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrActionSet type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT ActionSet(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR ActionSet(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrActionSet
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrActionSet type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this ActionSet value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this ActionSet value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrActionSet manipulation
   * @{
   */
  //! Gets the raw XrActionSet value.
  OPENXR_HPP_CONSTEXPR XrActionSet get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * ActionSet yourHandle;
   * auto result = d.xrCreateActionSet(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(ActionSet&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyActionSet wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyActionSet>
   *
   * @xrentity{xrDestroyActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyActionSet enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyActionSet>
   *
   * @xrentity{xrDestroyActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyActionSet enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyActionSet>
   *
   * @xrentity{xrDestroyActionSet}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateAction wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createAction(const ActionCreateInfo& createInfo, Action& action,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateAction enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Action
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Action> createAction(const ActionCreateInfo& createInfo,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateAction enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Action
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Action createAction(const ActionCreateInfo& createInfo,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateAction wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Action
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Action, impl::RemoveRefConst<Dispatch>>> createActionUnique(
      const ActionCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateAction wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Action
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateAction>
   *
   * @xrentity{xrCreateAction}
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Action, impl::RemoveRefConst<Dispatch>> createActionUnique(
      const ActionCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrActionSet val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrActionSet) == sizeof(ActionSet),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrActionSet from an ActionSet value.
 *
 * @found_by_adl
 * @see ActionSet::get()
 * @relates ActionSet
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrActionSet get(ActionSet const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrActionSet handle in a ActionSet (by reference).
 *
 * e.g.
 * ```
 * ActionSet yourHandle;
 * auto result = d.xrCreateActionSet(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates ActionSet
 */
static OPENXR_HPP_INLINE XrActionSet* put(ActionSet& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(ActionSet const& lhs,
                                                      ActionSet const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(ActionSet const& lhs,
                                                      ActionSet const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(ActionSet const& lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(ActionSet const& lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(ActionSet const& lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between ActionSet values.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(ActionSet const& lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(ActionSet const& lhs,
                                                      XrActionSet rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrActionSet lhs,
                                                      ActionSet const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(ActionSet const& lhs,
                                                      XrActionSet rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrActionSet lhs,
                                                      ActionSet const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(ActionSet const& lhs,
                                                       XrActionSet rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrActionSet lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(ActionSet const& lhs,
                                                       XrActionSet rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrActionSet lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(ActionSet const& lhs,
                                                       XrActionSet rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrActionSet lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between ActionSet and raw XrActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(ActionSet const& lhs,
                                                       XrActionSet rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrActionSet and ActionSet.
//! @relates ActionSet
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrActionSet lhs,
                                                       ActionSet const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between ActionSet and nullptr: true if the handle is null.
 * @relates ActionSet
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(ActionSet const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and ActionSet: true if the handle is null.
 * @relates ActionSet
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       ActionSet const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between ActionSet and nullptr: true if the handle is not null.
 * @relates ActionSet
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(ActionSet const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and ActionSet: true if the handle is not null.
 * @relates ActionSet
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       ActionSet const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}

#ifdef XR_EXT_debug_utils

/*!
 * @brief Handle class - wrapping XrDebugUtilsMessengerEXT without indicating ownership.
 *
 * Provided by the `XR_EXT_debug_utils` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrDebugUtilsMessengerEXT>
 *
 * @xrentity{XrDebugUtilsMessengerEXT}
 * @ingroup handles
 */
class DebugUtilsMessengerEXT {
public:
  using Type = DebugUtilsMessengerEXT;
  using RawHandleType = XrDebugUtilsMessengerEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR DebugUtilsMessengerEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrDebugUtilsMessengerEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT DebugUtilsMessengerEXT(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR DebugUtilsMessengerEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrDebugUtilsMessengerEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrDebugUtilsMessengerEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this DebugUtilsMessengerEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this DebugUtilsMessengerEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrDebugUtilsMessengerEXT manipulation
   * @{
   */
  //! Gets the raw XrDebugUtilsMessengerEXT value.
  OPENXR_HPP_CONSTEXPR XrDebugUtilsMessengerEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * DebugUtilsMessengerEXT yourHandle;
   * auto result = d.xrCreateDebugUtilsMessengerEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(DebugUtilsMessengerEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyDebugUtilsMessengerEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyDebugUtilsMessengerEXT>
   *
   * @xrentity{xrDestroyDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyDebugUtilsMessengerEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyDebugUtilsMessengerEXT>
   *
   * @xrentity{xrDestroyDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyDebugUtilsMessengerEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyDebugUtilsMessengerEXT>
   *
   * @xrentity{xrDestroyDebugUtilsMessengerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrDebugUtilsMessengerEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrDebugUtilsMessengerEXT) == sizeof(DebugUtilsMessengerEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrDebugUtilsMessengerEXT from an DebugUtilsMessengerEXT
 * value.
 *
 * @found_by_adl
 * @see DebugUtilsMessengerEXT::get()
 * @relates DebugUtilsMessengerEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrDebugUtilsMessengerEXT
get(DebugUtilsMessengerEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrDebugUtilsMessengerEXT handle in a DebugUtilsMessengerEXT (by reference).
 *
 * e.g.
 * ```
 * DebugUtilsMessengerEXT yourHandle;
 * auto result = d.xrCreateDebugUtilsMessengerEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates DebugUtilsMessengerEXT
 */
static OPENXR_HPP_INLINE XrDebugUtilsMessengerEXT* put(DebugUtilsMessengerEXT& h,
                                                       bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(DebugUtilsMessengerEXT const& lhs,
                                                      DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(DebugUtilsMessengerEXT const& lhs,
                                                      DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(DebugUtilsMessengerEXT const& lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(DebugUtilsMessengerEXT const& lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(DebugUtilsMessengerEXT const& lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between DebugUtilsMessengerEXT values.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(DebugUtilsMessengerEXT const& lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(DebugUtilsMessengerEXT const& lhs,
                                                      XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrDebugUtilsMessengerEXT lhs,
                                                      DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(DebugUtilsMessengerEXT const& lhs,
                                                      XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrDebugUtilsMessengerEXT lhs,
                                                      DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(DebugUtilsMessengerEXT const& lhs,
                                                       XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrDebugUtilsMessengerEXT lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(DebugUtilsMessengerEXT const& lhs,
                                                       XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrDebugUtilsMessengerEXT lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(DebugUtilsMessengerEXT const& lhs,
                                                       XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrDebugUtilsMessengerEXT lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between DebugUtilsMessengerEXT and raw XrDebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(DebugUtilsMessengerEXT const& lhs,
                                                       XrDebugUtilsMessengerEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrDebugUtilsMessengerEXT and DebugUtilsMessengerEXT.
//! @relates DebugUtilsMessengerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrDebugUtilsMessengerEXT lhs,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between DebugUtilsMessengerEXT and nullptr: true if the handle is
 * null.
 * @relates DebugUtilsMessengerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(DebugUtilsMessengerEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and DebugUtilsMessengerEXT: true if the handle is
 * null.
 * @relates DebugUtilsMessengerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between DebugUtilsMessengerEXT and nullptr: true if the handle is
 * not null.
 * @relates DebugUtilsMessengerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(DebugUtilsMessengerEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and DebugUtilsMessengerEXT: true if the handle is
 * not null.
 * @relates DebugUtilsMessengerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       DebugUtilsMessengerEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_EXT_debug_utils

#ifdef XR_MSFT_spatial_anchor

/*!
 * @brief Handle class - wrapping XrSpatialAnchorMSFT without indicating ownership.
 *
 * Provided by the `XR_MSFT_spatial_anchor` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorMSFT>
 *
 * @xrentity{XrSpatialAnchorMSFT}
 * @ingroup handles
 */
class SpatialAnchorMSFT {
public:
  using Type = SpatialAnchorMSFT;
  using RawHandleType = XrSpatialAnchorMSFT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SpatialAnchorMSFT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpatialAnchorMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SpatialAnchorMSFT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SpatialAnchorMSFT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpatialAnchorMSFT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpatialAnchorMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SpatialAnchorMSFT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SpatialAnchorMSFT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpatialAnchorMSFT manipulation
   * @{
   */
  //! Gets the raw XrSpatialAnchorMSFT value.
  OPENXR_HPP_CONSTEXPR XrSpatialAnchorMSFT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SpatialAnchorMSFT yourHandle;
   * auto result = d.xrCreateSpatialAnchorMSFT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SpatialAnchorMSFT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrSpatialAnchorMSFT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpatialAnchorMSFT) == sizeof(SpatialAnchorMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpatialAnchorMSFT from an SpatialAnchorMSFT value.
 *
 * @found_by_adl
 * @see SpatialAnchorMSFT::get()
 * @relates SpatialAnchorMSFT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpatialAnchorMSFT
get(SpatialAnchorMSFT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSpatialAnchorMSFT handle in a SpatialAnchorMSFT (by reference).
 *
 * e.g.
 * ```
 * SpatialAnchorMSFT yourHandle;
 * auto result = d.xrCreateSpatialAnchorMSFT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SpatialAnchorMSFT
 */
static OPENXR_HPP_INLINE XrSpatialAnchorMSFT* put(SpatialAnchorMSFT& h,
                                                  bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialAnchorMSFT const& lhs,
                                                      SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialAnchorMSFT const& lhs,
                                                      SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialAnchorMSFT const& lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialAnchorMSFT const& lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorMSFT const& lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SpatialAnchorMSFT values.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorMSFT const& lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialAnchorMSFT const& lhs,
                                                      XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSpatialAnchorMSFT lhs,
                                                      SpatialAnchorMSFT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialAnchorMSFT const& lhs,
                                                      XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSpatialAnchorMSFT lhs,
                                                      SpatialAnchorMSFT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialAnchorMSFT const& lhs,
                                                       XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSpatialAnchorMSFT lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialAnchorMSFT const& lhs,
                                                       XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSpatialAnchorMSFT lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorMSFT const& lhs,
                                                       XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSpatialAnchorMSFT lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SpatialAnchorMSFT and raw XrSpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorMSFT const& lhs,
                                                       XrSpatialAnchorMSFT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpatialAnchorMSFT and SpatialAnchorMSFT.
//! @relates SpatialAnchorMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSpatialAnchorMSFT lhs,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SpatialAnchorMSFT and nullptr: true if the handle is null.
 * @relates SpatialAnchorMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SpatialAnchorMSFT: true if the handle is null.
 * @relates SpatialAnchorMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SpatialAnchorMSFT and nullptr: true if the handle is not
 * null.
 * @relates SpatialAnchorMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SpatialAnchorMSFT: true if the handle is not
 * null.
 * @relates SpatialAnchorMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SpatialAnchorMSFT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_MSFT_spatial_anchor

#ifdef XR_MSFT_spatial_graph_bridge

/*!
 * @brief Handle class - wrapping XrSpatialGraphNodeBindingMSFT without indicating ownership.
 *
 * Provided by the `XR_MSFT_spatial_graph_bridge` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialGraphNodeBindingMSFT>
 *
 * @xrentity{XrSpatialGraphNodeBindingMSFT}
 * @ingroup handles
 */
class SpatialGraphNodeBindingMSFT {
public:
  using Type = SpatialGraphNodeBindingMSFT;
  using RawHandleType = XrSpatialGraphNodeBindingMSFT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SpatialGraphNodeBindingMSFT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpatialGraphNodeBindingMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SpatialGraphNodeBindingMSFT(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SpatialGraphNodeBindingMSFT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpatialGraphNodeBindingMSFT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpatialGraphNodeBindingMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SpatialGraphNodeBindingMSFT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SpatialGraphNodeBindingMSFT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpatialGraphNodeBindingMSFT manipulation
   * @{
   */
  //! Gets the raw XrSpatialGraphNodeBindingMSFT value.
  OPENXR_HPP_CONSTEXPR XrSpatialGraphNodeBindingMSFT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SpatialGraphNodeBindingMSFT yourHandle;
   * auto result = d.xrCreateSpatialGraphNodeBindingMSFT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SpatialGraphNodeBindingMSFT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpatialGraphNodeBindingMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialGraphNodeBindingMSFT>
   *
   * @xrentity{xrDestroySpatialGraphNodeBindingMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpatialGraphNodeBindingMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialGraphNodeBindingMSFT>
   *
   * @xrentity{xrDestroySpatialGraphNodeBindingMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpatialGraphNodeBindingMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialGraphNodeBindingMSFT>
   *
   * @xrentity{xrDestroySpatialGraphNodeBindingMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSpatialGraphNodeBindingPropertiesMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialGraphNodeBindingPropertiesMSFT>
   *
   * @xrentity{xrGetSpatialGraphNodeBindingPropertiesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialGraphNodeBindingPropertiesMSFT(
      const SpatialGraphNodeBindingPropertiesGetInfoMSFT& getInfo,
      SpatialGraphNodeBindingPropertiesMSFT& properties,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpatialGraphNodeBindingPropertiesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialGraphNodeBindingPropertiesMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialGraphNodeBindingPropertiesMSFT>
   *
   * @xrentity{xrGetSpatialGraphNodeBindingPropertiesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialGraphNodeBindingPropertiesMSFT> getSpatialGraphNodeBindingPropertiesMSFT(
      const SpatialGraphNodeBindingPropertiesGetInfoMSFT& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpatialGraphNodeBindingPropertiesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialGraphNodeBindingPropertiesMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialGraphNodeBindingPropertiesMSFT>
   *
   * @xrentity{xrGetSpatialGraphNodeBindingPropertiesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialGraphNodeBindingPropertiesMSFT getSpatialGraphNodeBindingPropertiesMSFT(
      const SpatialGraphNodeBindingPropertiesGetInfoMSFT& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrSpatialGraphNodeBindingMSFT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpatialGraphNodeBindingMSFT) == sizeof(SpatialGraphNodeBindingMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpatialGraphNodeBindingMSFT from an
 * SpatialGraphNodeBindingMSFT value.
 *
 * @found_by_adl
 * @see SpatialGraphNodeBindingMSFT::get()
 * @relates SpatialGraphNodeBindingMSFT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpatialGraphNodeBindingMSFT
get(SpatialGraphNodeBindingMSFT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSpatialGraphNodeBindingMSFT handle in a SpatialGraphNodeBindingMSFT (by reference).
 *
 * e.g.
 * ```
 * SpatialGraphNodeBindingMSFT yourHandle;
 * auto result = d.xrCreateSpatialGraphNodeBindingMSFT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SpatialGraphNodeBindingMSFT
 */
static OPENXR_HPP_INLINE XrSpatialGraphNodeBindingMSFT* put(SpatialGraphNodeBindingMSFT& h,
                                                            bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SpatialGraphNodeBindingMSFT values.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    SpatialGraphNodeBindingMSFT const& lhs, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SpatialGraphNodeBindingMSFT values.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    SpatialGraphNodeBindingMSFT const& lhs, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SpatialGraphNodeBindingMSFT values.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    SpatialGraphNodeBindingMSFT const& lhs, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SpatialGraphNodeBindingMSFT values.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    SpatialGraphNodeBindingMSFT const& lhs, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SpatialGraphNodeBindingMSFT values.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    SpatialGraphNodeBindingMSFT const& lhs, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SpatialGraphNodeBindingMSFT values.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    SpatialGraphNodeBindingMSFT const& lhs, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SpatialGraphNodeBindingMSFT and raw XrSpatialGraphNodeBindingMSFT.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialGraphNodeBindingMSFT const& lhs,
                                                      XrSpatialGraphNodeBindingMSFT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpatialGraphNodeBindingMSFT and SpatialGraphNodeBindingMSFT.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    XrSpatialGraphNodeBindingMSFT lhs, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SpatialGraphNodeBindingMSFT and raw XrSpatialGraphNodeBindingMSFT.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialGraphNodeBindingMSFT const& lhs,
                                                      XrSpatialGraphNodeBindingMSFT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpatialGraphNodeBindingMSFT and SpatialGraphNodeBindingMSFT.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    XrSpatialGraphNodeBindingMSFT lhs, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SpatialGraphNodeBindingMSFT and raw
//! XrSpatialGraphNodeBindingMSFT.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialGraphNodeBindingMSFT const& lhs,
                                                       XrSpatialGraphNodeBindingMSFT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpatialGraphNodeBindingMSFT and
//! SpatialGraphNodeBindingMSFT.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    XrSpatialGraphNodeBindingMSFT lhs, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SpatialGraphNodeBindingMSFT and raw
//! XrSpatialGraphNodeBindingMSFT.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialGraphNodeBindingMSFT const& lhs,
                                                       XrSpatialGraphNodeBindingMSFT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpatialGraphNodeBindingMSFT and
//! SpatialGraphNodeBindingMSFT.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    XrSpatialGraphNodeBindingMSFT lhs, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SpatialGraphNodeBindingMSFT and raw
//! XrSpatialGraphNodeBindingMSFT.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialGraphNodeBindingMSFT const& lhs,
                                                       XrSpatialGraphNodeBindingMSFT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpatialGraphNodeBindingMSFT and
//! SpatialGraphNodeBindingMSFT.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    XrSpatialGraphNodeBindingMSFT lhs, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SpatialGraphNodeBindingMSFT and raw
//! XrSpatialGraphNodeBindingMSFT.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialGraphNodeBindingMSFT const& lhs,
                                                       XrSpatialGraphNodeBindingMSFT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpatialGraphNodeBindingMSFT and
//! SpatialGraphNodeBindingMSFT.
//! @relates SpatialGraphNodeBindingMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    XrSpatialGraphNodeBindingMSFT lhs, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SpatialGraphNodeBindingMSFT and nullptr: true if the handle is
 * null.
 * @relates SpatialGraphNodeBindingMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialGraphNodeBindingMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SpatialGraphNodeBindingMSFT: true if the handle is
 * null.
 * @relates SpatialGraphNodeBindingMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    std::nullptr_t /* unused */, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SpatialGraphNodeBindingMSFT and nullptr: true if the handle
 * is not null.
 * @relates SpatialGraphNodeBindingMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialGraphNodeBindingMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SpatialGraphNodeBindingMSFT: true if the handle
 * is not null.
 * @relates SpatialGraphNodeBindingMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    std::nullptr_t /* unused */, SpatialGraphNodeBindingMSFT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_MSFT_spatial_graph_bridge

#ifdef XR_EXT_hand_tracking

/*!
 * @brief Handle class - wrapping XrHandTrackerEXT without indicating ownership.
 *
 * Provided by the `XR_EXT_hand_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrHandTrackerEXT>
 *
 * @xrentity{XrHandTrackerEXT}
 * @ingroup handles
 */
class HandTrackerEXT {
public:
  using Type = HandTrackerEXT;
  using RawHandleType = XrHandTrackerEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR HandTrackerEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrHandTrackerEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT HandTrackerEXT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR HandTrackerEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrHandTrackerEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrHandTrackerEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this HandTrackerEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this HandTrackerEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrHandTrackerEXT manipulation
   * @{
   */
  //! Gets the raw XrHandTrackerEXT value.
  OPENXR_HPP_CONSTEXPR XrHandTrackerEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * HandTrackerEXT yourHandle;
   * auto result = d.xrCreateHandTrackerEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(HandTrackerEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyHandTrackerEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyHandTrackerEXT>
   *
   * @xrentity{xrDestroyHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyHandTrackerEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyHandTrackerEXT>
   *
   * @xrentity{xrDestroyHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyHandTrackerEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyHandTrackerEXT>
   *
   * @xrentity{xrDestroyHandTrackerEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrLocateHandJointsEXT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateHandJointsEXT>
   *
   * @xrentity{xrLocateHandJointsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateHandJointsEXT(const HandJointsLocateInfoEXT& locateInfo,
                             HandJointLocationsEXT& locations,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateHandJointsEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateHandJointsEXT>
   *
   * @xrentity{xrLocateHandJointsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateHandJointsEXT(const HandJointsLocateInfoEXT& locateInfo,
                             HandJointLocationsEXT& locations,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateHandJointsEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateHandJointsEXT>
   *
   * @xrentity{xrLocateHandJointsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void locateHandJointsEXT(const HandJointsLocateInfoEXT& locateInfo,
                           HandJointLocationsEXT& locations,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_MSFT_hand_tracking_mesh

  /*!
   * @brief xrCreateHandMeshSpaceMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createHandMeshSpaceMSFT(const HandMeshSpaceCreateInfoMSFT& createInfo, Space& space,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateHandMeshSpaceMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Space> createHandMeshSpaceMSFT(const HandMeshSpaceCreateInfoMSFT& createInfo,
                                             Dispatch&& d
                                                 OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateHandMeshSpaceMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Space createHandMeshSpaceMSFT(const HandMeshSpaceCreateInfoMSFT& createInfo,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateHandMeshSpaceMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<Space, impl::RemoveRefConst<Dispatch>>> createHandMeshSpaceUniqueMSFT(
      const HandMeshSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateHandMeshSpaceMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a Space
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateHandMeshSpaceMSFT>
   *
   * @xrentity{xrCreateHandMeshSpaceMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<Space, impl::RemoveRefConst<Dispatch>> createHandMeshSpaceUniqueMSFT(
      const HandMeshSpaceCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_MSFT_hand_tracking_mesh

  /*!
   * @brief xrUpdateHandMeshMSFT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateHandMeshMSFT>
   *
   * @xrentity{xrUpdateHandMeshMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result updateHandMeshMSFT(const HandMeshUpdateInfoMSFT& updateInfo, HandMeshMSFT& handMesh,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUpdateHandMeshMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type HandMeshMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateHandMeshMSFT>
   *
   * @xrentity{xrUpdateHandMeshMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<HandMeshMSFT> updateHandMeshMSFT(const HandMeshUpdateInfoMSFT& updateInfo,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUpdateHandMeshMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type HandMeshMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateHandMeshMSFT>
   *
   * @xrentity{xrUpdateHandMeshMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  HandMeshMSFT updateHandMeshMSFT(const HandMeshUpdateInfoMSFT& updateInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_hand_tracking_mesh

#ifdef XR_FB_hand_tracking_mesh

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetHandMeshFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetHandMeshFB>
   *
   * @xrentity{xrGetHandMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getHandMeshFB(HandTrackingMeshFB& mesh,
                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetHandMeshFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetHandMeshFB>
   *
   * @xrentity{xrGetHandMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getHandMeshFB(HandTrackingMeshFB& mesh,
                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetHandMeshFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetHandMeshFB>
   *
   * @xrentity{xrGetHandMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getHandMeshFB(HandTrackingMeshFB& mesh,
                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_hand_tracking_mesh

#ifdef XR_MNDX_force_feedback_curl

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrApplyForceFeedbackCurlMNDX wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrApplyForceFeedbackCurlMNDX>
   *
   * @xrentity{xrApplyForceFeedbackCurlMNDX}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result applyForceFeedbackCurlMNDX(const ForceFeedbackCurlApplyLocationsMNDX& locations,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrApplyForceFeedbackCurlMNDX enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::SessionNotFocused, or an error code if
   * asserts are not active and exceptions are disabled)
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrApplyForceFeedbackCurlMNDX>
   *
   * @xrentity{xrApplyForceFeedbackCurlMNDX}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result applyForceFeedbackCurlMNDX(const ForceFeedbackCurlApplyLocationsMNDX& locations,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MNDX_force_feedback_curl

  //! @}
private:
  XrHandTrackerEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrHandTrackerEXT) == sizeof(HandTrackerEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrHandTrackerEXT from an HandTrackerEXT value.
 *
 * @found_by_adl
 * @see HandTrackerEXT::get()
 * @relates HandTrackerEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrHandTrackerEXT get(HandTrackerEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrHandTrackerEXT handle in a HandTrackerEXT (by reference).
 *
 * e.g.
 * ```
 * HandTrackerEXT yourHandle;
 * auto result = d.xrCreateHandTrackerEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates HandTrackerEXT
 */
static OPENXR_HPP_INLINE XrHandTrackerEXT* put(HandTrackerEXT& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(HandTrackerEXT const& lhs,
                                                      HandTrackerEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(HandTrackerEXT const& lhs,
                                                      HandTrackerEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(HandTrackerEXT const& lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(HandTrackerEXT const& lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(HandTrackerEXT const& lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between HandTrackerEXT values.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(HandTrackerEXT const& lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(HandTrackerEXT const& lhs,
                                                      XrHandTrackerEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrHandTrackerEXT lhs,
                                                      HandTrackerEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(HandTrackerEXT const& lhs,
                                                      XrHandTrackerEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrHandTrackerEXT lhs,
                                                      HandTrackerEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(HandTrackerEXT const& lhs,
                                                       XrHandTrackerEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrHandTrackerEXT lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(HandTrackerEXT const& lhs,
                                                       XrHandTrackerEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrHandTrackerEXT lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(HandTrackerEXT const& lhs,
                                                       XrHandTrackerEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrHandTrackerEXT lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between HandTrackerEXT and raw XrHandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(HandTrackerEXT const& lhs,
                                                       XrHandTrackerEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrHandTrackerEXT and HandTrackerEXT.
//! @relates HandTrackerEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrHandTrackerEXT lhs,
                                                       HandTrackerEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between HandTrackerEXT and nullptr: true if the handle is null.
 * @relates HandTrackerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(HandTrackerEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and HandTrackerEXT: true if the handle is null.
 * @relates HandTrackerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       HandTrackerEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between HandTrackerEXT and nullptr: true if the handle is not null.
 * @relates HandTrackerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(HandTrackerEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and HandTrackerEXT: true if the handle is not null.
 * @relates HandTrackerEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       HandTrackerEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_EXT_hand_tracking

#ifdef XR_FB_body_tracking

/*!
 * @brief Handle class - wrapping XrBodyTrackerFB without indicating ownership.
 *
 * Provided by the `XR_FB_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyTrackerFB>
 *
 * @xrentity{XrBodyTrackerFB}
 * @ingroup handles
 */
class BodyTrackerFB {
public:
  using Type = BodyTrackerFB;
  using RawHandleType = XrBodyTrackerFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR BodyTrackerFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrBodyTrackerFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT BodyTrackerFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR BodyTrackerFB(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrBodyTrackerFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrBodyTrackerFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this BodyTrackerFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this BodyTrackerFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrBodyTrackerFB manipulation
   * @{
   */
  //! Gets the raw XrBodyTrackerFB value.
  OPENXR_HPP_CONSTEXPR XrBodyTrackerFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * BodyTrackerFB yourHandle;
   * auto result = d.xrCreateBodyTrackerFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(BodyTrackerFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyBodyTrackerFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyBodyTrackerFB>
   *
   * @xrentity{xrDestroyBodyTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyBodyTrackerFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyBodyTrackerFB>
   *
   * @xrentity{xrDestroyBodyTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyBodyTrackerFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyBodyTrackerFB>
   *
   * @xrentity{xrDestroyBodyTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrLocateBodyJointsFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateBodyJointsFB>
   *
   * @xrentity{xrLocateBodyJointsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateBodyJointsFB(const BodyJointsLocateInfoFB& locateInfo,
                            BodyJointLocationsFB& locations,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateBodyJointsFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateBodyJointsFB>
   *
   * @xrentity{xrLocateBodyJointsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateBodyJointsFB(const BodyJointsLocateInfoFB& locateInfo,
                            BodyJointLocationsFB& locations,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateBodyJointsFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateBodyJointsFB>
   *
   * @xrentity{xrLocateBodyJointsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void locateBodyJointsFB(const BodyJointsLocateInfoFB& locateInfo, BodyJointLocationsFB& locations,
                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetBodySkeletonFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetBodySkeletonFB>
   *
   * @xrentity{xrGetBodySkeletonFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getBodySkeletonFB(BodySkeletonFB& skeleton,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetBodySkeletonFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetBodySkeletonFB>
   *
   * @xrentity{xrGetBodySkeletonFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getBodySkeletonFB(BodySkeletonFB& skeleton,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetBodySkeletonFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetBodySkeletonFB>
   *
   * @xrentity{xrGetBodySkeletonFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getBodySkeletonFB(BodySkeletonFB& skeleton,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrBodyTrackerFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrBodyTrackerFB) == sizeof(BodyTrackerFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrBodyTrackerFB from an BodyTrackerFB value.
 *
 * @found_by_adl
 * @see BodyTrackerFB::get()
 * @relates BodyTrackerFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrBodyTrackerFB get(BodyTrackerFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrBodyTrackerFB handle in a BodyTrackerFB (by reference).
 *
 * e.g.
 * ```
 * BodyTrackerFB yourHandle;
 * auto result = d.xrCreateBodyTrackerFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates BodyTrackerFB
 */
static OPENXR_HPP_INLINE XrBodyTrackerFB* put(BodyTrackerFB& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between BodyTrackerFB values.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(BodyTrackerFB const& lhs,
                                                      BodyTrackerFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between BodyTrackerFB values.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(BodyTrackerFB const& lhs,
                                                      BodyTrackerFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between BodyTrackerFB values.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(BodyTrackerFB const& lhs,
                                                       BodyTrackerFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between BodyTrackerFB values.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(BodyTrackerFB const& lhs,
                                                       BodyTrackerFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between BodyTrackerFB values.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(BodyTrackerFB const& lhs,
                                                       BodyTrackerFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between BodyTrackerFB values.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(BodyTrackerFB const& lhs,
                                                       BodyTrackerFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between BodyTrackerFB and raw XrBodyTrackerFB.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(BodyTrackerFB const& lhs,
                                                      XrBodyTrackerFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrBodyTrackerFB and BodyTrackerFB.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrBodyTrackerFB lhs,
                                                      BodyTrackerFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between BodyTrackerFB and raw XrBodyTrackerFB.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(BodyTrackerFB const& lhs,
                                                      XrBodyTrackerFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrBodyTrackerFB and BodyTrackerFB.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrBodyTrackerFB lhs,
                                                      BodyTrackerFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between BodyTrackerFB and raw XrBodyTrackerFB.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(BodyTrackerFB const& lhs,
                                                       XrBodyTrackerFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrBodyTrackerFB and BodyTrackerFB.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrBodyTrackerFB lhs,
                                                       BodyTrackerFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between BodyTrackerFB and raw XrBodyTrackerFB.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(BodyTrackerFB const& lhs,
                                                       XrBodyTrackerFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrBodyTrackerFB and BodyTrackerFB.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrBodyTrackerFB lhs,
                                                       BodyTrackerFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between BodyTrackerFB and raw XrBodyTrackerFB.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(BodyTrackerFB const& lhs,
                                                       XrBodyTrackerFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrBodyTrackerFB and BodyTrackerFB.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrBodyTrackerFB lhs,
                                                       BodyTrackerFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between BodyTrackerFB and raw XrBodyTrackerFB.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(BodyTrackerFB const& lhs,
                                                       XrBodyTrackerFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrBodyTrackerFB and BodyTrackerFB.
//! @relates BodyTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrBodyTrackerFB lhs,
                                                       BodyTrackerFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between BodyTrackerFB and nullptr: true if the handle is null.
 * @relates BodyTrackerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(BodyTrackerFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and BodyTrackerFB: true if the handle is null.
 * @relates BodyTrackerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       BodyTrackerFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between BodyTrackerFB and nullptr: true if the handle is not null.
 * @relates BodyTrackerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(BodyTrackerFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and BodyTrackerFB: true if the handle is not null.
 * @relates BodyTrackerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       BodyTrackerFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_body_tracking

#ifdef XR_MSFT_scene_understanding

/*!
 * @brief Handle class - wrapping XrSceneObserverMSFT without indicating ownership.
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneObserverMSFT>
 *
 * @xrentity{XrSceneObserverMSFT}
 * @ingroup handles
 */
class SceneObserverMSFT {
public:
  using Type = SceneObserverMSFT;
  using RawHandleType = XrSceneObserverMSFT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SceneObserverMSFT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSceneObserverMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SceneObserverMSFT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SceneObserverMSFT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSceneObserverMSFT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSceneObserverMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SceneObserverMSFT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SceneObserverMSFT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSceneObserverMSFT manipulation
   * @{
   */
  //! Gets the raw XrSceneObserverMSFT value.
  OPENXR_HPP_CONSTEXPR XrSceneObserverMSFT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SceneObserverMSFT yourHandle;
   * auto result = d.xrCreateSceneObserverMSFT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SceneObserverMSFT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySceneObserverMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySceneObserverMSFT>
   *
   * @xrentity{xrDestroySceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySceneObserverMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySceneObserverMSFT>
   *
   * @xrentity{xrDestroySceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySceneObserverMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySceneObserverMSFT>
   *
   * @xrentity{xrDestroySceneObserverMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSceneMSFT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneMSFT>
   *
   * @xrentity{xrCreateSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSceneMSFT(const SceneCreateInfoMSFT& createInfo, SceneMSFT& scene,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSceneMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SceneMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneMSFT>
   *
   * @xrentity{xrCreateSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SceneMSFT> createSceneMSFT(const SceneCreateInfoMSFT& createInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSceneMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SceneMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneMSFT>
   *
   * @xrentity{xrCreateSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SceneMSFT createSceneMSFT(const SceneCreateInfoMSFT& createInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSceneMSFT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SceneMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneMSFT>
   *
   * @xrentity{xrCreateSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SceneMSFT, impl::RemoveRefConst<Dispatch>>> createSceneUniqueMSFT(
      const SceneCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSceneMSFT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SceneMSFT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSceneMSFT>
   *
   * @xrentity{xrCreateSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SceneMSFT, impl::RemoveRefConst<Dispatch>> createSceneUniqueMSFT(
      const SceneCreateInfoMSFT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrComputeNewSceneMSFT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrComputeNewSceneMSFT>
   *
   * @xrentity{xrComputeNewSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result computeNewSceneMSFT(const NewSceneComputeInfoMSFT& computeInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrComputeNewSceneMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrComputeNewSceneMSFT>
   *
   * @xrentity{xrComputeNewSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result computeNewSceneMSFT(const NewSceneComputeInfoMSFT& computeInfo,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrComputeNewSceneMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrComputeNewSceneMSFT>
   *
   * @xrentity{xrComputeNewSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void computeNewSceneMSFT(const NewSceneComputeInfoMSFT& computeInfo,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSceneComputeStateMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneComputeStateMSFT>
   *
   * @xrentity{xrGetSceneComputeStateMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSceneComputeStateMSFT(SceneComputeStateMSFT& state,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSceneComputeStateMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SceneComputeStateMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneComputeStateMSFT>
   *
   * @xrentity{xrGetSceneComputeStateMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SceneComputeStateMSFT> getSceneComputeStateMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSceneComputeStateMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SceneComputeStateMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneComputeStateMSFT>
   *
   * @xrentity{xrGetSceneComputeStateMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SceneComputeStateMSFT getSceneComputeStateMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_MSFT_scene_understanding_serialization

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDeserializeSceneMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDeserializeSceneMSFT>
   *
   * @xrentity{xrDeserializeSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result deserializeSceneMSFT(const SceneDeserializeInfoMSFT& deserializeInfo,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDeserializeSceneMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDeserializeSceneMSFT>
   *
   * @xrentity{xrDeserializeSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result deserializeSceneMSFT(const SceneDeserializeInfoMSFT& deserializeInfo,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrDeserializeSceneMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDeserializeSceneMSFT>
   *
   * @xrentity{xrDeserializeSceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void deserializeSceneMSFT(const SceneDeserializeInfoMSFT& deserializeInfo,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_scene_understanding_serialization

  //! @}
private:
  XrSceneObserverMSFT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSceneObserverMSFT) == sizeof(SceneObserverMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSceneObserverMSFT from an SceneObserverMSFT value.
 *
 * @found_by_adl
 * @see SceneObserverMSFT::get()
 * @relates SceneObserverMSFT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSceneObserverMSFT
get(SceneObserverMSFT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSceneObserverMSFT handle in a SceneObserverMSFT (by reference).
 *
 * e.g.
 * ```
 * SceneObserverMSFT yourHandle;
 * auto result = d.xrCreateSceneObserverMSFT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SceneObserverMSFT
 */
static OPENXR_HPP_INLINE XrSceneObserverMSFT* put(SceneObserverMSFT& h,
                                                  bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SceneObserverMSFT values.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SceneObserverMSFT const& lhs,
                                                      SceneObserverMSFT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SceneObserverMSFT values.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SceneObserverMSFT const& lhs,
                                                      SceneObserverMSFT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SceneObserverMSFT values.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SceneObserverMSFT const& lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SceneObserverMSFT values.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SceneObserverMSFT const& lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SceneObserverMSFT values.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SceneObserverMSFT const& lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SceneObserverMSFT values.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SceneObserverMSFT const& lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SceneObserverMSFT and raw XrSceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SceneObserverMSFT const& lhs,
                                                      XrSceneObserverMSFT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSceneObserverMSFT and SceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSceneObserverMSFT lhs,
                                                      SceneObserverMSFT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SceneObserverMSFT and raw XrSceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SceneObserverMSFT const& lhs,
                                                      XrSceneObserverMSFT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSceneObserverMSFT and SceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSceneObserverMSFT lhs,
                                                      SceneObserverMSFT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SceneObserverMSFT and raw XrSceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SceneObserverMSFT const& lhs,
                                                       XrSceneObserverMSFT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSceneObserverMSFT and SceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSceneObserverMSFT lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SceneObserverMSFT and raw XrSceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SceneObserverMSFT const& lhs,
                                                       XrSceneObserverMSFT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSceneObserverMSFT and SceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSceneObserverMSFT lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SceneObserverMSFT and raw XrSceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SceneObserverMSFT const& lhs,
                                                       XrSceneObserverMSFT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSceneObserverMSFT and SceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSceneObserverMSFT lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SceneObserverMSFT and raw XrSceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SceneObserverMSFT const& lhs,
                                                       XrSceneObserverMSFT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSceneObserverMSFT and SceneObserverMSFT.
//! @relates SceneObserverMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSceneObserverMSFT lhs,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SceneObserverMSFT and nullptr: true if the handle is null.
 * @relates SceneObserverMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SceneObserverMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SceneObserverMSFT: true if the handle is null.
 * @relates SceneObserverMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SceneObserverMSFT and nullptr: true if the handle is not
 * null.
 * @relates SceneObserverMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SceneObserverMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SceneObserverMSFT: true if the handle is not
 * null.
 * @relates SceneObserverMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SceneObserverMSFT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_MSFT_scene_understanding

/*!
 * @brief Handle class - wrapping XrSceneMSFT without indicating ownership.
 *
 * Provided by the `XR_MSFT_scene_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSceneMSFT>
 *
 * @xrentity{XrSceneMSFT}
 * @ingroup handles
 */
class SceneMSFT {
public:
  using Type = SceneMSFT;
  using RawHandleType = XrSceneMSFT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SceneMSFT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSceneMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SceneMSFT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SceneMSFT(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSceneMSFT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSceneMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SceneMSFT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SceneMSFT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSceneMSFT manipulation
   * @{
   */
  //! Gets the raw XrSceneMSFT value.
  OPENXR_HPP_CONSTEXPR XrSceneMSFT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SceneMSFT yourHandle;
   * auto result = d.xrCreateSceneMSFT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SceneMSFT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySceneMSFT wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySceneMSFT>
   *
   * @xrentity{xrDestroySceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySceneMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySceneMSFT>
   *
   * @xrentity{xrDestroySceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySceneMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySceneMSFT>
   *
   * @xrentity{xrDestroySceneMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetSceneComponentsMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneComponentsMSFT>
   *
   * @xrentity{xrGetSceneComponentsMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSceneComponentsMSFT(const SceneComponentsGetInfoMSFT& getInfo,
                                SceneComponentsMSFT& components,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSceneComponentsMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneComponentsMSFT>
   *
   * @xrentity{xrGetSceneComponentsMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSceneComponentsMSFT(const SceneComponentsGetInfoMSFT& getInfo,
                                SceneComponentsMSFT& components,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSceneComponentsMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneComponentsMSFT>
   *
   * @xrentity{xrGetSceneComponentsMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getSceneComponentsMSFT(const SceneComponentsGetInfoMSFT& getInfo,
                              SceneComponentsMSFT& components,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrLocateSceneComponentsMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSceneComponentsMSFT>
   *
   * @xrentity{xrLocateSceneComponentsMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateSceneComponentsMSFT(const SceneComponentsLocateInfoMSFT& locateInfo,
                                   SceneComponentLocationsMSFT& locations,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateSceneComponentsMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSceneComponentsMSFT>
   *
   * @xrentity{xrLocateSceneComponentsMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateSceneComponentsMSFT(const SceneComponentsLocateInfoMSFT& locateInfo,
                                   SceneComponentLocationsMSFT& locations,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateSceneComponentsMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateSceneComponentsMSFT>
   *
   * @xrentity{xrLocateSceneComponentsMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void locateSceneComponentsMSFT(const SceneComponentsLocateInfoMSFT& locateInfo,
                                 SceneComponentLocationsMSFT& locations,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSceneMeshBuffersMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMeshBuffersMSFT>
   *
   * @xrentity{xrGetSceneMeshBuffersMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSceneMeshBuffersMSFT(const SceneMeshBuffersGetInfoMSFT& getInfo,
                                 SceneMeshBuffersMSFT& buffers,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSceneMeshBuffersMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SceneMeshBuffersMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMeshBuffersMSFT>
   *
   * @xrentity{xrGetSceneMeshBuffersMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SceneMeshBuffersMSFT> getSceneMeshBuffersMSFT(
      const SceneMeshBuffersGetInfoMSFT& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSceneMeshBuffersMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SceneMeshBuffersMSFT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMeshBuffersMSFT>
   *
   * @xrentity{xrGetSceneMeshBuffersMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SceneMeshBuffersMSFT getSceneMeshBuffersMSFT(const SceneMeshBuffersGetInfoMSFT& getInfo,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_MSFT_scene_understanding_serialization

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetSerializedSceneFragmentDataMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSerializedSceneFragmentDataMSFT>
   *
   * @xrentity{xrGetSerializedSceneFragmentDataMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSerializedSceneFragmentDataMSFT(const SerializedSceneFragmentDataGetInfoMSFT& getInfo,
                                            uint32_t countInput, uint32_t& readOutput,
                                            uint8_t* buffer,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSerializedSceneFragmentDataMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSerializedSceneFragmentDataMSFT>
   *
   * @xrentity{xrGetSerializedSceneFragmentDataMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSerializedSceneFragmentDataMSFT(const SerializedSceneFragmentDataGetInfoMSFT& getInfo,
                                            uint32_t countInput, uint32_t& readOutput,
                                            uint8_t* buffer,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSerializedSceneFragmentDataMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSerializedSceneFragmentDataMSFT>
   *
   * @xrentity{xrGetSerializedSceneFragmentDataMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getSerializedSceneFragmentDataMSFT(const SerializedSceneFragmentDataGetInfoMSFT& getInfo,
                                          uint32_t countInput, uint32_t& readOutput,
                                          uint8_t* buffer,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_scene_understanding_serialization

#ifdef XR_MSFT_scene_marker

  /*!
   * @brief xrGetSceneMarkerRawDataMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMarkerRawDataMSFT>
   *
   * @xrentity{xrGetSceneMarkerRawDataMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSceneMarkerRawDataMSFT(const UuidMSFT& markerId, uint32_t bufferCapacityInput,
                                   uint32_t& bufferCountOutput, uint8_t* buffer,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSceneMarkerRawDataMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<uint8_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMarkerRawDataMSFT>
   *
   * @xrentity{xrGetSceneMarkerRawDataMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint8_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<uint8_t, Allocator>> getSceneMarkerRawDataToVectorMSFT(
      const UuidMSFT& markerId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSceneMarkerRawDataMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<uint8_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMarkerRawDataMSFT>
   *
   * @xrentity{xrGetSceneMarkerRawDataMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint8_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<uint8_t, Allocator>> getSceneMarkerRawDataToVectorMSFT(
      const UuidMSFT& markerId, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetSceneMarkerRawDataMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<uint8_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMarkerRawDataMSFT>
   *
   * @xrentity{xrGetSceneMarkerRawDataMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint8_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<uint8_t, Allocator> getSceneMarkerRawDataToVectorMSFT(
      const UuidMSFT& markerId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSceneMarkerRawDataMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<uint8_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMarkerRawDataMSFT>
   *
   * @xrentity{xrGetSceneMarkerRawDataMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint8_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<uint8_t, Allocator> getSceneMarkerRawDataToVectorMSFT(
      const UuidMSFT& markerId, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_scene_marker

#ifdef XR_MSFT_scene_marker

  /*!
   * @brief xrGetSceneMarkerDecodedStringMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMarkerDecodedStringMSFT>
   *
   * @xrentity{xrGetSceneMarkerDecodedStringMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSceneMarkerDecodedStringMSFT(const UuidMSFT& markerId, uint32_t bufferCapacityInput,
                                         uint32_t& bufferCountOutput, char* buffer,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetSceneMarkerDecodedStringMSFT enhanced wrapper.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, Result::SceneMarkerDataNotStringMSFT, or an error code
   * if asserts are not active and exceptions are disabled)
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMarkerDecodedStringMSFT>
   *
   * @xrentity{xrGetSceneMarkerDecodedStringMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getSceneMarkerDecodedStringMSFT(
      const UuidMSFT& markerId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSceneMarkerDecodedStringMSFT enhanced wrapper.
   *
   * Asserts that the result is one of the expected success codes.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, Result::SceneMarkerDataNotStringMSFT, or an error code
   * if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSceneMarkerDecodedStringMSFT>
   *
   * @xrentity{xrGetSceneMarkerDecodedStringMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getSceneMarkerDecodedStringMSFT(
      const UuidMSFT& markerId, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_MSFT_scene_marker

  //! @}
private:
  XrSceneMSFT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSceneMSFT) == sizeof(SceneMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSceneMSFT from an SceneMSFT value.
 *
 * @found_by_adl
 * @see SceneMSFT::get()
 * @relates SceneMSFT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSceneMSFT get(SceneMSFT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSceneMSFT handle in a SceneMSFT (by reference).
 *
 * e.g.
 * ```
 * SceneMSFT yourHandle;
 * auto result = d.xrCreateSceneMSFT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SceneMSFT
 */
static OPENXR_HPP_INLINE XrSceneMSFT* put(SceneMSFT& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SceneMSFT values.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SceneMSFT const& lhs,
                                                      SceneMSFT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SceneMSFT values.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SceneMSFT const& lhs,
                                                      SceneMSFT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SceneMSFT values.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SceneMSFT const& lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SceneMSFT values.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SceneMSFT const& lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SceneMSFT values.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SceneMSFT const& lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SceneMSFT values.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SceneMSFT const& lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SceneMSFT and raw XrSceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SceneMSFT const& lhs,
                                                      XrSceneMSFT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSceneMSFT and SceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSceneMSFT lhs,
                                                      SceneMSFT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SceneMSFT and raw XrSceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SceneMSFT const& lhs,
                                                      XrSceneMSFT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSceneMSFT and SceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSceneMSFT lhs,
                                                      SceneMSFT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SceneMSFT and raw XrSceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SceneMSFT const& lhs,
                                                       XrSceneMSFT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSceneMSFT and SceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSceneMSFT lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SceneMSFT and raw XrSceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SceneMSFT const& lhs,
                                                       XrSceneMSFT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSceneMSFT and SceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSceneMSFT lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SceneMSFT and raw XrSceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SceneMSFT const& lhs,
                                                       XrSceneMSFT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSceneMSFT and SceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSceneMSFT lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SceneMSFT and raw XrSceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SceneMSFT const& lhs,
                                                       XrSceneMSFT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSceneMSFT and SceneMSFT.
//! @relates SceneMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSceneMSFT lhs,
                                                       SceneMSFT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SceneMSFT and nullptr: true if the handle is null.
 * @relates SceneMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SceneMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SceneMSFT: true if the handle is null.
 * @relates SceneMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SceneMSFT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SceneMSFT and nullptr: true if the handle is not null.
 * @relates SceneMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SceneMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SceneMSFT: true if the handle is not null.
 * @relates SceneMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SceneMSFT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_MSFT_scene_understanding

#ifdef XR_HTC_facial_tracking

/*!
 * @brief Handle class - wrapping XrFacialTrackerHTC without indicating ownership.
 *
 * Provided by the `XR_HTC_facial_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialTrackerHTC>
 *
 * @xrentity{XrFacialTrackerHTC}
 * @ingroup handles
 */
class FacialTrackerHTC {
public:
  using Type = FacialTrackerHTC;
  using RawHandleType = XrFacialTrackerHTC;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR FacialTrackerHTC() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrFacialTrackerHTC type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT FacialTrackerHTC(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR FacialTrackerHTC(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrFacialTrackerHTC
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrFacialTrackerHTC type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this FacialTrackerHTC value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this FacialTrackerHTC value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrFacialTrackerHTC manipulation
   * @{
   */
  //! Gets the raw XrFacialTrackerHTC value.
  OPENXR_HPP_CONSTEXPR XrFacialTrackerHTC get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * FacialTrackerHTC yourHandle;
   * auto result = d.xrCreateFacialTrackerHTC(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(FacialTrackerHTC&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyFacialTrackerHTC wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFacialTrackerHTC>
   *
   * @xrentity{xrDestroyFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyFacialTrackerHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFacialTrackerHTC>
   *
   * @xrentity{xrDestroyFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyFacialTrackerHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFacialTrackerHTC>
   *
   * @xrentity{xrDestroyFacialTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetFacialExpressionsHTC wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFacialExpressionsHTC>
   *
   * @xrentity{xrGetFacialExpressionsHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getFacialExpressionsHTC(FacialExpressionsHTC& facialExpressions,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetFacialExpressionsHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFacialExpressionsHTC>
   *
   * @xrentity{xrGetFacialExpressionsHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getFacialExpressionsHTC(FacialExpressionsHTC& facialExpressions,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetFacialExpressionsHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFacialExpressionsHTC>
   *
   * @xrentity{xrGetFacialExpressionsHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getFacialExpressionsHTC(FacialExpressionsHTC& facialExpressions,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrFacialTrackerHTC val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrFacialTrackerHTC) == sizeof(FacialTrackerHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrFacialTrackerHTC from an FacialTrackerHTC value.
 *
 * @found_by_adl
 * @see FacialTrackerHTC::get()
 * @relates FacialTrackerHTC
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrFacialTrackerHTC get(FacialTrackerHTC const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrFacialTrackerHTC handle in a FacialTrackerHTC (by reference).
 *
 * e.g.
 * ```
 * FacialTrackerHTC yourHandle;
 * auto result = d.xrCreateFacialTrackerHTC(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates FacialTrackerHTC
 */
static OPENXR_HPP_INLINE XrFacialTrackerHTC* put(FacialTrackerHTC& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between FacialTrackerHTC values.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FacialTrackerHTC const& lhs,
                                                      FacialTrackerHTC const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between FacialTrackerHTC values.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FacialTrackerHTC const& lhs,
                                                      FacialTrackerHTC const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between FacialTrackerHTC values.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FacialTrackerHTC const& lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between FacialTrackerHTC values.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FacialTrackerHTC const& lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between FacialTrackerHTC values.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FacialTrackerHTC const& lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between FacialTrackerHTC values.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FacialTrackerHTC const& lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between FacialTrackerHTC and raw XrFacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FacialTrackerHTC const& lhs,
                                                      XrFacialTrackerHTC rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrFacialTrackerHTC and FacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrFacialTrackerHTC lhs,
                                                      FacialTrackerHTC const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between FacialTrackerHTC and raw XrFacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FacialTrackerHTC const& lhs,
                                                      XrFacialTrackerHTC rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrFacialTrackerHTC and FacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrFacialTrackerHTC lhs,
                                                      FacialTrackerHTC const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between FacialTrackerHTC and raw XrFacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FacialTrackerHTC const& lhs,
                                                       XrFacialTrackerHTC rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrFacialTrackerHTC and FacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrFacialTrackerHTC lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between FacialTrackerHTC and raw XrFacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FacialTrackerHTC const& lhs,
                                                       XrFacialTrackerHTC rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrFacialTrackerHTC and FacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrFacialTrackerHTC lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between FacialTrackerHTC and raw XrFacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FacialTrackerHTC const& lhs,
                                                       XrFacialTrackerHTC rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrFacialTrackerHTC and FacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrFacialTrackerHTC lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between FacialTrackerHTC and raw XrFacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FacialTrackerHTC const& lhs,
                                                       XrFacialTrackerHTC rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrFacialTrackerHTC and FacialTrackerHTC.
//! @relates FacialTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrFacialTrackerHTC lhs,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between FacialTrackerHTC and nullptr: true if the handle is null.
 * @relates FacialTrackerHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FacialTrackerHTC const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and FacialTrackerHTC: true if the handle is null.
 * @relates FacialTrackerHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between FacialTrackerHTC and nullptr: true if the handle is not
 * null.
 * @relates FacialTrackerHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FacialTrackerHTC const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and FacialTrackerHTC: true if the handle is not
 * null.
 * @relates FacialTrackerHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       FacialTrackerHTC const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_HTC_facial_tracking

#ifdef XR_FB_foveation

/*!
 * @brief Handle class - wrapping XrFoveationProfileFB without indicating ownership.
 *
 * Provided by the `XR_FB_foveation` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFoveationProfileFB>
 *
 * @xrentity{XrFoveationProfileFB}
 * @ingroup handles
 */
class FoveationProfileFB {
public:
  using Type = FoveationProfileFB;
  using RawHandleType = XrFoveationProfileFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR FoveationProfileFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrFoveationProfileFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT FoveationProfileFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR FoveationProfileFB(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrFoveationProfileFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrFoveationProfileFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this FoveationProfileFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this FoveationProfileFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrFoveationProfileFB manipulation
   * @{
   */
  //! Gets the raw XrFoveationProfileFB value.
  OPENXR_HPP_CONSTEXPR XrFoveationProfileFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * FoveationProfileFB yourHandle;
   * auto result = d.xrCreateFoveationProfileFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(FoveationProfileFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyFoveationProfileFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFoveationProfileFB>
   *
   * @xrentity{xrDestroyFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyFoveationProfileFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFoveationProfileFB>
   *
   * @xrentity{xrDestroyFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyFoveationProfileFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFoveationProfileFB>
   *
   * @xrentity{xrDestroyFoveationProfileFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrFoveationProfileFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrFoveationProfileFB) == sizeof(FoveationProfileFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrFoveationProfileFB from an FoveationProfileFB value.
 *
 * @found_by_adl
 * @see FoveationProfileFB::get()
 * @relates FoveationProfileFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrFoveationProfileFB
get(FoveationProfileFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrFoveationProfileFB handle in a FoveationProfileFB (by reference).
 *
 * e.g.
 * ```
 * FoveationProfileFB yourHandle;
 * auto result = d.xrCreateFoveationProfileFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates FoveationProfileFB
 */
static OPENXR_HPP_INLINE XrFoveationProfileFB* put(FoveationProfileFB& h,
                                                   bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between FoveationProfileFB values.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FoveationProfileFB const& lhs,
                                                      FoveationProfileFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between FoveationProfileFB values.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FoveationProfileFB const& lhs,
                                                      FoveationProfileFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between FoveationProfileFB values.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FoveationProfileFB const& lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between FoveationProfileFB values.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FoveationProfileFB const& lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between FoveationProfileFB values.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FoveationProfileFB const& lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between FoveationProfileFB values.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FoveationProfileFB const& lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between FoveationProfileFB and raw XrFoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FoveationProfileFB const& lhs,
                                                      XrFoveationProfileFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrFoveationProfileFB and FoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrFoveationProfileFB lhs,
                                                      FoveationProfileFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between FoveationProfileFB and raw XrFoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FoveationProfileFB const& lhs,
                                                      XrFoveationProfileFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrFoveationProfileFB and FoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrFoveationProfileFB lhs,
                                                      FoveationProfileFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between FoveationProfileFB and raw XrFoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FoveationProfileFB const& lhs,
                                                       XrFoveationProfileFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrFoveationProfileFB and FoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrFoveationProfileFB lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between FoveationProfileFB and raw XrFoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FoveationProfileFB const& lhs,
                                                       XrFoveationProfileFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrFoveationProfileFB and FoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrFoveationProfileFB lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between FoveationProfileFB and raw XrFoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FoveationProfileFB const& lhs,
                                                       XrFoveationProfileFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrFoveationProfileFB and FoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrFoveationProfileFB lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between FoveationProfileFB and raw XrFoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FoveationProfileFB const& lhs,
                                                       XrFoveationProfileFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrFoveationProfileFB and FoveationProfileFB.
//! @relates FoveationProfileFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrFoveationProfileFB lhs,
                                                       FoveationProfileFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between FoveationProfileFB and nullptr: true if the handle is null.
 * @relates FoveationProfileFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FoveationProfileFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and FoveationProfileFB: true if the handle is null.
 * @relates FoveationProfileFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       FoveationProfileFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between FoveationProfileFB and nullptr: true if the handle is not
 * null.
 * @relates FoveationProfileFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FoveationProfileFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and FoveationProfileFB: true if the handle is not
 * null.
 * @relates FoveationProfileFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       FoveationProfileFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_foveation

#ifdef XR_FB_triangle_mesh

/*!
 * @brief Handle class - wrapping XrTriangleMeshFB without indicating ownership.
 *
 * Provided by the `XR_FB_triangle_mesh` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrTriangleMeshFB>
 *
 * @xrentity{XrTriangleMeshFB}
 * @ingroup handles
 */
class TriangleMeshFB {
public:
  using Type = TriangleMeshFB;
  using RawHandleType = XrTriangleMeshFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR TriangleMeshFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrTriangleMeshFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT TriangleMeshFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR TriangleMeshFB(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrTriangleMeshFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrTriangleMeshFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this TriangleMeshFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this TriangleMeshFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrTriangleMeshFB manipulation
   * @{
   */
  //! Gets the raw XrTriangleMeshFB value.
  OPENXR_HPP_CONSTEXPR XrTriangleMeshFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * TriangleMeshFB yourHandle;
   * auto result = d.xrCreateTriangleMeshFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(TriangleMeshFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyTriangleMeshFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyTriangleMeshFB>
   *
   * @xrentity{xrDestroyTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyTriangleMeshFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyTriangleMeshFB>
   *
   * @xrentity{xrDestroyTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyTriangleMeshFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyTriangleMeshFB>
   *
   * @xrentity{xrDestroyTriangleMeshFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTriangleMeshGetVertexBufferFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshGetVertexBufferFB>
   *
   * @xrentity{xrTriangleMeshGetVertexBufferFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshGetVertexBufferFB(Vector3f*& outVertexBuffer,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTriangleMeshGetVertexBufferFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshGetVertexBufferFB>
   *
   * @xrentity{xrTriangleMeshGetVertexBufferFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshGetVertexBufferFB(Vector3f*& outVertexBuffer,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTriangleMeshGetVertexBufferFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshGetVertexBufferFB>
   *
   * @xrentity{xrTriangleMeshGetVertexBufferFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void triangleMeshGetVertexBufferFB(Vector3f*& outVertexBuffer,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTriangleMeshGetIndexBufferFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshGetIndexBufferFB>
   *
   * @xrentity{xrTriangleMeshGetIndexBufferFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshGetIndexBufferFB(uint32_t*& outIndexBuffer,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTriangleMeshGetIndexBufferFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshGetIndexBufferFB>
   *
   * @xrentity{xrTriangleMeshGetIndexBufferFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshGetIndexBufferFB(uint32_t*& outIndexBuffer,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTriangleMeshGetIndexBufferFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshGetIndexBufferFB>
   *
   * @xrentity{xrTriangleMeshGetIndexBufferFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void triangleMeshGetIndexBufferFB(uint32_t*& outIndexBuffer,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTriangleMeshBeginUpdateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshBeginUpdateFB>
   *
   * @xrentity{xrTriangleMeshBeginUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshBeginUpdateFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTriangleMeshBeginUpdateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshBeginUpdateFB>
   *
   * @xrentity{xrTriangleMeshBeginUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshBeginUpdateFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTriangleMeshBeginUpdateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshBeginUpdateFB>
   *
   * @xrentity{xrTriangleMeshBeginUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void triangleMeshBeginUpdateFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTriangleMeshEndUpdateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshEndUpdateFB>
   *
   * @xrentity{xrTriangleMeshEndUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshEndUpdateFB(uint32_t vertexCount, uint32_t triangleCount,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTriangleMeshEndUpdateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshEndUpdateFB>
   *
   * @xrentity{xrTriangleMeshEndUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshEndUpdateFB(uint32_t vertexCount, uint32_t triangleCount,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTriangleMeshEndUpdateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshEndUpdateFB>
   *
   * @xrentity{xrTriangleMeshEndUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void triangleMeshEndUpdateFB(uint32_t vertexCount, uint32_t triangleCount,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrTriangleMeshBeginVertexBufferUpdateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshBeginVertexBufferUpdateFB>
   *
   * @xrentity{xrTriangleMeshBeginVertexBufferUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshBeginVertexBufferUpdateFB(
      uint32_t& outVertexCount, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTriangleMeshBeginVertexBufferUpdateFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type uint32_t
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshBeginVertexBufferUpdateFB>
   *
   * @xrentity{xrTriangleMeshBeginVertexBufferUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<uint32_t> triangleMeshBeginVertexBufferUpdateFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTriangleMeshBeginVertexBufferUpdateFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type uint32_t
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshBeginVertexBufferUpdateFB>
   *
   * @xrentity{xrTriangleMeshBeginVertexBufferUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  uint32_t triangleMeshBeginVertexBufferUpdateFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrTriangleMeshEndVertexBufferUpdateFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshEndVertexBufferUpdateFB>
   *
   * @xrentity{xrTriangleMeshEndVertexBufferUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshEndVertexBufferUpdateFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrTriangleMeshEndVertexBufferUpdateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshEndVertexBufferUpdateFB>
   *
   * @xrentity{xrTriangleMeshEndVertexBufferUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result triangleMeshEndVertexBufferUpdateFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrTriangleMeshEndVertexBufferUpdateFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrTriangleMeshEndVertexBufferUpdateFB>
   *
   * @xrentity{xrTriangleMeshEndVertexBufferUpdateFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void triangleMeshEndVertexBufferUpdateFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrTriangleMeshFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrTriangleMeshFB) == sizeof(TriangleMeshFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrTriangleMeshFB from an TriangleMeshFB value.
 *
 * @found_by_adl
 * @see TriangleMeshFB::get()
 * @relates TriangleMeshFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrTriangleMeshFB get(TriangleMeshFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrTriangleMeshFB handle in a TriangleMeshFB (by reference).
 *
 * e.g.
 * ```
 * TriangleMeshFB yourHandle;
 * auto result = d.xrCreateTriangleMeshFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates TriangleMeshFB
 */
static OPENXR_HPP_INLINE XrTriangleMeshFB* put(TriangleMeshFB& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between TriangleMeshFB values.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(TriangleMeshFB const& lhs,
                                                      TriangleMeshFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between TriangleMeshFB values.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(TriangleMeshFB const& lhs,
                                                      TriangleMeshFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between TriangleMeshFB values.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(TriangleMeshFB const& lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between TriangleMeshFB values.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(TriangleMeshFB const& lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between TriangleMeshFB values.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(TriangleMeshFB const& lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between TriangleMeshFB values.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(TriangleMeshFB const& lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between TriangleMeshFB and raw XrTriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(TriangleMeshFB const& lhs,
                                                      XrTriangleMeshFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrTriangleMeshFB and TriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrTriangleMeshFB lhs,
                                                      TriangleMeshFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between TriangleMeshFB and raw XrTriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(TriangleMeshFB const& lhs,
                                                      XrTriangleMeshFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrTriangleMeshFB and TriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrTriangleMeshFB lhs,
                                                      TriangleMeshFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between TriangleMeshFB and raw XrTriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(TriangleMeshFB const& lhs,
                                                       XrTriangleMeshFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrTriangleMeshFB and TriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrTriangleMeshFB lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between TriangleMeshFB and raw XrTriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(TriangleMeshFB const& lhs,
                                                       XrTriangleMeshFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrTriangleMeshFB and TriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrTriangleMeshFB lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between TriangleMeshFB and raw XrTriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(TriangleMeshFB const& lhs,
                                                       XrTriangleMeshFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrTriangleMeshFB and TriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrTriangleMeshFB lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between TriangleMeshFB and raw XrTriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(TriangleMeshFB const& lhs,
                                                       XrTriangleMeshFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrTriangleMeshFB and TriangleMeshFB.
//! @relates TriangleMeshFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrTriangleMeshFB lhs,
                                                       TriangleMeshFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between TriangleMeshFB and nullptr: true if the handle is null.
 * @relates TriangleMeshFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(TriangleMeshFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and TriangleMeshFB: true if the handle is null.
 * @relates TriangleMeshFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       TriangleMeshFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between TriangleMeshFB and nullptr: true if the handle is not null.
 * @relates TriangleMeshFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(TriangleMeshFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and TriangleMeshFB: true if the handle is not null.
 * @relates TriangleMeshFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       TriangleMeshFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_triangle_mesh

#ifdef XR_FB_passthrough

/*!
 * @brief Handle class - wrapping XrPassthroughFB without indicating ownership.
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughFB>
 *
 * @xrentity{XrPassthroughFB}
 * @ingroup handles
 */
class PassthroughFB {
public:
  using Type = PassthroughFB;
  using RawHandleType = XrPassthroughFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR PassthroughFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrPassthroughFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT PassthroughFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR PassthroughFB(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrPassthroughFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrPassthroughFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this PassthroughFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this PassthroughFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrPassthroughFB manipulation
   * @{
   */
  //! Gets the raw XrPassthroughFB value.
  OPENXR_HPP_CONSTEXPR XrPassthroughFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * PassthroughFB yourHandle;
   * auto result = d.xrCreatePassthroughFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(PassthroughFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyPassthroughFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughFB>
   *
   * @xrentity{xrDestroyPassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyPassthroughFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughFB>
   *
   * @xrentity{xrDestroyPassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyPassthroughFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughFB>
   *
   * @xrentity{xrDestroyPassthroughFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPassthroughStartFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughStartFB>
   *
   * @xrentity{xrPassthroughStartFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughStartFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPassthroughStartFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughStartFB>
   *
   * @xrentity{xrPassthroughStartFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughStartFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPassthroughStartFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughStartFB>
   *
   * @xrentity{xrPassthroughStartFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void passthroughStartFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPassthroughPauseFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughPauseFB>
   *
   * @xrentity{xrPassthroughPauseFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughPauseFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPassthroughPauseFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughPauseFB>
   *
   * @xrentity{xrPassthroughPauseFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughPauseFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPassthroughPauseFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughPauseFB>
   *
   * @xrentity{xrPassthroughPauseFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void passthroughPauseFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_META_passthrough_color_lut

  /*!
   * @brief xrCreatePassthroughColorLutMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughColorLutMETA>
   *
   * @xrentity{xrCreatePassthroughColorLutMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createPassthroughColorLutMETA(const PassthroughColorLutCreateInfoMETA& createInfo,
                                       PassthroughColorLutMETA& colorLut,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePassthroughColorLutMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type PassthroughColorLutMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughColorLutMETA>
   *
   * @xrentity{xrCreatePassthroughColorLutMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<PassthroughColorLutMETA> createPassthroughColorLutMETA(
      const PassthroughColorLutCreateInfoMETA& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePassthroughColorLutMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type PassthroughColorLutMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughColorLutMETA>
   *
   * @xrentity{xrCreatePassthroughColorLutMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  PassthroughColorLutMETA createPassthroughColorLutMETA(
      const PassthroughColorLutCreateInfoMETA& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreatePassthroughColorLutMETA wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a PassthroughColorLutMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughColorLutMETA>
   *
   * @xrentity{xrCreatePassthroughColorLutMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<PassthroughColorLutMETA, impl::RemoveRefConst<Dispatch>>>
  createPassthroughColorLutUniqueMETA(const PassthroughColorLutCreateInfoMETA& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreatePassthroughColorLutMETA wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a PassthroughColorLutMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreatePassthroughColorLutMETA>
   *
   * @xrentity{xrCreatePassthroughColorLutMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<PassthroughColorLutMETA, impl::RemoveRefConst<Dispatch>>
  createPassthroughColorLutUniqueMETA(const PassthroughColorLutCreateInfoMETA& createInfo,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_META_passthrough_color_lut

  //! @}
private:
  XrPassthroughFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrPassthroughFB) == sizeof(PassthroughFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrPassthroughFB from an PassthroughFB value.
 *
 * @found_by_adl
 * @see PassthroughFB::get()
 * @relates PassthroughFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrPassthroughFB get(PassthroughFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrPassthroughFB handle in a PassthroughFB (by reference).
 *
 * e.g.
 * ```
 * PassthroughFB yourHandle;
 * auto result = d.xrCreatePassthroughFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates PassthroughFB
 */
static OPENXR_HPP_INLINE XrPassthroughFB* put(PassthroughFB& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between PassthroughFB values.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PassthroughFB const& lhs,
                                                      PassthroughFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between PassthroughFB values.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PassthroughFB const& lhs,
                                                      PassthroughFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between PassthroughFB values.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PassthroughFB const& lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between PassthroughFB values.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PassthroughFB const& lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between PassthroughFB values.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughFB const& lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between PassthroughFB values.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughFB const& lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between PassthroughFB and raw XrPassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PassthroughFB const& lhs,
                                                      XrPassthroughFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrPassthroughFB and PassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrPassthroughFB lhs,
                                                      PassthroughFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between PassthroughFB and raw XrPassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PassthroughFB const& lhs,
                                                      XrPassthroughFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrPassthroughFB and PassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrPassthroughFB lhs,
                                                      PassthroughFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between PassthroughFB and raw XrPassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PassthroughFB const& lhs,
                                                       XrPassthroughFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrPassthroughFB and PassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrPassthroughFB lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between PassthroughFB and raw XrPassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PassthroughFB const& lhs,
                                                       XrPassthroughFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrPassthroughFB and PassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrPassthroughFB lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between PassthroughFB and raw XrPassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughFB const& lhs,
                                                       XrPassthroughFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrPassthroughFB and PassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrPassthroughFB lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between PassthroughFB and raw XrPassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughFB const& lhs,
                                                       XrPassthroughFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrPassthroughFB and PassthroughFB.
//! @relates PassthroughFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrPassthroughFB lhs,
                                                       PassthroughFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between PassthroughFB and nullptr: true if the handle is null.
 * @relates PassthroughFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and PassthroughFB: true if the handle is null.
 * @relates PassthroughFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       PassthroughFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between PassthroughFB and nullptr: true if the handle is not null.
 * @relates PassthroughFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and PassthroughFB: true if the handle is not null.
 * @relates PassthroughFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       PassthroughFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

/*!
 * @brief Handle class - wrapping XrPassthroughLayerFB without indicating ownership.
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughLayerFB>
 *
 * @xrentity{XrPassthroughLayerFB}
 * @ingroup handles
 */
class PassthroughLayerFB {
public:
  using Type = PassthroughLayerFB;
  using RawHandleType = XrPassthroughLayerFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR PassthroughLayerFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrPassthroughLayerFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT PassthroughLayerFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR PassthroughLayerFB(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrPassthroughLayerFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrPassthroughLayerFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this PassthroughLayerFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this PassthroughLayerFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrPassthroughLayerFB manipulation
   * @{
   */
  //! Gets the raw XrPassthroughLayerFB value.
  OPENXR_HPP_CONSTEXPR XrPassthroughLayerFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * PassthroughLayerFB yourHandle;
   * auto result = d.xrCreatePassthroughLayerFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(PassthroughLayerFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyPassthroughLayerFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughLayerFB>
   *
   * @xrentity{xrDestroyPassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyPassthroughLayerFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughLayerFB>
   *
   * @xrentity{xrDestroyPassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyPassthroughLayerFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughLayerFB>
   *
   * @xrentity{xrDestroyPassthroughLayerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPassthroughLayerPauseFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerPauseFB>
   *
   * @xrentity{xrPassthroughLayerPauseFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerPauseFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPassthroughLayerPauseFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerPauseFB>
   *
   * @xrentity{xrPassthroughLayerPauseFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerPauseFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPassthroughLayerPauseFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerPauseFB>
   *
   * @xrentity{xrPassthroughLayerPauseFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void passthroughLayerPauseFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPassthroughLayerResumeFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerResumeFB>
   *
   * @xrentity{xrPassthroughLayerResumeFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerResumeFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPassthroughLayerResumeFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerResumeFB>
   *
   * @xrentity{xrPassthroughLayerResumeFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerResumeFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPassthroughLayerResumeFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerResumeFB>
   *
   * @xrentity{xrPassthroughLayerResumeFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void passthroughLayerResumeFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPassthroughLayerSetStyleFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerSetStyleFB>
   *
   * @xrentity{xrPassthroughLayerSetStyleFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerSetStyleFB(const PassthroughStyleFB& style,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPassthroughLayerSetStyleFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerSetStyleFB>
   *
   * @xrentity{xrPassthroughLayerSetStyleFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerSetStyleFB(const PassthroughStyleFB& style,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPassthroughLayerSetStyleFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerSetStyleFB>
   *
   * @xrentity{xrPassthroughLayerSetStyleFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void passthroughLayerSetStyleFB(const PassthroughStyleFB& style,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_FB_passthrough_keyboard_hands

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPassthroughLayerSetKeyboardHandsIntensityFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerSetKeyboardHandsIntensityFB>
   *
   * @xrentity{xrPassthroughLayerSetKeyboardHandsIntensityFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerSetKeyboardHandsIntensityFB(
      const PassthroughKeyboardHandsIntensityFB& intensity,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPassthroughLayerSetKeyboardHandsIntensityFB enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerSetKeyboardHandsIntensityFB>
   *
   * @xrentity{xrPassthroughLayerSetKeyboardHandsIntensityFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result passthroughLayerSetKeyboardHandsIntensityFB(
      const PassthroughKeyboardHandsIntensityFB& intensity,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPassthroughLayerSetKeyboardHandsIntensityFB enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPassthroughLayerSetKeyboardHandsIntensityFB>
   *
   * @xrentity{xrPassthroughLayerSetKeyboardHandsIntensityFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void passthroughLayerSetKeyboardHandsIntensityFB(
      const PassthroughKeyboardHandsIntensityFB& intensity,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_passthrough_keyboard_hands

  //! @}
private:
  XrPassthroughLayerFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrPassthroughLayerFB) == sizeof(PassthroughLayerFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrPassthroughLayerFB from an PassthroughLayerFB value.
 *
 * @found_by_adl
 * @see PassthroughLayerFB::get()
 * @relates PassthroughLayerFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrPassthroughLayerFB
get(PassthroughLayerFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrPassthroughLayerFB handle in a PassthroughLayerFB (by reference).
 *
 * e.g.
 * ```
 * PassthroughLayerFB yourHandle;
 * auto result = d.xrCreatePassthroughLayerFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates PassthroughLayerFB
 */
static OPENXR_HPP_INLINE XrPassthroughLayerFB* put(PassthroughLayerFB& h,
                                                   bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between PassthroughLayerFB values.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PassthroughLayerFB const& lhs,
                                                      PassthroughLayerFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between PassthroughLayerFB values.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PassthroughLayerFB const& lhs,
                                                      PassthroughLayerFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between PassthroughLayerFB values.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PassthroughLayerFB const& lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between PassthroughLayerFB values.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PassthroughLayerFB const& lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between PassthroughLayerFB values.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughLayerFB const& lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between PassthroughLayerFB values.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughLayerFB const& lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between PassthroughLayerFB and raw XrPassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PassthroughLayerFB const& lhs,
                                                      XrPassthroughLayerFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrPassthroughLayerFB and PassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrPassthroughLayerFB lhs,
                                                      PassthroughLayerFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between PassthroughLayerFB and raw XrPassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PassthroughLayerFB const& lhs,
                                                      XrPassthroughLayerFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrPassthroughLayerFB and PassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrPassthroughLayerFB lhs,
                                                      PassthroughLayerFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between PassthroughLayerFB and raw XrPassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PassthroughLayerFB const& lhs,
                                                       XrPassthroughLayerFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrPassthroughLayerFB and PassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrPassthroughLayerFB lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between PassthroughLayerFB and raw XrPassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PassthroughLayerFB const& lhs,
                                                       XrPassthroughLayerFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrPassthroughLayerFB and PassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrPassthroughLayerFB lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between PassthroughLayerFB and raw XrPassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughLayerFB const& lhs,
                                                       XrPassthroughLayerFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrPassthroughLayerFB and PassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrPassthroughLayerFB lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between PassthroughLayerFB and raw XrPassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughLayerFB const& lhs,
                                                       XrPassthroughLayerFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrPassthroughLayerFB and PassthroughLayerFB.
//! @relates PassthroughLayerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrPassthroughLayerFB lhs,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between PassthroughLayerFB and nullptr: true if the handle is null.
 * @relates PassthroughLayerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughLayerFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and PassthroughLayerFB: true if the handle is null.
 * @relates PassthroughLayerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between PassthroughLayerFB and nullptr: true if the handle is not
 * null.
 * @relates PassthroughLayerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughLayerFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and PassthroughLayerFB: true if the handle is not
 * null.
 * @relates PassthroughLayerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       PassthroughLayerFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_passthrough

#ifdef XR_FB_passthrough

/*!
 * @brief Handle class - wrapping XrGeometryInstanceFB without indicating ownership.
 *
 * Provided by the `XR_FB_passthrough` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrGeometryInstanceFB>
 *
 * @xrentity{XrGeometryInstanceFB}
 * @ingroup handles
 */
class GeometryInstanceFB {
public:
  using Type = GeometryInstanceFB;
  using RawHandleType = XrGeometryInstanceFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR GeometryInstanceFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrGeometryInstanceFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT GeometryInstanceFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR GeometryInstanceFB(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrGeometryInstanceFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrGeometryInstanceFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this GeometryInstanceFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this GeometryInstanceFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrGeometryInstanceFB manipulation
   * @{
   */
  //! Gets the raw XrGeometryInstanceFB value.
  OPENXR_HPP_CONSTEXPR XrGeometryInstanceFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * GeometryInstanceFB yourHandle;
   * auto result = d.xrCreateGeometryInstanceFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(GeometryInstanceFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyGeometryInstanceFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyGeometryInstanceFB>
   *
   * @xrentity{xrDestroyGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyGeometryInstanceFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyGeometryInstanceFB>
   *
   * @xrentity{xrDestroyGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyGeometryInstanceFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyGeometryInstanceFB>
   *
   * @xrentity{xrDestroyGeometryInstanceFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGeometryInstanceSetTransformFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGeometryInstanceSetTransformFB>
   *
   * @xrentity{xrGeometryInstanceSetTransformFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result geometryInstanceSetTransformFB(const GeometryInstanceTransformFB& transformation,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGeometryInstanceSetTransformFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGeometryInstanceSetTransformFB>
   *
   * @xrentity{xrGeometryInstanceSetTransformFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result geometryInstanceSetTransformFB(const GeometryInstanceTransformFB& transformation,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGeometryInstanceSetTransformFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGeometryInstanceSetTransformFB>
   *
   * @xrentity{xrGeometryInstanceSetTransformFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void geometryInstanceSetTransformFB(const GeometryInstanceTransformFB& transformation,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrGeometryInstanceFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrGeometryInstanceFB) == sizeof(GeometryInstanceFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrGeometryInstanceFB from an GeometryInstanceFB value.
 *
 * @found_by_adl
 * @see GeometryInstanceFB::get()
 * @relates GeometryInstanceFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrGeometryInstanceFB
get(GeometryInstanceFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrGeometryInstanceFB handle in a GeometryInstanceFB (by reference).
 *
 * e.g.
 * ```
 * GeometryInstanceFB yourHandle;
 * auto result = d.xrCreateGeometryInstanceFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates GeometryInstanceFB
 */
static OPENXR_HPP_INLINE XrGeometryInstanceFB* put(GeometryInstanceFB& h,
                                                   bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between GeometryInstanceFB values.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(GeometryInstanceFB const& lhs,
                                                      GeometryInstanceFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between GeometryInstanceFB values.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(GeometryInstanceFB const& lhs,
                                                      GeometryInstanceFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between GeometryInstanceFB values.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(GeometryInstanceFB const& lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between GeometryInstanceFB values.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(GeometryInstanceFB const& lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between GeometryInstanceFB values.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(GeometryInstanceFB const& lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between GeometryInstanceFB values.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(GeometryInstanceFB const& lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between GeometryInstanceFB and raw XrGeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(GeometryInstanceFB const& lhs,
                                                      XrGeometryInstanceFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrGeometryInstanceFB and GeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrGeometryInstanceFB lhs,
                                                      GeometryInstanceFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between GeometryInstanceFB and raw XrGeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(GeometryInstanceFB const& lhs,
                                                      XrGeometryInstanceFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrGeometryInstanceFB and GeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrGeometryInstanceFB lhs,
                                                      GeometryInstanceFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between GeometryInstanceFB and raw XrGeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(GeometryInstanceFB const& lhs,
                                                       XrGeometryInstanceFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrGeometryInstanceFB and GeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrGeometryInstanceFB lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between GeometryInstanceFB and raw XrGeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(GeometryInstanceFB const& lhs,
                                                       XrGeometryInstanceFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrGeometryInstanceFB and GeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrGeometryInstanceFB lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between GeometryInstanceFB and raw XrGeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(GeometryInstanceFB const& lhs,
                                                       XrGeometryInstanceFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrGeometryInstanceFB and GeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrGeometryInstanceFB lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between GeometryInstanceFB and raw XrGeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(GeometryInstanceFB const& lhs,
                                                       XrGeometryInstanceFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrGeometryInstanceFB and GeometryInstanceFB.
//! @relates GeometryInstanceFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrGeometryInstanceFB lhs,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between GeometryInstanceFB and nullptr: true if the handle is null.
 * @relates GeometryInstanceFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(GeometryInstanceFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and GeometryInstanceFB: true if the handle is null.
 * @relates GeometryInstanceFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between GeometryInstanceFB and nullptr: true if the handle is not
 * null.
 * @relates GeometryInstanceFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(GeometryInstanceFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and GeometryInstanceFB: true if the handle is not
 * null.
 * @relates GeometryInstanceFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       GeometryInstanceFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_passthrough

#ifdef XR_ML_marker_understanding

/*!
 * @brief Handle class - wrapping XrMarkerDetectorML without indicating ownership.
 *
 * Provided by the `XR_ML_marker_understanding` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrMarkerDetectorML>
 *
 * @xrentity{XrMarkerDetectorML}
 * @ingroup handles
 */
class MarkerDetectorML {
public:
  using Type = MarkerDetectorML;
  using RawHandleType = XrMarkerDetectorML;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR MarkerDetectorML() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrMarkerDetectorML type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT MarkerDetectorML(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR MarkerDetectorML(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrMarkerDetectorML
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrMarkerDetectorML type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this MarkerDetectorML value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this MarkerDetectorML value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrMarkerDetectorML manipulation
   * @{
   */
  //! Gets the raw XrMarkerDetectorML value.
  OPENXR_HPP_CONSTEXPR XrMarkerDetectorML get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * MarkerDetectorML yourHandle;
   * auto result = d.xrCreateMarkerDetectorML(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(MarkerDetectorML&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyMarkerDetectorML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyMarkerDetectorML>
   *
   * @xrentity{xrDestroyMarkerDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyMarkerDetectorML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyMarkerDetectorML>
   *
   * @xrentity{xrDestroyMarkerDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyMarkerDetectorML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyMarkerDetectorML>
   *
   * @xrentity{xrDestroyMarkerDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrSnapshotMarkerDetectorML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSnapshotMarkerDetectorML>
   *
   * @xrentity{xrSnapshotMarkerDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result snapshotMarkerDetectorML(MarkerDetectorSnapshotInfoML& snapshotInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSnapshotMarkerDetectorML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type MarkerDetectorSnapshotInfoML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSnapshotMarkerDetectorML>
   *
   * @xrentity{xrSnapshotMarkerDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<MarkerDetectorSnapshotInfoML> snapshotMarkerDetectorML(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSnapshotMarkerDetectorML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type MarkerDetectorSnapshotInfoML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSnapshotMarkerDetectorML>
   *
   * @xrentity{xrSnapshotMarkerDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  MarkerDetectorSnapshotInfoML snapshotMarkerDetectorML(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetMarkerDetectorStateML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerDetectorStateML>
   *
   * @xrentity{xrGetMarkerDetectorStateML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getMarkerDetectorStateML(MarkerDetectorStateML& state,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetMarkerDetectorStateML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type MarkerDetectorStateML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerDetectorStateML>
   *
   * @xrentity{xrGetMarkerDetectorStateML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<MarkerDetectorStateML> getMarkerDetectorStateML(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetMarkerDetectorStateML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type MarkerDetectorStateML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerDetectorStateML>
   *
   * @xrentity{xrGetMarkerDetectorStateML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  MarkerDetectorStateML getMarkerDetectorStateML(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetMarkersML wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkersML>
   *
   * @xrentity{xrGetMarkersML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getMarkersML(uint32_t markerCapacityInput, uint32_t& markerCountOutput, MarkerML* markers,
                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetMarkersML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<MarkerML, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkersML>
   *
   * @xrentity{xrGetMarkersML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<MarkerML>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<MarkerML, Allocator>> getMarkersToVectorML(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetMarkersML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<MarkerML, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkersML>
   *
   * @xrentity{xrGetMarkersML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<MarkerML>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<MarkerML, Allocator>> getMarkersToVectorML(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetMarkersML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<MarkerML, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkersML>
   *
   * @xrentity{xrGetMarkersML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<MarkerML>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<MarkerML, Allocator> getMarkersToVectorML(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetMarkersML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<MarkerML, Allocator>
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkersML>
   *
   * @xrentity{xrGetMarkersML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<MarkerML>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<MarkerML, Allocator> getMarkersToVectorML(Allocator const& vectorAllocator,
                                                        Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetMarkerReprojectionErrorML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerReprojectionErrorML>
   *
   * @xrentity{xrGetMarkerReprojectionErrorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getMarkerReprojectionErrorML(MarkerML marker, float& reprojectionErrorMeters,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetMarkerReprojectionErrorML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type float
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerReprojectionErrorML>
   *
   * @xrentity{xrGetMarkerReprojectionErrorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<float> getMarkerReprojectionErrorML(
      MarkerML marker, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetMarkerReprojectionErrorML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type float
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerReprojectionErrorML>
   *
   * @xrentity{xrGetMarkerReprojectionErrorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  float getMarkerReprojectionErrorML(MarkerML marker,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetMarkerLengthML wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerLengthML>
   *
   * @xrentity{xrGetMarkerLengthML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getMarkerLengthML(MarkerML marker, float& meters,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetMarkerLengthML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type float
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerLengthML>
   *
   * @xrentity{xrGetMarkerLengthML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<float> getMarkerLengthML(MarkerML marker,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetMarkerLengthML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type float
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerLengthML>
   *
   * @xrentity{xrGetMarkerLengthML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  float getMarkerLengthML(MarkerML marker, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetMarkerNumberML wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerNumberML>
   *
   * @xrentity{xrGetMarkerNumberML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getMarkerNumberML(MarkerML marker, uint64_t& number,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetMarkerNumberML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type uint64_t
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerNumberML>
   *
   * @xrentity{xrGetMarkerNumberML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<uint64_t> getMarkerNumberML(MarkerML marker,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetMarkerNumberML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type uint64_t
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerNumberML>
   *
   * @xrentity{xrGetMarkerNumberML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  uint64_t getMarkerNumberML(MarkerML marker,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetMarkerStringML wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerStringML>
   *
   * @xrentity{xrGetMarkerStringML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getMarkerStringML(MarkerML marker, uint32_t bufferCapacityInput,
                           uint32_t& bufferCountOutput, char* buffer,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetMarkerStringML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerStringML>
   *
   * @xrentity{xrGetMarkerStringML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getMarkerStringML(
      MarkerML marker, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetMarkerStringML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerStringML>
   *
   * @xrentity{xrGetMarkerStringML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getMarkerStringML(MarkerML marker,
                                                                  Allocator const& vectorAllocator,
                                                                  Dispatch&& d) const;

#else
  /*!
   * @brief xrGetMarkerStringML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerStringML>
   *
   * @xrentity{xrGetMarkerStringML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getMarkerStringML(
      MarkerML marker, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetMarkerStringML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetMarkerStringML>
   *
   * @xrentity{xrGetMarkerStringML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getMarkerStringML(MarkerML marker,
                                                     Allocator const& vectorAllocator,
                                                     Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrMarkerDetectorML val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrMarkerDetectorML) == sizeof(MarkerDetectorML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrMarkerDetectorML from an MarkerDetectorML value.
 *
 * @found_by_adl
 * @see MarkerDetectorML::get()
 * @relates MarkerDetectorML
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrMarkerDetectorML get(MarkerDetectorML const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrMarkerDetectorML handle in a MarkerDetectorML (by reference).
 *
 * e.g.
 * ```
 * MarkerDetectorML yourHandle;
 * auto result = d.xrCreateMarkerDetectorML(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates MarkerDetectorML
 */
static OPENXR_HPP_INLINE XrMarkerDetectorML* put(MarkerDetectorML& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between MarkerDetectorML values.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(MarkerDetectorML const& lhs,
                                                      MarkerDetectorML const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between MarkerDetectorML values.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(MarkerDetectorML const& lhs,
                                                      MarkerDetectorML const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between MarkerDetectorML values.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(MarkerDetectorML const& lhs,
                                                       MarkerDetectorML const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between MarkerDetectorML values.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(MarkerDetectorML const& lhs,
                                                       MarkerDetectorML const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between MarkerDetectorML values.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(MarkerDetectorML const& lhs,
                                                       MarkerDetectorML const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between MarkerDetectorML values.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(MarkerDetectorML const& lhs,
                                                       MarkerDetectorML const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between MarkerDetectorML and raw XrMarkerDetectorML.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(MarkerDetectorML const& lhs,
                                                      XrMarkerDetectorML rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrMarkerDetectorML and MarkerDetectorML.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrMarkerDetectorML lhs,
                                                      MarkerDetectorML const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between MarkerDetectorML and raw XrMarkerDetectorML.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(MarkerDetectorML const& lhs,
                                                      XrMarkerDetectorML rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrMarkerDetectorML and MarkerDetectorML.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrMarkerDetectorML lhs,
                                                      MarkerDetectorML const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between MarkerDetectorML and raw XrMarkerDetectorML.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(MarkerDetectorML const& lhs,
                                                       XrMarkerDetectorML rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrMarkerDetectorML and MarkerDetectorML.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrMarkerDetectorML lhs,
                                                       MarkerDetectorML const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between MarkerDetectorML and raw XrMarkerDetectorML.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(MarkerDetectorML const& lhs,
                                                       XrMarkerDetectorML rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrMarkerDetectorML and MarkerDetectorML.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrMarkerDetectorML lhs,
                                                       MarkerDetectorML const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between MarkerDetectorML and raw XrMarkerDetectorML.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(MarkerDetectorML const& lhs,
                                                       XrMarkerDetectorML rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrMarkerDetectorML and MarkerDetectorML.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrMarkerDetectorML lhs,
                                                       MarkerDetectorML const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between MarkerDetectorML and raw XrMarkerDetectorML.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(MarkerDetectorML const& lhs,
                                                       XrMarkerDetectorML rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrMarkerDetectorML and MarkerDetectorML.
//! @relates MarkerDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrMarkerDetectorML lhs,
                                                       MarkerDetectorML const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between MarkerDetectorML and nullptr: true if the handle is null.
 * @relates MarkerDetectorML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(MarkerDetectorML const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and MarkerDetectorML: true if the handle is null.
 * @relates MarkerDetectorML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       MarkerDetectorML const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between MarkerDetectorML and nullptr: true if the handle is not
 * null.
 * @relates MarkerDetectorML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(MarkerDetectorML const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and MarkerDetectorML: true if the handle is not
 * null.
 * @relates MarkerDetectorML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       MarkerDetectorML const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_ML_marker_understanding

#ifdef XR_ML_localization_map

/*!
 * @brief Handle class - wrapping XrExportedLocalizationMapML without indicating ownership.
 *
 * Provided by the `XR_ML_localization_map` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrExportedLocalizationMapML>
 *
 * @xrentity{XrExportedLocalizationMapML}
 * @ingroup handles
 */
class ExportedLocalizationMapML {
public:
  using Type = ExportedLocalizationMapML;
  using RawHandleType = XrExportedLocalizationMapML;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR ExportedLocalizationMapML() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrExportedLocalizationMapML type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT ExportedLocalizationMapML(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR ExportedLocalizationMapML(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrExportedLocalizationMapML
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrExportedLocalizationMapML type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this ExportedLocalizationMapML value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this ExportedLocalizationMapML value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrExportedLocalizationMapML manipulation
   * @{
   */
  //! Gets the raw XrExportedLocalizationMapML value.
  OPENXR_HPP_CONSTEXPR XrExportedLocalizationMapML get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * ExportedLocalizationMapML yourHandle;
   * auto result = d.xrCreateExportedLocalizationMapML(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(ExportedLocalizationMapML&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyExportedLocalizationMapML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyExportedLocalizationMapML>
   *
   * @xrentity{xrDestroyExportedLocalizationMapML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyExportedLocalizationMapML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyExportedLocalizationMapML>
   *
   * @xrentity{xrDestroyExportedLocalizationMapML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyExportedLocalizationMapML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyExportedLocalizationMapML>
   *
   * @xrentity{xrDestroyExportedLocalizationMapML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetExportedLocalizationMapDataML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetExportedLocalizationMapDataML>
   *
   * @xrentity{xrGetExportedLocalizationMapDataML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getExportedLocalizationMapDataML(uint32_t bufferCapacityInput, uint32_t& bufferCountOutput,
                                          char* buffer,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetExportedLocalizationMapDataML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetExportedLocalizationMapDataML>
   *
   * @xrentity{xrGetExportedLocalizationMapDataML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getExportedLocalizationMapDataML(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetExportedLocalizationMapDataML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetExportedLocalizationMapDataML>
   *
   * @xrentity{xrGetExportedLocalizationMapDataML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getExportedLocalizationMapDataML(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetExportedLocalizationMapDataML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetExportedLocalizationMapDataML>
   *
   * @xrentity{xrGetExportedLocalizationMapDataML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getExportedLocalizationMapDataML(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetExportedLocalizationMapDataML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetExportedLocalizationMapDataML>
   *
   * @xrentity{xrGetExportedLocalizationMapDataML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getExportedLocalizationMapDataML(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrExportedLocalizationMapML val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrExportedLocalizationMapML) == sizeof(ExportedLocalizationMapML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrExportedLocalizationMapML from an
 * ExportedLocalizationMapML value.
 *
 * @found_by_adl
 * @see ExportedLocalizationMapML::get()
 * @relates ExportedLocalizationMapML
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrExportedLocalizationMapML
get(ExportedLocalizationMapML const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrExportedLocalizationMapML handle in a ExportedLocalizationMapML (by reference).
 *
 * e.g.
 * ```
 * ExportedLocalizationMapML yourHandle;
 * auto result = d.xrCreateExportedLocalizationMapML(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates ExportedLocalizationMapML
 */
static OPENXR_HPP_INLINE XrExportedLocalizationMapML* put(ExportedLocalizationMapML& h,
                                                          bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between ExportedLocalizationMapML values.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    ExportedLocalizationMapML const& lhs, ExportedLocalizationMapML const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between ExportedLocalizationMapML values.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    ExportedLocalizationMapML const& lhs, ExportedLocalizationMapML const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between ExportedLocalizationMapML values.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    ExportedLocalizationMapML const& lhs, ExportedLocalizationMapML const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between ExportedLocalizationMapML values.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    ExportedLocalizationMapML const& lhs, ExportedLocalizationMapML const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between ExportedLocalizationMapML values.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    ExportedLocalizationMapML const& lhs, ExportedLocalizationMapML const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between ExportedLocalizationMapML values.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    ExportedLocalizationMapML const& lhs, ExportedLocalizationMapML const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between ExportedLocalizationMapML and raw XrExportedLocalizationMapML.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(ExportedLocalizationMapML const& lhs,
                                                      XrExportedLocalizationMapML rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrExportedLocalizationMapML and ExportedLocalizationMapML.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    XrExportedLocalizationMapML lhs, ExportedLocalizationMapML const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between ExportedLocalizationMapML and raw XrExportedLocalizationMapML.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(ExportedLocalizationMapML const& lhs,
                                                      XrExportedLocalizationMapML rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrExportedLocalizationMapML and ExportedLocalizationMapML.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    XrExportedLocalizationMapML lhs, ExportedLocalizationMapML const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between ExportedLocalizationMapML and raw XrExportedLocalizationMapML.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(ExportedLocalizationMapML const& lhs,
                                                       XrExportedLocalizationMapML rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrExportedLocalizationMapML and ExportedLocalizationMapML.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    XrExportedLocalizationMapML lhs, ExportedLocalizationMapML const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between ExportedLocalizationMapML and raw XrExportedLocalizationMapML.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(ExportedLocalizationMapML const& lhs,
                                                       XrExportedLocalizationMapML rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrExportedLocalizationMapML and ExportedLocalizationMapML.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    XrExportedLocalizationMapML lhs, ExportedLocalizationMapML const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between ExportedLocalizationMapML and raw XrExportedLocalizationMapML.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(ExportedLocalizationMapML const& lhs,
                                                       XrExportedLocalizationMapML rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrExportedLocalizationMapML and ExportedLocalizationMapML.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    XrExportedLocalizationMapML lhs, ExportedLocalizationMapML const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between ExportedLocalizationMapML and raw XrExportedLocalizationMapML.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(ExportedLocalizationMapML const& lhs,
                                                       XrExportedLocalizationMapML rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrExportedLocalizationMapML and ExportedLocalizationMapML.
//! @relates ExportedLocalizationMapML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    XrExportedLocalizationMapML lhs, ExportedLocalizationMapML const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between ExportedLocalizationMapML and nullptr: true if the handle is
 * null.
 * @relates ExportedLocalizationMapML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(ExportedLocalizationMapML const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and ExportedLocalizationMapML: true if the handle is
 * null.
 * @relates ExportedLocalizationMapML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    std::nullptr_t /* unused */, ExportedLocalizationMapML const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between ExportedLocalizationMapML and nullptr: true if the handle is
 * not null.
 * @relates ExportedLocalizationMapML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(ExportedLocalizationMapML const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and ExportedLocalizationMapML: true if the handle is
 * not null.
 * @relates ExportedLocalizationMapML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    std::nullptr_t /* unused */, ExportedLocalizationMapML const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_ML_localization_map

#ifdef XR_ML_spatial_anchors_storage

/*!
 * @brief Handle class - wrapping XrSpatialAnchorsStorageML without indicating ownership.
 *
 * Provided by the `XR_ML_spatial_anchors_storage` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorsStorageML>
 *
 * @xrentity{XrSpatialAnchorsStorageML}
 * @ingroup handles
 */
class SpatialAnchorsStorageML {
public:
  using Type = SpatialAnchorsStorageML;
  using RawHandleType = XrSpatialAnchorsStorageML;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SpatialAnchorsStorageML() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpatialAnchorsStorageML type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SpatialAnchorsStorageML(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SpatialAnchorsStorageML(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpatialAnchorsStorageML
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpatialAnchorsStorageML type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SpatialAnchorsStorageML value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SpatialAnchorsStorageML value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpatialAnchorsStorageML manipulation
   * @{
   */
  //! Gets the raw XrSpatialAnchorsStorageML value.
  OPENXR_HPP_CONSTEXPR XrSpatialAnchorsStorageML get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SpatialAnchorsStorageML yourHandle;
   * auto result = d.xrCreateSpatialAnchorsStorageML(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SpatialAnchorsStorageML&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpatialAnchorsStorageML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorsStorageML>
   *
   * @xrentity{xrDestroySpatialAnchorsStorageML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpatialAnchorsStorageML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorsStorageML>
   *
   * @xrentity{xrDestroySpatialAnchorsStorageML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpatialAnchorsStorageML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorsStorageML>
   *
   * @xrentity{xrDestroySpatialAnchorsStorageML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrQuerySpatialAnchorsAsyncML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySpatialAnchorsAsyncML>
   *
   * @xrentity{xrQuerySpatialAnchorsAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result querySpatialAnchorsAsyncML(const SpatialAnchorsQueryInfoBaseHeaderML& queryInfo,
                                    FutureEXT& future,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrQuerySpatialAnchorsAsyncML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySpatialAnchorsAsyncML>
   *
   * @xrentity{xrQuerySpatialAnchorsAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> querySpatialAnchorsAsyncML(
      const SpatialAnchorsQueryInfoBaseHeaderML& queryInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrQuerySpatialAnchorsAsyncML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySpatialAnchorsAsyncML>
   *
   * @xrentity{xrQuerySpatialAnchorsAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT querySpatialAnchorsAsyncML(const SpatialAnchorsQueryInfoBaseHeaderML& queryInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrQuerySpatialAnchorsCompleteML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySpatialAnchorsCompleteML>
   *
   * @xrentity{xrQuerySpatialAnchorsCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result querySpatialAnchorsCompleteML(FutureEXT future,
                                       SpatialAnchorsQueryCompletionML& completion,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrQuerySpatialAnchorsCompleteML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySpatialAnchorsCompleteML>
   *
   * @xrentity{xrQuerySpatialAnchorsCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result querySpatialAnchorsCompleteML(FutureEXT future,
                                       SpatialAnchorsQueryCompletionML& completion,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrQuerySpatialAnchorsCompleteML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySpatialAnchorsCompleteML>
   *
   * @xrentity{xrQuerySpatialAnchorsCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void querySpatialAnchorsCompleteML(FutureEXT future, SpatialAnchorsQueryCompletionML& completion,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrPublishSpatialAnchorsAsyncML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPublishSpatialAnchorsAsyncML>
   *
   * @xrentity{xrPublishSpatialAnchorsAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result publishSpatialAnchorsAsyncML(const SpatialAnchorsPublishInfoML& publishInfo,
                                      FutureEXT& future,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPublishSpatialAnchorsAsyncML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPublishSpatialAnchorsAsyncML>
   *
   * @xrentity{xrPublishSpatialAnchorsAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> publishSpatialAnchorsAsyncML(
      const SpatialAnchorsPublishInfoML& publishInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPublishSpatialAnchorsAsyncML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPublishSpatialAnchorsAsyncML>
   *
   * @xrentity{xrPublishSpatialAnchorsAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT publishSpatialAnchorsAsyncML(const SpatialAnchorsPublishInfoML& publishInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPublishSpatialAnchorsCompleteML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPublishSpatialAnchorsCompleteML>
   *
   * @xrentity{xrPublishSpatialAnchorsCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result publishSpatialAnchorsCompleteML(FutureEXT future,
                                         SpatialAnchorsPublishCompletionML& completion,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPublishSpatialAnchorsCompleteML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPublishSpatialAnchorsCompleteML>
   *
   * @xrentity{xrPublishSpatialAnchorsCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result publishSpatialAnchorsCompleteML(FutureEXT future,
                                         SpatialAnchorsPublishCompletionML& completion,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPublishSpatialAnchorsCompleteML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPublishSpatialAnchorsCompleteML>
   *
   * @xrentity{xrPublishSpatialAnchorsCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void publishSpatialAnchorsCompleteML(FutureEXT future,
                                       SpatialAnchorsPublishCompletionML& completion,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrDeleteSpatialAnchorsAsyncML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDeleteSpatialAnchorsAsyncML>
   *
   * @xrentity{xrDeleteSpatialAnchorsAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result deleteSpatialAnchorsAsyncML(const SpatialAnchorsDeleteInfoML& deleteInfo,
                                     FutureEXT& future,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDeleteSpatialAnchorsAsyncML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDeleteSpatialAnchorsAsyncML>
   *
   * @xrentity{xrDeleteSpatialAnchorsAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> deleteSpatialAnchorsAsyncML(const SpatialAnchorsDeleteInfoML& deleteInfo,
                                                     Dispatch&& d
                                                         OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrDeleteSpatialAnchorsAsyncML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDeleteSpatialAnchorsAsyncML>
   *
   * @xrentity{xrDeleteSpatialAnchorsAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT deleteSpatialAnchorsAsyncML(const SpatialAnchorsDeleteInfoML& deleteInfo,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrDeleteSpatialAnchorsCompleteML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDeleteSpatialAnchorsCompleteML>
   *
   * @xrentity{xrDeleteSpatialAnchorsCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result deleteSpatialAnchorsCompleteML(FutureEXT future,
                                        SpatialAnchorsDeleteCompletionML& completion,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDeleteSpatialAnchorsCompleteML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorsDeleteCompletionML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDeleteSpatialAnchorsCompleteML>
   *
   * @xrentity{xrDeleteSpatialAnchorsCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorsDeleteCompletionML> deleteSpatialAnchorsCompleteML(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrDeleteSpatialAnchorsCompleteML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorsDeleteCompletionML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDeleteSpatialAnchorsCompleteML>
   *
   * @xrentity{xrDeleteSpatialAnchorsCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorsDeleteCompletionML deleteSpatialAnchorsCompleteML(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrUpdateSpatialAnchorsExpirationAsyncML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateSpatialAnchorsExpirationAsyncML>
   *
   * @xrentity{xrUpdateSpatialAnchorsExpirationAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result updateSpatialAnchorsExpirationAsyncML(
      const SpatialAnchorsUpdateExpirationInfoML& updateInfo, FutureEXT& future,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUpdateSpatialAnchorsExpirationAsyncML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateSpatialAnchorsExpirationAsyncML>
   *
   * @xrentity{xrUpdateSpatialAnchorsExpirationAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> updateSpatialAnchorsExpirationAsyncML(
      const SpatialAnchorsUpdateExpirationInfoML& updateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUpdateSpatialAnchorsExpirationAsyncML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateSpatialAnchorsExpirationAsyncML>
   *
   * @xrentity{xrUpdateSpatialAnchorsExpirationAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT updateSpatialAnchorsExpirationAsyncML(
      const SpatialAnchorsUpdateExpirationInfoML& updateInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrUpdateSpatialAnchorsExpirationCompleteML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateSpatialAnchorsExpirationCompleteML>
   *
   * @xrentity{xrUpdateSpatialAnchorsExpirationCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result updateSpatialAnchorsExpirationCompleteML(
      FutureEXT future, SpatialAnchorsUpdateExpirationCompletionML& completion,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUpdateSpatialAnchorsExpirationCompleteML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorsUpdateExpirationCompletionML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateSpatialAnchorsExpirationCompleteML>
   *
   * @xrentity{xrUpdateSpatialAnchorsExpirationCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorsUpdateExpirationCompletionML> updateSpatialAnchorsExpirationCompleteML(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUpdateSpatialAnchorsExpirationCompleteML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorsUpdateExpirationCompletionML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdateSpatialAnchorsExpirationCompleteML>
   *
   * @xrentity{xrUpdateSpatialAnchorsExpirationCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorsUpdateExpirationCompletionML updateSpatialAnchorsExpirationCompleteML(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrSpatialAnchorsStorageML val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpatialAnchorsStorageML) == sizeof(SpatialAnchorsStorageML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpatialAnchorsStorageML from an
 * SpatialAnchorsStorageML value.
 *
 * @found_by_adl
 * @see SpatialAnchorsStorageML::get()
 * @relates SpatialAnchorsStorageML
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpatialAnchorsStorageML
get(SpatialAnchorsStorageML const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSpatialAnchorsStorageML handle in a SpatialAnchorsStorageML (by reference).
 *
 * e.g.
 * ```
 * SpatialAnchorsStorageML yourHandle;
 * auto result = d.xrCreateSpatialAnchorsStorageML(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SpatialAnchorsStorageML
 */
static OPENXR_HPP_INLINE XrSpatialAnchorsStorageML* put(SpatialAnchorsStorageML& h,
                                                        bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SpatialAnchorsStorageML values.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialAnchorsStorageML const& lhs,
                                                      SpatialAnchorsStorageML const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SpatialAnchorsStorageML values.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialAnchorsStorageML const& lhs,
                                                      SpatialAnchorsStorageML const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SpatialAnchorsStorageML values.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    SpatialAnchorsStorageML const& lhs, SpatialAnchorsStorageML const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SpatialAnchorsStorageML values.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    SpatialAnchorsStorageML const& lhs, SpatialAnchorsStorageML const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SpatialAnchorsStorageML values.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    SpatialAnchorsStorageML const& lhs, SpatialAnchorsStorageML const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SpatialAnchorsStorageML values.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    SpatialAnchorsStorageML const& lhs, SpatialAnchorsStorageML const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SpatialAnchorsStorageML and raw XrSpatialAnchorsStorageML.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialAnchorsStorageML const& lhs,
                                                      XrSpatialAnchorsStorageML rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpatialAnchorsStorageML and SpatialAnchorsStorageML.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSpatialAnchorsStorageML lhs,
                                                      SpatialAnchorsStorageML const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SpatialAnchorsStorageML and raw XrSpatialAnchorsStorageML.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialAnchorsStorageML const& lhs,
                                                      XrSpatialAnchorsStorageML rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpatialAnchorsStorageML and SpatialAnchorsStorageML.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSpatialAnchorsStorageML lhs,
                                                      SpatialAnchorsStorageML const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SpatialAnchorsStorageML and raw XrSpatialAnchorsStorageML.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialAnchorsStorageML const& lhs,
                                                       XrSpatialAnchorsStorageML rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpatialAnchorsStorageML and SpatialAnchorsStorageML.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    XrSpatialAnchorsStorageML lhs, SpatialAnchorsStorageML const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SpatialAnchorsStorageML and raw XrSpatialAnchorsStorageML.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialAnchorsStorageML const& lhs,
                                                       XrSpatialAnchorsStorageML rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpatialAnchorsStorageML and SpatialAnchorsStorageML.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    XrSpatialAnchorsStorageML lhs, SpatialAnchorsStorageML const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SpatialAnchorsStorageML and raw XrSpatialAnchorsStorageML.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorsStorageML const& lhs,
                                                       XrSpatialAnchorsStorageML rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpatialAnchorsStorageML and SpatialAnchorsStorageML.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    XrSpatialAnchorsStorageML lhs, SpatialAnchorsStorageML const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SpatialAnchorsStorageML and raw XrSpatialAnchorsStorageML.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorsStorageML const& lhs,
                                                       XrSpatialAnchorsStorageML rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpatialAnchorsStorageML and SpatialAnchorsStorageML.
//! @relates SpatialAnchorsStorageML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    XrSpatialAnchorsStorageML lhs, SpatialAnchorsStorageML const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SpatialAnchorsStorageML and nullptr: true if the handle is
 * null.
 * @relates SpatialAnchorsStorageML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorsStorageML const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SpatialAnchorsStorageML: true if the handle is
 * null.
 * @relates SpatialAnchorsStorageML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    std::nullptr_t /* unused */, SpatialAnchorsStorageML const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SpatialAnchorsStorageML and nullptr: true if the handle is
 * not null.
 * @relates SpatialAnchorsStorageML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorsStorageML const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SpatialAnchorsStorageML: true if the handle is
 * not null.
 * @relates SpatialAnchorsStorageML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    std::nullptr_t /* unused */, SpatialAnchorsStorageML const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_ML_spatial_anchors_storage

#ifdef XR_MSFT_spatial_anchor_persistence

/*!
 * @brief Handle class - wrapping XrSpatialAnchorStoreConnectionMSFT without indicating ownership.
 *
 * Provided by the `XR_MSFT_spatial_anchor_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialAnchorStoreConnectionMSFT>
 *
 * @xrentity{XrSpatialAnchorStoreConnectionMSFT}
 * @ingroup handles
 */
class SpatialAnchorStoreConnectionMSFT {
public:
  using Type = SpatialAnchorStoreConnectionMSFT;
  using RawHandleType = XrSpatialAnchorStoreConnectionMSFT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SpatialAnchorStoreConnectionMSFT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpatialAnchorStoreConnectionMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SpatialAnchorStoreConnectionMSFT(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SpatialAnchorStoreConnectionMSFT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpatialAnchorStoreConnectionMSFT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpatialAnchorStoreConnectionMSFT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SpatialAnchorStoreConnectionMSFT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SpatialAnchorStoreConnectionMSFT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpatialAnchorStoreConnectionMSFT manipulation
   * @{
   */
  //! Gets the raw XrSpatialAnchorStoreConnectionMSFT value.
  OPENXR_HPP_CONSTEXPR XrSpatialAnchorStoreConnectionMSFT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SpatialAnchorStoreConnectionMSFT yourHandle;
   * auto result = d.xrCreateSpatialAnchorStoreConnectionMSFT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SpatialAnchorStoreConnectionMSFT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpatialAnchorStoreConnectionMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpatialAnchorStoreConnectionMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrDestroySpatialAnchorStoreConnectionMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialAnchorStoreConnectionMSFT>
   *
   * @xrentity{xrDestroySpatialAnchorStoreConnectionMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrPersistSpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialAnchorMSFT>
   *
   * @xrentity{xrPersistSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result persistSpatialAnchorMSFT(
      const SpatialAnchorPersistenceInfoMSFT& spatialAnchorPersistenceInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPersistSpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialAnchorMSFT>
   *
   * @xrentity{xrPersistSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result persistSpatialAnchorMSFT(
      const SpatialAnchorPersistenceInfoMSFT& spatialAnchorPersistenceInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPersistSpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialAnchorMSFT>
   *
   * @xrentity{xrPersistSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void persistSpatialAnchorMSFT(
      const SpatialAnchorPersistenceInfoMSFT& spatialAnchorPersistenceInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrEnumeratePersistedSpatialAnchorNamesMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePersistedSpatialAnchorNamesMSFT>
   *
   * @xrentity{xrEnumeratePersistedSpatialAnchorNamesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumeratePersistedSpatialAnchorNamesMSFT(
      uint32_t spatialAnchorNameCapacityInput, uint32_t& spatialAnchorNameCountOutput,
      SpatialAnchorPersistenceNameMSFT* spatialAnchorNames,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumeratePersistedSpatialAnchorNamesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePersistedSpatialAnchorNamesMSFT>
   *
   * @xrentity{xrEnumeratePersistedSpatialAnchorNamesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialAnchorPersistenceNameMSFT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>>
  enumeratePersistedSpatialAnchorNamesToVectorMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumeratePersistedSpatialAnchorNamesMSFT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePersistedSpatialAnchorNamesMSFT>
   *
   * @xrentity{xrEnumeratePersistedSpatialAnchorNamesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialAnchorPersistenceNameMSFT>,
            typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>>
  enumeratePersistedSpatialAnchorNamesToVectorMSFT(Allocator const& vectorAllocator,
                                                   Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumeratePersistedSpatialAnchorNamesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePersistedSpatialAnchorNamesMSFT>
   *
   * @xrentity{xrEnumeratePersistedSpatialAnchorNamesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialAnchorPersistenceNameMSFT>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
  enumeratePersistedSpatialAnchorNamesToVectorMSFT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumeratePersistedSpatialAnchorNamesMSFT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumeratePersistedSpatialAnchorNamesMSFT>
   *
   * @xrentity{xrEnumeratePersistedSpatialAnchorNamesMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialAnchorPersistenceNameMSFT>,
            typename Dispatch, OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpatialAnchorPersistenceNameMSFT, Allocator>
  enumeratePersistedSpatialAnchorNamesToVectorMSFT(Allocator const& vectorAllocator,
                                                   Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrUnpersistSpatialAnchorMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialAnchorMSFT>
   *
   * @xrentity{xrUnpersistSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result unpersistSpatialAnchorMSFT(
      const SpatialAnchorPersistenceNameMSFT& spatialAnchorPersistenceName,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUnpersistSpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialAnchorMSFT>
   *
   * @xrentity{xrUnpersistSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result unpersistSpatialAnchorMSFT(
      const SpatialAnchorPersistenceNameMSFT& spatialAnchorPersistenceName,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUnpersistSpatialAnchorMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialAnchorMSFT>
   *
   * @xrentity{xrUnpersistSpatialAnchorMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void unpersistSpatialAnchorMSFT(
      const SpatialAnchorPersistenceNameMSFT& spatialAnchorPersistenceName,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrClearSpatialAnchorStoreMSFT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrClearSpatialAnchorStoreMSFT>
   *
   * @xrentity{xrClearSpatialAnchorStoreMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result clearSpatialAnchorStoreMSFT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrClearSpatialAnchorStoreMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrClearSpatialAnchorStoreMSFT>
   *
   * @xrentity{xrClearSpatialAnchorStoreMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result clearSpatialAnchorStoreMSFT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrClearSpatialAnchorStoreMSFT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrClearSpatialAnchorStoreMSFT>
   *
   * @xrentity{xrClearSpatialAnchorStoreMSFT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void clearSpatialAnchorStoreMSFT(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrSpatialAnchorStoreConnectionMSFT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpatialAnchorStoreConnectionMSFT) ==
                  sizeof(SpatialAnchorStoreConnectionMSFT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpatialAnchorStoreConnectionMSFT from an
 * SpatialAnchorStoreConnectionMSFT value.
 *
 * @found_by_adl
 * @see SpatialAnchorStoreConnectionMSFT::get()
 * @relates SpatialAnchorStoreConnectionMSFT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpatialAnchorStoreConnectionMSFT
get(SpatialAnchorStoreConnectionMSFT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSpatialAnchorStoreConnectionMSFT handle in a SpatialAnchorStoreConnectionMSFT (by reference).
 *
 * e.g.
 * ```
 * SpatialAnchorStoreConnectionMSFT yourHandle;
 * auto result = d.xrCreateSpatialAnchorStoreConnectionMSFT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SpatialAnchorStoreConnectionMSFT
 */
static OPENXR_HPP_INLINE XrSpatialAnchorStoreConnectionMSFT* put(
    SpatialAnchorStoreConnectionMSFT& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SpatialAnchorStoreConnectionMSFT values.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    SpatialAnchorStoreConnectionMSFT const& lhs,
    SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SpatialAnchorStoreConnectionMSFT values.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    SpatialAnchorStoreConnectionMSFT const& lhs,
    SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SpatialAnchorStoreConnectionMSFT values.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    SpatialAnchorStoreConnectionMSFT const& lhs,
    SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SpatialAnchorStoreConnectionMSFT values.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    SpatialAnchorStoreConnectionMSFT const& lhs,
    SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SpatialAnchorStoreConnectionMSFT values.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    SpatialAnchorStoreConnectionMSFT const& lhs,
    SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SpatialAnchorStoreConnectionMSFT values.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    SpatialAnchorStoreConnectionMSFT const& lhs,
    SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SpatialAnchorStoreConnectionMSFT and raw
//! XrSpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    SpatialAnchorStoreConnectionMSFT const& lhs, XrSpatialAnchorStoreConnectionMSFT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpatialAnchorStoreConnectionMSFT and
//! SpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    XrSpatialAnchorStoreConnectionMSFT lhs, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SpatialAnchorStoreConnectionMSFT and raw
//! XrSpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    SpatialAnchorStoreConnectionMSFT const& lhs, XrSpatialAnchorStoreConnectionMSFT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpatialAnchorStoreConnectionMSFT and
//! SpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    XrSpatialAnchorStoreConnectionMSFT lhs, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SpatialAnchorStoreConnectionMSFT and raw
//! XrSpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    SpatialAnchorStoreConnectionMSFT const& lhs, XrSpatialAnchorStoreConnectionMSFT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpatialAnchorStoreConnectionMSFT and
//! SpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    XrSpatialAnchorStoreConnectionMSFT lhs, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SpatialAnchorStoreConnectionMSFT and raw
//! XrSpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    SpatialAnchorStoreConnectionMSFT const& lhs, XrSpatialAnchorStoreConnectionMSFT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpatialAnchorStoreConnectionMSFT and
//! SpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    XrSpatialAnchorStoreConnectionMSFT lhs, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SpatialAnchorStoreConnectionMSFT and raw
//! XrSpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    SpatialAnchorStoreConnectionMSFT const& lhs, XrSpatialAnchorStoreConnectionMSFT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpatialAnchorStoreConnectionMSFT and
//! SpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    XrSpatialAnchorStoreConnectionMSFT lhs, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SpatialAnchorStoreConnectionMSFT and raw
//! XrSpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    SpatialAnchorStoreConnectionMSFT const& lhs, XrSpatialAnchorStoreConnectionMSFT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpatialAnchorStoreConnectionMSFT and
//! SpatialAnchorStoreConnectionMSFT.
//! @relates SpatialAnchorStoreConnectionMSFT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    XrSpatialAnchorStoreConnectionMSFT lhs, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SpatialAnchorStoreConnectionMSFT and nullptr: true if the
 * handle is null.
 * @relates SpatialAnchorStoreConnectionMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialAnchorStoreConnectionMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SpatialAnchorStoreConnectionMSFT: true if the
 * handle is null.
 * @relates SpatialAnchorStoreConnectionMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    std::nullptr_t /* unused */, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SpatialAnchorStoreConnectionMSFT and nullptr: true if the
 * handle is not null.
 * @relates SpatialAnchorStoreConnectionMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialAnchorStoreConnectionMSFT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SpatialAnchorStoreConnectionMSFT: true if the
 * handle is not null.
 * @relates SpatialAnchorStoreConnectionMSFT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    std::nullptr_t /* unused */, SpatialAnchorStoreConnectionMSFT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_MSFT_spatial_anchor_persistence

#ifdef XR_FB_spatial_entity_sharing

/*!
 * @brief Handle class - wrapping XrSpaceUserFB without indicating ownership.
 *
 * Provided by the `XR_FB_spatial_entity_sharing` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpaceUserFB>
 *
 * @xrentity{XrSpaceUserFB}
 * @ingroup handles
 */
class SpaceUserFB {
public:
  using Type = SpaceUserFB;
  using RawHandleType = XrSpaceUserFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SpaceUserFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpaceUserFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SpaceUserFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SpaceUserFB(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpaceUserFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpaceUserFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SpaceUserFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SpaceUserFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpaceUserFB manipulation
   * @{
   */
  //! Gets the raw XrSpaceUserFB value.
  OPENXR_HPP_CONSTEXPR XrSpaceUserFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SpaceUserFB yourHandle;
   * auto result = d.xrCreateSpaceUserFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SpaceUserFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef XR_FB_spatial_entity_user

  /*!
   * @brief xrGetSpaceUserIdFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceUserIdFB>
   *
   * @xrentity{xrGetSpaceUserIdFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpaceUserIdFB(SpaceUserIdFB& userId,
                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpaceUserIdFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpaceUserIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceUserIdFB>
   *
   * @xrentity{xrGetSpaceUserIdFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpaceUserIdFB> getSpaceUserIdFB(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpaceUserIdFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpaceUserIdFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpaceUserIdFB>
   *
   * @xrentity{xrGetSpaceUserIdFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpaceUserIdFB getSpaceUserIdFB(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity_user

#ifdef XR_FB_spatial_entity_user

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpaceUserFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpaceUserFB>
   *
   * @xrentity{xrDestroySpaceUserFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpaceUserFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpaceUserFB>
   *
   * @xrentity{xrDestroySpaceUserFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpaceUserFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpaceUserFB>
   *
   * @xrentity{xrDestroySpaceUserFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_FB_spatial_entity_user

  //! @}
private:
  XrSpaceUserFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpaceUserFB) == sizeof(SpaceUserFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpaceUserFB from an SpaceUserFB value.
 *
 * @found_by_adl
 * @see SpaceUserFB::get()
 * @relates SpaceUserFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpaceUserFB get(SpaceUserFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSpaceUserFB handle in a SpaceUserFB (by reference).
 *
 * e.g.
 * ```
 * SpaceUserFB yourHandle;
 * auto result = d.xrCreateSpaceUserFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SpaceUserFB
 */
static OPENXR_HPP_INLINE XrSpaceUserFB* put(SpaceUserFB& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SpaceUserFB values.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpaceUserFB const& lhs,
                                                      SpaceUserFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SpaceUserFB values.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpaceUserFB const& lhs,
                                                      SpaceUserFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SpaceUserFB values.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpaceUserFB const& lhs,
                                                       SpaceUserFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SpaceUserFB values.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpaceUserFB const& lhs,
                                                       SpaceUserFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SpaceUserFB values.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpaceUserFB const& lhs,
                                                       SpaceUserFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SpaceUserFB values.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpaceUserFB const& lhs,
                                                       SpaceUserFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SpaceUserFB and raw XrSpaceUserFB.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpaceUserFB const& lhs,
                                                      XrSpaceUserFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpaceUserFB and SpaceUserFB.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSpaceUserFB lhs,
                                                      SpaceUserFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SpaceUserFB and raw XrSpaceUserFB.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpaceUserFB const& lhs,
                                                      XrSpaceUserFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpaceUserFB and SpaceUserFB.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSpaceUserFB lhs,
                                                      SpaceUserFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SpaceUserFB and raw XrSpaceUserFB.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpaceUserFB const& lhs,
                                                       XrSpaceUserFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpaceUserFB and SpaceUserFB.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSpaceUserFB lhs,
                                                       SpaceUserFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SpaceUserFB and raw XrSpaceUserFB.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpaceUserFB const& lhs,
                                                       XrSpaceUserFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpaceUserFB and SpaceUserFB.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSpaceUserFB lhs,
                                                       SpaceUserFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SpaceUserFB and raw XrSpaceUserFB.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpaceUserFB const& lhs,
                                                       XrSpaceUserFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpaceUserFB and SpaceUserFB.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSpaceUserFB lhs,
                                                       SpaceUserFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SpaceUserFB and raw XrSpaceUserFB.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpaceUserFB const& lhs,
                                                       XrSpaceUserFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpaceUserFB and SpaceUserFB.
//! @relates SpaceUserFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSpaceUserFB lhs,
                                                       SpaceUserFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SpaceUserFB and nullptr: true if the handle is null.
 * @relates SpaceUserFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpaceUserFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SpaceUserFB: true if the handle is null.
 * @relates SpaceUserFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SpaceUserFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SpaceUserFB and nullptr: true if the handle is not null.
 * @relates SpaceUserFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpaceUserFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SpaceUserFB: true if the handle is not null.
 * @relates SpaceUserFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SpaceUserFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_spatial_entity_sharing

#ifdef XR_FB_face_tracking

/*!
 * @brief Handle class - wrapping XrFaceTrackerFB without indicating ownership.
 *
 * Provided by the `XR_FB_face_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceTrackerFB>
 *
 * @xrentity{XrFaceTrackerFB}
 * @ingroup handles
 */
class FaceTrackerFB {
public:
  using Type = FaceTrackerFB;
  using RawHandleType = XrFaceTrackerFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR FaceTrackerFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrFaceTrackerFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT FaceTrackerFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR FaceTrackerFB(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrFaceTrackerFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrFaceTrackerFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this FaceTrackerFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this FaceTrackerFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrFaceTrackerFB manipulation
   * @{
   */
  //! Gets the raw XrFaceTrackerFB value.
  OPENXR_HPP_CONSTEXPR XrFaceTrackerFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * FaceTrackerFB yourHandle;
   * auto result = d.xrCreateFaceTrackerFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(FaceTrackerFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyFaceTrackerFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFaceTrackerFB>
   *
   * @xrentity{xrDestroyFaceTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyFaceTrackerFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFaceTrackerFB>
   *
   * @xrentity{xrDestroyFaceTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyFaceTrackerFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFaceTrackerFB>
   *
   * @xrentity{xrDestroyFaceTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetFaceExpressionWeightsFB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFaceExpressionWeightsFB>
   *
   * @xrentity{xrGetFaceExpressionWeightsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getFaceExpressionWeightsFB(const FaceExpressionInfoFB& expressionInfo,
                                    FaceExpressionWeightsFB& expressionWeights,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetFaceExpressionWeightsFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFaceExpressionWeightsFB>
   *
   * @xrentity{xrGetFaceExpressionWeightsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getFaceExpressionWeightsFB(const FaceExpressionInfoFB& expressionInfo,
                                    FaceExpressionWeightsFB& expressionWeights,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetFaceExpressionWeightsFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFaceExpressionWeightsFB>
   *
   * @xrentity{xrGetFaceExpressionWeightsFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getFaceExpressionWeightsFB(const FaceExpressionInfoFB& expressionInfo,
                                  FaceExpressionWeightsFB& expressionWeights,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrFaceTrackerFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrFaceTrackerFB) == sizeof(FaceTrackerFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrFaceTrackerFB from an FaceTrackerFB value.
 *
 * @found_by_adl
 * @see FaceTrackerFB::get()
 * @relates FaceTrackerFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrFaceTrackerFB get(FaceTrackerFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrFaceTrackerFB handle in a FaceTrackerFB (by reference).
 *
 * e.g.
 * ```
 * FaceTrackerFB yourHandle;
 * auto result = d.xrCreateFaceTrackerFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates FaceTrackerFB
 */
static OPENXR_HPP_INLINE XrFaceTrackerFB* put(FaceTrackerFB& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between FaceTrackerFB values.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FaceTrackerFB const& lhs,
                                                      FaceTrackerFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between FaceTrackerFB values.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FaceTrackerFB const& lhs,
                                                      FaceTrackerFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between FaceTrackerFB values.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FaceTrackerFB const& lhs,
                                                       FaceTrackerFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between FaceTrackerFB values.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FaceTrackerFB const& lhs,
                                                       FaceTrackerFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between FaceTrackerFB values.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FaceTrackerFB const& lhs,
                                                       FaceTrackerFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between FaceTrackerFB values.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FaceTrackerFB const& lhs,
                                                       FaceTrackerFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between FaceTrackerFB and raw XrFaceTrackerFB.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FaceTrackerFB const& lhs,
                                                      XrFaceTrackerFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrFaceTrackerFB and FaceTrackerFB.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrFaceTrackerFB lhs,
                                                      FaceTrackerFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between FaceTrackerFB and raw XrFaceTrackerFB.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FaceTrackerFB const& lhs,
                                                      XrFaceTrackerFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrFaceTrackerFB and FaceTrackerFB.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrFaceTrackerFB lhs,
                                                      FaceTrackerFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between FaceTrackerFB and raw XrFaceTrackerFB.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FaceTrackerFB const& lhs,
                                                       XrFaceTrackerFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrFaceTrackerFB and FaceTrackerFB.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrFaceTrackerFB lhs,
                                                       FaceTrackerFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between FaceTrackerFB and raw XrFaceTrackerFB.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FaceTrackerFB const& lhs,
                                                       XrFaceTrackerFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrFaceTrackerFB and FaceTrackerFB.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrFaceTrackerFB lhs,
                                                       FaceTrackerFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between FaceTrackerFB and raw XrFaceTrackerFB.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FaceTrackerFB const& lhs,
                                                       XrFaceTrackerFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrFaceTrackerFB and FaceTrackerFB.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrFaceTrackerFB lhs,
                                                       FaceTrackerFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between FaceTrackerFB and raw XrFaceTrackerFB.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FaceTrackerFB const& lhs,
                                                       XrFaceTrackerFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrFaceTrackerFB and FaceTrackerFB.
//! @relates FaceTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrFaceTrackerFB lhs,
                                                       FaceTrackerFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between FaceTrackerFB and nullptr: true if the handle is null.
 * @relates FaceTrackerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FaceTrackerFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and FaceTrackerFB: true if the handle is null.
 * @relates FaceTrackerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       FaceTrackerFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between FaceTrackerFB and nullptr: true if the handle is not null.
 * @relates FaceTrackerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FaceTrackerFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and FaceTrackerFB: true if the handle is not null.
 * @relates FaceTrackerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       FaceTrackerFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_face_tracking

#ifdef XR_FB_eye_tracking_social

/*!
 * @brief Handle class - wrapping XrEyeTrackerFB without indicating ownership.
 *
 * Provided by the `XR_FB_eye_tracking_social` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEyeTrackerFB>
 *
 * @xrentity{XrEyeTrackerFB}
 * @ingroup handles
 */
class EyeTrackerFB {
public:
  using Type = EyeTrackerFB;
  using RawHandleType = XrEyeTrackerFB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR EyeTrackerFB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrEyeTrackerFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT EyeTrackerFB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR EyeTrackerFB(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrEyeTrackerFB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrEyeTrackerFB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this EyeTrackerFB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this EyeTrackerFB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrEyeTrackerFB manipulation
   * @{
   */
  //! Gets the raw XrEyeTrackerFB value.
  OPENXR_HPP_CONSTEXPR XrEyeTrackerFB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * EyeTrackerFB yourHandle;
   * auto result = d.xrCreateEyeTrackerFB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(EyeTrackerFB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyEyeTrackerFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyEyeTrackerFB>
   *
   * @xrentity{xrDestroyEyeTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyEyeTrackerFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyEyeTrackerFB>
   *
   * @xrentity{xrDestroyEyeTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyEyeTrackerFB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyEyeTrackerFB>
   *
   * @xrentity{xrDestroyEyeTrackerFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetEyeGazesFB wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetEyeGazesFB>
   *
   * @xrentity{xrGetEyeGazesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getEyeGazesFB(const EyeGazesInfoFB& gazeInfo, EyeGazesFB& eyeGazes,
                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetEyeGazesFB enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type EyeGazesFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetEyeGazesFB>
   *
   * @xrentity{xrGetEyeGazesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<EyeGazesFB> getEyeGazesFB(const EyeGazesInfoFB& gazeInfo,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetEyeGazesFB enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type EyeGazesFB
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetEyeGazesFB>
   *
   * @xrentity{xrGetEyeGazesFB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  EyeGazesFB getEyeGazesFB(const EyeGazesInfoFB& gazeInfo,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrEyeTrackerFB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrEyeTrackerFB) == sizeof(EyeTrackerFB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrEyeTrackerFB from an EyeTrackerFB value.
 *
 * @found_by_adl
 * @see EyeTrackerFB::get()
 * @relates EyeTrackerFB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrEyeTrackerFB get(EyeTrackerFB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrEyeTrackerFB handle in a EyeTrackerFB (by reference).
 *
 * e.g.
 * ```
 * EyeTrackerFB yourHandle;
 * auto result = d.xrCreateEyeTrackerFB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates EyeTrackerFB
 */
static OPENXR_HPP_INLINE XrEyeTrackerFB* put(EyeTrackerFB& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between EyeTrackerFB values.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(EyeTrackerFB const& lhs,
                                                      EyeTrackerFB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between EyeTrackerFB values.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(EyeTrackerFB const& lhs,
                                                      EyeTrackerFB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between EyeTrackerFB values.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(EyeTrackerFB const& lhs,
                                                       EyeTrackerFB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between EyeTrackerFB values.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(EyeTrackerFB const& lhs,
                                                       EyeTrackerFB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between EyeTrackerFB values.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(EyeTrackerFB const& lhs,
                                                       EyeTrackerFB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between EyeTrackerFB values.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(EyeTrackerFB const& lhs,
                                                       EyeTrackerFB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between EyeTrackerFB and raw XrEyeTrackerFB.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(EyeTrackerFB const& lhs,
                                                      XrEyeTrackerFB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrEyeTrackerFB and EyeTrackerFB.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrEyeTrackerFB lhs,
                                                      EyeTrackerFB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between EyeTrackerFB and raw XrEyeTrackerFB.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(EyeTrackerFB const& lhs,
                                                      XrEyeTrackerFB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrEyeTrackerFB and EyeTrackerFB.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrEyeTrackerFB lhs,
                                                      EyeTrackerFB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between EyeTrackerFB and raw XrEyeTrackerFB.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(EyeTrackerFB const& lhs,
                                                       XrEyeTrackerFB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrEyeTrackerFB and EyeTrackerFB.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrEyeTrackerFB lhs,
                                                       EyeTrackerFB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between EyeTrackerFB and raw XrEyeTrackerFB.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(EyeTrackerFB const& lhs,
                                                       XrEyeTrackerFB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrEyeTrackerFB and EyeTrackerFB.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrEyeTrackerFB lhs,
                                                       EyeTrackerFB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between EyeTrackerFB and raw XrEyeTrackerFB.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(EyeTrackerFB const& lhs,
                                                       XrEyeTrackerFB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrEyeTrackerFB and EyeTrackerFB.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrEyeTrackerFB lhs,
                                                       EyeTrackerFB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between EyeTrackerFB and raw XrEyeTrackerFB.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(EyeTrackerFB const& lhs,
                                                       XrEyeTrackerFB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrEyeTrackerFB and EyeTrackerFB.
//! @relates EyeTrackerFB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrEyeTrackerFB lhs,
                                                       EyeTrackerFB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between EyeTrackerFB and nullptr: true if the handle is null.
 * @relates EyeTrackerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(EyeTrackerFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and EyeTrackerFB: true if the handle is null.
 * @relates EyeTrackerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       EyeTrackerFB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between EyeTrackerFB and nullptr: true if the handle is not null.
 * @relates EyeTrackerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(EyeTrackerFB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and EyeTrackerFB: true if the handle is not null.
 * @relates EyeTrackerFB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       EyeTrackerFB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_eye_tracking_social

#ifdef XR_META_virtual_keyboard

/*!
 * @brief Handle class - wrapping XrVirtualKeyboardMETA without indicating ownership.
 *
 * Provided by the `XR_META_virtual_keyboard` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrVirtualKeyboardMETA>
 *
 * @xrentity{XrVirtualKeyboardMETA}
 * @ingroup handles
 */
class VirtualKeyboardMETA {
public:
  using Type = VirtualKeyboardMETA;
  using RawHandleType = XrVirtualKeyboardMETA;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR VirtualKeyboardMETA() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrVirtualKeyboardMETA type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT VirtualKeyboardMETA(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR VirtualKeyboardMETA(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrVirtualKeyboardMETA
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrVirtualKeyboardMETA type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this VirtualKeyboardMETA value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this VirtualKeyboardMETA value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrVirtualKeyboardMETA manipulation
   * @{
   */
  //! Gets the raw XrVirtualKeyboardMETA value.
  OPENXR_HPP_CONSTEXPR XrVirtualKeyboardMETA get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * VirtualKeyboardMETA yourHandle;
   * auto result = d.xrCreateVirtualKeyboardMETA(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(VirtualKeyboardMETA&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyVirtualKeyboardMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyVirtualKeyboardMETA>
   *
   * @xrentity{xrDestroyVirtualKeyboardMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyVirtualKeyboardMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyVirtualKeyboardMETA>
   *
   * @xrentity{xrDestroyVirtualKeyboardMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyVirtualKeyboardMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyVirtualKeyboardMETA>
   *
   * @xrentity{xrDestroyVirtualKeyboardMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSuggestVirtualKeyboardLocationMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSuggestVirtualKeyboardLocationMETA>
   *
   * @xrentity{xrSuggestVirtualKeyboardLocationMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result suggestVirtualKeyboardLocationMETA(const VirtualKeyboardLocationInfoMETA& locationInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSuggestVirtualKeyboardLocationMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSuggestVirtualKeyboardLocationMETA>
   *
   * @xrentity{xrSuggestVirtualKeyboardLocationMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result suggestVirtualKeyboardLocationMETA(const VirtualKeyboardLocationInfoMETA& locationInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSuggestVirtualKeyboardLocationMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSuggestVirtualKeyboardLocationMETA>
   *
   * @xrentity{xrSuggestVirtualKeyboardLocationMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void suggestVirtualKeyboardLocationMETA(const VirtualKeyboardLocationInfoMETA& locationInfo,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetVirtualKeyboardScaleMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardScaleMETA>
   *
   * @xrentity{xrGetVirtualKeyboardScaleMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVirtualKeyboardScaleMETA(float& scale,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVirtualKeyboardScaleMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type float
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardScaleMETA>
   *
   * @xrentity{xrGetVirtualKeyboardScaleMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<float> getVirtualKeyboardScaleMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVirtualKeyboardScaleMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type float
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardScaleMETA>
   *
   * @xrentity{xrGetVirtualKeyboardScaleMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  float getVirtualKeyboardScaleMETA(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetVirtualKeyboardModelVisibilityMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetVirtualKeyboardModelVisibilityMETA>
   *
   * @xrentity{xrSetVirtualKeyboardModelVisibilityMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setVirtualKeyboardModelVisibilityMETA(
      const VirtualKeyboardModelVisibilitySetInfoMETA& modelVisibility,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetVirtualKeyboardModelVisibilityMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetVirtualKeyboardModelVisibilityMETA>
   *
   * @xrentity{xrSetVirtualKeyboardModelVisibilityMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setVirtualKeyboardModelVisibilityMETA(
      const VirtualKeyboardModelVisibilitySetInfoMETA& modelVisibility,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetVirtualKeyboardModelVisibilityMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetVirtualKeyboardModelVisibilityMETA>
   *
   * @xrentity{xrSetVirtualKeyboardModelVisibilityMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setVirtualKeyboardModelVisibilityMETA(
      const VirtualKeyboardModelVisibilitySetInfoMETA& modelVisibility,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetVirtualKeyboardModelAnimationStatesMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardModelAnimationStatesMETA>
   *
   * @xrentity{xrGetVirtualKeyboardModelAnimationStatesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVirtualKeyboardModelAnimationStatesMETA(
      VirtualKeyboardModelAnimationStatesMETA& animationStates,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVirtualKeyboardModelAnimationStatesMETA enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardModelAnimationStatesMETA>
   *
   * @xrentity{xrGetVirtualKeyboardModelAnimationStatesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVirtualKeyboardModelAnimationStatesMETA(
      VirtualKeyboardModelAnimationStatesMETA& animationStates,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVirtualKeyboardModelAnimationStatesMETA enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardModelAnimationStatesMETA>
   *
   * @xrentity{xrGetVirtualKeyboardModelAnimationStatesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getVirtualKeyboardModelAnimationStatesMETA(
      VirtualKeyboardModelAnimationStatesMETA& animationStates,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetVirtualKeyboardDirtyTexturesMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardDirtyTexturesMETA>
   *
   * @xrentity{xrGetVirtualKeyboardDirtyTexturesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVirtualKeyboardDirtyTexturesMETA(
      uint32_t textureIdCapacityInput, uint32_t& textureIdCountOutput, uint64_t* textureIds,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVirtualKeyboardDirtyTexturesMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<uint64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardDirtyTexturesMETA>
   *
   * @xrentity{xrGetVirtualKeyboardDirtyTexturesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint64_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<uint64_t, Allocator>> getVirtualKeyboardDirtyTexturesToVectorMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVirtualKeyboardDirtyTexturesMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<uint64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardDirtyTexturesMETA>
   *
   * @xrentity{xrGetVirtualKeyboardDirtyTexturesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint64_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<uint64_t, Allocator>> getVirtualKeyboardDirtyTexturesToVectorMETA(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetVirtualKeyboardDirtyTexturesMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<uint64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardDirtyTexturesMETA>
   *
   * @xrentity{xrGetVirtualKeyboardDirtyTexturesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint64_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<uint64_t, Allocator> getVirtualKeyboardDirtyTexturesToVectorMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetVirtualKeyboardDirtyTexturesMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<uint64_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardDirtyTexturesMETA>
   *
   * @xrentity{xrGetVirtualKeyboardDirtyTexturesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint64_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<uint64_t, Allocator> getVirtualKeyboardDirtyTexturesToVectorMETA(
      Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetVirtualKeyboardTextureDataMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardTextureDataMETA>
   *
   * @xrentity{xrGetVirtualKeyboardTextureDataMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVirtualKeyboardTextureDataMETA(uint64_t textureId,
                                           VirtualKeyboardTextureDataMETA& textureData,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetVirtualKeyboardTextureDataMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardTextureDataMETA>
   *
   * @xrentity{xrGetVirtualKeyboardTextureDataMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getVirtualKeyboardTextureDataMETA(uint64_t textureId,
                                           VirtualKeyboardTextureDataMETA& textureData,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetVirtualKeyboardTextureDataMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetVirtualKeyboardTextureDataMETA>
   *
   * @xrentity{xrGetVirtualKeyboardTextureDataMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getVirtualKeyboardTextureDataMETA(uint64_t textureId,
                                         VirtualKeyboardTextureDataMETA& textureData,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrSendVirtualKeyboardInputMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSendVirtualKeyboardInputMETA>
   *
   * @xrentity{xrSendVirtualKeyboardInputMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result sendVirtualKeyboardInputMETA(const VirtualKeyboardInputInfoMETA& info,
                                      Posef& interactorRootPose,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSendVirtualKeyboardInputMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Posef
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSendVirtualKeyboardInputMETA>
   *
   * @xrentity{xrSendVirtualKeyboardInputMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Posef> sendVirtualKeyboardInputMETA(const VirtualKeyboardInputInfoMETA& info,
                                                  Dispatch&& d
                                                      OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSendVirtualKeyboardInputMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Posef
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSendVirtualKeyboardInputMETA>
   *
   * @xrentity{xrSendVirtualKeyboardInputMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Posef sendVirtualKeyboardInputMETA(const VirtualKeyboardInputInfoMETA& info,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrChangeVirtualKeyboardTextContextMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrChangeVirtualKeyboardTextContextMETA>
   *
   * @xrentity{xrChangeVirtualKeyboardTextContextMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result changeVirtualKeyboardTextContextMETA(
      const VirtualKeyboardTextContextChangeInfoMETA& changeInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrChangeVirtualKeyboardTextContextMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrChangeVirtualKeyboardTextContextMETA>
   *
   * @xrentity{xrChangeVirtualKeyboardTextContextMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result changeVirtualKeyboardTextContextMETA(
      const VirtualKeyboardTextContextChangeInfoMETA& changeInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrChangeVirtualKeyboardTextContextMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrChangeVirtualKeyboardTextContextMETA>
   *
   * @xrentity{xrChangeVirtualKeyboardTextContextMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void changeVirtualKeyboardTextContextMETA(
      const VirtualKeyboardTextContextChangeInfoMETA& changeInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrVirtualKeyboardMETA val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrVirtualKeyboardMETA) == sizeof(VirtualKeyboardMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrVirtualKeyboardMETA from an VirtualKeyboardMETA value.
 *
 * @found_by_adl
 * @see VirtualKeyboardMETA::get()
 * @relates VirtualKeyboardMETA
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrVirtualKeyboardMETA
get(VirtualKeyboardMETA const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrVirtualKeyboardMETA handle in a VirtualKeyboardMETA (by reference).
 *
 * e.g.
 * ```
 * VirtualKeyboardMETA yourHandle;
 * auto result = d.xrCreateVirtualKeyboardMETA(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates VirtualKeyboardMETA
 */
static OPENXR_HPP_INLINE XrVirtualKeyboardMETA* put(VirtualKeyboardMETA& h,
                                                    bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between VirtualKeyboardMETA values.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(VirtualKeyboardMETA const& lhs,
                                                      VirtualKeyboardMETA const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between VirtualKeyboardMETA values.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(VirtualKeyboardMETA const& lhs,
                                                      VirtualKeyboardMETA const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between VirtualKeyboardMETA values.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(VirtualKeyboardMETA const& lhs,
                                                       VirtualKeyboardMETA const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between VirtualKeyboardMETA values.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(VirtualKeyboardMETA const& lhs,
                                                       VirtualKeyboardMETA const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between VirtualKeyboardMETA values.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(VirtualKeyboardMETA const& lhs,
                                                       VirtualKeyboardMETA const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between VirtualKeyboardMETA values.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(VirtualKeyboardMETA const& lhs,
                                                       VirtualKeyboardMETA const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between VirtualKeyboardMETA and raw XrVirtualKeyboardMETA.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(VirtualKeyboardMETA const& lhs,
                                                      XrVirtualKeyboardMETA rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrVirtualKeyboardMETA and VirtualKeyboardMETA.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrVirtualKeyboardMETA lhs,
                                                      VirtualKeyboardMETA const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between VirtualKeyboardMETA and raw XrVirtualKeyboardMETA.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(VirtualKeyboardMETA const& lhs,
                                                      XrVirtualKeyboardMETA rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrVirtualKeyboardMETA and VirtualKeyboardMETA.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrVirtualKeyboardMETA lhs,
                                                      VirtualKeyboardMETA const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between VirtualKeyboardMETA and raw XrVirtualKeyboardMETA.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(VirtualKeyboardMETA const& lhs,
                                                       XrVirtualKeyboardMETA rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrVirtualKeyboardMETA and VirtualKeyboardMETA.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrVirtualKeyboardMETA lhs,
                                                       VirtualKeyboardMETA const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between VirtualKeyboardMETA and raw XrVirtualKeyboardMETA.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(VirtualKeyboardMETA const& lhs,
                                                       XrVirtualKeyboardMETA rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrVirtualKeyboardMETA and VirtualKeyboardMETA.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrVirtualKeyboardMETA lhs,
                                                       VirtualKeyboardMETA const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between VirtualKeyboardMETA and raw XrVirtualKeyboardMETA.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(VirtualKeyboardMETA const& lhs,
                                                       XrVirtualKeyboardMETA rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrVirtualKeyboardMETA and VirtualKeyboardMETA.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrVirtualKeyboardMETA lhs,
                                                       VirtualKeyboardMETA const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between VirtualKeyboardMETA and raw XrVirtualKeyboardMETA.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(VirtualKeyboardMETA const& lhs,
                                                       XrVirtualKeyboardMETA rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrVirtualKeyboardMETA and VirtualKeyboardMETA.
//! @relates VirtualKeyboardMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrVirtualKeyboardMETA lhs,
                                                       VirtualKeyboardMETA const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between VirtualKeyboardMETA and nullptr: true if the handle is null.
 * @relates VirtualKeyboardMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(VirtualKeyboardMETA const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and VirtualKeyboardMETA: true if the handle is null.
 * @relates VirtualKeyboardMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       VirtualKeyboardMETA const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between VirtualKeyboardMETA and nullptr: true if the handle is not
 * null.
 * @relates VirtualKeyboardMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(VirtualKeyboardMETA const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and VirtualKeyboardMETA: true if the handle is not
 * null.
 * @relates VirtualKeyboardMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       VirtualKeyboardMETA const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_META_virtual_keyboard

#ifdef XR_META_passthrough_color_lut

/*!
 * @brief Handle class - wrapping XrPassthroughColorLutMETA without indicating ownership.
 *
 * Provided by the `XR_META_passthrough_color_lut` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughColorLutMETA>
 *
 * @xrentity{XrPassthroughColorLutMETA}
 * @ingroup handles
 */
class PassthroughColorLutMETA {
public:
  using Type = PassthroughColorLutMETA;
  using RawHandleType = XrPassthroughColorLutMETA;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR PassthroughColorLutMETA() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrPassthroughColorLutMETA type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT PassthroughColorLutMETA(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR PassthroughColorLutMETA(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrPassthroughColorLutMETA
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrPassthroughColorLutMETA type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this PassthroughColorLutMETA value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this PassthroughColorLutMETA value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrPassthroughColorLutMETA manipulation
   * @{
   */
  //! Gets the raw XrPassthroughColorLutMETA value.
  OPENXR_HPP_CONSTEXPR XrPassthroughColorLutMETA get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * PassthroughColorLutMETA yourHandle;
   * auto result = d.xrCreatePassthroughColorLutMETA(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(PassthroughColorLutMETA&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyPassthroughColorLutMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughColorLutMETA>
   *
   * @xrentity{xrDestroyPassthroughColorLutMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyPassthroughColorLutMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughColorLutMETA>
   *
   * @xrentity{xrDestroyPassthroughColorLutMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyPassthroughColorLutMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughColorLutMETA>
   *
   * @xrentity{xrDestroyPassthroughColorLutMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrUpdatePassthroughColorLutMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdatePassthroughColorLutMETA>
   *
   * @xrentity{xrUpdatePassthroughColorLutMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result updatePassthroughColorLutMETA(const PassthroughColorLutUpdateInfoMETA& updateInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUpdatePassthroughColorLutMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdatePassthroughColorLutMETA>
   *
   * @xrentity{xrUpdatePassthroughColorLutMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result updatePassthroughColorLutMETA(const PassthroughColorLutUpdateInfoMETA& updateInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUpdatePassthroughColorLutMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUpdatePassthroughColorLutMETA>
   *
   * @xrentity{xrUpdatePassthroughColorLutMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void updatePassthroughColorLutMETA(const PassthroughColorLutUpdateInfoMETA& updateInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrPassthroughColorLutMETA val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrPassthroughColorLutMETA) == sizeof(PassthroughColorLutMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrPassthroughColorLutMETA from an
 * PassthroughColorLutMETA value.
 *
 * @found_by_adl
 * @see PassthroughColorLutMETA::get()
 * @relates PassthroughColorLutMETA
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrPassthroughColorLutMETA
get(PassthroughColorLutMETA const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrPassthroughColorLutMETA handle in a PassthroughColorLutMETA (by reference).
 *
 * e.g.
 * ```
 * PassthroughColorLutMETA yourHandle;
 * auto result = d.xrCreatePassthroughColorLutMETA(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates PassthroughColorLutMETA
 */
static OPENXR_HPP_INLINE XrPassthroughColorLutMETA* put(PassthroughColorLutMETA& h,
                                                        bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between PassthroughColorLutMETA values.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PassthroughColorLutMETA const& lhs,
                                                      PassthroughColorLutMETA const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between PassthroughColorLutMETA values.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PassthroughColorLutMETA const& lhs,
                                                      PassthroughColorLutMETA const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between PassthroughColorLutMETA values.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    PassthroughColorLutMETA const& lhs, PassthroughColorLutMETA const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between PassthroughColorLutMETA values.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    PassthroughColorLutMETA const& lhs, PassthroughColorLutMETA const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between PassthroughColorLutMETA values.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    PassthroughColorLutMETA const& lhs, PassthroughColorLutMETA const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between PassthroughColorLutMETA values.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    PassthroughColorLutMETA const& lhs, PassthroughColorLutMETA const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between PassthroughColorLutMETA and raw XrPassthroughColorLutMETA.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PassthroughColorLutMETA const& lhs,
                                                      XrPassthroughColorLutMETA rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrPassthroughColorLutMETA and PassthroughColorLutMETA.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrPassthroughColorLutMETA lhs,
                                                      PassthroughColorLutMETA const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between PassthroughColorLutMETA and raw XrPassthroughColorLutMETA.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PassthroughColorLutMETA const& lhs,
                                                      XrPassthroughColorLutMETA rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrPassthroughColorLutMETA and PassthroughColorLutMETA.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrPassthroughColorLutMETA lhs,
                                                      PassthroughColorLutMETA const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between PassthroughColorLutMETA and raw XrPassthroughColorLutMETA.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PassthroughColorLutMETA const& lhs,
                                                       XrPassthroughColorLutMETA rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrPassthroughColorLutMETA and PassthroughColorLutMETA.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    XrPassthroughColorLutMETA lhs, PassthroughColorLutMETA const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between PassthroughColorLutMETA and raw XrPassthroughColorLutMETA.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PassthroughColorLutMETA const& lhs,
                                                       XrPassthroughColorLutMETA rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrPassthroughColorLutMETA and PassthroughColorLutMETA.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    XrPassthroughColorLutMETA lhs, PassthroughColorLutMETA const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between PassthroughColorLutMETA and raw XrPassthroughColorLutMETA.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughColorLutMETA const& lhs,
                                                       XrPassthroughColorLutMETA rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrPassthroughColorLutMETA and PassthroughColorLutMETA.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    XrPassthroughColorLutMETA lhs, PassthroughColorLutMETA const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between PassthroughColorLutMETA and raw XrPassthroughColorLutMETA.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughColorLutMETA const& lhs,
                                                       XrPassthroughColorLutMETA rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrPassthroughColorLutMETA and PassthroughColorLutMETA.
//! @relates PassthroughColorLutMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    XrPassthroughColorLutMETA lhs, PassthroughColorLutMETA const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between PassthroughColorLutMETA and nullptr: true if the handle is
 * null.
 * @relates PassthroughColorLutMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughColorLutMETA const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and PassthroughColorLutMETA: true if the handle is
 * null.
 * @relates PassthroughColorLutMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    std::nullptr_t /* unused */, PassthroughColorLutMETA const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between PassthroughColorLutMETA and nullptr: true if the handle is
 * not null.
 * @relates PassthroughColorLutMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughColorLutMETA const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and PassthroughColorLutMETA: true if the handle is
 * not null.
 * @relates PassthroughColorLutMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    std::nullptr_t /* unused */, PassthroughColorLutMETA const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_META_passthrough_color_lut

#ifdef XR_FB_face_tracking2

/*!
 * @brief Handle class - wrapping XrFaceTracker2FB without indicating ownership.
 *
 * Provided by the `XR_FB_face_tracking2` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFaceTracker2FB>
 *
 * @xrentity{XrFaceTracker2FB}
 * @ingroup handles
 */
class FaceTracker2FB {
public:
  using Type = FaceTracker2FB;
  using RawHandleType = XrFaceTracker2FB;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR FaceTracker2FB() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrFaceTracker2FB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT FaceTracker2FB(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR FaceTracker2FB(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrFaceTracker2FB
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrFaceTracker2FB type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this FaceTracker2FB value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this FaceTracker2FB value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrFaceTracker2FB manipulation
   * @{
   */
  //! Gets the raw XrFaceTracker2FB value.
  OPENXR_HPP_CONSTEXPR XrFaceTracker2FB get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * FaceTracker2FB yourHandle;
   * auto result = d.xrCreateFaceTracker2FB(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(FaceTracker2FB&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyFaceTracker2FB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFaceTracker2FB>
   *
   * @xrentity{xrDestroyFaceTracker2FB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyFaceTracker2FB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFaceTracker2FB>
   *
   * @xrentity{xrDestroyFaceTracker2FB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyFaceTracker2FB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFaceTracker2FB>
   *
   * @xrentity{xrDestroyFaceTracker2FB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetFaceExpressionWeights2FB wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFaceExpressionWeights2FB>
   *
   * @xrentity{xrGetFaceExpressionWeights2FB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getFaceExpressionWeights2FB(const FaceExpressionInfo2FB& expressionInfo,
                                     FaceExpressionWeights2FB& expressionWeights,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetFaceExpressionWeights2FB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFaceExpressionWeights2FB>
   *
   * @xrentity{xrGetFaceExpressionWeights2FB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getFaceExpressionWeights2FB(const FaceExpressionInfo2FB& expressionInfo,
                                     FaceExpressionWeights2FB& expressionWeights,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetFaceExpressionWeights2FB enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFaceExpressionWeights2FB>
   *
   * @xrentity{xrGetFaceExpressionWeights2FB}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getFaceExpressionWeights2FB(const FaceExpressionInfo2FB& expressionInfo,
                                   FaceExpressionWeights2FB& expressionWeights,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrFaceTracker2FB val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrFaceTracker2FB) == sizeof(FaceTracker2FB),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrFaceTracker2FB from an FaceTracker2FB value.
 *
 * @found_by_adl
 * @see FaceTracker2FB::get()
 * @relates FaceTracker2FB
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrFaceTracker2FB get(FaceTracker2FB const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrFaceTracker2FB handle in a FaceTracker2FB (by reference).
 *
 * e.g.
 * ```
 * FaceTracker2FB yourHandle;
 * auto result = d.xrCreateFaceTracker2FB(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates FaceTracker2FB
 */
static OPENXR_HPP_INLINE XrFaceTracker2FB* put(FaceTracker2FB& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between FaceTracker2FB values.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FaceTracker2FB const& lhs,
                                                      FaceTracker2FB const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between FaceTracker2FB values.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FaceTracker2FB const& lhs,
                                                      FaceTracker2FB const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between FaceTracker2FB values.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FaceTracker2FB const& lhs,
                                                       FaceTracker2FB const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between FaceTracker2FB values.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FaceTracker2FB const& lhs,
                                                       FaceTracker2FB const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between FaceTracker2FB values.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FaceTracker2FB const& lhs,
                                                       FaceTracker2FB const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between FaceTracker2FB values.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FaceTracker2FB const& lhs,
                                                       FaceTracker2FB const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between FaceTracker2FB and raw XrFaceTracker2FB.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FaceTracker2FB const& lhs,
                                                      XrFaceTracker2FB rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrFaceTracker2FB and FaceTracker2FB.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrFaceTracker2FB lhs,
                                                      FaceTracker2FB const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between FaceTracker2FB and raw XrFaceTracker2FB.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FaceTracker2FB const& lhs,
                                                      XrFaceTracker2FB rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrFaceTracker2FB and FaceTracker2FB.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrFaceTracker2FB lhs,
                                                      FaceTracker2FB const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between FaceTracker2FB and raw XrFaceTracker2FB.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FaceTracker2FB const& lhs,
                                                       XrFaceTracker2FB rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrFaceTracker2FB and FaceTracker2FB.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrFaceTracker2FB lhs,
                                                       FaceTracker2FB const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between FaceTracker2FB and raw XrFaceTracker2FB.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FaceTracker2FB const& lhs,
                                                       XrFaceTracker2FB rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrFaceTracker2FB and FaceTracker2FB.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrFaceTracker2FB lhs,
                                                       FaceTracker2FB const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between FaceTracker2FB and raw XrFaceTracker2FB.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FaceTracker2FB const& lhs,
                                                       XrFaceTracker2FB rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrFaceTracker2FB and FaceTracker2FB.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrFaceTracker2FB lhs,
                                                       FaceTracker2FB const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between FaceTracker2FB and raw XrFaceTracker2FB.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FaceTracker2FB const& lhs,
                                                       XrFaceTracker2FB rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrFaceTracker2FB and FaceTracker2FB.
//! @relates FaceTracker2FB
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrFaceTracker2FB lhs,
                                                       FaceTracker2FB const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between FaceTracker2FB and nullptr: true if the handle is null.
 * @relates FaceTracker2FB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FaceTracker2FB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and FaceTracker2FB: true if the handle is null.
 * @relates FaceTracker2FB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       FaceTracker2FB const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between FaceTracker2FB and nullptr: true if the handle is not null.
 * @relates FaceTracker2FB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FaceTracker2FB const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and FaceTracker2FB: true if the handle is not null.
 * @relates FaceTracker2FB
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       FaceTracker2FB const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_FB_face_tracking2

#ifdef XR_META_environment_depth

/*!
 * @brief Handle class - wrapping XrEnvironmentDepthProviderMETA without indicating ownership.
 *
 * Provided by the `XR_META_environment_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEnvironmentDepthProviderMETA>
 *
 * @xrentity{XrEnvironmentDepthProviderMETA}
 * @ingroup handles
 */
class EnvironmentDepthProviderMETA {
public:
  using Type = EnvironmentDepthProviderMETA;
  using RawHandleType = XrEnvironmentDepthProviderMETA;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR EnvironmentDepthProviderMETA() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrEnvironmentDepthProviderMETA type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT EnvironmentDepthProviderMETA(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR EnvironmentDepthProviderMETA(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrEnvironmentDepthProviderMETA
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrEnvironmentDepthProviderMETA type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this EnvironmentDepthProviderMETA value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this EnvironmentDepthProviderMETA value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrEnvironmentDepthProviderMETA manipulation
   * @{
   */
  //! Gets the raw XrEnvironmentDepthProviderMETA value.
  OPENXR_HPP_CONSTEXPR XrEnvironmentDepthProviderMETA get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * EnvironmentDepthProviderMETA yourHandle;
   * auto result = d.xrCreateEnvironmentDepthProviderMETA(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(EnvironmentDepthProviderMETA&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyEnvironmentDepthProviderMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrDestroyEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyEnvironmentDepthProviderMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrDestroyEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyEnvironmentDepthProviderMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrDestroyEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrStartEnvironmentDepthProviderMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrStartEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result startEnvironmentDepthProviderMETA(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStartEnvironmentDepthProviderMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrStartEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result startEnvironmentDepthProviderMETA(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStartEnvironmentDepthProviderMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrStartEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void startEnvironmentDepthProviderMETA(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrStopEnvironmentDepthProviderMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrStopEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stopEnvironmentDepthProviderMETA(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStopEnvironmentDepthProviderMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrStopEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stopEnvironmentDepthProviderMETA(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStopEnvironmentDepthProviderMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopEnvironmentDepthProviderMETA>
   *
   * @xrentity{xrStopEnvironmentDepthProviderMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void stopEnvironmentDepthProviderMETA(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateEnvironmentDepthSwapchainMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEnvironmentDepthSwapchainMETA>
   *
   * @xrentity{xrCreateEnvironmentDepthSwapchainMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createEnvironmentDepthSwapchainMETA(
      const EnvironmentDepthSwapchainCreateInfoMETA& createInfo,
      EnvironmentDepthSwapchainMETA& swapchain,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateEnvironmentDepthSwapchainMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type EnvironmentDepthSwapchainMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEnvironmentDepthSwapchainMETA>
   *
   * @xrentity{xrCreateEnvironmentDepthSwapchainMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<EnvironmentDepthSwapchainMETA> createEnvironmentDepthSwapchainMETA(
      const EnvironmentDepthSwapchainCreateInfoMETA& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateEnvironmentDepthSwapchainMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type EnvironmentDepthSwapchainMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEnvironmentDepthSwapchainMETA>
   *
   * @xrentity{xrCreateEnvironmentDepthSwapchainMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  EnvironmentDepthSwapchainMETA createEnvironmentDepthSwapchainMETA(
      const EnvironmentDepthSwapchainCreateInfoMETA& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateEnvironmentDepthSwapchainMETA wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a EnvironmentDepthSwapchainMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEnvironmentDepthSwapchainMETA>
   *
   * @xrentity{xrCreateEnvironmentDepthSwapchainMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<EnvironmentDepthSwapchainMETA, impl::RemoveRefConst<Dispatch>>>
  createEnvironmentDepthSwapchainUniqueMETA(
      const EnvironmentDepthSwapchainCreateInfoMETA& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateEnvironmentDepthSwapchainMETA wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a EnvironmentDepthSwapchainMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateEnvironmentDepthSwapchainMETA>
   *
   * @xrentity{xrCreateEnvironmentDepthSwapchainMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<EnvironmentDepthSwapchainMETA, impl::RemoveRefConst<Dispatch>>
  createEnvironmentDepthSwapchainUniqueMETA(
      const EnvironmentDepthSwapchainCreateInfoMETA& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrAcquireEnvironmentDepthImageMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAcquireEnvironmentDepthImageMETA>
   *
   * @xrentity{xrAcquireEnvironmentDepthImageMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result acquireEnvironmentDepthImageMETA(const EnvironmentDepthImageAcquireInfoMETA& acquireInfo,
                                          EnvironmentDepthImageMETA& environmentDepthImage,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrAcquireEnvironmentDepthImageMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Throws an appropriate exception on failure if `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * @returns Result (which may be Result::Success, Result::EnvironmentDepthNotAvailableMETA, or an
   * error code if asserts are not active and exceptions are disabled)
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAcquireEnvironmentDepthImageMETA>
   *
   * @xrentity{xrAcquireEnvironmentDepthImageMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result acquireEnvironmentDepthImageMETA(const EnvironmentDepthImageAcquireInfoMETA& acquireInfo,
                                          EnvironmentDepthImageMETA& environmentDepthImage,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrSetEnvironmentDepthHandRemovalMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetEnvironmentDepthHandRemovalMETA>
   *
   * @xrentity{xrSetEnvironmentDepthHandRemovalMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setEnvironmentDepthHandRemovalMETA(const EnvironmentDepthHandRemovalSetInfoMETA& setInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrSetEnvironmentDepthHandRemovalMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetEnvironmentDepthHandRemovalMETA>
   *
   * @xrentity{xrSetEnvironmentDepthHandRemovalMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result setEnvironmentDepthHandRemovalMETA(const EnvironmentDepthHandRemovalSetInfoMETA& setInfo,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrSetEnvironmentDepthHandRemovalMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrSetEnvironmentDepthHandRemovalMETA>
   *
   * @xrentity{xrSetEnvironmentDepthHandRemovalMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void setEnvironmentDepthHandRemovalMETA(const EnvironmentDepthHandRemovalSetInfoMETA& setInfo,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrEnvironmentDepthProviderMETA val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrEnvironmentDepthProviderMETA) == sizeof(EnvironmentDepthProviderMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrEnvironmentDepthProviderMETA from an
 * EnvironmentDepthProviderMETA value.
 *
 * @found_by_adl
 * @see EnvironmentDepthProviderMETA::get()
 * @relates EnvironmentDepthProviderMETA
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrEnvironmentDepthProviderMETA
get(EnvironmentDepthProviderMETA const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrEnvironmentDepthProviderMETA handle in a EnvironmentDepthProviderMETA (by reference).
 *
 * e.g.
 * ```
 * EnvironmentDepthProviderMETA yourHandle;
 * auto result = d.xrCreateEnvironmentDepthProviderMETA(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates EnvironmentDepthProviderMETA
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthProviderMETA* put(EnvironmentDepthProviderMETA& h,
                                                             bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between EnvironmentDepthProviderMETA values.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    EnvironmentDepthProviderMETA const& lhs, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between EnvironmentDepthProviderMETA values.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    EnvironmentDepthProviderMETA const& lhs, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between EnvironmentDepthProviderMETA values.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    EnvironmentDepthProviderMETA const& lhs, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between EnvironmentDepthProviderMETA values.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    EnvironmentDepthProviderMETA const& lhs, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between EnvironmentDepthProviderMETA values.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    EnvironmentDepthProviderMETA const& lhs, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between EnvironmentDepthProviderMETA values.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    EnvironmentDepthProviderMETA const& lhs, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between EnvironmentDepthProviderMETA and raw
//! XrEnvironmentDepthProviderMETA.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(EnvironmentDepthProviderMETA const& lhs,
                                                      XrEnvironmentDepthProviderMETA rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrEnvironmentDepthProviderMETA and
//! EnvironmentDepthProviderMETA.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    XrEnvironmentDepthProviderMETA lhs, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between EnvironmentDepthProviderMETA and raw
//! XrEnvironmentDepthProviderMETA.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(EnvironmentDepthProviderMETA const& lhs,
                                                      XrEnvironmentDepthProviderMETA rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrEnvironmentDepthProviderMETA and
//! EnvironmentDepthProviderMETA.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    XrEnvironmentDepthProviderMETA lhs, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between EnvironmentDepthProviderMETA and raw
//! XrEnvironmentDepthProviderMETA.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    EnvironmentDepthProviderMETA const& lhs, XrEnvironmentDepthProviderMETA rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrEnvironmentDepthProviderMETA and
//! EnvironmentDepthProviderMETA.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    XrEnvironmentDepthProviderMETA lhs, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between EnvironmentDepthProviderMETA and raw
//! XrEnvironmentDepthProviderMETA.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    EnvironmentDepthProviderMETA const& lhs, XrEnvironmentDepthProviderMETA rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrEnvironmentDepthProviderMETA and
//! EnvironmentDepthProviderMETA.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    XrEnvironmentDepthProviderMETA lhs, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between EnvironmentDepthProviderMETA and raw
//! XrEnvironmentDepthProviderMETA.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    EnvironmentDepthProviderMETA const& lhs, XrEnvironmentDepthProviderMETA rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrEnvironmentDepthProviderMETA and
//! EnvironmentDepthProviderMETA.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    XrEnvironmentDepthProviderMETA lhs, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between EnvironmentDepthProviderMETA and raw
//! XrEnvironmentDepthProviderMETA.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    EnvironmentDepthProviderMETA const& lhs, XrEnvironmentDepthProviderMETA rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrEnvironmentDepthProviderMETA and
//! EnvironmentDepthProviderMETA.
//! @relates EnvironmentDepthProviderMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    XrEnvironmentDepthProviderMETA lhs, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between EnvironmentDepthProviderMETA and nullptr: true if the handle
 * is null.
 * @relates EnvironmentDepthProviderMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(EnvironmentDepthProviderMETA const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and EnvironmentDepthProviderMETA: true if the handle
 * is null.
 * @relates EnvironmentDepthProviderMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    std::nullptr_t /* unused */, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between EnvironmentDepthProviderMETA and nullptr: true if the handle
 * is not null.
 * @relates EnvironmentDepthProviderMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(EnvironmentDepthProviderMETA const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and EnvironmentDepthProviderMETA: true if the handle
 * is not null.
 * @relates EnvironmentDepthProviderMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    std::nullptr_t /* unused */, EnvironmentDepthProviderMETA const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_META_environment_depth

#ifdef XR_META_environment_depth

/*!
 * @brief Handle class - wrapping XrEnvironmentDepthSwapchainMETA without indicating ownership.
 *
 * Provided by the `XR_META_environment_depth` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrEnvironmentDepthSwapchainMETA>
 *
 * @xrentity{XrEnvironmentDepthSwapchainMETA}
 * @ingroup handles
 */
class EnvironmentDepthSwapchainMETA {
public:
  using Type = EnvironmentDepthSwapchainMETA;
  using RawHandleType = XrEnvironmentDepthSwapchainMETA;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR EnvironmentDepthSwapchainMETA() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrEnvironmentDepthSwapchainMETA type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT EnvironmentDepthSwapchainMETA(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR EnvironmentDepthSwapchainMETA(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrEnvironmentDepthSwapchainMETA
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrEnvironmentDepthSwapchainMETA type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this EnvironmentDepthSwapchainMETA value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this EnvironmentDepthSwapchainMETA value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrEnvironmentDepthSwapchainMETA manipulation
   * @{
   */
  //! Gets the raw XrEnvironmentDepthSwapchainMETA value.
  OPENXR_HPP_CONSTEXPR XrEnvironmentDepthSwapchainMETA get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * EnvironmentDepthSwapchainMETA yourHandle;
   * auto result = d.xrCreateEnvironmentDepthSwapchainMETA(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(EnvironmentDepthSwapchainMETA&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyEnvironmentDepthSwapchainMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyEnvironmentDepthSwapchainMETA>
   *
   * @xrentity{xrDestroyEnvironmentDepthSwapchainMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyEnvironmentDepthSwapchainMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyEnvironmentDepthSwapchainMETA>
   *
   * @xrentity{xrDestroyEnvironmentDepthSwapchainMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyEnvironmentDepthSwapchainMETA enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyEnvironmentDepthSwapchainMETA>
   *
   * @xrentity{xrDestroyEnvironmentDepthSwapchainMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrEnumerateEnvironmentDepthSwapchainImagesMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentDepthSwapchainImagesMETA>
   *
   * @xrentity{xrEnumerateEnvironmentDepthSwapchainImagesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateEnvironmentDepthSwapchainImagesMETA(
      uint32_t imageCapacityInput, uint32_t& imageCountOutput, SwapchainImageBaseHeader* images,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateEnvironmentDepthSwapchainImagesMETA enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentDepthSwapchainImagesMETA>
   *
   * @xrentity{xrEnumerateEnvironmentDepthSwapchainImagesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateEnvironmentDepthSwapchainImagesMETA(
      uint32_t imageCapacityInput, uint32_t& imageCountOutput, SwapchainImageBaseHeader* images,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrEnumerateEnvironmentDepthSwapchainImagesMETA enhanced wrapper (hides basic wrapper
   * unless `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateEnvironmentDepthSwapchainImagesMETA>
   *
   * @xrentity{xrEnumerateEnvironmentDepthSwapchainImagesMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void enumerateEnvironmentDepthSwapchainImagesMETA(
      uint32_t imageCapacityInput, uint32_t& imageCountOutput, SwapchainImageBaseHeader* images,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetEnvironmentDepthSwapchainStateMETA wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetEnvironmentDepthSwapchainStateMETA>
   *
   * @xrentity{xrGetEnvironmentDepthSwapchainStateMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getEnvironmentDepthSwapchainStateMETA(EnvironmentDepthSwapchainStateMETA& state,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetEnvironmentDepthSwapchainStateMETA enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type EnvironmentDepthSwapchainStateMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetEnvironmentDepthSwapchainStateMETA>
   *
   * @xrentity{xrGetEnvironmentDepthSwapchainStateMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<EnvironmentDepthSwapchainStateMETA> getEnvironmentDepthSwapchainStateMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetEnvironmentDepthSwapchainStateMETA enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type EnvironmentDepthSwapchainStateMETA
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetEnvironmentDepthSwapchainStateMETA>
   *
   * @xrentity{xrGetEnvironmentDepthSwapchainStateMETA}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  EnvironmentDepthSwapchainStateMETA getEnvironmentDepthSwapchainStateMETA(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrEnvironmentDepthSwapchainMETA val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrEnvironmentDepthSwapchainMETA) == sizeof(EnvironmentDepthSwapchainMETA),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrEnvironmentDepthSwapchainMETA from an
 * EnvironmentDepthSwapchainMETA value.
 *
 * @found_by_adl
 * @see EnvironmentDepthSwapchainMETA::get()
 * @relates EnvironmentDepthSwapchainMETA
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrEnvironmentDepthSwapchainMETA
get(EnvironmentDepthSwapchainMETA const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrEnvironmentDepthSwapchainMETA handle in a EnvironmentDepthSwapchainMETA (by reference).
 *
 * e.g.
 * ```
 * EnvironmentDepthSwapchainMETA yourHandle;
 * auto result = d.xrCreateEnvironmentDepthSwapchainMETA(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates EnvironmentDepthSwapchainMETA
 */
static OPENXR_HPP_INLINE XrEnvironmentDepthSwapchainMETA* put(EnvironmentDepthSwapchainMETA& h,
                                                              bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between EnvironmentDepthSwapchainMETA values.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    EnvironmentDepthSwapchainMETA const& lhs, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between EnvironmentDepthSwapchainMETA values.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    EnvironmentDepthSwapchainMETA const& lhs, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between EnvironmentDepthSwapchainMETA values.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    EnvironmentDepthSwapchainMETA const& lhs, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between EnvironmentDepthSwapchainMETA values.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    EnvironmentDepthSwapchainMETA const& lhs, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between EnvironmentDepthSwapchainMETA values.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    EnvironmentDepthSwapchainMETA const& lhs, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between EnvironmentDepthSwapchainMETA values.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    EnvironmentDepthSwapchainMETA const& lhs, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between EnvironmentDepthSwapchainMETA and raw
//! XrEnvironmentDepthSwapchainMETA.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    EnvironmentDepthSwapchainMETA const& lhs, XrEnvironmentDepthSwapchainMETA rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrEnvironmentDepthSwapchainMETA and
//! EnvironmentDepthSwapchainMETA.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    XrEnvironmentDepthSwapchainMETA lhs, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between EnvironmentDepthSwapchainMETA and raw
//! XrEnvironmentDepthSwapchainMETA.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    EnvironmentDepthSwapchainMETA const& lhs, XrEnvironmentDepthSwapchainMETA rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrEnvironmentDepthSwapchainMETA and
//! EnvironmentDepthSwapchainMETA.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    XrEnvironmentDepthSwapchainMETA lhs, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between EnvironmentDepthSwapchainMETA and raw
//! XrEnvironmentDepthSwapchainMETA.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    EnvironmentDepthSwapchainMETA const& lhs, XrEnvironmentDepthSwapchainMETA rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrEnvironmentDepthSwapchainMETA and
//! EnvironmentDepthSwapchainMETA.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    XrEnvironmentDepthSwapchainMETA lhs, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between EnvironmentDepthSwapchainMETA and raw
//! XrEnvironmentDepthSwapchainMETA.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    EnvironmentDepthSwapchainMETA const& lhs, XrEnvironmentDepthSwapchainMETA rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrEnvironmentDepthSwapchainMETA and
//! EnvironmentDepthSwapchainMETA.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    XrEnvironmentDepthSwapchainMETA lhs, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between EnvironmentDepthSwapchainMETA and raw
//! XrEnvironmentDepthSwapchainMETA.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    EnvironmentDepthSwapchainMETA const& lhs, XrEnvironmentDepthSwapchainMETA rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrEnvironmentDepthSwapchainMETA and
//! EnvironmentDepthSwapchainMETA.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    XrEnvironmentDepthSwapchainMETA lhs, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between EnvironmentDepthSwapchainMETA and raw
//! XrEnvironmentDepthSwapchainMETA.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    EnvironmentDepthSwapchainMETA const& lhs, XrEnvironmentDepthSwapchainMETA rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrEnvironmentDepthSwapchainMETA and
//! EnvironmentDepthSwapchainMETA.
//! @relates EnvironmentDepthSwapchainMETA
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    XrEnvironmentDepthSwapchainMETA lhs, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between EnvironmentDepthSwapchainMETA and nullptr: true if the handle
 * is null.
 * @relates EnvironmentDepthSwapchainMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(EnvironmentDepthSwapchainMETA const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and EnvironmentDepthSwapchainMETA: true if the handle
 * is null.
 * @relates EnvironmentDepthSwapchainMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    std::nullptr_t /* unused */, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between EnvironmentDepthSwapchainMETA and nullptr: true if the
 * handle is not null.
 * @relates EnvironmentDepthSwapchainMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(EnvironmentDepthSwapchainMETA const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and EnvironmentDepthSwapchainMETA: true if the
 * handle is not null.
 * @relates EnvironmentDepthSwapchainMETA
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    std::nullptr_t /* unused */, EnvironmentDepthSwapchainMETA const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_META_environment_depth

#ifdef XR_EXT_render_model

/*!
 * @brief Handle class - wrapping XrRenderModelEXT without indicating ownership.
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelEXT>
 *
 * @xrentity{XrRenderModelEXT}
 * @ingroup handles
 */
class RenderModelEXT {
public:
  using Type = RenderModelEXT;
  using RawHandleType = XrRenderModelEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR RenderModelEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrRenderModelEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT RenderModelEXT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR RenderModelEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrRenderModelEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrRenderModelEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this RenderModelEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this RenderModelEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrRenderModelEXT manipulation
   * @{
   */
  //! Gets the raw XrRenderModelEXT value.
  OPENXR_HPP_CONSTEXPR XrRenderModelEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * RenderModelEXT yourHandle;
   * auto result = d.xrCreateRenderModelEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(RenderModelEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyRenderModelEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyRenderModelEXT>
   *
   * @xrentity{xrDestroyRenderModelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyRenderModelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyRenderModelEXT>
   *
   * @xrentity{xrDestroyRenderModelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyRenderModelEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyRenderModelEXT>
   *
   * @xrentity{xrDestroyRenderModelEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetRenderModelPropertiesEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelPropertiesEXT>
   *
   * @xrentity{xrGetRenderModelPropertiesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRenderModelPropertiesEXT(const RenderModelPropertiesGetInfoEXT& getInfo,
                                     RenderModelPropertiesEXT& properties,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetRenderModelPropertiesEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type RenderModelPropertiesEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelPropertiesEXT>
   *
   * @xrentity{xrGetRenderModelPropertiesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<RenderModelPropertiesEXT> getRenderModelPropertiesEXT(
      const RenderModelPropertiesGetInfoEXT& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetRenderModelPropertiesEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type RenderModelPropertiesEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelPropertiesEXT>
   *
   * @xrentity{xrGetRenderModelPropertiesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  RenderModelPropertiesEXT getRenderModelPropertiesEXT(
      const RenderModelPropertiesGetInfoEXT& getInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetRenderModelStateEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelStateEXT>
   *
   * @xrentity{xrGetRenderModelStateEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRenderModelStateEXT(const RenderModelStateGetInfoEXT& getInfo,
                                RenderModelStateEXT& state,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetRenderModelStateEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelStateEXT>
   *
   * @xrentity{xrGetRenderModelStateEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRenderModelStateEXT(const RenderModelStateGetInfoEXT& getInfo,
                                RenderModelStateEXT& state,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetRenderModelStateEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelStateEXT>
   *
   * @xrentity{xrGetRenderModelStateEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getRenderModelStateEXT(const RenderModelStateGetInfoEXT& getInfo, RenderModelStateEXT& state,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_EXT_interaction_render_model

  /*!
   * @brief xrEnumerateRenderModelSubactionPathsEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelSubactionPathsEXT>
   *
   * @xrentity{xrEnumerateRenderModelSubactionPathsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateRenderModelSubactionPathsEXT(
      const InteractionRenderModelSubactionPathInfoEXT& info, uint32_t pathCapacityInput,
      uint32_t& pathCountOutput, Path* paths,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateRenderModelSubactionPathsEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelSubactionPathsEXT>
   *
   * @xrentity{xrEnumerateRenderModelSubactionPathsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Path>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Path, Allocator>> enumerateRenderModelSubactionPathsToVectorEXT(
      const InteractionRenderModelSubactionPathInfoEXT& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateRenderModelSubactionPathsEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelSubactionPathsEXT>
   *
   * @xrentity{xrEnumerateRenderModelSubactionPathsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Path>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Path, Allocator>> enumerateRenderModelSubactionPathsToVectorEXT(
      const InteractionRenderModelSubactionPathInfoEXT& info, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateRenderModelSubactionPathsEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelSubactionPathsEXT>
   *
   * @xrentity{xrEnumerateRenderModelSubactionPathsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Path>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Path, Allocator> enumerateRenderModelSubactionPathsToVectorEXT(
      const InteractionRenderModelSubactionPathInfoEXT& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateRenderModelSubactionPathsEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<Path, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateRenderModelSubactionPathsEXT>
   *
   * @xrentity{xrEnumerateRenderModelSubactionPathsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Path>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Path, Allocator> enumerateRenderModelSubactionPathsToVectorEXT(
      const InteractionRenderModelSubactionPathInfoEXT& info, Allocator const& vectorAllocator,
      Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_interaction_render_model

#ifdef XR_EXT_interaction_render_model

  /*!
   * @brief xrGetRenderModelPoseTopLevelUserPathEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelPoseTopLevelUserPathEXT>
   *
   * @xrentity{xrGetRenderModelPoseTopLevelUserPathEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRenderModelPoseTopLevelUserPathEXT(
      const InteractionRenderModelTopLevelUserPathGetInfoEXT& info, Path& topLevelUserPath,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetRenderModelPoseTopLevelUserPathEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type Path
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelPoseTopLevelUserPathEXT>
   *
   * @xrentity{xrGetRenderModelPoseTopLevelUserPathEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<Path> getRenderModelPoseTopLevelUserPathEXT(
      const InteractionRenderModelTopLevelUserPathGetInfoEXT& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetRenderModelPoseTopLevelUserPathEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type Path
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelPoseTopLevelUserPathEXT>
   *
   * @xrentity{xrGetRenderModelPoseTopLevelUserPathEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Path getRenderModelPoseTopLevelUserPathEXT(
      const InteractionRenderModelTopLevelUserPathGetInfoEXT& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_interaction_render_model

  //! @}
private:
  XrRenderModelEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrRenderModelEXT) == sizeof(RenderModelEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrRenderModelEXT from an RenderModelEXT value.
 *
 * @found_by_adl
 * @see RenderModelEXT::get()
 * @relates RenderModelEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrRenderModelEXT get(RenderModelEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrRenderModelEXT handle in a RenderModelEXT (by reference).
 *
 * e.g.
 * ```
 * RenderModelEXT yourHandle;
 * auto result = d.xrCreateRenderModelEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates RenderModelEXT
 */
static OPENXR_HPP_INLINE XrRenderModelEXT* put(RenderModelEXT& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between RenderModelEXT values.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(RenderModelEXT const& lhs,
                                                      RenderModelEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between RenderModelEXT values.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(RenderModelEXT const& lhs,
                                                      RenderModelEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between RenderModelEXT values.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(RenderModelEXT const& lhs,
                                                       RenderModelEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between RenderModelEXT values.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(RenderModelEXT const& lhs,
                                                       RenderModelEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between RenderModelEXT values.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(RenderModelEXT const& lhs,
                                                       RenderModelEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between RenderModelEXT values.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(RenderModelEXT const& lhs,
                                                       RenderModelEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between RenderModelEXT and raw XrRenderModelEXT.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(RenderModelEXT const& lhs,
                                                      XrRenderModelEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrRenderModelEXT and RenderModelEXT.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrRenderModelEXT lhs,
                                                      RenderModelEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between RenderModelEXT and raw XrRenderModelEXT.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(RenderModelEXT const& lhs,
                                                      XrRenderModelEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrRenderModelEXT and RenderModelEXT.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrRenderModelEXT lhs,
                                                      RenderModelEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between RenderModelEXT and raw XrRenderModelEXT.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(RenderModelEXT const& lhs,
                                                       XrRenderModelEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrRenderModelEXT and RenderModelEXT.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrRenderModelEXT lhs,
                                                       RenderModelEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between RenderModelEXT and raw XrRenderModelEXT.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(RenderModelEXT const& lhs,
                                                       XrRenderModelEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrRenderModelEXT and RenderModelEXT.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrRenderModelEXT lhs,
                                                       RenderModelEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between RenderModelEXT and raw XrRenderModelEXT.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(RenderModelEXT const& lhs,
                                                       XrRenderModelEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrRenderModelEXT and RenderModelEXT.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrRenderModelEXT lhs,
                                                       RenderModelEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between RenderModelEXT and raw XrRenderModelEXT.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(RenderModelEXT const& lhs,
                                                       XrRenderModelEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrRenderModelEXT and RenderModelEXT.
//! @relates RenderModelEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrRenderModelEXT lhs,
                                                       RenderModelEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between RenderModelEXT and nullptr: true if the handle is null.
 * @relates RenderModelEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(RenderModelEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and RenderModelEXT: true if the handle is null.
 * @relates RenderModelEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       RenderModelEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between RenderModelEXT and nullptr: true if the handle is not null.
 * @relates RenderModelEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(RenderModelEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and RenderModelEXT: true if the handle is not null.
 * @relates RenderModelEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       RenderModelEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_EXT_render_model

#ifdef XR_EXT_render_model

/*!
 * @brief Handle class - wrapping XrRenderModelAssetEXT without indicating ownership.
 *
 * Provided by the `XR_EXT_render_model` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrRenderModelAssetEXT>
 *
 * @xrentity{XrRenderModelAssetEXT}
 * @ingroup handles
 */
class RenderModelAssetEXT {
public:
  using Type = RenderModelAssetEXT;
  using RawHandleType = XrRenderModelAssetEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR RenderModelAssetEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrRenderModelAssetEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT RenderModelAssetEXT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR RenderModelAssetEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrRenderModelAssetEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrRenderModelAssetEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this RenderModelAssetEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this RenderModelAssetEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrRenderModelAssetEXT manipulation
   * @{
   */
  //! Gets the raw XrRenderModelAssetEXT value.
  OPENXR_HPP_CONSTEXPR XrRenderModelAssetEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * RenderModelAssetEXT yourHandle;
   * auto result = d.xrCreateRenderModelAssetEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(RenderModelAssetEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyRenderModelAssetEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyRenderModelAssetEXT>
   *
   * @xrentity{xrDestroyRenderModelAssetEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyRenderModelAssetEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyRenderModelAssetEXT>
   *
   * @xrentity{xrDestroyRenderModelAssetEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyRenderModelAssetEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyRenderModelAssetEXT>
   *
   * @xrentity{xrDestroyRenderModelAssetEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetRenderModelAssetDataEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelAssetDataEXT>
   *
   * @xrentity{xrGetRenderModelAssetDataEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRenderModelAssetDataEXT(const RenderModelAssetDataGetInfoEXT& getInfo,
                                    RenderModelAssetDataEXT& buffer,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetRenderModelAssetDataEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelAssetDataEXT>
   *
   * @xrentity{xrGetRenderModelAssetDataEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRenderModelAssetDataEXT(const RenderModelAssetDataGetInfoEXT& getInfo,
                                    RenderModelAssetDataEXT& buffer,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetRenderModelAssetDataEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelAssetDataEXT>
   *
   * @xrentity{xrGetRenderModelAssetDataEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getRenderModelAssetDataEXT(const RenderModelAssetDataGetInfoEXT& getInfo,
                                  RenderModelAssetDataEXT& buffer,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetRenderModelAssetPropertiesEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelAssetPropertiesEXT>
   *
   * @xrentity{xrGetRenderModelAssetPropertiesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRenderModelAssetPropertiesEXT(const RenderModelAssetPropertiesGetInfoEXT& getInfo,
                                          RenderModelAssetPropertiesEXT& properties,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetRenderModelAssetPropertiesEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelAssetPropertiesEXT>
   *
   * @xrentity{xrGetRenderModelAssetPropertiesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getRenderModelAssetPropertiesEXT(const RenderModelAssetPropertiesGetInfoEXT& getInfo,
                                          RenderModelAssetPropertiesEXT& properties,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetRenderModelAssetPropertiesEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetRenderModelAssetPropertiesEXT>
   *
   * @xrentity{xrGetRenderModelAssetPropertiesEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getRenderModelAssetPropertiesEXT(const RenderModelAssetPropertiesGetInfoEXT& getInfo,
                                        RenderModelAssetPropertiesEXT& properties,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrRenderModelAssetEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrRenderModelAssetEXT) == sizeof(RenderModelAssetEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrRenderModelAssetEXT from an RenderModelAssetEXT value.
 *
 * @found_by_adl
 * @see RenderModelAssetEXT::get()
 * @relates RenderModelAssetEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrRenderModelAssetEXT
get(RenderModelAssetEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrRenderModelAssetEXT handle in a RenderModelAssetEXT (by reference).
 *
 * e.g.
 * ```
 * RenderModelAssetEXT yourHandle;
 * auto result = d.xrCreateRenderModelAssetEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates RenderModelAssetEXT
 */
static OPENXR_HPP_INLINE XrRenderModelAssetEXT* put(RenderModelAssetEXT& h,
                                                    bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between RenderModelAssetEXT values.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(RenderModelAssetEXT const& lhs,
                                                      RenderModelAssetEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between RenderModelAssetEXT values.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(RenderModelAssetEXT const& lhs,
                                                      RenderModelAssetEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between RenderModelAssetEXT values.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(RenderModelAssetEXT const& lhs,
                                                       RenderModelAssetEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between RenderModelAssetEXT values.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(RenderModelAssetEXT const& lhs,
                                                       RenderModelAssetEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between RenderModelAssetEXT values.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(RenderModelAssetEXT const& lhs,
                                                       RenderModelAssetEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between RenderModelAssetEXT values.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(RenderModelAssetEXT const& lhs,
                                                       RenderModelAssetEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between RenderModelAssetEXT and raw XrRenderModelAssetEXT.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(RenderModelAssetEXT const& lhs,
                                                      XrRenderModelAssetEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrRenderModelAssetEXT and RenderModelAssetEXT.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrRenderModelAssetEXT lhs,
                                                      RenderModelAssetEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between RenderModelAssetEXT and raw XrRenderModelAssetEXT.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(RenderModelAssetEXT const& lhs,
                                                      XrRenderModelAssetEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrRenderModelAssetEXT and RenderModelAssetEXT.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrRenderModelAssetEXT lhs,
                                                      RenderModelAssetEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between RenderModelAssetEXT and raw XrRenderModelAssetEXT.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(RenderModelAssetEXT const& lhs,
                                                       XrRenderModelAssetEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrRenderModelAssetEXT and RenderModelAssetEXT.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrRenderModelAssetEXT lhs,
                                                       RenderModelAssetEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between RenderModelAssetEXT and raw XrRenderModelAssetEXT.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(RenderModelAssetEXT const& lhs,
                                                       XrRenderModelAssetEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrRenderModelAssetEXT and RenderModelAssetEXT.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrRenderModelAssetEXT lhs,
                                                       RenderModelAssetEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between RenderModelAssetEXT and raw XrRenderModelAssetEXT.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(RenderModelAssetEXT const& lhs,
                                                       XrRenderModelAssetEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrRenderModelAssetEXT and RenderModelAssetEXT.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrRenderModelAssetEXT lhs,
                                                       RenderModelAssetEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between RenderModelAssetEXT and raw XrRenderModelAssetEXT.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(RenderModelAssetEXT const& lhs,
                                                       XrRenderModelAssetEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrRenderModelAssetEXT and RenderModelAssetEXT.
//! @relates RenderModelAssetEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrRenderModelAssetEXT lhs,
                                                       RenderModelAssetEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between RenderModelAssetEXT and nullptr: true if the handle is null.
 * @relates RenderModelAssetEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(RenderModelAssetEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and RenderModelAssetEXT: true if the handle is null.
 * @relates RenderModelAssetEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       RenderModelAssetEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between RenderModelAssetEXT and nullptr: true if the handle is not
 * null.
 * @relates RenderModelAssetEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(RenderModelAssetEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and RenderModelAssetEXT: true if the handle is not
 * null.
 * @relates RenderModelAssetEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       RenderModelAssetEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_EXT_render_model

#ifdef XR_HTC_passthrough

/*!
 * @brief Handle class - wrapping XrPassthroughHTC without indicating ownership.
 *
 * Provided by the `XR_HTC_passthrough` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPassthroughHTC>
 *
 * @xrentity{XrPassthroughHTC}
 * @ingroup handles
 */
class PassthroughHTC {
public:
  using Type = PassthroughHTC;
  using RawHandleType = XrPassthroughHTC;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR PassthroughHTC() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrPassthroughHTC type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT PassthroughHTC(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR PassthroughHTC(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrPassthroughHTC
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrPassthroughHTC type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this PassthroughHTC value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this PassthroughHTC value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrPassthroughHTC manipulation
   * @{
   */
  //! Gets the raw XrPassthroughHTC value.
  OPENXR_HPP_CONSTEXPR XrPassthroughHTC get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * PassthroughHTC yourHandle;
   * auto result = d.xrCreatePassthroughHTC(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(PassthroughHTC&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyPassthroughHTC wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughHTC>
   *
   * @xrentity{xrDestroyPassthroughHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyPassthroughHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughHTC>
   *
   * @xrentity{xrDestroyPassthroughHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyPassthroughHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPassthroughHTC>
   *
   * @xrentity{xrDestroyPassthroughHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrPassthroughHTC val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrPassthroughHTC) == sizeof(PassthroughHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrPassthroughHTC from an PassthroughHTC value.
 *
 * @found_by_adl
 * @see PassthroughHTC::get()
 * @relates PassthroughHTC
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrPassthroughHTC get(PassthroughHTC const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrPassthroughHTC handle in a PassthroughHTC (by reference).
 *
 * e.g.
 * ```
 * PassthroughHTC yourHandle;
 * auto result = d.xrCreatePassthroughHTC(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates PassthroughHTC
 */
static OPENXR_HPP_INLINE XrPassthroughHTC* put(PassthroughHTC& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between PassthroughHTC values.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PassthroughHTC const& lhs,
                                                      PassthroughHTC const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between PassthroughHTC values.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PassthroughHTC const& lhs,
                                                      PassthroughHTC const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between PassthroughHTC values.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PassthroughHTC const& lhs,
                                                       PassthroughHTC const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between PassthroughHTC values.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PassthroughHTC const& lhs,
                                                       PassthroughHTC const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between PassthroughHTC values.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughHTC const& lhs,
                                                       PassthroughHTC const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between PassthroughHTC values.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughHTC const& lhs,
                                                       PassthroughHTC const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between PassthroughHTC and raw XrPassthroughHTC.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PassthroughHTC const& lhs,
                                                      XrPassthroughHTC rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrPassthroughHTC and PassthroughHTC.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrPassthroughHTC lhs,
                                                      PassthroughHTC const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between PassthroughHTC and raw XrPassthroughHTC.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PassthroughHTC const& lhs,
                                                      XrPassthroughHTC rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrPassthroughHTC and PassthroughHTC.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrPassthroughHTC lhs,
                                                      PassthroughHTC const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between PassthroughHTC and raw XrPassthroughHTC.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PassthroughHTC const& lhs,
                                                       XrPassthroughHTC rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrPassthroughHTC and PassthroughHTC.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrPassthroughHTC lhs,
                                                       PassthroughHTC const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between PassthroughHTC and raw XrPassthroughHTC.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PassthroughHTC const& lhs,
                                                       XrPassthroughHTC rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrPassthroughHTC and PassthroughHTC.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrPassthroughHTC lhs,
                                                       PassthroughHTC const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between PassthroughHTC and raw XrPassthroughHTC.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughHTC const& lhs,
                                                       XrPassthroughHTC rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrPassthroughHTC and PassthroughHTC.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrPassthroughHTC lhs,
                                                       PassthroughHTC const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between PassthroughHTC and raw XrPassthroughHTC.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughHTC const& lhs,
                                                       XrPassthroughHTC rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrPassthroughHTC and PassthroughHTC.
//! @relates PassthroughHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrPassthroughHTC lhs,
                                                       PassthroughHTC const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between PassthroughHTC and nullptr: true if the handle is null.
 * @relates PassthroughHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PassthroughHTC const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and PassthroughHTC: true if the handle is null.
 * @relates PassthroughHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       PassthroughHTC const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between PassthroughHTC and nullptr: true if the handle is not null.
 * @relates PassthroughHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PassthroughHTC const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and PassthroughHTC: true if the handle is not null.
 * @relates PassthroughHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       PassthroughHTC const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_HTC_passthrough

#ifdef XR_HTC_body_tracking

/*!
 * @brief Handle class - wrapping XrBodyTrackerHTC without indicating ownership.
 *
 * Provided by the `XR_HTC_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyTrackerHTC>
 *
 * @xrentity{XrBodyTrackerHTC}
 * @ingroup handles
 */
class BodyTrackerHTC {
public:
  using Type = BodyTrackerHTC;
  using RawHandleType = XrBodyTrackerHTC;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR BodyTrackerHTC() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrBodyTrackerHTC type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT BodyTrackerHTC(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR BodyTrackerHTC(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrBodyTrackerHTC
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrBodyTrackerHTC type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this BodyTrackerHTC value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this BodyTrackerHTC value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrBodyTrackerHTC manipulation
   * @{
   */
  //! Gets the raw XrBodyTrackerHTC value.
  OPENXR_HPP_CONSTEXPR XrBodyTrackerHTC get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * BodyTrackerHTC yourHandle;
   * auto result = d.xrCreateBodyTrackerHTC(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(BodyTrackerHTC&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyBodyTrackerHTC wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyBodyTrackerHTC>
   *
   * @xrentity{xrDestroyBodyTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyBodyTrackerHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyBodyTrackerHTC>
   *
   * @xrentity{xrDestroyBodyTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyBodyTrackerHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyBodyTrackerHTC>
   *
   * @xrentity{xrDestroyBodyTrackerHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrLocateBodyJointsHTC wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateBodyJointsHTC>
   *
   * @xrentity{xrLocateBodyJointsHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateBodyJointsHTC(const BodyJointsLocateInfoHTC& locateInfo,
                             BodyJointLocationsHTC& locations,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateBodyJointsHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateBodyJointsHTC>
   *
   * @xrentity{xrLocateBodyJointsHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateBodyJointsHTC(const BodyJointsLocateInfoHTC& locateInfo,
                             BodyJointLocationsHTC& locations,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateBodyJointsHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateBodyJointsHTC>
   *
   * @xrentity{xrLocateBodyJointsHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void locateBodyJointsHTC(const BodyJointsLocateInfoHTC& locateInfo,
                           BodyJointLocationsHTC& locations,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetBodySkeletonHTC wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetBodySkeletonHTC>
   *
   * @xrentity{xrGetBodySkeletonHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getBodySkeletonHTC(Space baseSpace, uint32_t skeletonGenerationId,
                            BodySkeletonHTC& skeleton,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetBodySkeletonHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetBodySkeletonHTC>
   *
   * @xrentity{xrGetBodySkeletonHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getBodySkeletonHTC(Space baseSpace, uint32_t skeletonGenerationId,
                            BodySkeletonHTC& skeleton,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetBodySkeletonHTC enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetBodySkeletonHTC>
   *
   * @xrentity{xrGetBodySkeletonHTC}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getBodySkeletonHTC(Space baseSpace, uint32_t skeletonGenerationId, BodySkeletonHTC& skeleton,
                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrBodyTrackerHTC val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrBodyTrackerHTC) == sizeof(BodyTrackerHTC),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrBodyTrackerHTC from an BodyTrackerHTC value.
 *
 * @found_by_adl
 * @see BodyTrackerHTC::get()
 * @relates BodyTrackerHTC
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrBodyTrackerHTC get(BodyTrackerHTC const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrBodyTrackerHTC handle in a BodyTrackerHTC (by reference).
 *
 * e.g.
 * ```
 * BodyTrackerHTC yourHandle;
 * auto result = d.xrCreateBodyTrackerHTC(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates BodyTrackerHTC
 */
static OPENXR_HPP_INLINE XrBodyTrackerHTC* put(BodyTrackerHTC& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between BodyTrackerHTC values.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(BodyTrackerHTC const& lhs,
                                                      BodyTrackerHTC const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between BodyTrackerHTC values.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(BodyTrackerHTC const& lhs,
                                                      BodyTrackerHTC const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between BodyTrackerHTC values.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(BodyTrackerHTC const& lhs,
                                                       BodyTrackerHTC const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between BodyTrackerHTC values.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(BodyTrackerHTC const& lhs,
                                                       BodyTrackerHTC const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between BodyTrackerHTC values.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(BodyTrackerHTC const& lhs,
                                                       BodyTrackerHTC const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between BodyTrackerHTC values.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(BodyTrackerHTC const& lhs,
                                                       BodyTrackerHTC const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between BodyTrackerHTC and raw XrBodyTrackerHTC.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(BodyTrackerHTC const& lhs,
                                                      XrBodyTrackerHTC rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrBodyTrackerHTC and BodyTrackerHTC.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrBodyTrackerHTC lhs,
                                                      BodyTrackerHTC const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between BodyTrackerHTC and raw XrBodyTrackerHTC.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(BodyTrackerHTC const& lhs,
                                                      XrBodyTrackerHTC rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrBodyTrackerHTC and BodyTrackerHTC.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrBodyTrackerHTC lhs,
                                                      BodyTrackerHTC const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between BodyTrackerHTC and raw XrBodyTrackerHTC.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(BodyTrackerHTC const& lhs,
                                                       XrBodyTrackerHTC rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrBodyTrackerHTC and BodyTrackerHTC.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrBodyTrackerHTC lhs,
                                                       BodyTrackerHTC const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between BodyTrackerHTC and raw XrBodyTrackerHTC.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(BodyTrackerHTC const& lhs,
                                                       XrBodyTrackerHTC rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrBodyTrackerHTC and BodyTrackerHTC.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrBodyTrackerHTC lhs,
                                                       BodyTrackerHTC const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between BodyTrackerHTC and raw XrBodyTrackerHTC.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(BodyTrackerHTC const& lhs,
                                                       XrBodyTrackerHTC rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrBodyTrackerHTC and BodyTrackerHTC.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrBodyTrackerHTC lhs,
                                                       BodyTrackerHTC const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between BodyTrackerHTC and raw XrBodyTrackerHTC.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(BodyTrackerHTC const& lhs,
                                                       XrBodyTrackerHTC rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrBodyTrackerHTC and BodyTrackerHTC.
//! @relates BodyTrackerHTC
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrBodyTrackerHTC lhs,
                                                       BodyTrackerHTC const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between BodyTrackerHTC and nullptr: true if the handle is null.
 * @relates BodyTrackerHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(BodyTrackerHTC const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and BodyTrackerHTC: true if the handle is null.
 * @relates BodyTrackerHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       BodyTrackerHTC const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between BodyTrackerHTC and nullptr: true if the handle is not null.
 * @relates BodyTrackerHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(BodyTrackerHTC const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and BodyTrackerHTC: true if the handle is not null.
 * @relates BodyTrackerHTC
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       BodyTrackerHTC const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_HTC_body_tracking

#ifdef XR_BD_body_tracking

/*!
 * @brief Handle class - wrapping XrBodyTrackerBD without indicating ownership.
 *
 * Provided by the `XR_BD_body_tracking` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrBodyTrackerBD>
 *
 * @xrentity{XrBodyTrackerBD}
 * @ingroup handles
 */
class BodyTrackerBD {
public:
  using Type = BodyTrackerBD;
  using RawHandleType = XrBodyTrackerBD;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR BodyTrackerBD() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrBodyTrackerBD type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT BodyTrackerBD(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR BodyTrackerBD(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrBodyTrackerBD
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrBodyTrackerBD type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this BodyTrackerBD value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this BodyTrackerBD value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrBodyTrackerBD manipulation
   * @{
   */
  //! Gets the raw XrBodyTrackerBD value.
  OPENXR_HPP_CONSTEXPR XrBodyTrackerBD get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * BodyTrackerBD yourHandle;
   * auto result = d.xrCreateBodyTrackerBD(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(BodyTrackerBD&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyBodyTrackerBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyBodyTrackerBD>
   *
   * @xrentity{xrDestroyBodyTrackerBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyBodyTrackerBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyBodyTrackerBD>
   *
   * @xrentity{xrDestroyBodyTrackerBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyBodyTrackerBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyBodyTrackerBD>
   *
   * @xrentity{xrDestroyBodyTrackerBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrLocateBodyJointsBD wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateBodyJointsBD>
   *
   * @xrentity{xrLocateBodyJointsBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateBodyJointsBD(const BodyJointsLocateInfoBD& locateInfo,
                            BodyJointLocationsBD& locations,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrLocateBodyJointsBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateBodyJointsBD>
   *
   * @xrentity{xrLocateBodyJointsBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result locateBodyJointsBD(const BodyJointsLocateInfoBD& locateInfo,
                            BodyJointLocationsBD& locations,
                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrLocateBodyJointsBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrLocateBodyJointsBD>
   *
   * @xrentity{xrLocateBodyJointsBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void locateBodyJointsBD(const BodyJointsLocateInfoBD& locateInfo, BodyJointLocationsBD& locations,
                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrBodyTrackerBD val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrBodyTrackerBD) == sizeof(BodyTrackerBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrBodyTrackerBD from an BodyTrackerBD value.
 *
 * @found_by_adl
 * @see BodyTrackerBD::get()
 * @relates BodyTrackerBD
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrBodyTrackerBD get(BodyTrackerBD const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrBodyTrackerBD handle in a BodyTrackerBD (by reference).
 *
 * e.g.
 * ```
 * BodyTrackerBD yourHandle;
 * auto result = d.xrCreateBodyTrackerBD(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates BodyTrackerBD
 */
static OPENXR_HPP_INLINE XrBodyTrackerBD* put(BodyTrackerBD& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between BodyTrackerBD values.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(BodyTrackerBD const& lhs,
                                                      BodyTrackerBD const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between BodyTrackerBD values.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(BodyTrackerBD const& lhs,
                                                      BodyTrackerBD const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between BodyTrackerBD values.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(BodyTrackerBD const& lhs,
                                                       BodyTrackerBD const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between BodyTrackerBD values.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(BodyTrackerBD const& lhs,
                                                       BodyTrackerBD const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between BodyTrackerBD values.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(BodyTrackerBD const& lhs,
                                                       BodyTrackerBD const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between BodyTrackerBD values.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(BodyTrackerBD const& lhs,
                                                       BodyTrackerBD const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between BodyTrackerBD and raw XrBodyTrackerBD.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(BodyTrackerBD const& lhs,
                                                      XrBodyTrackerBD rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrBodyTrackerBD and BodyTrackerBD.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrBodyTrackerBD lhs,
                                                      BodyTrackerBD const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between BodyTrackerBD and raw XrBodyTrackerBD.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(BodyTrackerBD const& lhs,
                                                      XrBodyTrackerBD rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrBodyTrackerBD and BodyTrackerBD.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrBodyTrackerBD lhs,
                                                      BodyTrackerBD const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between BodyTrackerBD and raw XrBodyTrackerBD.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(BodyTrackerBD const& lhs,
                                                       XrBodyTrackerBD rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrBodyTrackerBD and BodyTrackerBD.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrBodyTrackerBD lhs,
                                                       BodyTrackerBD const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between BodyTrackerBD and raw XrBodyTrackerBD.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(BodyTrackerBD const& lhs,
                                                       XrBodyTrackerBD rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrBodyTrackerBD and BodyTrackerBD.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrBodyTrackerBD lhs,
                                                       BodyTrackerBD const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between BodyTrackerBD and raw XrBodyTrackerBD.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(BodyTrackerBD const& lhs,
                                                       XrBodyTrackerBD rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrBodyTrackerBD and BodyTrackerBD.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrBodyTrackerBD lhs,
                                                       BodyTrackerBD const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between BodyTrackerBD and raw XrBodyTrackerBD.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(BodyTrackerBD const& lhs,
                                                       XrBodyTrackerBD rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrBodyTrackerBD and BodyTrackerBD.
//! @relates BodyTrackerBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrBodyTrackerBD lhs,
                                                       BodyTrackerBD const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between BodyTrackerBD and nullptr: true if the handle is null.
 * @relates BodyTrackerBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(BodyTrackerBD const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and BodyTrackerBD: true if the handle is null.
 * @relates BodyTrackerBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       BodyTrackerBD const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between BodyTrackerBD and nullptr: true if the handle is not null.
 * @relates BodyTrackerBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(BodyTrackerBD const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and BodyTrackerBD: true if the handle is not null.
 * @relates BodyTrackerBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       BodyTrackerBD const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_BD_body_tracking

#ifdef XR_BD_spatial_sensing

/*!
 * @brief Handle class - wrapping XrSenseDataProviderBD without indicating ownership.
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSenseDataProviderBD>
 *
 * @xrentity{XrSenseDataProviderBD}
 * @ingroup handles
 */
class SenseDataProviderBD {
public:
  using Type = SenseDataProviderBD;
  using RawHandleType = XrSenseDataProviderBD;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SenseDataProviderBD() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSenseDataProviderBD type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SenseDataProviderBD(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SenseDataProviderBD(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSenseDataProviderBD
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSenseDataProviderBD type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SenseDataProviderBD value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SenseDataProviderBD value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSenseDataProviderBD manipulation
   * @{
   */
  //! Gets the raw XrSenseDataProviderBD value.
  OPENXR_HPP_CONSTEXPR XrSenseDataProviderBD get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SenseDataProviderBD yourHandle;
   * auto result = d.xrCreateSenseDataProviderBD(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SenseDataProviderBD&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

  /*!
   * @brief xrStartSenseDataProviderAsyncBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartSenseDataProviderAsyncBD>
   *
   * @xrentity{xrStartSenseDataProviderAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result startSenseDataProviderAsyncBD(const SenseDataProviderStartInfoBD& startInfo,
                                       FutureEXT& future,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStartSenseDataProviderAsyncBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartSenseDataProviderAsyncBD>
   *
   * @xrentity{xrStartSenseDataProviderAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> startSenseDataProviderAsyncBD(
      const SenseDataProviderStartInfoBD& startInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStartSenseDataProviderAsyncBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStartSenseDataProviderAsyncBD>
   *
   * @xrentity{xrStartSenseDataProviderAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT startSenseDataProviderAsyncBD(const SenseDataProviderStartInfoBD& startInfo,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSenseDataProviderStateBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSenseDataProviderStateBD>
   *
   * @xrentity{xrGetSenseDataProviderStateBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSenseDataProviderStateBD(SenseDataProviderStateBD& state,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSenseDataProviderStateBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SenseDataProviderStateBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSenseDataProviderStateBD>
   *
   * @xrentity{xrGetSenseDataProviderStateBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SenseDataProviderStateBD> getSenseDataProviderStateBD(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSenseDataProviderStateBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SenseDataProviderStateBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSenseDataProviderStateBD>
   *
   * @xrentity{xrGetSenseDataProviderStateBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SenseDataProviderStateBD getSenseDataProviderStateBD(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrQuerySenseDataAsyncBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySenseDataAsyncBD>
   *
   * @xrentity{xrQuerySenseDataAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result querySenseDataAsyncBD(const SenseDataQueryInfoBD& queryInfo, FutureEXT& future,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrQuerySenseDataAsyncBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySenseDataAsyncBD>
   *
   * @xrentity{xrQuerySenseDataAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> querySenseDataAsyncBD(const SenseDataQueryInfoBD& queryInfo,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrQuerySenseDataAsyncBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySenseDataAsyncBD>
   *
   * @xrentity{xrQuerySenseDataAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT querySenseDataAsyncBD(const SenseDataQueryInfoBD& queryInfo,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrQuerySenseDataCompleteBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySenseDataCompleteBD>
   *
   * @xrentity{xrQuerySenseDataCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result querySenseDataCompleteBD(FutureEXT future, SenseDataQueryCompletionBD& completion,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrQuerySenseDataCompleteBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SenseDataQueryCompletionBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySenseDataCompleteBD>
   *
   * @xrentity{xrQuerySenseDataCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SenseDataQueryCompletionBD> querySenseDataCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrQuerySenseDataCompleteBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SenseDataQueryCompletionBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySenseDataCompleteBD>
   *
   * @xrentity{xrQuerySenseDataCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SenseDataQueryCompletionBD querySenseDataCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrStopSenseDataProviderBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopSenseDataProviderBD>
   *
   * @xrentity{xrStopSenseDataProviderBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stopSenseDataProviderBD(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrStopSenseDataProviderBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopSenseDataProviderBD>
   *
   * @xrentity{xrStopSenseDataProviderBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result stopSenseDataProviderBD(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrStopSenseDataProviderBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrStopSenseDataProviderBD>
   *
   * @xrentity{xrStopSenseDataProviderBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void stopSenseDataProviderBD(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySenseDataProviderBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySenseDataProviderBD>
   *
   * @xrentity{xrDestroySenseDataProviderBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySenseDataProviderBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySenseDataProviderBD>
   *
   * @xrentity{xrDestroySenseDataProviderBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySenseDataProviderBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySenseDataProviderBD>
   *
   * @xrentity{xrDestroySenseDataProviderBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSpatialEntityAnchorBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialEntityAnchorBD>
   *
   * @xrentity{xrCreateSpatialEntityAnchorBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialEntityAnchorBD(const SpatialEntityAnchorCreateInfoBD& createInfo,
                                     AnchorBD& anchor,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialEntityAnchorBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type AnchorBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialEntityAnchorBD>
   *
   * @xrentity{xrCreateSpatialEntityAnchorBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<AnchorBD> createSpatialEntityAnchorBD(
      const SpatialEntityAnchorCreateInfoBD& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialEntityAnchorBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type AnchorBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialEntityAnchorBD>
   *
   * @xrentity{xrCreateSpatialEntityAnchorBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  AnchorBD createSpatialEntityAnchorBD(const SpatialEntityAnchorCreateInfoBD& createInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialEntityAnchorBD wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a AnchorBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialEntityAnchorBD>
   *
   * @xrentity{xrCreateSpatialEntityAnchorBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<AnchorBD, impl::RemoveRefConst<Dispatch>>>
  createSpatialEntityAnchorUniqueBD(const SpatialEntityAnchorCreateInfoBD& createInfo,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialEntityAnchorBD wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a AnchorBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialEntityAnchorBD>
   *
   * @xrentity{xrCreateSpatialEntityAnchorBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<AnchorBD, impl::RemoveRefConst<Dispatch>> createSpatialEntityAnchorUniqueBD(
      const SpatialEntityAnchorCreateInfoBD& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_BD_spatial_anchor

  /*!
   * @brief xrCreateSpatialAnchorAsyncBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorAsyncBD>
   *
   * @xrentity{xrCreateSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorAsyncBD(const SpatialAnchorCreateInfoBD& info, FutureEXT& future,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorAsyncBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorAsyncBD>
   *
   * @xrentity{xrCreateSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> createSpatialAnchorAsyncBD(const SpatialAnchorCreateInfoBD& info,
                                                    Dispatch&& d
                                                        OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorAsyncBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorAsyncBD>
   *
   * @xrentity{xrCreateSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT createSpatialAnchorAsyncBD(const SpatialAnchorCreateInfoBD& info,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_anchor

#ifdef XR_BD_spatial_anchor

  /*!
   * @brief xrCreateSpatialAnchorCompleteBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorCompleteBD>
   *
   * @xrentity{xrCreateSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorCompleteBD(FutureEXT future,
                                       SpatialAnchorCreateCompletionBD& completion,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorCompleteBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialAnchorCreateCompletionBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorCompleteBD>
   *
   * @xrentity{xrCreateSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialAnchorCreateCompletionBD> createSpatialAnchorCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorCompleteBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialAnchorCreateCompletionBD
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorCompleteBD>
   *
   * @xrentity{xrCreateSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialAnchorCreateCompletionBD createSpatialAnchorCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_anchor

#ifdef XR_BD_spatial_anchor

  /*!
   * @brief xrPersistSpatialAnchorAsyncBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialAnchorAsyncBD>
   *
   * @xrentity{xrPersistSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result persistSpatialAnchorAsyncBD(const SpatialAnchorPersistInfoBD& info, FutureEXT& future,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPersistSpatialAnchorAsyncBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialAnchorAsyncBD>
   *
   * @xrentity{xrPersistSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> persistSpatialAnchorAsyncBD(const SpatialAnchorPersistInfoBD& info,
                                                     Dispatch&& d
                                                         OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPersistSpatialAnchorAsyncBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialAnchorAsyncBD>
   *
   * @xrentity{xrPersistSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT persistSpatialAnchorAsyncBD(const SpatialAnchorPersistInfoBD& info,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_anchor

#ifdef XR_BD_spatial_anchor

  /*!
   * @brief xrPersistSpatialAnchorCompleteBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialAnchorCompleteBD>
   *
   * @xrentity{xrPersistSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result persistSpatialAnchorCompleteBD(FutureEXT future, FutureCompletionEXT& completion,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPersistSpatialAnchorCompleteBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialAnchorCompleteBD>
   *
   * @xrentity{xrPersistSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureCompletionEXT> persistSpatialAnchorCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPersistSpatialAnchorCompleteBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialAnchorCompleteBD>
   *
   * @xrentity{xrPersistSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureCompletionEXT persistSpatialAnchorCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_anchor

#ifdef XR_BD_spatial_anchor

  /*!
   * @brief xrUnpersistSpatialAnchorAsyncBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialAnchorAsyncBD>
   *
   * @xrentity{xrUnpersistSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result unpersistSpatialAnchorAsyncBD(const SpatialAnchorUnpersistInfoBD& info, FutureEXT& future,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUnpersistSpatialAnchorAsyncBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialAnchorAsyncBD>
   *
   * @xrentity{xrUnpersistSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> unpersistSpatialAnchorAsyncBD(
      const SpatialAnchorUnpersistInfoBD& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUnpersistSpatialAnchorAsyncBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialAnchorAsyncBD>
   *
   * @xrentity{xrUnpersistSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT unpersistSpatialAnchorAsyncBD(const SpatialAnchorUnpersistInfoBD& info,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_anchor

#ifdef XR_BD_spatial_anchor

  /*!
   * @brief xrUnpersistSpatialAnchorCompleteBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialAnchorCompleteBD>
   *
   * @xrentity{xrUnpersistSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result unpersistSpatialAnchorCompleteBD(FutureEXT future, FutureCompletionEXT& completion,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUnpersistSpatialAnchorCompleteBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialAnchorCompleteBD>
   *
   * @xrentity{xrUnpersistSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureCompletionEXT> unpersistSpatialAnchorCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUnpersistSpatialAnchorCompleteBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialAnchorCompleteBD>
   *
   * @xrentity{xrUnpersistSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureCompletionEXT unpersistSpatialAnchorCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_anchor

#ifdef XR_BD_spatial_anchor_sharing

  /*!
   * @brief xrShareSpatialAnchorAsyncBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrShareSpatialAnchorAsyncBD>
   *
   * @xrentity{xrShareSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result shareSpatialAnchorAsyncBD(const SpatialAnchorShareInfoBD& info, FutureEXT& future,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrShareSpatialAnchorAsyncBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrShareSpatialAnchorAsyncBD>
   *
   * @xrentity{xrShareSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> shareSpatialAnchorAsyncBD(
      const SpatialAnchorShareInfoBD& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrShareSpatialAnchorAsyncBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrShareSpatialAnchorAsyncBD>
   *
   * @xrentity{xrShareSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT shareSpatialAnchorAsyncBD(const SpatialAnchorShareInfoBD& info,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_anchor_sharing

#ifdef XR_BD_spatial_anchor_sharing

  /*!
   * @brief xrShareSpatialAnchorCompleteBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrShareSpatialAnchorCompleteBD>
   *
   * @xrentity{xrShareSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result shareSpatialAnchorCompleteBD(FutureEXT future, FutureCompletionEXT& completion,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrShareSpatialAnchorCompleteBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrShareSpatialAnchorCompleteBD>
   *
   * @xrentity{xrShareSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureCompletionEXT> shareSpatialAnchorCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrShareSpatialAnchorCompleteBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrShareSpatialAnchorCompleteBD>
   *
   * @xrentity{xrShareSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureCompletionEXT shareSpatialAnchorCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_anchor_sharing

#ifdef XR_BD_spatial_anchor_sharing

  /*!
   * @brief xrDownloadSharedSpatialAnchorAsyncBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDownloadSharedSpatialAnchorAsyncBD>
   *
   * @xrentity{xrDownloadSharedSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result downloadSharedSpatialAnchorAsyncBD(const SharedSpatialAnchorDownloadInfoBD& info,
                                            FutureEXT& future,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDownloadSharedSpatialAnchorAsyncBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDownloadSharedSpatialAnchorAsyncBD>
   *
   * @xrentity{xrDownloadSharedSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> downloadSharedSpatialAnchorAsyncBD(
      const SharedSpatialAnchorDownloadInfoBD& info,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrDownloadSharedSpatialAnchorAsyncBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDownloadSharedSpatialAnchorAsyncBD>
   *
   * @xrentity{xrDownloadSharedSpatialAnchorAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT downloadSharedSpatialAnchorAsyncBD(const SharedSpatialAnchorDownloadInfoBD& info,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_anchor_sharing

#ifdef XR_BD_spatial_anchor_sharing

  /*!
   * @brief xrDownloadSharedSpatialAnchorCompleteBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDownloadSharedSpatialAnchorCompleteBD>
   *
   * @xrentity{xrDownloadSharedSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result downloadSharedSpatialAnchorCompleteBD(FutureEXT future, FutureCompletionEXT& completion,
                                               Dispatch&& d
                                                   OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDownloadSharedSpatialAnchorCompleteBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDownloadSharedSpatialAnchorCompleteBD>
   *
   * @xrentity{xrDownloadSharedSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureCompletionEXT> downloadSharedSpatialAnchorCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrDownloadSharedSpatialAnchorCompleteBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDownloadSharedSpatialAnchorCompleteBD>
   *
   * @xrentity{xrDownloadSharedSpatialAnchorCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureCompletionEXT downloadSharedSpatialAnchorCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_anchor_sharing

#ifdef XR_BD_spatial_scene

  /*!
   * @brief xrCaptureSceneAsyncBD wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCaptureSceneAsyncBD>
   *
   * @xrentity{xrCaptureSceneAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result captureSceneAsyncBD(const SceneCaptureInfoBD& info, FutureEXT& future,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCaptureSceneAsyncBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCaptureSceneAsyncBD>
   *
   * @xrentity{xrCaptureSceneAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> captureSceneAsyncBD(
      const SceneCaptureInfoBD& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCaptureSceneAsyncBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCaptureSceneAsyncBD>
   *
   * @xrentity{xrCaptureSceneAsyncBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT captureSceneAsyncBD(const SceneCaptureInfoBD& info,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_scene

#ifdef XR_BD_spatial_scene

  /*!
   * @brief xrCaptureSceneCompleteBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCaptureSceneCompleteBD>
   *
   * @xrentity{xrCaptureSceneCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result captureSceneCompleteBD(FutureEXT future, FutureCompletionEXT& completion,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCaptureSceneCompleteBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCaptureSceneCompleteBD>
   *
   * @xrentity{xrCaptureSceneCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureCompletionEXT> captureSceneCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCaptureSceneCompleteBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCaptureSceneCompleteBD>
   *
   * @xrentity{xrCaptureSceneCompleteBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureCompletionEXT captureSceneCompleteBD(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_BD_spatial_scene

  //! @}
private:
  XrSenseDataProviderBD val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSenseDataProviderBD) == sizeof(SenseDataProviderBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSenseDataProviderBD from an SenseDataProviderBD value.
 *
 * @found_by_adl
 * @see SenseDataProviderBD::get()
 * @relates SenseDataProviderBD
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSenseDataProviderBD
get(SenseDataProviderBD const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSenseDataProviderBD handle in a SenseDataProviderBD (by reference).
 *
 * e.g.
 * ```
 * SenseDataProviderBD yourHandle;
 * auto result = d.xrCreateSenseDataProviderBD(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SenseDataProviderBD
 */
static OPENXR_HPP_INLINE XrSenseDataProviderBD* put(SenseDataProviderBD& h,
                                                    bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SenseDataProviderBD values.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SenseDataProviderBD const& lhs,
                                                      SenseDataProviderBD const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SenseDataProviderBD values.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SenseDataProviderBD const& lhs,
                                                      SenseDataProviderBD const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SenseDataProviderBD values.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SenseDataProviderBD const& lhs,
                                                       SenseDataProviderBD const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SenseDataProviderBD values.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SenseDataProviderBD const& lhs,
                                                       SenseDataProviderBD const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SenseDataProviderBD values.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SenseDataProviderBD const& lhs,
                                                       SenseDataProviderBD const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SenseDataProviderBD values.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SenseDataProviderBD const& lhs,
                                                       SenseDataProviderBD const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SenseDataProviderBD and raw XrSenseDataProviderBD.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SenseDataProviderBD const& lhs,
                                                      XrSenseDataProviderBD rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSenseDataProviderBD and SenseDataProviderBD.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSenseDataProviderBD lhs,
                                                      SenseDataProviderBD const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SenseDataProviderBD and raw XrSenseDataProviderBD.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SenseDataProviderBD const& lhs,
                                                      XrSenseDataProviderBD rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSenseDataProviderBD and SenseDataProviderBD.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSenseDataProviderBD lhs,
                                                      SenseDataProviderBD const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SenseDataProviderBD and raw XrSenseDataProviderBD.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SenseDataProviderBD const& lhs,
                                                       XrSenseDataProviderBD rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSenseDataProviderBD and SenseDataProviderBD.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSenseDataProviderBD lhs,
                                                       SenseDataProviderBD const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SenseDataProviderBD and raw XrSenseDataProviderBD.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SenseDataProviderBD const& lhs,
                                                       XrSenseDataProviderBD rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSenseDataProviderBD and SenseDataProviderBD.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSenseDataProviderBD lhs,
                                                       SenseDataProviderBD const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SenseDataProviderBD and raw XrSenseDataProviderBD.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SenseDataProviderBD const& lhs,
                                                       XrSenseDataProviderBD rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSenseDataProviderBD and SenseDataProviderBD.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSenseDataProviderBD lhs,
                                                       SenseDataProviderBD const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SenseDataProviderBD and raw XrSenseDataProviderBD.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SenseDataProviderBD const& lhs,
                                                       XrSenseDataProviderBD rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSenseDataProviderBD and SenseDataProviderBD.
//! @relates SenseDataProviderBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSenseDataProviderBD lhs,
                                                       SenseDataProviderBD const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SenseDataProviderBD and nullptr: true if the handle is null.
 * @relates SenseDataProviderBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SenseDataProviderBD const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SenseDataProviderBD: true if the handle is null.
 * @relates SenseDataProviderBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SenseDataProviderBD const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SenseDataProviderBD and nullptr: true if the handle is not
 * null.
 * @relates SenseDataProviderBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SenseDataProviderBD const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SenseDataProviderBD: true if the handle is not
 * null.
 * @relates SenseDataProviderBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SenseDataProviderBD const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing

/*!
 * @brief Handle class - wrapping XrSenseDataSnapshotBD without indicating ownership.
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSenseDataSnapshotBD>
 *
 * @xrentity{XrSenseDataSnapshotBD}
 * @ingroup handles
 */
class SenseDataSnapshotBD {
public:
  using Type = SenseDataSnapshotBD;
  using RawHandleType = XrSenseDataSnapshotBD;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SenseDataSnapshotBD() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSenseDataSnapshotBD type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SenseDataSnapshotBD(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SenseDataSnapshotBD(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSenseDataSnapshotBD
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSenseDataSnapshotBD type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SenseDataSnapshotBD value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SenseDataSnapshotBD value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSenseDataSnapshotBD manipulation
   * @{
   */
  //! Gets the raw XrSenseDataSnapshotBD value.
  OPENXR_HPP_CONSTEXPR XrSenseDataSnapshotBD get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SenseDataSnapshotBD yourHandle;
   * auto result = d.xrCreateSenseDataSnapshotBD(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SenseDataSnapshotBD&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

  /*!
   * @brief xrEnumerateSpatialEntityComponentTypesBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialEntityComponentTypesBD>
   *
   * @xrentity{xrEnumerateSpatialEntityComponentTypesBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result enumerateSpatialEntityComponentTypesBD(
      SpatialEntityIdBD entityId, uint32_t componentTypeCapacityInput,
      uint32_t& componentTypeCountOutput, SpatialEntityComponentTypeBD* componentTypes,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrEnumerateSpatialEntityComponentTypesBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpatialEntityComponentTypeBD, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialEntityComponentTypesBD>
   *
   * @xrentity{xrEnumerateSpatialEntityComponentTypesBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialEntityComponentTypeBD>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpatialEntityComponentTypeBD, Allocator>>
  enumerateSpatialEntityComponentTypesToVectorBD(
      SpatialEntityIdBD entityId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSpatialEntityComponentTypesBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<SpatialEntityComponentTypeBD, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialEntityComponentTypesBD>
   *
   * @xrentity{xrEnumerateSpatialEntityComponentTypesBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialEntityComponentTypeBD>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<SpatialEntityComponentTypeBD, Allocator>>
  enumerateSpatialEntityComponentTypesToVectorBD(SpatialEntityIdBD entityId,
                                                 Allocator const& vectorAllocator,
                                                 Dispatch&& d) const;

#else
  /*!
   * @brief xrEnumerateSpatialEntityComponentTypesBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<SpatialEntityComponentTypeBD, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialEntityComponentTypesBD>
   *
   * @xrentity{xrEnumerateSpatialEntityComponentTypesBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialEntityComponentTypeBD>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpatialEntityComponentTypeBD, Allocator>
  enumerateSpatialEntityComponentTypesToVectorBD(
      SpatialEntityIdBD entityId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrEnumerateSpatialEntityComponentTypesBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<SpatialEntityComponentTypeBD, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateSpatialEntityComponentTypesBD>
   *
   * @xrentity{xrEnumerateSpatialEntityComponentTypesBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<SpatialEntityComponentTypeBD>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<SpatialEntityComponentTypeBD, Allocator>
  enumerateSpatialEntityComponentTypesToVectorBD(SpatialEntityIdBD entityId,
                                                 Allocator const& vectorAllocator,
                                                 Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSpatialEntityUuidBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialEntityUuidBD>
   *
   * @xrentity{xrGetSpatialEntityUuidBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialEntityUuidBD(SpatialEntityIdBD entityId, XrUuidEXT* uuid,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpatialEntityUuidBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type UuidEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialEntityUuidBD>
   *
   * @xrentity{xrGetSpatialEntityUuidBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UuidEXT> getSpatialEntityUuidBD(
      SpatialEntityIdBD entityId, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpatialEntityUuidBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type UuidEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialEntityUuidBD>
   *
   * @xrentity{xrGetSpatialEntityUuidBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UuidEXT getSpatialEntityUuidBD(SpatialEntityIdBD entityId,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetSpatialEntityComponentDataBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialEntityComponentDataBD>
   *
   * @xrentity{xrGetSpatialEntityComponentDataBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialEntityComponentDataBD(const SpatialEntityComponentGetInfoBD& getInfo,
                                         SpatialEntityComponentDataBaseHeaderBD& componentData,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpatialEntityComponentDataBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialEntityComponentDataBD>
   *
   * @xrentity{xrGetSpatialEntityComponentDataBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialEntityComponentDataBD(const SpatialEntityComponentGetInfoBD& getInfo,
                                         SpatialEntityComponentDataBaseHeaderBD& componentData,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetSpatialEntityComponentDataBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialEntityComponentDataBD>
   *
   * @xrentity{xrGetSpatialEntityComponentDataBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getSpatialEntityComponentDataBD(const SpatialEntityComponentGetInfoBD& getInfo,
                                       SpatialEntityComponentDataBaseHeaderBD& componentData,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySenseDataSnapshotBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySenseDataSnapshotBD>
   *
   * @xrentity{xrDestroySenseDataSnapshotBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySenseDataSnapshotBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySenseDataSnapshotBD>
   *
   * @xrentity{xrDestroySenseDataSnapshotBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySenseDataSnapshotBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySenseDataSnapshotBD>
   *
   * @xrentity{xrDestroySenseDataSnapshotBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetQueriedSenseDataBD wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetQueriedSenseDataBD>
   *
   * @xrentity{xrGetQueriedSenseDataBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getQueriedSenseDataBD(QueriedSenseDataGetInfoBD& getInfo,
                               QueriedSenseDataBD& queriedSenseData,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetQueriedSenseDataBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetQueriedSenseDataBD>
   *
   * @xrentity{xrGetQueriedSenseDataBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getQueriedSenseDataBD(QueriedSenseDataGetInfoBD& getInfo,
                               QueriedSenseDataBD& queriedSenseData,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetQueriedSenseDataBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetQueriedSenseDataBD>
   *
   * @xrentity{xrGetQueriedSenseDataBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getQueriedSenseDataBD(QueriedSenseDataGetInfoBD& getInfo,
                             QueriedSenseDataBD& queriedSenseData,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrSenseDataSnapshotBD val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSenseDataSnapshotBD) == sizeof(SenseDataSnapshotBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSenseDataSnapshotBD from an SenseDataSnapshotBD value.
 *
 * @found_by_adl
 * @see SenseDataSnapshotBD::get()
 * @relates SenseDataSnapshotBD
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSenseDataSnapshotBD
get(SenseDataSnapshotBD const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSenseDataSnapshotBD handle in a SenseDataSnapshotBD (by reference).
 *
 * e.g.
 * ```
 * SenseDataSnapshotBD yourHandle;
 * auto result = d.xrCreateSenseDataSnapshotBD(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SenseDataSnapshotBD
 */
static OPENXR_HPP_INLINE XrSenseDataSnapshotBD* put(SenseDataSnapshotBD& h,
                                                    bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SenseDataSnapshotBD values.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SenseDataSnapshotBD const& lhs,
                                                      SenseDataSnapshotBD const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SenseDataSnapshotBD values.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SenseDataSnapshotBD const& lhs,
                                                      SenseDataSnapshotBD const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SenseDataSnapshotBD values.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SenseDataSnapshotBD const& lhs,
                                                       SenseDataSnapshotBD const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SenseDataSnapshotBD values.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SenseDataSnapshotBD const& lhs,
                                                       SenseDataSnapshotBD const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SenseDataSnapshotBD values.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SenseDataSnapshotBD const& lhs,
                                                       SenseDataSnapshotBD const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SenseDataSnapshotBD values.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SenseDataSnapshotBD const& lhs,
                                                       SenseDataSnapshotBD const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SenseDataSnapshotBD and raw XrSenseDataSnapshotBD.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SenseDataSnapshotBD const& lhs,
                                                      XrSenseDataSnapshotBD rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSenseDataSnapshotBD and SenseDataSnapshotBD.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSenseDataSnapshotBD lhs,
                                                      SenseDataSnapshotBD const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SenseDataSnapshotBD and raw XrSenseDataSnapshotBD.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SenseDataSnapshotBD const& lhs,
                                                      XrSenseDataSnapshotBD rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSenseDataSnapshotBD and SenseDataSnapshotBD.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSenseDataSnapshotBD lhs,
                                                      SenseDataSnapshotBD const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SenseDataSnapshotBD and raw XrSenseDataSnapshotBD.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SenseDataSnapshotBD const& lhs,
                                                       XrSenseDataSnapshotBD rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSenseDataSnapshotBD and SenseDataSnapshotBD.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSenseDataSnapshotBD lhs,
                                                       SenseDataSnapshotBD const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SenseDataSnapshotBD and raw XrSenseDataSnapshotBD.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SenseDataSnapshotBD const& lhs,
                                                       XrSenseDataSnapshotBD rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSenseDataSnapshotBD and SenseDataSnapshotBD.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSenseDataSnapshotBD lhs,
                                                       SenseDataSnapshotBD const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SenseDataSnapshotBD and raw XrSenseDataSnapshotBD.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SenseDataSnapshotBD const& lhs,
                                                       XrSenseDataSnapshotBD rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSenseDataSnapshotBD and SenseDataSnapshotBD.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSenseDataSnapshotBD lhs,
                                                       SenseDataSnapshotBD const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SenseDataSnapshotBD and raw XrSenseDataSnapshotBD.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SenseDataSnapshotBD const& lhs,
                                                       XrSenseDataSnapshotBD rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSenseDataSnapshotBD and SenseDataSnapshotBD.
//! @relates SenseDataSnapshotBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSenseDataSnapshotBD lhs,
                                                       SenseDataSnapshotBD const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SenseDataSnapshotBD and nullptr: true if the handle is null.
 * @relates SenseDataSnapshotBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SenseDataSnapshotBD const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SenseDataSnapshotBD: true if the handle is null.
 * @relates SenseDataSnapshotBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SenseDataSnapshotBD const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SenseDataSnapshotBD and nullptr: true if the handle is not
 * null.
 * @relates SenseDataSnapshotBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SenseDataSnapshotBD const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SenseDataSnapshotBD: true if the handle is not
 * null.
 * @relates SenseDataSnapshotBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SenseDataSnapshotBD const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_BD_spatial_sensing

/*!
 * @brief Handle class - wrapping XrAnchorBD without indicating ownership.
 *
 * Provided by the `XR_BD_spatial_sensing` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrAnchorBD>
 *
 * @xrentity{XrAnchorBD}
 * @ingroup handles
 */
class AnchorBD {
public:
  using Type = AnchorBD;
  using RawHandleType = XrAnchorBD;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR AnchorBD() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrAnchorBD type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT AnchorBD(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR AnchorBD(std::nullptr_t /* unused */) noexcept : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrAnchorBD
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrAnchorBD type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this AnchorBD value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this AnchorBD value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrAnchorBD manipulation
   * @{
   */
  //! Gets the raw XrAnchorBD value.
  OPENXR_HPP_CONSTEXPR XrAnchorBD get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * AnchorBD yourHandle;
   * auto result = d.xrCreateAnchorBD(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(AnchorBD&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyAnchorBD wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyAnchorBD>
   *
   * @xrentity{xrDestroyAnchorBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyAnchorBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyAnchorBD>
   *
   * @xrentity{xrDestroyAnchorBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyAnchorBD enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyAnchorBD>
   *
   * @xrentity{xrDestroyAnchorBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetAnchorUuidBD wrapper (basic).
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAnchorUuidBD>
   *
   * @xrentity{xrGetAnchorUuidBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getAnchorUuidBD(XrUuidEXT* uuid, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetAnchorUuidBD enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type UuidEXT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAnchorUuidBD>
   *
   * @xrentity{xrGetAnchorUuidBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UuidEXT> getAnchorUuidBD(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetAnchorUuidBD enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type UuidEXT
   *
   * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetAnchorUuidBD>
   *
   * @xrentity{xrGetAnchorUuidBD}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UuidEXT getAnchorUuidBD(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrAnchorBD val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrAnchorBD) == sizeof(AnchorBD),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrAnchorBD from an AnchorBD value.
 *
 * @found_by_adl
 * @see AnchorBD::get()
 * @relates AnchorBD
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrAnchorBD get(AnchorBD const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrAnchorBD handle in a AnchorBD (by reference).
 *
 * e.g.
 * ```
 * AnchorBD yourHandle;
 * auto result = d.xrCreateAnchorBD(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates AnchorBD
 */
static OPENXR_HPP_INLINE XrAnchorBD* put(AnchorBD& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between AnchorBD values.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(AnchorBD const& lhs,
                                                      AnchorBD const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between AnchorBD values.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(AnchorBD const& lhs,
                                                      AnchorBD const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between AnchorBD values.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(AnchorBD const& lhs,
                                                       AnchorBD const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between AnchorBD values.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(AnchorBD const& lhs,
                                                       AnchorBD const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between AnchorBD values.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(AnchorBD const& lhs,
                                                       AnchorBD const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between AnchorBD values.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(AnchorBD const& lhs,
                                                       AnchorBD const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between AnchorBD and raw XrAnchorBD.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(AnchorBD const& lhs,
                                                      XrAnchorBD rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrAnchorBD and AnchorBD.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrAnchorBD lhs,
                                                      AnchorBD const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between AnchorBD and raw XrAnchorBD.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(AnchorBD const& lhs,
                                                      XrAnchorBD rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrAnchorBD and AnchorBD.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrAnchorBD lhs,
                                                      AnchorBD const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between AnchorBD and raw XrAnchorBD.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(AnchorBD const& lhs,
                                                       XrAnchorBD rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrAnchorBD and AnchorBD.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrAnchorBD lhs,
                                                       AnchorBD const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between AnchorBD and raw XrAnchorBD.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(AnchorBD const& lhs,
                                                       XrAnchorBD rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrAnchorBD and AnchorBD.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrAnchorBD lhs,
                                                       AnchorBD const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between AnchorBD and raw XrAnchorBD.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(AnchorBD const& lhs,
                                                       XrAnchorBD rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrAnchorBD and AnchorBD.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrAnchorBD lhs,
                                                       AnchorBD const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between AnchorBD and raw XrAnchorBD.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(AnchorBD const& lhs,
                                                       XrAnchorBD rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrAnchorBD and AnchorBD.
//! @relates AnchorBD
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrAnchorBD lhs,
                                                       AnchorBD const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between AnchorBD and nullptr: true if the handle is null.
 * @relates AnchorBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(AnchorBD const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and AnchorBD: true if the handle is null.
 * @relates AnchorBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       AnchorBD const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between AnchorBD and nullptr: true if the handle is not null.
 * @relates AnchorBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(AnchorBD const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and AnchorBD: true if the handle is not null.
 * @relates AnchorBD
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       AnchorBD const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_BD_spatial_sensing

#ifdef XR_EXT_plane_detection

/*!
 * @brief Handle class - wrapping XrPlaneDetectorEXT without indicating ownership.
 *
 * Provided by the `XR_EXT_plane_detection` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrPlaneDetectorEXT>
 *
 * @xrentity{XrPlaneDetectorEXT}
 * @ingroup handles
 */
class PlaneDetectorEXT {
public:
  using Type = PlaneDetectorEXT;
  using RawHandleType = XrPlaneDetectorEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR PlaneDetectorEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrPlaneDetectorEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT PlaneDetectorEXT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR PlaneDetectorEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrPlaneDetectorEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrPlaneDetectorEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this PlaneDetectorEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this PlaneDetectorEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrPlaneDetectorEXT manipulation
   * @{
   */
  //! Gets the raw XrPlaneDetectorEXT value.
  OPENXR_HPP_CONSTEXPR XrPlaneDetectorEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * PlaneDetectorEXT yourHandle;
   * auto result = d.xrCreatePlaneDetectorEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(PlaneDetectorEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyPlaneDetectorEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPlaneDetectorEXT>
   *
   * @xrentity{xrDestroyPlaneDetectorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyPlaneDetectorEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPlaneDetectorEXT>
   *
   * @xrentity{xrDestroyPlaneDetectorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyPlaneDetectorEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyPlaneDetectorEXT>
   *
   * @xrentity{xrDestroyPlaneDetectorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrBeginPlaneDetectionEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginPlaneDetectionEXT>
   *
   * @xrentity{xrBeginPlaneDetectionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginPlaneDetectionEXT(const PlaneDetectorBeginInfoEXT& beginInfo,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrBeginPlaneDetectionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginPlaneDetectionEXT>
   *
   * @xrentity{xrBeginPlaneDetectionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result beginPlaneDetectionEXT(const PlaneDetectorBeginInfoEXT& beginInfo,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrBeginPlaneDetectionEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrBeginPlaneDetectionEXT>
   *
   * @xrentity{xrBeginPlaneDetectionEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void beginPlaneDetectionEXT(const PlaneDetectorBeginInfoEXT& beginInfo,
                              Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetPlaneDetectionStateEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPlaneDetectionStateEXT>
   *
   * @xrentity{xrGetPlaneDetectionStateEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getPlaneDetectionStateEXT(PlaneDetectionStateEXT& state,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetPlaneDetectionStateEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type PlaneDetectionStateEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPlaneDetectionStateEXT>
   *
   * @xrentity{xrGetPlaneDetectionStateEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<PlaneDetectionStateEXT> getPlaneDetectionStateEXT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetPlaneDetectionStateEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type PlaneDetectionStateEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPlaneDetectionStateEXT>
   *
   * @xrentity{xrGetPlaneDetectionStateEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  PlaneDetectionStateEXT getPlaneDetectionStateEXT(
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetPlaneDetectionsEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPlaneDetectionsEXT>
   *
   * @xrentity{xrGetPlaneDetectionsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getPlaneDetectionsEXT(const PlaneDetectorGetInfoEXT& info,
                               PlaneDetectorLocationsEXT& locations,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetPlaneDetectionsEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPlaneDetectionsEXT>
   *
   * @xrentity{xrGetPlaneDetectionsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getPlaneDetectionsEXT(const PlaneDetectorGetInfoEXT& info,
                               PlaneDetectorLocationsEXT& locations,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetPlaneDetectionsEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPlaneDetectionsEXT>
   *
   * @xrentity{xrGetPlaneDetectionsEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getPlaneDetectionsEXT(const PlaneDetectorGetInfoEXT& info,
                             PlaneDetectorLocationsEXT& locations,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrGetPlanePolygonBufferEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPlanePolygonBufferEXT>
   *
   * @xrentity{xrGetPlanePolygonBufferEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getPlanePolygonBufferEXT(uint64_t planeId, uint32_t polygonBufferIndex,
                                  PlaneDetectorPolygonBufferEXT& polygonBuffer,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetPlanePolygonBufferEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPlanePolygonBufferEXT>
   *
   * @xrentity{xrGetPlanePolygonBufferEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getPlanePolygonBufferEXT(uint64_t planeId, uint32_t polygonBufferIndex,
                                  PlaneDetectorPolygonBufferEXT& polygonBuffer,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetPlanePolygonBufferEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetPlanePolygonBufferEXT>
   *
   * @xrentity{xrGetPlanePolygonBufferEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void getPlanePolygonBufferEXT(uint64_t planeId, uint32_t polygonBufferIndex,
                                PlaneDetectorPolygonBufferEXT& polygonBuffer,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrPlaneDetectorEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrPlaneDetectorEXT) == sizeof(PlaneDetectorEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrPlaneDetectorEXT from an PlaneDetectorEXT value.
 *
 * @found_by_adl
 * @see PlaneDetectorEXT::get()
 * @relates PlaneDetectorEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrPlaneDetectorEXT get(PlaneDetectorEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrPlaneDetectorEXT handle in a PlaneDetectorEXT (by reference).
 *
 * e.g.
 * ```
 * PlaneDetectorEXT yourHandle;
 * auto result = d.xrCreatePlaneDetectorEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates PlaneDetectorEXT
 */
static OPENXR_HPP_INLINE XrPlaneDetectorEXT* put(PlaneDetectorEXT& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between PlaneDetectorEXT values.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PlaneDetectorEXT const& lhs,
                                                      PlaneDetectorEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between PlaneDetectorEXT values.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PlaneDetectorEXT const& lhs,
                                                      PlaneDetectorEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between PlaneDetectorEXT values.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PlaneDetectorEXT const& lhs,
                                                       PlaneDetectorEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between PlaneDetectorEXT values.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PlaneDetectorEXT const& lhs,
                                                       PlaneDetectorEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between PlaneDetectorEXT values.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PlaneDetectorEXT const& lhs,
                                                       PlaneDetectorEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between PlaneDetectorEXT values.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PlaneDetectorEXT const& lhs,
                                                       PlaneDetectorEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between PlaneDetectorEXT and raw XrPlaneDetectorEXT.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(PlaneDetectorEXT const& lhs,
                                                      XrPlaneDetectorEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrPlaneDetectorEXT and PlaneDetectorEXT.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrPlaneDetectorEXT lhs,
                                                      PlaneDetectorEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between PlaneDetectorEXT and raw XrPlaneDetectorEXT.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(PlaneDetectorEXT const& lhs,
                                                      XrPlaneDetectorEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrPlaneDetectorEXT and PlaneDetectorEXT.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrPlaneDetectorEXT lhs,
                                                      PlaneDetectorEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between PlaneDetectorEXT and raw XrPlaneDetectorEXT.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(PlaneDetectorEXT const& lhs,
                                                       XrPlaneDetectorEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrPlaneDetectorEXT and PlaneDetectorEXT.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrPlaneDetectorEXT lhs,
                                                       PlaneDetectorEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between PlaneDetectorEXT and raw XrPlaneDetectorEXT.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(PlaneDetectorEXT const& lhs,
                                                       XrPlaneDetectorEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrPlaneDetectorEXT and PlaneDetectorEXT.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrPlaneDetectorEXT lhs,
                                                       PlaneDetectorEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between PlaneDetectorEXT and raw XrPlaneDetectorEXT.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PlaneDetectorEXT const& lhs,
                                                       XrPlaneDetectorEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrPlaneDetectorEXT and PlaneDetectorEXT.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrPlaneDetectorEXT lhs,
                                                       PlaneDetectorEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between PlaneDetectorEXT and raw XrPlaneDetectorEXT.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PlaneDetectorEXT const& lhs,
                                                       XrPlaneDetectorEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrPlaneDetectorEXT and PlaneDetectorEXT.
//! @relates PlaneDetectorEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrPlaneDetectorEXT lhs,
                                                       PlaneDetectorEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between PlaneDetectorEXT and nullptr: true if the handle is null.
 * @relates PlaneDetectorEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(PlaneDetectorEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and PlaneDetectorEXT: true if the handle is null.
 * @relates PlaneDetectorEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       PlaneDetectorEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between PlaneDetectorEXT and nullptr: true if the handle is not
 * null.
 * @relates PlaneDetectorEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(PlaneDetectorEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and PlaneDetectorEXT: true if the handle is not
 * null.
 * @relates PlaneDetectorEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       PlaneDetectorEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_EXT_plane_detection

#ifdef XR_ML_world_mesh_detection

/*!
 * @brief Handle class - wrapping XrWorldMeshDetectorML without indicating ownership.
 *
 * Provided by the `XR_ML_world_mesh_detection` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrWorldMeshDetectorML>
 *
 * @xrentity{XrWorldMeshDetectorML}
 * @ingroup handles
 */
class WorldMeshDetectorML {
public:
  using Type = WorldMeshDetectorML;
  using RawHandleType = XrWorldMeshDetectorML;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR WorldMeshDetectorML() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrWorldMeshDetectorML type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT WorldMeshDetectorML(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR WorldMeshDetectorML(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrWorldMeshDetectorML
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrWorldMeshDetectorML type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this WorldMeshDetectorML value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this WorldMeshDetectorML value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrWorldMeshDetectorML manipulation
   * @{
   */
  //! Gets the raw XrWorldMeshDetectorML value.
  OPENXR_HPP_CONSTEXPR XrWorldMeshDetectorML get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * WorldMeshDetectorML yourHandle;
   * auto result = d.xrCreateWorldMeshDetectorML(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(WorldMeshDetectorML&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyWorldMeshDetectorML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyWorldMeshDetectorML>
   *
   * @xrentity{xrDestroyWorldMeshDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyWorldMeshDetectorML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyWorldMeshDetectorML>
   *
   * @xrentity{xrDestroyWorldMeshDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyWorldMeshDetectorML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyWorldMeshDetectorML>
   *
   * @xrentity{xrDestroyWorldMeshDetectorML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrRequestWorldMeshStateAsyncML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestWorldMeshStateAsyncML>
   *
   * @xrentity{xrRequestWorldMeshStateAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestWorldMeshStateAsyncML(const WorldMeshStateRequestInfoML& stateRequest,
                                      FutureEXT& future,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRequestWorldMeshStateAsyncML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestWorldMeshStateAsyncML>
   *
   * @xrentity{xrRequestWorldMeshStateAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> requestWorldMeshStateAsyncML(
      const WorldMeshStateRequestInfoML& stateRequest,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRequestWorldMeshStateAsyncML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestWorldMeshStateAsyncML>
   *
   * @xrentity{xrRequestWorldMeshStateAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT requestWorldMeshStateAsyncML(const WorldMeshStateRequestInfoML& stateRequest,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrRequestWorldMeshStateCompleteML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestWorldMeshStateCompleteML>
   *
   * @xrentity{xrRequestWorldMeshStateCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestWorldMeshStateCompleteML(FutureEXT future,
                                         WorldMeshStateRequestCompletionML& completion,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRequestWorldMeshStateCompleteML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestWorldMeshStateCompleteML>
   *
   * @xrentity{xrRequestWorldMeshStateCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestWorldMeshStateCompleteML(FutureEXT future,
                                         WorldMeshStateRequestCompletionML& completion,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRequestWorldMeshStateCompleteML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestWorldMeshStateCompleteML>
   *
   * @xrentity{xrRequestWorldMeshStateCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void requestWorldMeshStateCompleteML(FutureEXT future,
                                       WorldMeshStateRequestCompletionML& completion,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetWorldMeshBufferRecommendSizeML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetWorldMeshBufferRecommendSizeML>
   *
   * @xrentity{xrGetWorldMeshBufferRecommendSizeML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getWorldMeshBufferRecommendSizeML(const WorldMeshBufferRecommendedSizeInfoML& sizeInfo,
                                           WorldMeshBufferSizeML& size,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetWorldMeshBufferRecommendSizeML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type WorldMeshBufferSizeML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetWorldMeshBufferRecommendSizeML>
   *
   * @xrentity{xrGetWorldMeshBufferRecommendSizeML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<WorldMeshBufferSizeML> getWorldMeshBufferRecommendSizeML(
      const WorldMeshBufferRecommendedSizeInfoML& sizeInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetWorldMeshBufferRecommendSizeML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type WorldMeshBufferSizeML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetWorldMeshBufferRecommendSizeML>
   *
   * @xrentity{xrGetWorldMeshBufferRecommendSizeML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  WorldMeshBufferSizeML getWorldMeshBufferRecommendSizeML(
      const WorldMeshBufferRecommendedSizeInfoML& sizeInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrAllocateWorldMeshBufferML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAllocateWorldMeshBufferML>
   *
   * @xrentity{xrAllocateWorldMeshBufferML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result allocateWorldMeshBufferML(const WorldMeshBufferSizeML& size, WorldMeshBufferML& buffer,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrAllocateWorldMeshBufferML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAllocateWorldMeshBufferML>
   *
   * @xrentity{xrAllocateWorldMeshBufferML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result allocateWorldMeshBufferML(const WorldMeshBufferSizeML& size, WorldMeshBufferML& buffer,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrAllocateWorldMeshBufferML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrAllocateWorldMeshBufferML>
   *
   * @xrentity{xrAllocateWorldMeshBufferML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void allocateWorldMeshBufferML(const WorldMeshBufferSizeML& size, WorldMeshBufferML& buffer,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrFreeWorldMeshBufferML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrFreeWorldMeshBufferML>
   *
   * @xrentity{xrFreeWorldMeshBufferML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result freeWorldMeshBufferML(const WorldMeshBufferML& buffer,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrFreeWorldMeshBufferML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrFreeWorldMeshBufferML>
   *
   * @xrentity{xrFreeWorldMeshBufferML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result freeWorldMeshBufferML(const WorldMeshBufferML& buffer,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrFreeWorldMeshBufferML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrFreeWorldMeshBufferML>
   *
   * @xrentity{xrFreeWorldMeshBufferML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void freeWorldMeshBufferML(const WorldMeshBufferML& buffer,
                             Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrRequestWorldMeshAsyncML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestWorldMeshAsyncML>
   *
   * @xrentity{xrRequestWorldMeshAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestWorldMeshAsyncML(const WorldMeshGetInfoML& getInfo, WorldMeshBufferML& buffer,
                                 FutureEXT& future,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRequestWorldMeshAsyncML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestWorldMeshAsyncML>
   *
   * @xrentity{xrRequestWorldMeshAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestWorldMeshAsyncML(const WorldMeshGetInfoML& getInfo, WorldMeshBufferML& buffer,
                                 FutureEXT& future,
                                 Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRequestWorldMeshAsyncML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestWorldMeshAsyncML>
   *
   * @xrentity{xrRequestWorldMeshAsyncML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void requestWorldMeshAsyncML(const WorldMeshGetInfoML& getInfo, WorldMeshBufferML& buffer,
                               FutureEXT& future,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrRequestWorldMeshCompleteML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestWorldMeshCompleteML>
   *
   * @xrentity{xrRequestWorldMeshCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestWorldMeshCompleteML(const WorldMeshRequestCompletionInfoML& completionInfo,
                                    FutureEXT future, WorldMeshRequestCompletionML& completion,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrRequestWorldMeshCompleteML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestWorldMeshCompleteML>
   *
   * @xrentity{xrRequestWorldMeshCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result requestWorldMeshCompleteML(const WorldMeshRequestCompletionInfoML& completionInfo,
                                    FutureEXT future, WorldMeshRequestCompletionML& completion,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrRequestWorldMeshCompleteML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrRequestWorldMeshCompleteML>
   *
   * @xrentity{xrRequestWorldMeshCompleteML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void requestWorldMeshCompleteML(const WorldMeshRequestCompletionInfoML& completionInfo,
                                  FutureEXT future, WorldMeshRequestCompletionML& completion,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrWorldMeshDetectorML val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrWorldMeshDetectorML) == sizeof(WorldMeshDetectorML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrWorldMeshDetectorML from an WorldMeshDetectorML value.
 *
 * @found_by_adl
 * @see WorldMeshDetectorML::get()
 * @relates WorldMeshDetectorML
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrWorldMeshDetectorML
get(WorldMeshDetectorML const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrWorldMeshDetectorML handle in a WorldMeshDetectorML (by reference).
 *
 * e.g.
 * ```
 * WorldMeshDetectorML yourHandle;
 * auto result = d.xrCreateWorldMeshDetectorML(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates WorldMeshDetectorML
 */
static OPENXR_HPP_INLINE XrWorldMeshDetectorML* put(WorldMeshDetectorML& h,
                                                    bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between WorldMeshDetectorML values.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(WorldMeshDetectorML const& lhs,
                                                      WorldMeshDetectorML const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between WorldMeshDetectorML values.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(WorldMeshDetectorML const& lhs,
                                                      WorldMeshDetectorML const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between WorldMeshDetectorML values.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(WorldMeshDetectorML const& lhs,
                                                       WorldMeshDetectorML const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between WorldMeshDetectorML values.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(WorldMeshDetectorML const& lhs,
                                                       WorldMeshDetectorML const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between WorldMeshDetectorML values.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(WorldMeshDetectorML const& lhs,
                                                       WorldMeshDetectorML const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between WorldMeshDetectorML values.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(WorldMeshDetectorML const& lhs,
                                                       WorldMeshDetectorML const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between WorldMeshDetectorML and raw XrWorldMeshDetectorML.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(WorldMeshDetectorML const& lhs,
                                                      XrWorldMeshDetectorML rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrWorldMeshDetectorML and WorldMeshDetectorML.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrWorldMeshDetectorML lhs,
                                                      WorldMeshDetectorML const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between WorldMeshDetectorML and raw XrWorldMeshDetectorML.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(WorldMeshDetectorML const& lhs,
                                                      XrWorldMeshDetectorML rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrWorldMeshDetectorML and WorldMeshDetectorML.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrWorldMeshDetectorML lhs,
                                                      WorldMeshDetectorML const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between WorldMeshDetectorML and raw XrWorldMeshDetectorML.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(WorldMeshDetectorML const& lhs,
                                                       XrWorldMeshDetectorML rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrWorldMeshDetectorML and WorldMeshDetectorML.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrWorldMeshDetectorML lhs,
                                                       WorldMeshDetectorML const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between WorldMeshDetectorML and raw XrWorldMeshDetectorML.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(WorldMeshDetectorML const& lhs,
                                                       XrWorldMeshDetectorML rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrWorldMeshDetectorML and WorldMeshDetectorML.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrWorldMeshDetectorML lhs,
                                                       WorldMeshDetectorML const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between WorldMeshDetectorML and raw XrWorldMeshDetectorML.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(WorldMeshDetectorML const& lhs,
                                                       XrWorldMeshDetectorML rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrWorldMeshDetectorML and WorldMeshDetectorML.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrWorldMeshDetectorML lhs,
                                                       WorldMeshDetectorML const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between WorldMeshDetectorML and raw XrWorldMeshDetectorML.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(WorldMeshDetectorML const& lhs,
                                                       XrWorldMeshDetectorML rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrWorldMeshDetectorML and WorldMeshDetectorML.
//! @relates WorldMeshDetectorML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrWorldMeshDetectorML lhs,
                                                       WorldMeshDetectorML const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between WorldMeshDetectorML and nullptr: true if the handle is null.
 * @relates WorldMeshDetectorML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(WorldMeshDetectorML const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and WorldMeshDetectorML: true if the handle is null.
 * @relates WorldMeshDetectorML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       WorldMeshDetectorML const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between WorldMeshDetectorML and nullptr: true if the handle is not
 * null.
 * @relates WorldMeshDetectorML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(WorldMeshDetectorML const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and WorldMeshDetectorML: true if the handle is not
 * null.
 * @relates WorldMeshDetectorML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       WorldMeshDetectorML const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_ML_world_mesh_detection

#ifdef XR_ML_facial_expression

/*!
 * @brief Handle class - wrapping XrFacialExpressionClientML without indicating ownership.
 *
 * Provided by the `XR_ML_facial_expression` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrFacialExpressionClientML>
 *
 * @xrentity{XrFacialExpressionClientML}
 * @ingroup handles
 */
class FacialExpressionClientML {
public:
  using Type = FacialExpressionClientML;
  using RawHandleType = XrFacialExpressionClientML;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR FacialExpressionClientML() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrFacialExpressionClientML type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT FacialExpressionClientML(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR FacialExpressionClientML(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrFacialExpressionClientML
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrFacialExpressionClientML type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this FacialExpressionClientML value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this FacialExpressionClientML value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrFacialExpressionClientML manipulation
   * @{
   */
  //! Gets the raw XrFacialExpressionClientML value.
  OPENXR_HPP_CONSTEXPR XrFacialExpressionClientML get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * FacialExpressionClientML yourHandle;
   * auto result = d.xrCreateFacialExpressionClientML(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(FacialExpressionClientML&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroyFacialExpressionClientML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFacialExpressionClientML>
   *
   * @xrentity{xrDestroyFacialExpressionClientML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroyFacialExpressionClientML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFacialExpressionClientML>
   *
   * @xrentity{xrDestroyFacialExpressionClientML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroyFacialExpressionClientML enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroyFacialExpressionClientML>
   *
   * @xrentity{xrDestroyFacialExpressionClientML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetFacialExpressionBlendShapePropertiesML wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFacialExpressionBlendShapePropertiesML>
   *
   * @xrentity{xrGetFacialExpressionBlendShapePropertiesML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getFacialExpressionBlendShapePropertiesML(
      const FacialExpressionBlendShapeGetInfoML& blendShapeGetInfo, uint32_t blendShapeCount,
      FacialExpressionBlendShapePropertiesML* blendShapes,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetFacialExpressionBlendShapePropertiesML enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FacialExpressionBlendShapePropertiesML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFacialExpressionBlendShapePropertiesML>
   *
   * @xrentity{xrGetFacialExpressionBlendShapePropertiesML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FacialExpressionBlendShapePropertiesML> getFacialExpressionBlendShapePropertiesML(
      const FacialExpressionBlendShapeGetInfoML& blendShapeGetInfo, uint32_t blendShapeCount,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrGetFacialExpressionBlendShapePropertiesML enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FacialExpressionBlendShapePropertiesML
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetFacialExpressionBlendShapePropertiesML>
   *
   * @xrentity{xrGetFacialExpressionBlendShapePropertiesML}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FacialExpressionBlendShapePropertiesML getFacialExpressionBlendShapePropertiesML(
      const FacialExpressionBlendShapeGetInfoML& blendShapeGetInfo, uint32_t blendShapeCount,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrFacialExpressionClientML val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrFacialExpressionClientML) == sizeof(FacialExpressionClientML),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrFacialExpressionClientML from an
 * FacialExpressionClientML value.
 *
 * @found_by_adl
 * @see FacialExpressionClientML::get()
 * @relates FacialExpressionClientML
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrFacialExpressionClientML
get(FacialExpressionClientML const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrFacialExpressionClientML handle in a FacialExpressionClientML (by reference).
 *
 * e.g.
 * ```
 * FacialExpressionClientML yourHandle;
 * auto result = d.xrCreateFacialExpressionClientML(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates FacialExpressionClientML
 */
static OPENXR_HPP_INLINE XrFacialExpressionClientML* put(FacialExpressionClientML& h,
                                                         bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between FacialExpressionClientML values.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    FacialExpressionClientML const& lhs, FacialExpressionClientML const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between FacialExpressionClientML values.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    FacialExpressionClientML const& lhs, FacialExpressionClientML const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between FacialExpressionClientML values.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    FacialExpressionClientML const& lhs, FacialExpressionClientML const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between FacialExpressionClientML values.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    FacialExpressionClientML const& lhs, FacialExpressionClientML const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between FacialExpressionClientML values.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    FacialExpressionClientML const& lhs, FacialExpressionClientML const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between FacialExpressionClientML values.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    FacialExpressionClientML const& lhs, FacialExpressionClientML const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between FacialExpressionClientML and raw XrFacialExpressionClientML.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(FacialExpressionClientML const& lhs,
                                                      XrFacialExpressionClientML rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrFacialExpressionClientML and FacialExpressionClientML.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    XrFacialExpressionClientML lhs, FacialExpressionClientML const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between FacialExpressionClientML and raw XrFacialExpressionClientML.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(FacialExpressionClientML const& lhs,
                                                      XrFacialExpressionClientML rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrFacialExpressionClientML and FacialExpressionClientML.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    XrFacialExpressionClientML lhs, FacialExpressionClientML const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between FacialExpressionClientML and raw XrFacialExpressionClientML.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(FacialExpressionClientML const& lhs,
                                                       XrFacialExpressionClientML rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrFacialExpressionClientML and FacialExpressionClientML.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    XrFacialExpressionClientML lhs, FacialExpressionClientML const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between FacialExpressionClientML and raw XrFacialExpressionClientML.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(FacialExpressionClientML const& lhs,
                                                       XrFacialExpressionClientML rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrFacialExpressionClientML and FacialExpressionClientML.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    XrFacialExpressionClientML lhs, FacialExpressionClientML const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between FacialExpressionClientML and raw XrFacialExpressionClientML.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FacialExpressionClientML const& lhs,
                                                       XrFacialExpressionClientML rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrFacialExpressionClientML and FacialExpressionClientML.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    XrFacialExpressionClientML lhs, FacialExpressionClientML const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between FacialExpressionClientML and raw XrFacialExpressionClientML.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FacialExpressionClientML const& lhs,
                                                       XrFacialExpressionClientML rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrFacialExpressionClientML and FacialExpressionClientML.
//! @relates FacialExpressionClientML
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    XrFacialExpressionClientML lhs, FacialExpressionClientML const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between FacialExpressionClientML and nullptr: true if the handle is
 * null.
 * @relates FacialExpressionClientML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(FacialExpressionClientML const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and FacialExpressionClientML: true if the handle is
 * null.
 * @relates FacialExpressionClientML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    std::nullptr_t /* unused */, FacialExpressionClientML const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between FacialExpressionClientML and nullptr: true if the handle is
 * not null.
 * @relates FacialExpressionClientML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(FacialExpressionClientML const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and FacialExpressionClientML: true if the handle is
 * not null.
 * @relates FacialExpressionClientML
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    std::nullptr_t /* unused */, FacialExpressionClientML const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_ML_facial_expression

#ifdef XR_EXT_spatial_entity

/*!
 * @brief Handle class - wrapping XrSpatialEntityEXT without indicating ownership.
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialEntityEXT>
 *
 * @xrentity{XrSpatialEntityEXT}
 * @ingroup handles
 */
class SpatialEntityEXT {
public:
  using Type = SpatialEntityEXT;
  using RawHandleType = XrSpatialEntityEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SpatialEntityEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpatialEntityEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SpatialEntityEXT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SpatialEntityEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpatialEntityEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpatialEntityEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SpatialEntityEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SpatialEntityEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpatialEntityEXT manipulation
   * @{
   */
  //! Gets the raw XrSpatialEntityEXT value.
  OPENXR_HPP_CONSTEXPR XrSpatialEntityEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SpatialEntityEXT yourHandle;
   * auto result = d.xrCreateSpatialEntityEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SpatialEntityEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpatialEntityEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialEntityEXT>
   *
   * @xrentity{xrDestroySpatialEntityEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpatialEntityEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialEntityEXT>
   *
   * @xrentity{xrDestroySpatialEntityEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpatialEntityEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialEntityEXT>
   *
   * @xrentity{xrDestroySpatialEntityEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrSpatialEntityEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpatialEntityEXT) == sizeof(SpatialEntityEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpatialEntityEXT from an SpatialEntityEXT value.
 *
 * @found_by_adl
 * @see SpatialEntityEXT::get()
 * @relates SpatialEntityEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpatialEntityEXT get(SpatialEntityEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSpatialEntityEXT handle in a SpatialEntityEXT (by reference).
 *
 * e.g.
 * ```
 * SpatialEntityEXT yourHandle;
 * auto result = d.xrCreateSpatialEntityEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SpatialEntityEXT
 */
static OPENXR_HPP_INLINE XrSpatialEntityEXT* put(SpatialEntityEXT& h, bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SpatialEntityEXT values.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialEntityEXT const& lhs,
                                                      SpatialEntityEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SpatialEntityEXT values.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialEntityEXT const& lhs,
                                                      SpatialEntityEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SpatialEntityEXT values.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialEntityEXT const& lhs,
                                                       SpatialEntityEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SpatialEntityEXT values.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialEntityEXT const& lhs,
                                                       SpatialEntityEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SpatialEntityEXT values.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialEntityEXT const& lhs,
                                                       SpatialEntityEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SpatialEntityEXT values.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialEntityEXT const& lhs,
                                                       SpatialEntityEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SpatialEntityEXT and raw XrSpatialEntityEXT.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialEntityEXT const& lhs,
                                                      XrSpatialEntityEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpatialEntityEXT and SpatialEntityEXT.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSpatialEntityEXT lhs,
                                                      SpatialEntityEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SpatialEntityEXT and raw XrSpatialEntityEXT.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialEntityEXT const& lhs,
                                                      XrSpatialEntityEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpatialEntityEXT and SpatialEntityEXT.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSpatialEntityEXT lhs,
                                                      SpatialEntityEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SpatialEntityEXT and raw XrSpatialEntityEXT.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialEntityEXT const& lhs,
                                                       XrSpatialEntityEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpatialEntityEXT and SpatialEntityEXT.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSpatialEntityEXT lhs,
                                                       SpatialEntityEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SpatialEntityEXT and raw XrSpatialEntityEXT.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialEntityEXT const& lhs,
                                                       XrSpatialEntityEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpatialEntityEXT and SpatialEntityEXT.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSpatialEntityEXT lhs,
                                                       SpatialEntityEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SpatialEntityEXT and raw XrSpatialEntityEXT.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialEntityEXT const& lhs,
                                                       XrSpatialEntityEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpatialEntityEXT and SpatialEntityEXT.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSpatialEntityEXT lhs,
                                                       SpatialEntityEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SpatialEntityEXT and raw XrSpatialEntityEXT.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialEntityEXT const& lhs,
                                                       XrSpatialEntityEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpatialEntityEXT and SpatialEntityEXT.
//! @relates SpatialEntityEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSpatialEntityEXT lhs,
                                                       SpatialEntityEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SpatialEntityEXT and nullptr: true if the handle is null.
 * @relates SpatialEntityEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialEntityEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SpatialEntityEXT: true if the handle is null.
 * @relates SpatialEntityEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SpatialEntityEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SpatialEntityEXT and nullptr: true if the handle is not
 * null.
 * @relates SpatialEntityEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialEntityEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SpatialEntityEXT: true if the handle is not
 * null.
 * @relates SpatialEntityEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SpatialEntityEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity

/*!
 * @brief Handle class - wrapping XrSpatialContextEXT without indicating ownership.
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialContextEXT>
 *
 * @xrentity{XrSpatialContextEXT}
 * @ingroup handles
 */
class SpatialContextEXT {
public:
  using Type = SpatialContextEXT;
  using RawHandleType = XrSpatialContextEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SpatialContextEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpatialContextEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SpatialContextEXT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SpatialContextEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpatialContextEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpatialContextEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SpatialContextEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SpatialContextEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpatialContextEXT manipulation
   * @{
   */
  //! Gets the raw XrSpatialContextEXT value.
  OPENXR_HPP_CONSTEXPR XrSpatialContextEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SpatialContextEXT yourHandle;
   * auto result = d.xrCreateSpatialContextEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SpatialContextEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpatialContextEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialContextEXT>
   *
   * @xrentity{xrDestroySpatialContextEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpatialContextEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialContextEXT>
   *
   * @xrentity{xrDestroySpatialContextEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpatialContextEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialContextEXT>
   *
   * @xrentity{xrDestroySpatialContextEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSpatialDiscoverySnapshotAsyncEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialDiscoverySnapshotAsyncEXT>
   *
   * @xrentity{xrCreateSpatialDiscoverySnapshotAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialDiscoverySnapshotAsyncEXT(
      const SpatialDiscoverySnapshotCreateInfoEXT& createInfo, FutureEXT& future,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialDiscoverySnapshotAsyncEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialDiscoverySnapshotAsyncEXT>
   *
   * @xrentity{xrCreateSpatialDiscoverySnapshotAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> createSpatialDiscoverySnapshotAsyncEXT(
      const SpatialDiscoverySnapshotCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialDiscoverySnapshotAsyncEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialDiscoverySnapshotAsyncEXT>
   *
   * @xrentity{xrCreateSpatialDiscoverySnapshotAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT createSpatialDiscoverySnapshotAsyncEXT(
      const SpatialDiscoverySnapshotCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSpatialDiscoverySnapshotCompleteEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialDiscoverySnapshotCompleteEXT>
   *
   * @xrentity{xrCreateSpatialDiscoverySnapshotCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialDiscoverySnapshotCompleteEXT(
      const CreateSpatialDiscoverySnapshotCompletionInfoEXT& createSnapshotCompletionInfo,
      CreateSpatialDiscoverySnapshotCompletionEXT& completion,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialDiscoverySnapshotCompleteEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type CreateSpatialDiscoverySnapshotCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialDiscoverySnapshotCompleteEXT>
   *
   * @xrentity{xrCreateSpatialDiscoverySnapshotCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<CreateSpatialDiscoverySnapshotCompletionEXT>
  createSpatialDiscoverySnapshotCompleteEXT(
      const CreateSpatialDiscoverySnapshotCompletionInfoEXT& createSnapshotCompletionInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialDiscoverySnapshotCompleteEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type CreateSpatialDiscoverySnapshotCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialDiscoverySnapshotCompleteEXT>
   *
   * @xrentity{xrCreateSpatialDiscoverySnapshotCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  CreateSpatialDiscoverySnapshotCompletionEXT createSpatialDiscoverySnapshotCompleteEXT(
      const CreateSpatialDiscoverySnapshotCompletionInfoEXT& createSnapshotCompletionInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSpatialEntityFromIdEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialEntityFromIdEXT>
   *
   * @xrentity{xrCreateSpatialEntityFromIdEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialEntityFromIdEXT(const SpatialEntityFromIdCreateInfoEXT& createInfo,
                                      SpatialEntityEXT& spatialEntity,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialEntityFromIdEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialEntityEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialEntityFromIdEXT>
   *
   * @xrentity{xrCreateSpatialEntityFromIdEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialEntityEXT> createSpatialEntityFromIdEXT(
      const SpatialEntityFromIdCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialEntityFromIdEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialEntityEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialEntityFromIdEXT>
   *
   * @xrentity{xrCreateSpatialEntityFromIdEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialEntityEXT createSpatialEntityFromIdEXT(const SpatialEntityFromIdCreateInfoEXT& createInfo,
                                                Dispatch&& d
                                                    OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialEntityFromIdEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialEntityEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialEntityFromIdEXT>
   *
   * @xrentity{xrCreateSpatialEntityFromIdEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialEntityEXT, impl::RemoveRefConst<Dispatch>>>
  createSpatialEntityFromIdUniqueEXT(const SpatialEntityFromIdCreateInfoEXT& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialEntityFromIdEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialEntityEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialEntityFromIdEXT>
   *
   * @xrentity{xrCreateSpatialEntityFromIdEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialEntityEXT, impl::RemoveRefConst<Dispatch>> createSpatialEntityFromIdUniqueEXT(
      const SpatialEntityFromIdCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrCreateSpatialUpdateSnapshotEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialUpdateSnapshotEXT>
   *
   * @xrentity{xrCreateSpatialUpdateSnapshotEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialUpdateSnapshotEXT(const SpatialUpdateSnapshotCreateInfoEXT& createInfo,
                                        SpatialSnapshotEXT& snapshot,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialUpdateSnapshotEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialSnapshotEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialUpdateSnapshotEXT>
   *
   * @xrentity{xrCreateSpatialUpdateSnapshotEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialSnapshotEXT> createSpatialUpdateSnapshotEXT(
      const SpatialUpdateSnapshotCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialUpdateSnapshotEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialSnapshotEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialUpdateSnapshotEXT>
   *
   * @xrentity{xrCreateSpatialUpdateSnapshotEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialSnapshotEXT createSpatialUpdateSnapshotEXT(
      const SpatialUpdateSnapshotCreateInfoEXT& createInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialUpdateSnapshotEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialSnapshotEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialUpdateSnapshotEXT>
   *
   * @xrentity{xrCreateSpatialUpdateSnapshotEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialSnapshotEXT, impl::RemoveRefConst<Dispatch>>>
  createSpatialUpdateSnapshotUniqueEXT(const SpatialUpdateSnapshotCreateInfoEXT& createInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialUpdateSnapshotEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialSnapshotEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialUpdateSnapshotEXT>
   *
   * @xrentity{xrCreateSpatialUpdateSnapshotEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialSnapshotEXT, impl::RemoveRefConst<Dispatch>>
  createSpatialUpdateSnapshotUniqueEXT(const SpatialUpdateSnapshotCreateInfoEXT& createInfo,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_EXT_spatial_anchor

  /*!
   * @brief xrCreateSpatialAnchorEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorEXT>
   *
   * @xrentity{xrCreateSpatialAnchorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result createSpatialAnchorEXT(const SpatialAnchorCreateInfoEXT& createInfo,
                                SpatialEntityIdEXT& anchorEntityId, SpatialEntityEXT& anchorEntity,
                                Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type SpatialEntityEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorEXT>
   *
   * @xrentity{xrCreateSpatialAnchorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<SpatialEntityEXT> createSpatialAnchorEXT(
      const SpatialAnchorCreateInfoEXT& createInfo, SpatialEntityIdEXT& anchorEntityId,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type SpatialEntityEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorEXT>
   *
   * @xrentity{xrCreateSpatialAnchorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  SpatialEntityEXT createSpatialAnchorEXT(const SpatialAnchorCreateInfoEXT& createInfo,
                                          SpatialEntityIdEXT& anchorEntityId,
                                          Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrCreateSpatialAnchorEXT wrapper returning a smart handle.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * -  a smart wrapper uniquely owning a SpatialEntityEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorEXT>
   *
   * @xrentity{xrCreateSpatialAnchorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UniqueHandle<SpatialEntityEXT, impl::RemoveRefConst<Dispatch>>>
  createSpatialAnchorUniqueEXT(const SpatialAnchorCreateInfoEXT& createInfo,
                               SpatialEntityIdEXT& anchorEntityId,
                               Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrCreateSpatialAnchorEXT wrapper returning a smart handle.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns  a smart wrapper uniquely owning a SpatialEntityEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateSpatialAnchorEXT>
   *
   * @xrentity{xrCreateSpatialAnchorEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UniqueHandle<SpatialEntityEXT, impl::RemoveRefConst<Dispatch>> createSpatialAnchorUniqueEXT(
      const SpatialAnchorCreateInfoEXT& createInfo, SpatialEntityIdEXT& anchorEntityId,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_anchor

  //! @}
private:
  XrSpatialContextEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpatialContextEXT) == sizeof(SpatialContextEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpatialContextEXT from an SpatialContextEXT value.
 *
 * @found_by_adl
 * @see SpatialContextEXT::get()
 * @relates SpatialContextEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpatialContextEXT
get(SpatialContextEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSpatialContextEXT handle in a SpatialContextEXT (by reference).
 *
 * e.g.
 * ```
 * SpatialContextEXT yourHandle;
 * auto result = d.xrCreateSpatialContextEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SpatialContextEXT
 */
static OPENXR_HPP_INLINE XrSpatialContextEXT* put(SpatialContextEXT& h,
                                                  bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SpatialContextEXT values.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialContextEXT const& lhs,
                                                      SpatialContextEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SpatialContextEXT values.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialContextEXT const& lhs,
                                                      SpatialContextEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SpatialContextEXT values.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialContextEXT const& lhs,
                                                       SpatialContextEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SpatialContextEXT values.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialContextEXT const& lhs,
                                                       SpatialContextEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SpatialContextEXT values.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialContextEXT const& lhs,
                                                       SpatialContextEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SpatialContextEXT values.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialContextEXT const& lhs,
                                                       SpatialContextEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SpatialContextEXT and raw XrSpatialContextEXT.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialContextEXT const& lhs,
                                                      XrSpatialContextEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpatialContextEXT and SpatialContextEXT.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSpatialContextEXT lhs,
                                                      SpatialContextEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SpatialContextEXT and raw XrSpatialContextEXT.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialContextEXT const& lhs,
                                                      XrSpatialContextEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpatialContextEXT and SpatialContextEXT.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSpatialContextEXT lhs,
                                                      SpatialContextEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SpatialContextEXT and raw XrSpatialContextEXT.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialContextEXT const& lhs,
                                                       XrSpatialContextEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpatialContextEXT and SpatialContextEXT.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSpatialContextEXT lhs,
                                                       SpatialContextEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SpatialContextEXT and raw XrSpatialContextEXT.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialContextEXT const& lhs,
                                                       XrSpatialContextEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpatialContextEXT and SpatialContextEXT.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSpatialContextEXT lhs,
                                                       SpatialContextEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SpatialContextEXT and raw XrSpatialContextEXT.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialContextEXT const& lhs,
                                                       XrSpatialContextEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpatialContextEXT and SpatialContextEXT.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSpatialContextEXT lhs,
                                                       SpatialContextEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SpatialContextEXT and raw XrSpatialContextEXT.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialContextEXT const& lhs,
                                                       XrSpatialContextEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpatialContextEXT and SpatialContextEXT.
//! @relates SpatialContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSpatialContextEXT lhs,
                                                       SpatialContextEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SpatialContextEXT and nullptr: true if the handle is null.
 * @relates SpatialContextEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialContextEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SpatialContextEXT: true if the handle is null.
 * @relates SpatialContextEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SpatialContextEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SpatialContextEXT and nullptr: true if the handle is not
 * null.
 * @relates SpatialContextEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialContextEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SpatialContextEXT: true if the handle is not
 * null.
 * @relates SpatialContextEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SpatialContextEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_entity

/*!
 * @brief Handle class - wrapping XrSpatialSnapshotEXT without indicating ownership.
 *
 * Provided by the `XR_EXT_spatial_entity` extension.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialSnapshotEXT>
 *
 * @xrentity{XrSpatialSnapshotEXT}
 * @ingroup handles
 */
class SpatialSnapshotEXT {
public:
  using Type = SpatialSnapshotEXT;
  using RawHandleType = XrSpatialSnapshotEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SpatialSnapshotEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpatialSnapshotEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SpatialSnapshotEXT(RawHandleType handle) noexcept : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SpatialSnapshotEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpatialSnapshotEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpatialSnapshotEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SpatialSnapshotEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SpatialSnapshotEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpatialSnapshotEXT manipulation
   * @{
   */
  //! Gets the raw XrSpatialSnapshotEXT value.
  OPENXR_HPP_CONSTEXPR XrSpatialSnapshotEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SpatialSnapshotEXT yourHandle;
   * auto result = d.xrCreateSpatialSnapshotEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SpatialSnapshotEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrQuerySpatialComponentDataEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySpatialComponentDataEXT>
   *
   * @xrentity{xrQuerySpatialComponentDataEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result querySpatialComponentDataEXT(const SpatialComponentDataQueryConditionEXT& queryCondition,
                                      SpatialComponentDataQueryResultEXT& queryResult,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrQuerySpatialComponentDataEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySpatialComponentDataEXT>
   *
   * @xrentity{xrQuerySpatialComponentDataEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result querySpatialComponentDataEXT(const SpatialComponentDataQueryConditionEXT& queryCondition,
                                      SpatialComponentDataQueryResultEXT& queryResult,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrQuerySpatialComponentDataEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrQuerySpatialComponentDataEXT>
   *
   * @xrentity{xrQuerySpatialComponentDataEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void querySpatialComponentDataEXT(const SpatialComponentDataQueryConditionEXT& queryCondition,
                                    SpatialComponentDataQueryResultEXT& queryResult,
                                    Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpatialSnapshotEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialSnapshotEXT>
   *
   * @xrentity{xrDestroySpatialSnapshotEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpatialSnapshotEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialSnapshotEXT>
   *
   * @xrentity{xrDestroySpatialSnapshotEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpatialSnapshotEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialSnapshotEXT>
   *
   * @xrentity{xrDestroySpatialSnapshotEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSpatialBufferStringEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferStringEXT>
   *
   * @xrentity{xrGetSpatialBufferStringEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialBufferStringEXT(const SpatialBufferGetInfoEXT& info,
                                   uint32_t bufferCapacityInput, uint32_t& bufferCountOutput,
                                   char* buffer,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpatialBufferStringEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferStringEXT>
   *
   * @xrentity{xrGetSpatialBufferStringEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getSpatialBufferStringEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferStringEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferStringEXT>
   *
   * @xrentity{xrGetSpatialBufferStringEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<string_with_allocator<Allocator>> getSpatialBufferStringEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetSpatialBufferStringEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferStringEXT>
   *
   * @xrentity{xrGetSpatialBufferStringEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getSpatialBufferStringEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferStringEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output string
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferStringEXT>
   *
   * @xrentity{xrGetSpatialBufferStringEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<char>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  string_with_allocator<Allocator> getSpatialBufferStringEXT(const SpatialBufferGetInfoEXT& info,
                                                             Allocator const& vectorAllocator,
                                                             Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSpatialBufferUint8EXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint8EXT>
   *
   * @xrentity{xrGetSpatialBufferUint8EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialBufferUint8EXT(const SpatialBufferGetInfoEXT& info, uint32_t bufferCapacityInput,
                                  uint32_t& bufferCountOutput, uint8_t* buffer,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpatialBufferUint8EXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<uint8_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint8EXT>
   *
   * @xrentity{xrGetSpatialBufferUint8EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint8_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<uint8_t, Allocator>> getSpatialBufferUint8ToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferUint8EXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<uint8_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint8EXT>
   *
   * @xrentity{xrGetSpatialBufferUint8EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint8_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<uint8_t, Allocator>> getSpatialBufferUint8ToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetSpatialBufferUint8EXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<uint8_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint8EXT>
   *
   * @xrentity{xrGetSpatialBufferUint8EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint8_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<uint8_t, Allocator> getSpatialBufferUint8ToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferUint8EXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<uint8_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint8EXT>
   *
   * @xrentity{xrGetSpatialBufferUint8EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint8_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<uint8_t, Allocator> getSpatialBufferUint8ToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSpatialBufferUint16EXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint16EXT>
   *
   * @xrentity{xrGetSpatialBufferUint16EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialBufferUint16EXT(const SpatialBufferGetInfoEXT& info,
                                   uint32_t bufferCapacityInput, uint32_t& bufferCountOutput,
                                   uint16_t* buffer,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpatialBufferUint16EXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<uint16_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint16EXT>
   *
   * @xrentity{xrGetSpatialBufferUint16EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint16_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<uint16_t, Allocator>> getSpatialBufferUint16ToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferUint16EXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<uint16_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint16EXT>
   *
   * @xrentity{xrGetSpatialBufferUint16EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint16_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<uint16_t, Allocator>> getSpatialBufferUint16ToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetSpatialBufferUint16EXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<uint16_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint16EXT>
   *
   * @xrentity{xrGetSpatialBufferUint16EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint16_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<uint16_t, Allocator> getSpatialBufferUint16ToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferUint16EXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<uint16_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint16EXT>
   *
   * @xrentity{xrGetSpatialBufferUint16EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint16_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<uint16_t, Allocator> getSpatialBufferUint16ToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSpatialBufferUint32EXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint32EXT>
   *
   * @xrentity{xrGetSpatialBufferUint32EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialBufferUint32EXT(const SpatialBufferGetInfoEXT& info,
                                   uint32_t bufferCapacityInput, uint32_t& bufferCountOutput,
                                   uint32_t* buffer,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpatialBufferUint32EXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<uint32_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint32EXT>
   *
   * @xrentity{xrGetSpatialBufferUint32EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint32_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<uint32_t, Allocator>> getSpatialBufferUint32ToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferUint32EXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<uint32_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint32EXT>
   *
   * @xrentity{xrGetSpatialBufferUint32EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint32_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<uint32_t, Allocator>> getSpatialBufferUint32ToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetSpatialBufferUint32EXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<uint32_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint32EXT>
   *
   * @xrentity{xrGetSpatialBufferUint32EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint32_t>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<uint32_t, Allocator> getSpatialBufferUint32ToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferUint32EXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<uint32_t, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferUint32EXT>
   *
   * @xrentity{xrGetSpatialBufferUint32EXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<uint32_t>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<uint32_t, Allocator> getSpatialBufferUint32ToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSpatialBufferFloatEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferFloatEXT>
   *
   * @xrentity{xrGetSpatialBufferFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialBufferFloatEXT(const SpatialBufferGetInfoEXT& info, uint32_t bufferCapacityInput,
                                  uint32_t& bufferCountOutput, float* buffer,
                                  Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpatialBufferFloatEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferFloatEXT>
   *
   * @xrentity{xrGetSpatialBufferFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<float, Allocator>> getSpatialBufferFloatToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferFloatEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferFloatEXT>
   *
   * @xrentity{xrGetSpatialBufferFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<float, Allocator>> getSpatialBufferFloatToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetSpatialBufferFloatEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferFloatEXT>
   *
   * @xrentity{xrGetSpatialBufferFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<float, Allocator> getSpatialBufferFloatToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferFloatEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<float, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferFloatEXT>
   *
   * @xrentity{xrGetSpatialBufferFloatEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<float>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<float, Allocator> getSpatialBufferFloatToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSpatialBufferVector2fEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferVector2fEXT>
   *
   * @xrentity{xrGetSpatialBufferVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialBufferVector2fEXT(const SpatialBufferGetInfoEXT& info,
                                     uint32_t bufferCapacityInput, uint32_t& bufferCountOutput,
                                     Vector2f* buffer,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpatialBufferVector2fEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Vector2f, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferVector2fEXT>
   *
   * @xrentity{xrGetSpatialBufferVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Vector2f>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Vector2f, Allocator>> getSpatialBufferVector2fToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferVector2fEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Vector2f, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferVector2fEXT>
   *
   * @xrentity{xrGetSpatialBufferVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Vector2f>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Vector2f, Allocator>> getSpatialBufferVector2fToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetSpatialBufferVector2fEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<Vector2f, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferVector2fEXT>
   *
   * @xrentity{xrGetSpatialBufferVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Vector2f>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Vector2f, Allocator> getSpatialBufferVector2fToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferVector2fEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<Vector2f, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferVector2fEXT>
   *
   * @xrentity{xrGetSpatialBufferVector2fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Vector2f>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Vector2f, Allocator> getSpatialBufferVector2fToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  /*!
   * @brief xrGetSpatialBufferVector3fEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferVector3fEXT>
   *
   * @xrentity{xrGetSpatialBufferVector3fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result getSpatialBufferVector3fEXT(const SpatialBufferGetInfoEXT& info,
                                     uint32_t bufferCapacityInput, uint32_t& bufferCountOutput,
                                     Vector3f* buffer,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrGetSpatialBufferVector3fEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined. Performs two-call idiom. Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Vector3f, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferVector3fEXT>
   *
   * @xrentity{xrGetSpatialBufferVector3fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Vector3f>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Vector3f, Allocator>> getSpatialBufferVector3fToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferVector3fEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type std::vector<Vector3f, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferVector3fEXT>
   *
   * @xrentity{xrGetSpatialBufferVector3fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Vector3f>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<std::vector<Vector3f, Allocator>> getSpatialBufferVector3fToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#else
  /*!
   * @brief xrGetSpatialBufferVector3fEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   * Performs two-call idiom.
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type std::vector<Vector3f, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferVector3fEXT>
   *
   * @xrentity{xrGetSpatialBufferVector3fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Vector3f>,
            typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Vector3f, Allocator> getSpatialBufferVector3fToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;
  /*!
   * @brief xrGetSpatialBufferVector3fEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns the output of type std::vector<Vector3f, Allocator>
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrGetSpatialBufferVector3fEXT>
   *
   * @xrentity{xrGetSpatialBufferVector3fEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Allocator = std::allocator<Vector3f>, typename Dispatch,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  std::vector<Vector3f, Allocator> getSpatialBufferVector3fToVectorEXT(
      const SpatialBufferGetInfoEXT& info, Allocator const& vectorAllocator, Dispatch&& d) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

  //! @}
private:
  XrSpatialSnapshotEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpatialSnapshotEXT) == sizeof(SpatialSnapshotEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpatialSnapshotEXT from an SpatialSnapshotEXT value.
 *
 * @found_by_adl
 * @see SpatialSnapshotEXT::get()
 * @relates SpatialSnapshotEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpatialSnapshotEXT
get(SpatialSnapshotEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSpatialSnapshotEXT handle in a SpatialSnapshotEXT (by reference).
 *
 * e.g.
 * ```
 * SpatialSnapshotEXT yourHandle;
 * auto result = d.xrCreateSpatialSnapshotEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SpatialSnapshotEXT
 */
static OPENXR_HPP_INLINE XrSpatialSnapshotEXT* put(SpatialSnapshotEXT& h,
                                                   bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SpatialSnapshotEXT values.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialSnapshotEXT const& lhs,
                                                      SpatialSnapshotEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SpatialSnapshotEXT values.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialSnapshotEXT const& lhs,
                                                      SpatialSnapshotEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SpatialSnapshotEXT values.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialSnapshotEXT const& lhs,
                                                       SpatialSnapshotEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SpatialSnapshotEXT values.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialSnapshotEXT const& lhs,
                                                       SpatialSnapshotEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SpatialSnapshotEXT values.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialSnapshotEXT const& lhs,
                                                       SpatialSnapshotEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SpatialSnapshotEXT values.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialSnapshotEXT const& lhs,
                                                       SpatialSnapshotEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SpatialSnapshotEXT and raw XrSpatialSnapshotEXT.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialSnapshotEXT const& lhs,
                                                      XrSpatialSnapshotEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpatialSnapshotEXT and SpatialSnapshotEXT.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(XrSpatialSnapshotEXT lhs,
                                                      SpatialSnapshotEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SpatialSnapshotEXT and raw XrSpatialSnapshotEXT.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialSnapshotEXT const& lhs,
                                                      XrSpatialSnapshotEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpatialSnapshotEXT and SpatialSnapshotEXT.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(XrSpatialSnapshotEXT lhs,
                                                      SpatialSnapshotEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SpatialSnapshotEXT and raw XrSpatialSnapshotEXT.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(SpatialSnapshotEXT const& lhs,
                                                       XrSpatialSnapshotEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpatialSnapshotEXT and SpatialSnapshotEXT.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(XrSpatialSnapshotEXT lhs,
                                                       SpatialSnapshotEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SpatialSnapshotEXT and raw XrSpatialSnapshotEXT.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(SpatialSnapshotEXT const& lhs,
                                                       XrSpatialSnapshotEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpatialSnapshotEXT and SpatialSnapshotEXT.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(XrSpatialSnapshotEXT lhs,
                                                       SpatialSnapshotEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SpatialSnapshotEXT and raw XrSpatialSnapshotEXT.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialSnapshotEXT const& lhs,
                                                       XrSpatialSnapshotEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpatialSnapshotEXT and SpatialSnapshotEXT.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(XrSpatialSnapshotEXT lhs,
                                                       SpatialSnapshotEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SpatialSnapshotEXT and raw XrSpatialSnapshotEXT.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialSnapshotEXT const& lhs,
                                                       XrSpatialSnapshotEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpatialSnapshotEXT and SpatialSnapshotEXT.
//! @relates SpatialSnapshotEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(XrSpatialSnapshotEXT lhs,
                                                       SpatialSnapshotEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SpatialSnapshotEXT and nullptr: true if the handle is null.
 * @relates SpatialSnapshotEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialSnapshotEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SpatialSnapshotEXT: true if the handle is null.
 * @relates SpatialSnapshotEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       SpatialSnapshotEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SpatialSnapshotEXT and nullptr: true if the handle is not
 * null.
 * @relates SpatialSnapshotEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialSnapshotEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SpatialSnapshotEXT: true if the handle is not
 * null.
 * @relates SpatialSnapshotEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       SpatialSnapshotEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_EXT_spatial_entity

#ifdef XR_EXT_spatial_persistence

/*!
 * @brief Handle class - wrapping XrSpatialPersistenceContextEXT without indicating ownership.
 *
 * Provided by the `XR_EXT_spatial_persistence` extension.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#XrSpatialPersistenceContextEXT>
 *
 * @xrentity{XrSpatialPersistenceContextEXT}
 * @ingroup handles
 */
class SpatialPersistenceContextEXT {
public:
  using Type = SpatialPersistenceContextEXT;
  using RawHandleType = XrSpatialPersistenceContextEXT;
  /*!
   * @name Constructors, assignment, and conversions
   * @{
   */
  //! Default (empty/null) constructor
  OPENXR_HPP_CONSTEXPR SpatialPersistenceContextEXT() noexcept : val_(XR_NULL_HANDLE) {}
  /*!
   * @brief Conversion constructor from the raw XrSpatialPersistenceContextEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_TYPESAFE_EXPLICIT SpatialPersistenceContextEXT(RawHandleType handle) noexcept
      : val_(handle) {}
  //! Constructor from nullptr - creates empty/null handle.
  OPENXR_HPP_CONSTEXPR SpatialPersistenceContextEXT(std::nullptr_t /* unused */) noexcept
      : val_(XR_NULL_HANDLE) {}

#if defined(OPENXR_HPP_TYPESAFE_CONVERSION)
  /*!
   * @brief Assignment operator from the raw XrSpatialPersistenceContextEXT
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   *
   * Only provided if `OPENXR_HPP_TYPESAFE_CONVERSION` is defined (64-bit platforms by default).
   */
  Type& operator=(RawHandleType handle) noexcept {
    val_ = handle;
    return *this;
  }
#endif

  /*!
   * @brief Assignment operator from nullptr - assigns to empty/null handle.
   *
   * Does *not* destroy any contained non-null handle first! For that, see @ref UniqueHandle.
   */
  Type& operator=(std::nullptr_t /* unused */) noexcept {
    val_ = XR_NULL_HANDLE;
    return *this;
  }

  /*!
   * @brief Conversion operator to the raw XrSpatialPersistenceContextEXT type
   *
   * Explicit on 32-bit platforms by default unless `OPENXR_HPP_TYPESAFE_CONVERSION` is defined.
   */
  OPENXR_HPP_CONSTEXPR OPENXR_HPP_TYPESAFE_EXPLICIT operator RawHandleType() const noexcept {
    return val_;
  }
  //! @}
  /*!
   * @name Validity checking
   * @{
   */

  //! Returns true in conditionals if this SpatialPersistenceContextEXT value is valid
  OPENXR_HPP_CONSTEXPR explicit operator bool() const noexcept { return val_ != XR_NULL_HANDLE; }

  //! Unary negation: True if this SpatialPersistenceContextEXT value is invalid
  OPENXR_HPP_CONSTEXPR bool operator!() const noexcept { return val_ == XR_NULL_HANDLE; }

  //! @}
  /*!
   * @name Raw XrSpatialPersistenceContextEXT manipulation
   * @{
   */
  //! Gets the raw XrSpatialPersistenceContextEXT value.
  OPENXR_HPP_CONSTEXPR XrSpatialPersistenceContextEXT get() const noexcept { return val_; }
  /*!
   * @brief "Put" function for assigning as null (by default) then getting the address of the raw
   * pointer to pass to creation functions.
   *
   * e.g.
   * ```
   * SpatialPersistenceContextEXT yourHandle;
   * auto result = d.xrCreateSpatialPersistenceContextEXT(..., yourHandle.put()));
   * ```
   *
   * @see xr::put(SpatialPersistenceContextEXT&, bool)
   */
  RawHandleType* put(bool clear = true) noexcept {
    if (clear) val_ = XR_NULL_HANDLE;
    return &val_;
  }
  //! @}

  /*!
   * @name OpenXR API calls as member functions
   * @{
   */

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
  /*!
   * @brief xrDestroySpatialPersistenceContextEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialPersistenceContextEXT>
   *
   * @xrentity{xrDestroySpatialPersistenceContextEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrDestroySpatialPersistenceContextEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns Result (which may be Result::Success, or an error code if asserts are not active )
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialPersistenceContextEXT>
   *
   * @xrentity{xrDestroySpatialPersistenceContextEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
  /*!
   * @brief xrDestroySpatialPersistenceContextEXT enhanced wrapper (hides basic wrapper unless
   * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrDestroySpatialPersistenceContextEXT>
   *
   * @xrentity{xrDestroySpatialPersistenceContextEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  void destroy(Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_EXT_spatial_persistence_operations

  /*!
   * @brief xrPersistSpatialEntityAsyncEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialEntityAsyncEXT>
   *
   * @xrentity{xrPersistSpatialEntityAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result persistSpatialEntityAsyncEXT(const SpatialEntityPersistInfoEXT& persistInfo,
                                      FutureEXT& future,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPersistSpatialEntityAsyncEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialEntityAsyncEXT>
   *
   * @xrentity{xrPersistSpatialEntityAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> persistSpatialEntityAsyncEXT(
      const SpatialEntityPersistInfoEXT& persistInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPersistSpatialEntityAsyncEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialEntityAsyncEXT>
   *
   * @xrentity{xrPersistSpatialEntityAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT persistSpatialEntityAsyncEXT(const SpatialEntityPersistInfoEXT& persistInfo,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_persistence_operations

#ifdef XR_EXT_spatial_persistence_operations

  /*!
   * @brief xrPersistSpatialEntityCompleteEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialEntityCompleteEXT>
   *
   * @xrentity{xrPersistSpatialEntityCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result persistSpatialEntityCompleteEXT(FutureEXT future,
                                         PersistSpatialEntityCompletionEXT& completion,
                                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrPersistSpatialEntityCompleteEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type PersistSpatialEntityCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialEntityCompleteEXT>
   *
   * @xrentity{xrPersistSpatialEntityCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<PersistSpatialEntityCompletionEXT> persistSpatialEntityCompleteEXT(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrPersistSpatialEntityCompleteEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type PersistSpatialEntityCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrPersistSpatialEntityCompleteEXT>
   *
   * @xrentity{xrPersistSpatialEntityCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  PersistSpatialEntityCompletionEXT persistSpatialEntityCompleteEXT(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_persistence_operations

#ifdef XR_EXT_spatial_persistence_operations

  /*!
   * @brief xrUnpersistSpatialEntityAsyncEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialEntityAsyncEXT>
   *
   * @xrentity{xrUnpersistSpatialEntityAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result unpersistSpatialEntityAsyncEXT(const SpatialEntityUnpersistInfoEXT& unpersistInfo,
                                        FutureEXT& future,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUnpersistSpatialEntityAsyncEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialEntityAsyncEXT>
   *
   * @xrentity{xrUnpersistSpatialEntityAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<FutureEXT> unpersistSpatialEntityAsyncEXT(
      const SpatialEntityUnpersistInfoEXT& unpersistInfo,
      Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUnpersistSpatialEntityAsyncEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type FutureEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialEntityAsyncEXT>
   *
   * @xrentity{xrUnpersistSpatialEntityAsyncEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  FutureEXT unpersistSpatialEntityAsyncEXT(const SpatialEntityUnpersistInfoEXT& unpersistInfo,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_persistence_operations

#ifdef XR_EXT_spatial_persistence_operations

  /*!
   * @brief xrUnpersistSpatialEntityCompleteEXT wrapper (basic).
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialEntityCompleteEXT>
   *
   * @xrentity{xrUnpersistSpatialEntityCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  Result unpersistSpatialEntityCompleteEXT(FutureEXT future,
                                           UnpersistSpatialEntityCompletionEXT& completion,
                                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
  /*!
   * @brief xrUnpersistSpatialEntityCompleteEXT enhanced wrapper.
   *
   * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
   * defined.
   *
   * Asserts that the result is Result::Success.
   *
   * @returns a ResultValue tuple containing:
   * - Result (which may be Result::Success, or an error code if asserts are not active )
   * - the output of type UnpersistSpatialEntityCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialEntityCompleteEXT>
   *
   * @xrentity{xrUnpersistSpatialEntityCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  ResultValue<UnpersistSpatialEntityCompletionEXT> unpersistSpatialEntityCompleteEXT(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#else
  /*!
   * @brief xrUnpersistSpatialEntityCompleteEXT enhanced wrapper.
   *
   * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
   *
   * Throws an appropriate exception on failure.
   *
   * @returns the output of type UnpersistSpatialEntityCompletionEXT
   *
   * @see
   * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrUnpersistSpatialEntityCompleteEXT>
   *
   * @xrentity{xrUnpersistSpatialEntityCompleteEXT}
   *
   * @note Non-core function: needs a dynamic dispatch.
   */
  template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
            OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
  UnpersistSpatialEntityCompletionEXT unpersistSpatialEntityCompleteEXT(
      FutureEXT future, Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG) const;

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_EXT_spatial_persistence_operations

  //! @}
private:
  XrSpatialPersistenceContextEXT val_{XR_NULL_HANDLE};
};

static_assert(sizeof(XrSpatialPersistenceContextEXT) == sizeof(SpatialPersistenceContextEXT),
              "Original type and wrapper have different size!");

/*!
 * @brief Free function for getting the raw XrSpatialPersistenceContextEXT from an
 * SpatialPersistenceContextEXT value.
 *
 * @found_by_adl
 * @see SpatialPersistenceContextEXT::get()
 * @relates SpatialPersistenceContextEXT
 * @ingroup utility_accessors
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE XrSpatialPersistenceContextEXT
get(SpatialPersistenceContextEXT const& v) noexcept {
  return v.get();
}
/*!
 * @brief Free "put" function for clearing (by default) and getting the address of the raw
 * XrSpatialPersistenceContextEXT handle in a SpatialPersistenceContextEXT (by reference).
 *
 * e.g.
 * ```
 * SpatialPersistenceContextEXT yourHandle;
 * auto result = d.xrCreateSpatialPersistenceContextEXT(..., put(yourHandle));
 * ```
 *
 * @ingroup utility_accessors
 * @relates SpatialPersistenceContextEXT
 */
static OPENXR_HPP_INLINE XrSpatialPersistenceContextEXT* put(SpatialPersistenceContextEXT& h,
                                                             bool clear = true) noexcept {
  return h.put(clear);
}

//! @brief `<` comparison between SpatialPersistenceContextEXT values.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    SpatialPersistenceContextEXT const& lhs, SpatialPersistenceContextEXT const& rhs) noexcept {
  return lhs.get() < rhs.get();
}
//! @brief `>` comparison between SpatialPersistenceContextEXT values.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    SpatialPersistenceContextEXT const& lhs, SpatialPersistenceContextEXT const& rhs) noexcept {
  return lhs.get() > rhs.get();
}
//! @brief `<=` comparison between SpatialPersistenceContextEXT values.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    SpatialPersistenceContextEXT const& lhs, SpatialPersistenceContextEXT const& rhs) noexcept {
  return lhs.get() <= rhs.get();
}
//! @brief `>=` comparison between SpatialPersistenceContextEXT values.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    SpatialPersistenceContextEXT const& lhs, SpatialPersistenceContextEXT const& rhs) noexcept {
  return lhs.get() >= rhs.get();
}
//! @brief `==` comparison between SpatialPersistenceContextEXT values.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    SpatialPersistenceContextEXT const& lhs, SpatialPersistenceContextEXT const& rhs) noexcept {
  return lhs.get() == rhs.get();
}
//! @brief `!=` comparison between SpatialPersistenceContextEXT values.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    SpatialPersistenceContextEXT const& lhs, SpatialPersistenceContextEXT const& rhs) noexcept {
  return lhs.get() != rhs.get();
}
//! @brief `<` comparison between SpatialPersistenceContextEXT and raw
//! XrSpatialPersistenceContextEXT.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(SpatialPersistenceContextEXT const& lhs,
                                                      XrSpatialPersistenceContextEXT rhs) noexcept {
  return lhs.get() < rhs;
}
//! @brief `<` comparison between raw XrSpatialPersistenceContextEXT and
//! SpatialPersistenceContextEXT.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<(
    XrSpatialPersistenceContextEXT lhs, SpatialPersistenceContextEXT const& rhs) noexcept {
  return lhs < rhs.get();
}
//! @brief `>` comparison between SpatialPersistenceContextEXT and raw
//! XrSpatialPersistenceContextEXT.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(SpatialPersistenceContextEXT const& lhs,
                                                      XrSpatialPersistenceContextEXT rhs) noexcept {
  return lhs.get() > rhs;
}
//! @brief `>` comparison between raw XrSpatialPersistenceContextEXT and
//! SpatialPersistenceContextEXT.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>(
    XrSpatialPersistenceContextEXT lhs, SpatialPersistenceContextEXT const& rhs) noexcept {
  return lhs > rhs.get();
}
//! @brief `<=` comparison between SpatialPersistenceContextEXT and raw
//! XrSpatialPersistenceContextEXT.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    SpatialPersistenceContextEXT const& lhs, XrSpatialPersistenceContextEXT rhs) noexcept {
  return lhs.get() <= rhs;
}
//! @brief `<=` comparison between raw XrSpatialPersistenceContextEXT and
//! SpatialPersistenceContextEXT.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator<=(
    XrSpatialPersistenceContextEXT lhs, SpatialPersistenceContextEXT const& rhs) noexcept {
  return lhs <= rhs.get();
}
//! @brief `>=` comparison between SpatialPersistenceContextEXT and raw
//! XrSpatialPersistenceContextEXT.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    SpatialPersistenceContextEXT const& lhs, XrSpatialPersistenceContextEXT rhs) noexcept {
  return lhs.get() >= rhs;
}
//! @brief `>=` comparison between raw XrSpatialPersistenceContextEXT and
//! SpatialPersistenceContextEXT.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator>=(
    XrSpatialPersistenceContextEXT lhs, SpatialPersistenceContextEXT const& rhs) noexcept {
  return lhs >= rhs.get();
}
//! @brief `==` comparison between SpatialPersistenceContextEXT and raw
//! XrSpatialPersistenceContextEXT.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    SpatialPersistenceContextEXT const& lhs, XrSpatialPersistenceContextEXT rhs) noexcept {
  return lhs.get() == rhs;
}
//! @brief `==` comparison between raw XrSpatialPersistenceContextEXT and
//! SpatialPersistenceContextEXT.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    XrSpatialPersistenceContextEXT lhs, SpatialPersistenceContextEXT const& rhs) noexcept {
  return lhs == rhs.get();
}
//! @brief `!=` comparison between SpatialPersistenceContextEXT and raw
//! XrSpatialPersistenceContextEXT.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    SpatialPersistenceContextEXT const& lhs, XrSpatialPersistenceContextEXT rhs) noexcept {
  return lhs.get() != rhs;
}
//! @brief `!=` comparison between raw XrSpatialPersistenceContextEXT and
//! SpatialPersistenceContextEXT.
//! @relates SpatialPersistenceContextEXT
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    XrSpatialPersistenceContextEXT lhs, SpatialPersistenceContextEXT const& rhs) noexcept {
  return lhs != rhs.get();
}
/*!
 * @brief Equality comparison between SpatialPersistenceContextEXT and nullptr: true if the handle
 * is null.
 * @relates SpatialPersistenceContextEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(SpatialPersistenceContextEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Equality comparison between nullptr and SpatialPersistenceContextEXT: true if the handle
 * is null.
 * @relates SpatialPersistenceContextEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(
    std::nullptr_t /* unused */, SpatialPersistenceContextEXT const& rhs) noexcept {
  return rhs.get() == XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between SpatialPersistenceContextEXT and nullptr: true if the handle
 * is not null.
 * @relates SpatialPersistenceContextEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(SpatialPersistenceContextEXT const& lhs,
                                                       std::nullptr_t /* unused */) noexcept {
  return lhs.get() != XR_NULL_HANDLE;
}
/*!
 * @brief Inequality comparison between nullptr and SpatialPersistenceContextEXT: true if the handle
 * is not null.
 * @relates SpatialPersistenceContextEXT
 */
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(
    std::nullptr_t /* unused */, SpatialPersistenceContextEXT const& rhs) noexcept {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif  // XR_EXT_spatial_persistence

/*!
 * @defgroup api_free_functions OpenXR API free functions
 * @ingroup wrappers
 *
 * Equivalent to the method wrappers in the handle classes,
 * but for the few functions that don't take (or don't require)
 * a handle as their first argument.
 * @{
 */
// Declarations - implementations are out of line.

/*!
 * @brief xrEnumerateApiLayerProperties wrapper (basic).
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result enumerateApiLayerProperties(uint32_t propertyCapacityInput, uint32_t& propertyCountOutput,
                                   ApiLayerProperties* properties,
                                   Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrEnumerateApiLayerProperties enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined. Performs two-call idiom. Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type std::vector<ApiLayerProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Allocator = std::allocator<ApiLayerProperties>,
          typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<std::vector<ApiLayerProperties, Allocator>> enumerateApiLayerPropertiesToVector(
    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);
/*!
 * @brief xrEnumerateApiLayerProperties enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type std::vector<ApiLayerProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Allocator = std::allocator<ApiLayerProperties>, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<std::vector<ApiLayerProperties, Allocator>> enumerateApiLayerPropertiesToVector(
    Allocator const& vectorAllocator, Dispatch&& d);

#else
/*!
 * @brief xrEnumerateApiLayerProperties enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 * Performs two-call idiom.
 * Throws an appropriate exception on failure.
 *
 * @returns the output of type std::vector<ApiLayerProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Allocator = std::allocator<ApiLayerProperties>,
          typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
std::vector<ApiLayerProperties, Allocator> enumerateApiLayerPropertiesToVector(
    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);
/*!
 * @brief xrEnumerateApiLayerProperties enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns the output of type std::vector<ApiLayerProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateApiLayerProperties>
 *
 * @xrentity{xrEnumerateApiLayerProperties}
 */
template <typename Allocator = std::allocator<ApiLayerProperties>, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
std::vector<ApiLayerProperties, Allocator> enumerateApiLayerPropertiesToVector(
    Allocator const& vectorAllocator, Dispatch&& d);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

/*!
 * @brief xrEnumerateInstanceExtensionProperties wrapper (basic).
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result enumerateInstanceExtensionProperties(const char* layerName, uint32_t propertyCapacityInput,
                                            uint32_t& propertyCountOutput,
                                            ExtensionProperties* properties,
                                            Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrEnumerateInstanceExtensionProperties enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined. Performs two-call idiom. Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type std::vector<ExtensionProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Allocator = std::allocator<ExtensionProperties>,
          typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<std::vector<ExtensionProperties, Allocator>>
enumerateInstanceExtensionPropertiesToVector(const char* layerName,
                                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);
/*!
 * @brief xrEnumerateInstanceExtensionProperties enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type std::vector<ExtensionProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Allocator = std::allocator<ExtensionProperties>, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<std::vector<ExtensionProperties, Allocator>>
enumerateInstanceExtensionPropertiesToVector(const char* layerName,
                                             Allocator const& vectorAllocator, Dispatch&& d);

#else
/*!
 * @brief xrEnumerateInstanceExtensionProperties enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 * Performs two-call idiom.
 * Throws an appropriate exception on failure.
 *
 * @returns the output of type std::vector<ExtensionProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Allocator = std::allocator<ExtensionProperties>,
          typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
std::vector<ExtensionProperties, Allocator> enumerateInstanceExtensionPropertiesToVector(
    const char* layerName, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);
/*!
 * @brief xrEnumerateInstanceExtensionProperties enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns the output of type std::vector<ExtensionProperties, Allocator>
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrEnumerateInstanceExtensionProperties>
 *
 * @xrentity{xrEnumerateInstanceExtensionProperties}
 */
template <typename Allocator = std::allocator<ExtensionProperties>, typename Dispatch,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
std::vector<ExtensionProperties, Allocator> enumerateInstanceExtensionPropertiesToVector(
    const char* layerName, Allocator const& vectorAllocator, Dispatch&& d);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

/*!
 * @brief xrCreateInstance wrapper (basic).
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result createInstance(const InstanceCreateInfo& createInfo, Instance& instance,
                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrCreateInstance enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type Instance
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<Instance> createInstance(const InstanceCreateInfo& createInfo,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
/*!
 * @brief xrCreateInstance enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @returns the output of type Instance
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Instance createInstance(const InstanceCreateInfo& createInfo,
                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrCreateInstance wrapper returning a smart handle.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * -  a smart wrapper uniquely owning a Instance
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>>> createInstanceUnique(
    const InstanceCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
/*!
 * @brief xrCreateInstance wrapper returning a smart handle.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @returns  a smart wrapper uniquely owning a Instance
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateInstance>
 *
 * @xrentity{xrCreateInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>> createInstanceUnique(
    const InstanceCreateInfo& createInfo, Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#ifdef XR_LOADER_VERSION_1_0

/*!
 * @brief xrCreateApiLayerInstance wrapper (basic).
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateApiLayerInstance>
 *
 * @xrentity{xrCreateApiLayerInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result createApiLayerInstance(const InstanceCreateInfo& info, const ApiLayerCreateInfo& layerInfo,
                              Instance& instance,
                              Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#ifndef OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrCreateApiLayerInstance enhanced wrapper.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * - the output of type Instance
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateApiLayerInstance>
 *
 * @xrentity{xrCreateApiLayerInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<Instance> createApiLayerInstance(const InstanceCreateInfo& info,
                                             const ApiLayerCreateInfo& layerInfo,
                                             Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
/*!
 * @brief xrCreateApiLayerInstance enhanced wrapper.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @returns the output of type Instance
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateApiLayerInstance>
 *
 * @xrentity{xrCreateApiLayerInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Instance createApiLayerInstance(const InstanceCreateInfo& info, const ApiLayerCreateInfo& layerInfo,
                                Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#ifndef OPENXR_HPP_NO_SMART_HANDLE

#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrCreateApiLayerInstance wrapper returning a smart handle.
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns a ResultValue tuple containing:
 * - Result (which may be Result::Success, or an error code if asserts are not active )
 * -  a smart wrapper uniquely owning a Instance
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateApiLayerInstance>
 *
 * @xrentity{xrCreateApiLayerInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
ResultValue<UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>>> createApiLayerInstanceUnique(
    const InstanceCreateInfo& info, const ApiLayerCreateInfo& layerInfo,
    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
/*!
 * @brief xrCreateApiLayerInstance wrapper returning a smart handle.
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @returns  a smart wrapper uniquely owning a Instance
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrCreateApiLayerInstance>
 *
 * @xrentity{xrCreateApiLayerInstance}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
UniqueHandle<Instance, impl::RemoveRefConst<Dispatch>> createApiLayerInstanceUnique(
    const InstanceCreateInfo& info, const ApiLayerCreateInfo& layerInfo,
    Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif
#endif  // !OPENXR_HPP_NO_SMART_HANDLE
#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_LOADER_VERSION_1_0

#ifdef XR_LOADER_VERSION_1_0

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
/*!
 * @brief xrNegotiateLoaderRuntimeInterface wrapper (basic).
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrNegotiateLoaderRuntimeInterface>
 *
 * @xrentity{xrNegotiateLoaderRuntimeInterface}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result negotiateLoaderRuntimeInterface(const NegotiateLoaderInfo& loaderInfo,
                                       NegotiateRuntimeRequest& runtimeRequest,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrNegotiateLoaderRuntimeInterface enhanced wrapper (hides basic wrapper unless
 * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns Result (which may be Result::Success, or an error code if asserts are not active )
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrNegotiateLoaderRuntimeInterface>
 *
 * @xrentity{xrNegotiateLoaderRuntimeInterface}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result negotiateLoaderRuntimeInterface(const NegotiateLoaderInfo& loaderInfo,
                                       NegotiateRuntimeRequest& runtimeRequest,
                                       Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
/*!
 * @brief xrNegotiateLoaderRuntimeInterface enhanced wrapper (hides basic wrapper unless
 * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrNegotiateLoaderRuntimeInterface>
 *
 * @xrentity{xrNegotiateLoaderRuntimeInterface}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
void negotiateLoaderRuntimeInterface(const NegotiateLoaderInfo& loaderInfo,
                                     NegotiateRuntimeRequest& runtimeRequest,
                                     Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_LOADER_VERSION_1_0

#ifdef XR_LOADER_VERSION_1_0

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
/*!
 * @brief xrNegotiateLoaderApiLayerInterface wrapper (basic).
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrNegotiateLoaderApiLayerInterface>
 *
 * @xrentity{xrNegotiateLoaderApiLayerInterface}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result negotiateLoaderApiLayerInterface(const NegotiateLoaderInfo& loaderInfo,
                                        const char* layerName,
                                        NegotiateApiLayerRequest& apiLayerRequest,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrNegotiateLoaderApiLayerInterface enhanced wrapper (hides basic wrapper unless
 * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns Result (which may be Result::Success, or an error code if asserts are not active )
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrNegotiateLoaderApiLayerInterface>
 *
 * @xrentity{xrNegotiateLoaderApiLayerInterface}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result negotiateLoaderApiLayerInterface(const NegotiateLoaderInfo& loaderInfo,
                                        const char* layerName,
                                        NegotiateApiLayerRequest& apiLayerRequest,
                                        Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#else
/*!
 * @brief xrNegotiateLoaderApiLayerInterface enhanced wrapper (hides basic wrapper unless
 * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @see
 * <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrNegotiateLoaderApiLayerInterface>
 *
 * @xrentity{xrNegotiateLoaderApiLayerInterface}
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_CORE_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
void negotiateLoaderApiLayerInterface(const NegotiateLoaderInfo& loaderInfo, const char* layerName,
                                      NegotiateApiLayerRequest& apiLayerRequest,
                                      Dispatch&& d OPENXR_HPP_DEFAULT_CORE_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_LOADER_VERSION_1_0

#ifdef XR_KHR_loader_init

#ifdef OPENXR_HPP_DISABLE_ENHANCED_MODE
/*!
 * @brief xrInitializeLoaderKHR wrapper (basic).
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrInitializeLoaderKHR>
 *
 * @xrentity{xrInitializeLoaderKHR}
 *
 * @note Non-core function: needs a dynamic dispatch.
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result initializeLoaderKHR(const LoaderInitInfoBaseHeaderKHR& loaderInitInfo,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else  // OPENXR_HPP_DISABLE_ENHANCED_MODE
#ifdef OPENXR_HPP_NO_EXCEPTIONS
/*!
 * @brief xrInitializeLoaderKHR enhanced wrapper (hides basic wrapper unless
 * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
 *
 * Will not throw exceptions. This overload is only available when `OPENXR_HPP_NO_EXCEPTIONS` is
 * defined.
 *
 * Asserts that the result is Result::Success.
 *
 * @returns Result (which may be Result::Success, or an error code if asserts are not active )
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrInitializeLoaderKHR>
 *
 * @xrentity{xrInitializeLoaderKHR}
 *
 * @note Non-core function: needs a dynamic dispatch.
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
Result initializeLoaderKHR(const LoaderInitInfoBaseHeaderKHR& loaderInitInfo,
                           Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#else
/*!
 * @brief xrInitializeLoaderKHR enhanced wrapper (hides basic wrapper unless
 * `OPENXR_HPP_DISABLE_ENHANCED_MODE` defined).
 *
 * Only available when `OPENXR_HPP_NO_EXCEPTIONS` is not defined.
 *
 * Throws an appropriate exception on failure.
 *
 * @see <https://www.khronos.org/registry/OpenXR/specs/1.0/html/xrspec.html#xrInitializeLoaderKHR>
 *
 * @xrentity{xrInitializeLoaderKHR}
 *
 * @note Non-core function: needs a dynamic dispatch.
 */
template <typename Dispatch OPENXR_HPP_DEFAULT_EXT_DISPATCH_TYPE_ARG,
          OPENXR_HPP_REQUIRE_DISPATCH(Dispatch) = 0>
void initializeLoaderKHR(const LoaderInitInfoBaseHeaderKHR& loaderInitInfo,
                         Dispatch&& d OPENXR_HPP_DEFAULT_EXT_DISPATCH_ARG);

#endif  // OPENXR_HPP_NO_EXCEPTIONS

#endif  // !OPENXR_HPP_DISABLE_ENHANCED_MODE

#endif  // XR_KHR_loader_init

//! @}

}  // namespace OPENXR_HPP_NAMESPACE

#endif  // ifndef OPENXR_HANDLES_HPP_
