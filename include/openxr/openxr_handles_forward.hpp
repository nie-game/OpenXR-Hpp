// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See cpp_generator.py for modifications
// ************************************************************

/*
** Copyright (c) 2017-2023 The Khronos Group Inc.
** Copyright (c) 2019-2023 Collabora, Ltd.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
**
** ---- Exceptions to the Apache 2.0 License: ----
**
** As an exception, if you use this Software to generate code and portions of
** this Software are embedded into the generated code as a result, you may
** redistribute such product without providing attribution as would otherwise
** be required by Sections 4(a), 4(b) and 4(d) of the License.
**
** In addition, if you combine or link code generated by this Software with
** software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
** ("`Combined Software`") and if a court of competent jurisdiction determines
** that the patent provision (Section 3), the indemnity provision (Section 9)
** or other Section of the License conflicts with the conditions of the
** applicable GPL or LGPL license, you may retroactively and prospectively
** choose to deem waived or otherwise exclude such Section(s) of the License,
** but only in their entirety and only with respect to the Combined Software.
**
*/

/*
** This header is generated from the Khronos OpenXR XML API Registry.
**
*/
#ifndef OPENXR_HANDLES_FORWARD_HPP_
#define OPENXR_HANDLES_FORWARD_HPP_
/**
 * @file
 * @brief Forward declarations of OpenXR handle wrapper types.
 *
 * @see openxr_handles.hpp
 * @ingroup handles
 */

#include "openxr_enums.hpp"

#if !defined(OPENXR_HPP_NAMESPACE)
#define OPENXR_HPP_NAMESPACE xr
#endif  // !OPENXR_HPP_NAMESPACE

namespace OPENXR_HPP_NAMESPACE {

#ifndef OPENXR_HPP_NO_SMART_HANDLE

namespace traits {

  template <typename Type, typename Dispatch>
  class UniqueHandleTraits;

}  // namespace traits

namespace impl {

  // Used when returning unique handles.
  template <typename T>
  using RemoveRefConst = typename std::remove_const<typename std::remove_reference<T>::type>::type;
}  // namespace impl

/*!
 * @brief Template class for holding a handle with unique ownership, much like unique_ptr.
 *
 * Note that this does not keep track of children or parents, though OpenXR specifies that
 * destruction of a handle also destroys its children automatically. Thus, it is important to order
 * destruction of these correctly, usually by ordering declarations.
 *
 * Inherits from the deleter to use empty-base-class optimization when possible.
 */
template <typename Type, typename Dispatch>
class UniqueHandle : public traits::UniqueHandleTraits<Type, Dispatch>::deleter {
private:
  using Deleter = typename traits::UniqueHandleTraits<Type, Dispatch>::deleter;

public:
  //! Explicit constructor with deleter.
  explicit UniqueHandle(Type const& value = Type(), Deleter const& deleter = Deleter())
      : Deleter(deleter), m_value(value) {}

  // Cannot copy
  UniqueHandle(UniqueHandle const&) = delete;

  //! Move constructor
  UniqueHandle(UniqueHandle&& other)
      : Deleter(std::move(static_cast<Deleter&>(other))), m_value(other.release()) {}

  //! Destructor: destroys owned handle if valid.
  ~UniqueHandle() {
    if (m_value) this->destroy(m_value);
  }

  // cannot copy-assign
  UniqueHandle& operator=(UniqueHandle const&) = delete;

  //! Move-assignment operator.
  UniqueHandle& operator=(UniqueHandle&& other) {
    reset(other.release());
    *static_cast<Deleter*>(this) = std::move(static_cast<Deleter&>(other));
    return *this;
  }

  //! Explicit bool conversion: for testing if the handle is valid.
  explicit operator bool() const { return m_value.operator bool(); }

  // Smart pointer operator
  Type const* operator->() const { return &m_value; }

  // Smart pointer operator
  Type* operator->() { return &m_value; }

  // Smart pointer operator
  Type const& operator*() const { return m_value; }

  // Smart pointer operator
  Type& operator*() { return m_value; }

  //! Get the underlying (wrapped) handle type.
  const Type& get() const { return m_value; }

  //! Get the underlying (wrapped) handle type.
  Type& get() { return m_value; }

  //! Get the raw OpenXR handle or XR_NULL_HANDLE
  typename Type::RawHandleType getRawHandle() { return m_value ? m_value.get() : XR_NULL_HANDLE; }

  //! Clear or re-assign the underlying handle
  void reset(Type const& value = Type()) {
    if (m_value != value) {
      if (m_value) this->destroy(m_value);
      m_value = value;
    }
  }

  //! Clear this handle and return a pointer to the storage, for assignment/creation purposes.
  typename Type::RawHandleType* put() {
    reset();
    return m_value.put();
  }

  //! Relinquish ownership of the contained handle and return it without destroying it.
  Type release() {
    Type value = m_value;
    m_value = nullptr;
    return value;
  }

  //! Swap with another handle of this type.
  void swap(UniqueHandle<Type, Dispatch>& rhs) {
    std::swap(m_value, rhs.m_value);
    std::swap(static_cast<Deleter&>(*this), static_cast<Deleter&>(rhs));
  }

private:
  Type m_value;
};

template <typename Type, typename Dispatch>
class UniqueHandle<Type, Dispatch&> : public UniqueHandle<Type, Dispatch> {};

template <typename Type, typename Dispatch>
class UniqueHandle<Type, Dispatch const> : public UniqueHandle<Type, Dispatch> {};

//! @relates UniqueHandle
template <typename Type, typename Dispatch>
OPENXR_HPP_INLINE void swap(UniqueHandle<Type, Dispatch>& lhs, UniqueHandle<Type, Dispatch>& rhs) {
  lhs.swap(rhs);
}

//! @relates UniqueHandle
template <typename Type, typename Dispatch>
OPENXR_HPP_INLINE const Type& get(const UniqueHandle<Type, Dispatch>& h) {
  return h.get();
}

//! @brief Equality comparison between two UniqueHandles, potentially of different dispatch.
//! @relates UniqueHandle
template <typename Type, typename D1, typename D2>
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(UniqueHandle<Type, D1> const& lhs,
                                                       UniqueHandle<Type, D2> const& rhs) {
  return lhs.get() == rhs.get();
}
//! @brief Inequality comparison between two UniqueHandles, potentially of different dispatch.
//! @relates UniqueHandle
template <typename Type, typename D1, typename D2>
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(UniqueHandle<Type, D1> const& lhs,
                                                       UniqueHandle<Type, D2> const& rhs) {
  return lhs.get() != rhs.get();
}
//! @brief Equality comparison between UniqueHandle and nullptr: true if the handle is
//! null.
//! @relates UniqueHandle
template <typename Type, typename Dispatch>
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(UniqueHandle<Type, Dispatch> const& lhs,
                                                       std::nullptr_t /* unused */) {
  return lhs.get() == XR_NULL_HANDLE;
}
//! @brief Equality comparison between nullptr and UniqueHandle: true if the handle is
//! null.
//! @relates UniqueHandle
template <typename Type, typename Dispatch>
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator==(std::nullptr_t /* unused */,
                                                       UniqueHandle<Type, Dispatch> const& rhs) {
  return rhs.get() == XR_NULL_HANDLE;
}
//! @brief Inequality comparison between UniqueHandle and nullptr: true if the handle
//! is not null.
//! @relates UniqueHandle
template <typename Type, typename Dispatch>
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(UniqueHandle<Type, Dispatch> const& lhs,
                                                       std::nullptr_t /* unused */) {
  return lhs.get() != XR_NULL_HANDLE;
}
//! @brief Inequality comparison between nullptr and UniqueHandle: true if the handle
//! is not null.
//! @relates UniqueHandle
template <typename Type, typename Dispatch>
OPENXR_HPP_CONSTEXPR OPENXR_HPP_INLINE bool operator!=(std::nullptr_t /* unused */,
                                                       UniqueHandle<Type, Dispatch> const& rhs) {
  return rhs.get() != XR_NULL_HANDLE;
}
#endif

template <typename Dispatch>
class ObjectDestroy {
public:
  ObjectDestroy(Dispatch const& dispatch = Dispatch()) : m_dispatch(&dispatch) {}

protected:
  template <typename T>
  void destroy(T t) {
    t.destroy(*m_dispatch);
  }

private:
  Dispatch const* m_dispatch;
};
}  // namespace OPENXR_HPP_NAMESPACE
namespace OPENXR_HPP_NAMESPACE {

namespace traits {
  //! Type trait associating an ObjectType enum value with its C++ type.
  template <ObjectType o>
  struct cpp_type_from_object_type_enum;
}  // namespace traits

// forward declarations

class DispatchLoaderStatic;
class DispatchLoaderDynamic;

// FIXME a hack to get this working, since I don't know how to appropriately force the code to not
// project the XrSpaceUserIdFB name, and I don't want to make a openxr_spaceuseridfb.hpp file just
// for this.
using SpaceUserIdFB = XrSpaceUserIdFB;

class Instance;

class Session;

class Space;

class Action;

class Swapchain;

class ActionSet;

class DebugUtilsMessengerEXT;

class SpatialAnchorMSFT;

class SpatialGraphNodeBindingMSFT;

class HandTrackerEXT;

class BodyTrackerFB;

class SceneObserverMSFT;

class SceneMSFT;

class FacialTrackerHTC;

class FoveationProfileFB;

class TriangleMeshFB;

class PassthroughFB;

class PassthroughLayerFB;

class GeometryInstanceFB;

class MarkerDetectorML;

class ExportedLocalizationMapML;

class SpatialAnchorsStorageML;

class SpatialAnchorStoreConnectionMSFT;

class SpaceUserFB;

class FaceTrackerFB;

class EyeTrackerFB;

class VirtualKeyboardMETA;

class PassthroughColorLutMETA;

class FaceTracker2FB;

class EnvironmentDepthProviderMETA;

class EnvironmentDepthSwapchainMETA;

class RenderModelEXT;

class RenderModelAssetEXT;

class PassthroughHTC;

class BodyTrackerHTC;

class BodyTrackerBD;

class SenseDataProviderBD;

class SenseDataSnapshotBD;

class AnchorBD;

class PlaneDetectorEXT;

class WorldMeshDetectorML;

class FacialExpressionClientML;

class SpatialEntityEXT;

class SpatialContextEXT;

class SpatialSnapshotEXT;

class SpatialPersistenceContextEXT;
/*!
 * @defgroup handles Handle types
 * @brief Wrappers for OpenXR handle types, with associated functions mapped as methods.
 * @ingroup wrappers
 */
/*!
 * @defgroup unique_handle_aliases Aliases for UniqueHandle types
 * @brief Convenience names for specializations of UniqueHandle<>
 * @ingroup handles
 */

#ifndef OPENXR_HPP_NO_SMART_HANDLE
#ifndef OPENXR_HPP_DOXYGEN
namespace traits {
  template <typename Dispatch>
  class UniqueHandleTraits<Instance, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<Session, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<Space, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<Action, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<Swapchain, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<ActionSet, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<DebugUtilsMessengerEXT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SpatialAnchorMSFT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SpatialGraphNodeBindingMSFT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<HandTrackerEXT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<BodyTrackerFB, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SceneObserverMSFT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SceneMSFT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<FacialTrackerHTC, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<FoveationProfileFB, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<TriangleMeshFB, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<PassthroughFB, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<PassthroughLayerFB, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<GeometryInstanceFB, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<MarkerDetectorML, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<ExportedLocalizationMapML, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SpatialAnchorsStorageML, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SpatialAnchorStoreConnectionMSFT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SpaceUserFB, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<FaceTrackerFB, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<EyeTrackerFB, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<VirtualKeyboardMETA, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<PassthroughColorLutMETA, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<FaceTracker2FB, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<EnvironmentDepthProviderMETA, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<EnvironmentDepthSwapchainMETA, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<RenderModelEXT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<RenderModelAssetEXT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<PassthroughHTC, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<BodyTrackerHTC, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<BodyTrackerBD, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SenseDataProviderBD, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SenseDataSnapshotBD, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<AnchorBD, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<PlaneDetectorEXT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<WorldMeshDetectorML, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<FacialExpressionClientML, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SpatialEntityEXT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SpatialContextEXT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SpatialSnapshotEXT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
  template <typename Dispatch>
  class UniqueHandleTraits<SpatialPersistenceContextEXT, Dispatch> {
  public:
    using deleter = ObjectDestroy<Dispatch>;
  };
}  // namespace traits
#endif  // !OPENXR_HPP_DOXYGEN

//! @addtogroup unique_handle_aliases
//! @{

//! Shorthand name for unique handles of type Instance, using a static dispatch.
using UniqueInstance = UniqueHandle<Instance, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type Instance, using a dynamic dispatch.
using UniqueDynamicInstance = UniqueHandle<Instance, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type Session, using a static dispatch.
using UniqueSession = UniqueHandle<Session, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type Session, using a dynamic dispatch.
using UniqueDynamicSession = UniqueHandle<Session, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type Space, using a static dispatch.
using UniqueSpace = UniqueHandle<Space, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type Space, using a dynamic dispatch.
using UniqueDynamicSpace = UniqueHandle<Space, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type Action, using a static dispatch.
using UniqueAction = UniqueHandle<Action, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type Action, using a dynamic dispatch.
using UniqueDynamicAction = UniqueHandle<Action, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type Swapchain, using a static dispatch.
using UniqueSwapchain = UniqueHandle<Swapchain, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type Swapchain, using a dynamic dispatch.
using UniqueDynamicSwapchain = UniqueHandle<Swapchain, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type ActionSet, using a static dispatch.
using UniqueActionSet = UniqueHandle<ActionSet, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type ActionSet, using a dynamic dispatch.
using UniqueDynamicActionSet = UniqueHandle<ActionSet, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type DebugUtilsMessengerEXT, using a static dispatch.
using UniqueDebugUtilsMessengerEXT = UniqueHandle<DebugUtilsMessengerEXT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type DebugUtilsMessengerEXT, using a dynamic dispatch.
using UniqueDynamicDebugUtilsMessengerEXT =
    UniqueHandle<DebugUtilsMessengerEXT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SpatialAnchorMSFT, using a static dispatch.
using UniqueSpatialAnchorMSFT = UniqueHandle<SpatialAnchorMSFT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SpatialAnchorMSFT, using a dynamic dispatch.
using UniqueDynamicSpatialAnchorMSFT = UniqueHandle<SpatialAnchorMSFT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SpatialGraphNodeBindingMSFT, using a static dispatch.
using UniqueSpatialGraphNodeBindingMSFT =
    UniqueHandle<SpatialGraphNodeBindingMSFT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SpatialGraphNodeBindingMSFT, using a dynamic dispatch.
using UniqueDynamicSpatialGraphNodeBindingMSFT =
    UniqueHandle<SpatialGraphNodeBindingMSFT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type HandTrackerEXT, using a static dispatch.
using UniqueHandTrackerEXT = UniqueHandle<HandTrackerEXT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type HandTrackerEXT, using a dynamic dispatch.
using UniqueDynamicHandTrackerEXT = UniqueHandle<HandTrackerEXT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type BodyTrackerFB, using a static dispatch.
using UniqueBodyTrackerFB = UniqueHandle<BodyTrackerFB, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type BodyTrackerFB, using a dynamic dispatch.
using UniqueDynamicBodyTrackerFB = UniqueHandle<BodyTrackerFB, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SceneObserverMSFT, using a static dispatch.
using UniqueSceneObserverMSFT = UniqueHandle<SceneObserverMSFT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SceneObserverMSFT, using a dynamic dispatch.
using UniqueDynamicSceneObserverMSFT = UniqueHandle<SceneObserverMSFT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SceneMSFT, using a static dispatch.
using UniqueSceneMSFT = UniqueHandle<SceneMSFT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SceneMSFT, using a dynamic dispatch.
using UniqueDynamicSceneMSFT = UniqueHandle<SceneMSFT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type FacialTrackerHTC, using a static dispatch.
using UniqueFacialTrackerHTC = UniqueHandle<FacialTrackerHTC, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type FacialTrackerHTC, using a dynamic dispatch.
using UniqueDynamicFacialTrackerHTC = UniqueHandle<FacialTrackerHTC, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type FoveationProfileFB, using a static dispatch.
using UniqueFoveationProfileFB = UniqueHandle<FoveationProfileFB, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type FoveationProfileFB, using a dynamic dispatch.
using UniqueDynamicFoveationProfileFB = UniqueHandle<FoveationProfileFB, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type TriangleMeshFB, using a static dispatch.
using UniqueTriangleMeshFB = UniqueHandle<TriangleMeshFB, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type TriangleMeshFB, using a dynamic dispatch.
using UniqueDynamicTriangleMeshFB = UniqueHandle<TriangleMeshFB, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type PassthroughFB, using a static dispatch.
using UniquePassthroughFB = UniqueHandle<PassthroughFB, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type PassthroughFB, using a dynamic dispatch.
using UniqueDynamicPassthroughFB = UniqueHandle<PassthroughFB, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type PassthroughLayerFB, using a static dispatch.
using UniquePassthroughLayerFB = UniqueHandle<PassthroughLayerFB, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type PassthroughLayerFB, using a dynamic dispatch.
using UniqueDynamicPassthroughLayerFB = UniqueHandle<PassthroughLayerFB, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type GeometryInstanceFB, using a static dispatch.
using UniqueGeometryInstanceFB = UniqueHandle<GeometryInstanceFB, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type GeometryInstanceFB, using a dynamic dispatch.
using UniqueDynamicGeometryInstanceFB = UniqueHandle<GeometryInstanceFB, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type MarkerDetectorML, using a static dispatch.
using UniqueMarkerDetectorML = UniqueHandle<MarkerDetectorML, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type MarkerDetectorML, using a dynamic dispatch.
using UniqueDynamicMarkerDetectorML = UniqueHandle<MarkerDetectorML, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type ExportedLocalizationMapML, using a static dispatch.
using UniqueExportedLocalizationMapML =
    UniqueHandle<ExportedLocalizationMapML, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type ExportedLocalizationMapML, using a dynamic dispatch.
using UniqueDynamicExportedLocalizationMapML =
    UniqueHandle<ExportedLocalizationMapML, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SpatialAnchorsStorageML, using a static dispatch.
using UniqueSpatialAnchorsStorageML = UniqueHandle<SpatialAnchorsStorageML, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SpatialAnchorsStorageML, using a dynamic dispatch.
using UniqueDynamicSpatialAnchorsStorageML =
    UniqueHandle<SpatialAnchorsStorageML, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SpatialAnchorStoreConnectionMSFT, using a static
//! dispatch.
using UniqueSpatialAnchorStoreConnectionMSFT =
    UniqueHandle<SpatialAnchorStoreConnectionMSFT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SpatialAnchorStoreConnectionMSFT, using a dynamic
//! dispatch.
using UniqueDynamicSpatialAnchorStoreConnectionMSFT =
    UniqueHandle<SpatialAnchorStoreConnectionMSFT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SpaceUserFB, using a static dispatch.
using UniqueSpaceUserFB = UniqueHandle<SpaceUserFB, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SpaceUserFB, using a dynamic dispatch.
using UniqueDynamicSpaceUserFB = UniqueHandle<SpaceUserFB, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type FaceTrackerFB, using a static dispatch.
using UniqueFaceTrackerFB = UniqueHandle<FaceTrackerFB, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type FaceTrackerFB, using a dynamic dispatch.
using UniqueDynamicFaceTrackerFB = UniqueHandle<FaceTrackerFB, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type EyeTrackerFB, using a static dispatch.
using UniqueEyeTrackerFB = UniqueHandle<EyeTrackerFB, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type EyeTrackerFB, using a dynamic dispatch.
using UniqueDynamicEyeTrackerFB = UniqueHandle<EyeTrackerFB, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type VirtualKeyboardMETA, using a static dispatch.
using UniqueVirtualKeyboardMETA = UniqueHandle<VirtualKeyboardMETA, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type VirtualKeyboardMETA, using a dynamic dispatch.
using UniqueDynamicVirtualKeyboardMETA = UniqueHandle<VirtualKeyboardMETA, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type PassthroughColorLutMETA, using a static dispatch.
using UniquePassthroughColorLutMETA = UniqueHandle<PassthroughColorLutMETA, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type PassthroughColorLutMETA, using a dynamic dispatch.
using UniqueDynamicPassthroughColorLutMETA =
    UniqueHandle<PassthroughColorLutMETA, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type FaceTracker2FB, using a static dispatch.
using UniqueFaceTracker2FB = UniqueHandle<FaceTracker2FB, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type FaceTracker2FB, using a dynamic dispatch.
using UniqueDynamicFaceTracker2FB = UniqueHandle<FaceTracker2FB, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type EnvironmentDepthProviderMETA, using a static dispatch.
using UniqueEnvironmentDepthProviderMETA =
    UniqueHandle<EnvironmentDepthProviderMETA, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type EnvironmentDepthProviderMETA, using a dynamic
//! dispatch.
using UniqueDynamicEnvironmentDepthProviderMETA =
    UniqueHandle<EnvironmentDepthProviderMETA, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type EnvironmentDepthSwapchainMETA, using a static
//! dispatch.
using UniqueEnvironmentDepthSwapchainMETA =
    UniqueHandle<EnvironmentDepthSwapchainMETA, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type EnvironmentDepthSwapchainMETA, using a dynamic
//! dispatch.
using UniqueDynamicEnvironmentDepthSwapchainMETA =
    UniqueHandle<EnvironmentDepthSwapchainMETA, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type RenderModelEXT, using a static dispatch.
using UniqueRenderModelEXT = UniqueHandle<RenderModelEXT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type RenderModelEXT, using a dynamic dispatch.
using UniqueDynamicRenderModelEXT = UniqueHandle<RenderModelEXT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type RenderModelAssetEXT, using a static dispatch.
using UniqueRenderModelAssetEXT = UniqueHandle<RenderModelAssetEXT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type RenderModelAssetEXT, using a dynamic dispatch.
using UniqueDynamicRenderModelAssetEXT = UniqueHandle<RenderModelAssetEXT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type PassthroughHTC, using a static dispatch.
using UniquePassthroughHTC = UniqueHandle<PassthroughHTC, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type PassthroughHTC, using a dynamic dispatch.
using UniqueDynamicPassthroughHTC = UniqueHandle<PassthroughHTC, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type BodyTrackerHTC, using a static dispatch.
using UniqueBodyTrackerHTC = UniqueHandle<BodyTrackerHTC, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type BodyTrackerHTC, using a dynamic dispatch.
using UniqueDynamicBodyTrackerHTC = UniqueHandle<BodyTrackerHTC, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type BodyTrackerBD, using a static dispatch.
using UniqueBodyTrackerBD = UniqueHandle<BodyTrackerBD, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type BodyTrackerBD, using a dynamic dispatch.
using UniqueDynamicBodyTrackerBD = UniqueHandle<BodyTrackerBD, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SenseDataProviderBD, using a static dispatch.
using UniqueSenseDataProviderBD = UniqueHandle<SenseDataProviderBD, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SenseDataProviderBD, using a dynamic dispatch.
using UniqueDynamicSenseDataProviderBD = UniqueHandle<SenseDataProviderBD, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SenseDataSnapshotBD, using a static dispatch.
using UniqueSenseDataSnapshotBD = UniqueHandle<SenseDataSnapshotBD, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SenseDataSnapshotBD, using a dynamic dispatch.
using UniqueDynamicSenseDataSnapshotBD = UniqueHandle<SenseDataSnapshotBD, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type AnchorBD, using a static dispatch.
using UniqueAnchorBD = UniqueHandle<AnchorBD, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type AnchorBD, using a dynamic dispatch.
using UniqueDynamicAnchorBD = UniqueHandle<AnchorBD, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type PlaneDetectorEXT, using a static dispatch.
using UniquePlaneDetectorEXT = UniqueHandle<PlaneDetectorEXT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type PlaneDetectorEXT, using a dynamic dispatch.
using UniqueDynamicPlaneDetectorEXT = UniqueHandle<PlaneDetectorEXT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type WorldMeshDetectorML, using a static dispatch.
using UniqueWorldMeshDetectorML = UniqueHandle<WorldMeshDetectorML, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type WorldMeshDetectorML, using a dynamic dispatch.
using UniqueDynamicWorldMeshDetectorML = UniqueHandle<WorldMeshDetectorML, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type FacialExpressionClientML, using a static dispatch.
using UniqueFacialExpressionClientML = UniqueHandle<FacialExpressionClientML, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type FacialExpressionClientML, using a dynamic dispatch.
using UniqueDynamicFacialExpressionClientML =
    UniqueHandle<FacialExpressionClientML, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SpatialEntityEXT, using a static dispatch.
using UniqueSpatialEntityEXT = UniqueHandle<SpatialEntityEXT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SpatialEntityEXT, using a dynamic dispatch.
using UniqueDynamicSpatialEntityEXT = UniqueHandle<SpatialEntityEXT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SpatialContextEXT, using a static dispatch.
using UniqueSpatialContextEXT = UniqueHandle<SpatialContextEXT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SpatialContextEXT, using a dynamic dispatch.
using UniqueDynamicSpatialContextEXT = UniqueHandle<SpatialContextEXT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SpatialSnapshotEXT, using a static dispatch.
using UniqueSpatialSnapshotEXT = UniqueHandle<SpatialSnapshotEXT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SpatialSnapshotEXT, using a dynamic dispatch.
using UniqueDynamicSpatialSnapshotEXT = UniqueHandle<SpatialSnapshotEXT, DispatchLoaderDynamic>;
//! Shorthand name for unique handles of type SpatialPersistenceContextEXT, using a static dispatch.
using UniqueSpatialPersistenceContextEXT =
    UniqueHandle<SpatialPersistenceContextEXT, DispatchLoaderStatic>;
//! Shorthand name for unique handles of type SpatialPersistenceContextEXT, using a dynamic
//! dispatch.
using UniqueDynamicSpatialPersistenceContextEXT =
    UniqueHandle<SpatialPersistenceContextEXT, DispatchLoaderDynamic>;
//! @}
#endif  // !OPENXR_HPP_NO_SMART_HANDLE

#ifndef OPENXR_HPP_DOXYGEN
namespace traits {
  // Explicit specializations of cpp_type_from_object_type_enum

  template <>
  struct cpp_type_from_object_type_enum<ObjectType::Instance> {
    using type = Instance;
  };

  template <>
  struct cpp_type_from_object_type_enum<ObjectType::Session> {
    using type = Session;
  };

  template <>
  struct cpp_type_from_object_type_enum<ObjectType::Space> {
    using type = Space;
  };

  template <>
  struct cpp_type_from_object_type_enum<ObjectType::Action> {
    using type = Action;
  };

  template <>
  struct cpp_type_from_object_type_enum<ObjectType::Swapchain> {
    using type = Swapchain;
  };

  template <>
  struct cpp_type_from_object_type_enum<ObjectType::ActionSet> {
    using type = ActionSet;
  };

#ifdef XR_EXT_debug_utils
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::DebugUtilsMessengerEXT> {
    using type = DebugUtilsMessengerEXT;
  };
#endif  // XR_EXT_debug_utils
#ifdef XR_MSFT_spatial_anchor
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SpatialAnchorMSFT> {
    using type = SpatialAnchorMSFT;
  };
#endif  // XR_MSFT_spatial_anchor
#ifdef XR_MSFT_spatial_graph_bridge
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SpatialGraphNodeBindingMSFT> {
    using type = SpatialGraphNodeBindingMSFT;
  };
#endif  // XR_MSFT_spatial_graph_bridge
#ifdef XR_EXT_hand_tracking
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::HandTrackerEXT> {
    using type = HandTrackerEXT;
  };
#endif  // XR_EXT_hand_tracking
#ifdef XR_FB_body_tracking
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::BodyTrackerFB> {
    using type = BodyTrackerFB;
  };
#endif  // XR_FB_body_tracking
#ifdef XR_MSFT_scene_understanding
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SceneObserverMSFT> {
    using type = SceneObserverMSFT;
  };
#endif  // XR_MSFT_scene_understanding
#ifdef XR_MSFT_scene_understanding
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SceneMSFT> {
    using type = SceneMSFT;
  };
#endif  // XR_MSFT_scene_understanding
#ifdef XR_HTC_facial_tracking
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::FacialTrackerHTC> {
    using type = FacialTrackerHTC;
  };
#endif  // XR_HTC_facial_tracking
#ifdef XR_FB_foveation
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::FoveationProfileFB> {
    using type = FoveationProfileFB;
  };
#endif  // XR_FB_foveation
#ifdef XR_FB_triangle_mesh
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::TriangleMeshFB> {
    using type = TriangleMeshFB;
  };
#endif  // XR_FB_triangle_mesh
#ifdef XR_FB_passthrough
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::PassthroughFB> {
    using type = PassthroughFB;
  };
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::PassthroughLayerFB> {
    using type = PassthroughLayerFB;
  };
#endif  // XR_FB_passthrough
#ifdef XR_FB_passthrough
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::GeometryInstanceFB> {
    using type = GeometryInstanceFB;
  };
#endif  // XR_FB_passthrough
#ifdef XR_ML_marker_understanding
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::MarkerDetectorML> {
    using type = MarkerDetectorML;
  };
#endif  // XR_ML_marker_understanding
#ifdef XR_ML_localization_map
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::ExportedLocalizationMapML> {
    using type = ExportedLocalizationMapML;
  };
#endif  // XR_ML_localization_map
#ifdef XR_ML_spatial_anchors_storage
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SpatialAnchorsStorageML> {
    using type = SpatialAnchorsStorageML;
  };
#endif  // XR_ML_spatial_anchors_storage
#ifdef XR_MSFT_spatial_anchor_persistence
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SpatialAnchorStoreConnectionMSFT> {
    using type = SpatialAnchorStoreConnectionMSFT;
  };
#endif  // XR_MSFT_spatial_anchor_persistence
#ifdef XR_FB_spatial_entity_sharing
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SpaceUserFB> {
    using type = SpaceUserFB;
  };
#endif  // XR_FB_spatial_entity_sharing
#ifdef XR_FB_face_tracking
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::FaceTrackerFB> {
    using type = FaceTrackerFB;
  };
#endif  // XR_FB_face_tracking
#ifdef XR_FB_eye_tracking_social
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::EyeTrackerFB> {
    using type = EyeTrackerFB;
  };
#endif  // XR_FB_eye_tracking_social
#ifdef XR_META_virtual_keyboard
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::VirtualKeyboardMETA> {
    using type = VirtualKeyboardMETA;
  };
#endif  // XR_META_virtual_keyboard
#ifdef XR_META_passthrough_color_lut
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::PassthroughColorLutMETA> {
    using type = PassthroughColorLutMETA;
  };
#endif  // XR_META_passthrough_color_lut
#ifdef XR_FB_face_tracking2
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::FaceTracker2FB> {
    using type = FaceTracker2FB;
  };
#endif  // XR_FB_face_tracking2
#ifdef XR_META_environment_depth
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::EnvironmentDepthProviderMETA> {
    using type = EnvironmentDepthProviderMETA;
  };
#endif  // XR_META_environment_depth
#ifdef XR_META_environment_depth
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::EnvironmentDepthSwapchainMETA> {
    using type = EnvironmentDepthSwapchainMETA;
  };
#endif  // XR_META_environment_depth
#ifdef XR_EXT_render_model
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::RenderModelEXT> {
    using type = RenderModelEXT;
  };
#endif  // XR_EXT_render_model
#ifdef XR_EXT_render_model
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::RenderModelAssetEXT> {
    using type = RenderModelAssetEXT;
  };
#endif  // XR_EXT_render_model
#ifdef XR_HTC_passthrough
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::PassthroughHTC> {
    using type = PassthroughHTC;
  };
#endif  // XR_HTC_passthrough
#ifdef XR_HTC_body_tracking
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::BodyTrackerHTC> {
    using type = BodyTrackerHTC;
  };
#endif  // XR_HTC_body_tracking
#ifdef XR_BD_body_tracking
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::BodyTrackerBD> {
    using type = BodyTrackerBD;
  };
#endif  // XR_BD_body_tracking
#ifdef XR_BD_spatial_sensing
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SenseDataProviderBD> {
    using type = SenseDataProviderBD;
  };
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SenseDataSnapshotBD> {
    using type = SenseDataSnapshotBD;
  };
#endif  // XR_BD_spatial_sensing
#ifdef XR_BD_spatial_sensing
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::AnchorBD> {
    using type = AnchorBD;
  };
#endif  // XR_BD_spatial_sensing
#ifdef XR_EXT_plane_detection
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::PlaneDetectorEXT> {
    using type = PlaneDetectorEXT;
  };
#endif  // XR_EXT_plane_detection
#ifdef XR_ML_world_mesh_detection
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::WorldMeshDetectorML> {
    using type = WorldMeshDetectorML;
  };
#endif  // XR_ML_world_mesh_detection
#ifdef XR_ML_facial_expression
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::FacialExpressionClientML> {
    using type = FacialExpressionClientML;
  };
#endif  // XR_ML_facial_expression
#ifdef XR_EXT_spatial_entity
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SpatialEntityEXT> {
    using type = SpatialEntityEXT;
  };
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SpatialContextEXT> {
    using type = SpatialContextEXT;
  };
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_entity
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SpatialSnapshotEXT> {
    using type = SpatialSnapshotEXT;
  };
#endif  // XR_EXT_spatial_entity
#ifdef XR_EXT_spatial_persistence
  template <>
  struct cpp_type_from_object_type_enum<ObjectType::SpatialPersistenceContextEXT> {
    using type = SpatialPersistenceContextEXT;
  };
#endif  // XR_EXT_spatial_persistence
}  // namespace traits
#endif  // !OPENXR_HPP_DOXYGEN

}  // namespace OPENXR_HPP_NAMESPACE

#endif  // ifndef OPENXR_HANDLES_FORWARD_HPP_
